--- Addon Header
--
----------------------------------------------------------------------
-------------------------------- CORE --------------------------------
----------------------------------------------------------------------

-------------------
--- Manager API ---
-------------------
local GetUnitCount = _G["GetUnitCount"];
_G["GetUnitCount"] = nil;
local OpenURL = _G["OpenURL"];
_G["OpenURL"] = nil;
local GetUnitByIndex = _G["GetUnitByIndex"];
_G["GetUnitByIndex"] = nil;
local GetClientVersion = _G["GetClientVersion"];
_G["GetClientVersion"] = nil;
local GetMembershipKey = _G["GetMembershipKey"];
_G["GetMembershipKey"] = nil;
local GetManagerVersion = _G["GetManagerVersion"];
_G["GetManagerVersion"] = nil;
local ReadFile = _G["ReadFile"];
_G["ReadFile"] = nil;
local WriteFile = _G["WriteFile"];
_G["WriteFile"] = nil;
local GetOSVersion = _G["GetOSVersion"];
_G["GetOSVersion"] = nil;
local GetAutoAway = _G["GetAutoAway"];
_G["GetAutoAway"] = nil;
local SetAutoAway = _G["SetAutoAway"];
_G["SetAutoAway"] = nil;
local UserHasRotation = _G["UserHasRotation"];
_G["UserHasRotation"] = nil;
local GetSetting = _G["GetSetting"];
_G["GetSetting"] = nil;
local SetSetting = _G["SetSetting"];
_G["SetSetting"] = nil;
local GetUnitPosition = _G["GetUnitPosition"];
_G["GetUnitPosition"] = nil;
local GetUnitFacing = _G["GetUnitFacing"];
_G["GetUnitFacing"] = nil;
local GetUnitBoundingRadius = _G["GetUnitBoundingRadius"];
_G["GetUnitBoundingRadius"] = nil;
local GetUnitCombatReach = _G["GetUnitCombatReach"];
_G["GetUnitCombatReach"] = nil;
local TraceLine = _G["TraceLine"];
_G["TraceLine"] = nil;
local IsAoEPending = _G["IsAoEPending"];
_G["IsAoEPending"] = nil;
local ClearPendingSpell = _G["ClearPendingSpell"];
_G["ClearPendingSpell"] = nil;
local CastAtPosition = _G["CastAtPosition"];
_G["CastAtPosition"] = nil;
local GetUnitNearPositionCount = _G["GetUnitNearPositionCount"];
_G["GetUnitNearPositionCount"] = nil;
local GetUnitNearPositionByIndex = _G["GetUnitNearPositionByIndex"];
_G["GetUnitNearPositionByIndex"] = nil;
local Is64Bit = _G["Is64Bit"];
_G["Is64Bit"] = nil;
local GetManagerDirectory = _G["GetManagerDirectory"];
_G["GetManagerDirectory"] = nil;
local IsInInstance = _G["IsInInstance"];
local GetRaidDifficultyID = _G["GetRaidDifficultyID"];
local GetRealZoneText = _G["GetRealZoneText"];
local IsRatedBattleground = _G["IsRatedBattleground"];
local UnitClass = _G["UnitClass"];
local GetSpecialization = _G["GetSpecialization"];
local GetSpecializationInfo = _G["GetSpecializationInfo"];

--------------
--- Module ---
--------------
local AddonTable = {};
AddonTable.Module = CreateFrame("Frame");
local module = AddonTable.Module;
--Engine = AddonTable.Module; -- Uncomment to have the AddonTable as the Global Var "Engine"


-------------------------------------------------------------------------
-------------------------------- CLASSES --------------------------------
-------------------------------------------------------------------------

--------------------
--- Construction ---
--------------------
--- Defines class functions.
local function InstanceCallOperator (self, ...) return self:Call(...); end
local function ToStringOperator (self, ...) return self:ToString(...); end
local function UnaryMinusOperator (self, ...) return self:UnaryMinus(...); end
local function AddOperator (self, ...) return self:Add(...); end
local function SubtractOperator (self, ...) return self:Subtract(...); end
local function MultiplyOperator (self, ...) return self:Multiply(...); end
local function DivideOperator (self, ...) return self:Divide(...); end
local function ModuloOperator (self, ...) return self:Modulo(...); end
local function PowerOperator (self, ...) return self:Power(...); end
local function ConcatenateOperator (self, ...) return self:Concatenate(...); end
local function EqualsOperator (self, ...) return self:Equals(...); end
local function LessThanOperator (self, ...) return self:LessThan(...); end
local function LessThanOrEqualToOperator (self, ...) return self:LessThanOrEqualTo(...); end
local function ClassCallOperator (self, ...) local Object = {}; setmetatable(Object, self); if Object.Constructor then Object:Constructor(...); end return Object; end

--- Create a new class.
-- @return A table that behaves as a class.
local function Class ()
    local Table = {};

    Table.__index = Table;
    Table.__call = InstanceCallOperator;
    Table.__tostring = ToStringOperator;
    Table.__unm = UnaryMinusOperator;
    Table.__add = AddOperator;
    Table.__sub = SubtractOperator;
    Table.__mul = MultiplyOperator;
    Table.__div = DivideOperator;
    Table.__mod = ModuloOperator;
    Table.__pow = PowerOperator;
    Table.__concat = ConcatenateOperator;
    Table.__eq = EqualsOperator;
    Table.__lt = LessThanOperator;
    Table.__le = LessThanOrEqualToOperator;

    local MetaTable = {};
    MetaTable.__call = ClassCallOperator;

    setmetatable(Table, MetaTable);
    return Table;
end

------------------
--- Unit Class ---
------------------
--- Variables.
module.Unit = Class();
local Unit = module.Unit;
--- Constructor.
-- @param UnitID The unit's unit ID. If the unit does not exist, methods may return invalid or incorrect results, or error.
function Unit:Constructor (UnitID) self.UnitID = UnitID; end
--- Objects.
Unit.Player = Unit("player");
Unit.PlayerPet, Unit.PlayerPetTarget = Unit("pet"), Unit("pettarget");
Unit.Target, Unit.TargetTarget = Unit("target"), Unit("targettarget");
Unit.Mouseover, Unit.MouseoverTarget = Unit("mouseover"), Unit("mouseovertarget");
Unit.Focus, Unit.FocusTarget = Unit("focus"), Unit("focustarget");
Unit.Boss1, Unit.Boss1Target = Unit("boss1"), Unit("boss1target");
Unit.Boss2, Unit.Boss2Target = Unit("boss2"), Unit("boss2target");
Unit.Boss3, Unit.Boss3Target = Unit("boss3"), Unit("boss3target");
Unit.Boss4, Unit.Boss4Target = Unit("boss4"), Unit("boss4target");
--- Player Table.
module.Player = Unit.Player;
module.PlayerPet = Unit.PlayerPet;
--- Local Variables.
local Player = module.Player;
local PlayerPet, PlayerPetTarget = module.PlayerPet, Unit.PlayerPetTarget;
local Target, TargetTarget = Unit.Target, Unit.TargetTarget;
local Mouseover, MouseoverTarget = Unit.Mouseover, Unit.MouseoverTarget;
local Focus, FocusTarget = Unit.Focus, Unit.FocusTarget;
local Boss1, Boss1Target = Unit.Boss1, Unit.Boss1Target;
local Boss2, Boss2Target = Unit.Boss2, Unit.Boss2Target;
local Boss3, Boss3Target = Unit.Boss3, Unit.Boss3Target;
local Boss4, Boss4Target = Unit.Boss4, Unit.Boss4Target;

------------------
--- Item Class ---
------------------
--- Variables.
module.Item = Class();
local Item = module.Item;
--- Constructor.
--- @param Identifier The item identifier.
function Item:Constructor (Identifier)
    if not Identifier then return; end
    self.Identifier = Identifier;
    self.LastUseTime = 0;
end

-------------------
--- Spell Class ---
-------------------
--- Variables.
module.Spell = Class();
local Spell = module.Spell;
local Spells = {};
--- Constructor.
-- @param Identifier The spell ID.
-- @param Power The spell power cost.
-- @param Hostile Whether the spell is hostile.
-- @param Instant Whether the spell is an instant-cast.
-- @param Resurrect Whether the spell is an resurrect-type ability.
function Spell:Constructor (Identifier, FacingRequired, Hostile, Instant, Resurrect)
    if not Identifier then return; end
    self.Identifier = Identifier;
    self.FacingRequired = FacingRequired and FacingRequired or false;
    self.Hostile = Hostile and Hostile or false;
    self.Instant = Instant and Instant or false;
    self.Resurrect = Resurrect and Resurrect or false;
    self.LastCastTime = 0;
    self.DoNotCast = false;
    Spells[Identifier] = self;
end
--- Local Variables.
local CastTime = nil;
local LastCastID = nil;
local S = {};

---------------------
--- Vector3 Class ---
---------------------
--- Variables.
module.Vector3 = Class();
local Vector3 = module.Vector3;
--- Constructor.
-- @param X The X coordinate.
-- @param Y The Y coordinate.
-- @param Z The Z coordinate.
function Vector3:Constructor (X, Y, Z)
    self.X = X;
    self.Y = Y;
    self.Z = Z;
end


-----------------------------------------------------------------------------------
-------------------------------- X-Files Variables --------------------------------
-----------------------------------------------------------------------------------

-----------------
--- Constants ---
-----------------
local C = {
    -- Interrupt Constants
    INTERRUPT_DEFAULT1 = 40,
    INTERRUPT_DEFAULT2 = 60,
    INTERRUPT_MIN = GetManagerVersion() == "Local" and 1 or 20, -- Min is set to 0 for Local.
    INTERRUPT_MAX = 90,
    INTERRUPT_STEP = 5,
    INTERRUPT_GAP = GetManagerVersion() == "Local" and 0 or 20, -- Gap is set to 0 for Local.
    -- Tooltip Constants
    TOOLTIP_DESCRIPTION = "|cFFFF0044Description|r\n",
    TOOLTIP_VALUE = "\n\n|cFFFF0044Value|r\n",
    TOOLTIP_VALUE_1 = "\n\n|cFFFF0044Value 1|r\n",
    TOOLTIP_VALUE_2 = "\n\n|cFFFF0044Value 2|r\n",
    TOOLTIP_DEFAULT_STATE = "\n\n|cFF66FF00Default State:|r ",
    TOOLTIP_DEFAULT_VALUE = "\n|cFF66FF00Default Value:|r ",
    TOOLTIP_DEFAULT_VALUE_1 = "\n|cFF66FF00Default Value 1:|r ",
    TOOLTIP_DEFAULT_VALUE_2 = "\n|cFF66FF00Default Value 2:|r ",
    TOOLTIP_SUBVALUE = function (Text, NoLineReturn) return NoLineReturn and "|cFF0088FF"..Text..":|r " or "\n|cFF0088FF"..Text..":|r " end,
    TOOLTIP_HINT = function (Text) return "\n\n|cFF26BAFF"..Text.."|r" end,
    -- Game Constants
    MAXIMUM_BUFFS = 40,
    -- Player Constants
    PLAYERGUID = UnitGUID("player"),
    CLASSNAME = ({UnitClass("player")})[2],
    CLASSINDEX = ({UnitClass("player")})[3]
};

---------------------
--- Lua & WoW API ---
---------------------
local tinsert, tremove = tinsert, tremove;
local wipe = table.wipe;

---------------
--- Manager ---
---------------
local ProfilesDirectoryChange = "/../../../Profiles/";
local ErrorsDirectoryChange = "/../../../Errors/";
local TicketDirectoryChange = "/../../../Ticket Information.txt";
local RotationsDirectoryChange = "/../../../Purchased Rotations.txt";
local SettingsDirectoryChange = "/../../../Settings Dump.txt";
local MacroCommandDirectoryChange = "/../../../Macro Command.txt";
local BenchmarkResultsDirectoryChange = "/../../../Benchmark Results.txt";
local RotationFileDate = "7-27-2016";
local Key = GetMembershipKey();
local ClientVersion = GetClientVersion();
local ClientMaxLevel = (string.find(ClientVersion, "Beta") and 110) or 100;
local ClientLevelingCap = 99;





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() -- Module options:
    local always_try_using_lpeg = true
    local register_global_module_table = false
    local global_module_name = 'json'

    --[==[

    David Kolf's JSON module for Lua 5.1/5.2

    Version 2.5


    For the documentation see the corresponding readme.txt or visit
    <http://dkolf.de/src/dkjson-lua.fsl/>.

    You can contact the author by sending an e-mail to 'david' at the
    domain 'dkolf.de'.


    Copyright (C) 2010-2013 David Heiko Kolf

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

    --]==]

    -- global dependencies:
    local pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset =
          pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset
    local error, require, pcall, select = error, require, pcall, select
    local floor, huge = math.floor, math.huge
    local strrep, gsub, strsub, strbyte, strchar, strfind, strlen, strformat =
          string.rep, string.gsub, string.sub, string.byte, string.char,
          string.find, string.len, string.format
    local strmatch = string.match
    local concat = table.concat

    json = { version = "dkjson 2.5" }

    if register_global_module_table then
      _G[global_module_name] = json
    end

    local _ENV = nil -- blocking globals in Lua 5.2

    pcall (function()
      -- Enable access to blocked metatables.
      -- Don't worry, this module doesn't change anything in them.
      local debmeta = require "debug".getmetatable
      if debmeta then getmetatable = debmeta end
    end)

    json.null = setmetatable ({}, {
      __tojson = function () return "null" end
    })

    local function isarray (tbl)
      local max, n, arraylen = 0, 0, 0
      for k,v in pairs (tbl) do
        if k == 'n' and type(v) == 'number' then
          arraylen = v
          if v > max then
            max = v
          end
        else
          if type(k) ~= 'number' or k < 1 or floor(k) ~= k then
            return false
          end
          if k > max then
            max = k
          end
          n = n + 1
        end
      end
      if max > 10 and max > arraylen and max > n * 2 then
        return false -- don't create an array with too many holes
      end
      return true, max
    end

    local escapecodes = {
      ["\""] = "\\\"", ["\\"] = "\\\\", ["\b"] = "\\b", ["\f"] = "\\f",
      ["\n"] = "\\n",  ["\r"] = "\\r",  ["\t"] = "\\t"
    }

    local function escapeutf8 (uchar)
        local value = escapecodes[uchar]
            if value then
            return value
        end
        local a, b, c, d = strbyte (uchar, 1, 4)
        a, b, c, d = a or 0, b or 0, c or 0, d or 0
        if a <= 0x7f then
            value = a
            elseif 0xc0 <= a and a <= 0xdf and b >= 0x80 then
            value = (a - 0xc0) * 0x40 + b - 0x80
        elseif 0xe0 <= a and a <= 0xef and b >= 0x80 and c >= 0x80 then
            value = ((a - 0xe0) * 0x40 + b - 0x80) * 0x40 + c - 0x80
            elseif 0xf0 <= a and a <= 0xf7 and b >= 0x80 and c >= 0x80 and d >= 0x80 then
            value = (((a - 0xf0) * 0x40 + b - 0x80) * 0x40 + c - 0x80) * 0x40 + d - 0x80
        else
            return ""
        end
        if value <= 0xffff then
            return strformat ("\\u%.4x", value)
        elseif value <= 0x10ffff then
            -- encode as UTF-16 surrogate pair
            value = value - 0x10000
            local highsur, lowsur = 0xD800 + floor (value/0x400), 0xDC00 + (value % 0x400)
            return strformat ("\\u%.4x\\u%.4x", highsur, lowsur)
        else
            return ""
        end
    end

    local function fsub (str, pattern, repl)
        -- gsub always builds a new string in a buffer, even when no match
        -- exists. First using find should be more efficient when most strings
        -- don't contain the pattern.
        if strfind (str, pattern) then
            return gsub (str, pattern, repl)
        else
            return str
        end
    end

    local function quotestring (value)
        -- based on the regexp "escapable" in https://github.com/douglascrockford/JSON-js
        value = fsub (value, "[%z\1-\31\"\\\127]", escapeutf8)
        if strfind (value, "[\194\216\220\225\226\239]") then
            value = fsub (value, "\194[\128-\159\173]", escapeutf8)
            value = fsub (value, "\216[\128-\132]", escapeutf8)
            value = fsub (value, "\220\143", escapeutf8)
            value = fsub (value, "\225\158[\180\181]", escapeutf8)
            value = fsub (value, "\226\128[\140-\143\168-\175]", escapeutf8)
            value = fsub (value, "\226\129[\160-\175]", escapeutf8)
            value = fsub (value, "\239\187\191", escapeutf8)
            value = fsub (value, "\239\191[\176-\191]", escapeutf8)
        end
        return "\"" .. value .. "\""
    end
    json.quotestring = quotestring

    local function replace(str, o, n)
        local i, j = strfind (str, o, 1, true)
        if i then
            return strsub(str, 1, i-1) .. n .. strsub(str, j+1, -1)
        else
            return str
        end
    end

    -- locale independent num2str and str2num functions
    local decpoint, numfilter

    local function updatedecpoint ()
        decpoint = strmatch(tostring(0.5), "([^05+])")
        -- build a filter that can be used to remove group separators
        numfilter = "[^0-9%-%+eE" .. gsub(decpoint, "[%^%$%(%)%%%.%[%]%*%+%-%?]", "%%%0") .. "]+"
    end

    updatedecpoint()

    local function num2str (num)
        return replace(fsub(tostring(num), numfilter, ""), decpoint, ".")
    end

    local function str2num (str)
        local num = tonumber(replace(str, ".", decpoint))
        if not num then
            updatedecpoint()
            num = tonumber(replace(str, ".", decpoint))
        end
        return num
    end

    local function addnewline2 (level, buffer, buflen)
        buffer[buflen+1] = "\n"
        buffer[buflen+2] = strrep ("  ", level)
        buflen = buflen + 2
        return buflen
    end

    function json.addnewline (state)
        if state.indent then
            state.bufferlen = addnewline2 (state.level or 0,
                              state.buffer, state.bufferlen or #(state.buffer))
        end
    end

    local encode2 -- forward declaration

    local function addpair (key, value, prev, indent, level, buffer, buflen, tables, globalorder, state)
        local kt = type (key)
        if kt ~= 'string' and kt ~= 'number' then
            return nil, "type '" .. kt .. "' is not supported as a key by JSON."
        end
        if prev then
            buflen = buflen + 1
            buffer[buflen] = ","
        end
        if indent then
            buflen = addnewline2 (level, buffer, buflen)
        end
        buffer[buflen+1] = quotestring (key)
        buffer[buflen+2] = ":"
        return encode2 (value, indent, level, buffer, buflen + 2, tables, globalorder, state)
    end

    local function appendcustom(res, buffer, state)
        local buflen = state.bufferlen
        if type (res) == 'string' then
            buflen = buflen + 1
            buffer[buflen] = res
        end
        return buflen
    end

    local function exception(reason, value, state, buffer, buflen, defaultmessage)
        defaultmessage = defaultmessage or reason
        local handler = state.exception
        if not handler then
            return nil, defaultmessage
        else
            state.bufferlen = buflen
            local ret, msg = handler (reason, value, state, defaultmessage)
            if not ret then return nil, msg or defaultmessage end
            return appendcustom(ret, buffer, state)
        end
    end

    function json.encodeexception(reason, value, state, defaultmessage)
        return quotestring("<" .. defaultmessage .. ">")
        --
    end

    encode2 = function (value, indent, level, buffer, buflen, tables, globalorder, state)
        local valtype = type (value)
        local valmeta = getmetatable (value)
        valmeta = type (valmeta) == 'table' and valmeta -- only tables
        local valtojson = valmeta and valmeta.__tojson
        if valtojson then
            if tables[value] then
                return exception('reference cycle', value, state, buffer, buflen)
            end
            tables[value] = true
            state.bufferlen = buflen
            local ret, msg = valtojson (value, state)
            if not ret then return exception('custom encoder failed', value, state, buffer, buflen, msg) end
            tables[value] = nil
            buflen = appendcustom(ret, buffer, state)
        elseif value == nil then
            buflen = buflen + 1
            buffer[buflen] = "null"
        elseif valtype == 'number' then
            local s
            if value ~= value or value >= huge or -value >= huge then
                -- This is the behaviour of the original JSON implementation.
                s = "null"
            else
                s = num2str (value)
            end
            buflen = buflen + 1
            buffer[buflen] = s
        elseif valtype == 'boolean' then
            buflen = buflen + 1
            buffer[buflen] = value and "true" or "false"
        elseif valtype == 'string' then
            buflen = buflen + 1
            buffer[buflen] = quotestring (value)
        elseif valtype == 'table' then
            if tables[value] then
                return exception('reference cycle', value, state, buffer, buflen)
            end
            tables[value] = true
            level = level + 1
            local isa, n = isarray (value)
            if n == 0 and valmeta and valmeta.__jsontype == 'object' then
                isa = false
            end
            local msg
            if isa then -- JSON array
                buflen = buflen + 1
                buffer[buflen] = "["
                for i = 1, n do
                    buflen, msg = encode2 (value[i], indent, level, buffer, buflen, tables, globalorder, state)
                    if not buflen then return nil, msg end
                    if i < n then
                        buflen = buflen + 1
                        buffer[buflen] = ","
                    end
                end
                buflen = buflen + 1
                buffer[buflen] = "]"
            else -- JSON object
                local prev = false
                buflen = buflen + 1
                buffer[buflen] = "{"
                local order = valmeta and valmeta.__jsonorder or globalorder
                if order then
                    local used = {}
                    n = #order
                    for i = 1, n do
                        local k = order[i]
                        local v = value[k]
                        if v then
                            used[k] = true
                            buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)
                            prev = true -- add a seperator before the next element
                        end
                    end
                    for k,v in pairs (value) do
                        if not used[k] then
                            buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)
                            if not buflen then return nil, msg end
                            prev = true -- add a seperator before the next element
                        end
                    end
                else -- unordered
                    for k,v in pairs (value) do
                        buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)
                        if not buflen then return nil, msg end
                        prev = true -- add a seperator before the next element
                    end
                end
                if indent then
                    buflen = addnewline2 (level - 1, buffer, buflen)
                end
                buflen = buflen + 1
                buffer[buflen] = "}"
            end
            tables[value] = nil
        else
            return exception ('unsupported type', value, state, buffer, buflen,
            "type '" .. valtype .. "' is not supported by JSON.")
        end
      return buflen
    end

    function Travelight (value, state)
        state = state or {}
        local oldbuffer = state.buffer
        local buffer = oldbuffer or {}
        state.buffer = buffer
        updatedecpoint()
        local ret, msg = encode2 (value, state.indent, state.level or 0,
                         buffer, state.bufferlen or 0, state.tables or {}, state.keyorder, state)
        if not ret then
            error (msg, 2)
        elseif oldbuffer == buffer then
            state.bufferlen = ret
            return true
        else
            state.bufferlen = nil
            state.buffer = nil
            return concat (buffer)
        end
    end

    function json.encode (value, state)
        state = state or {}
        local oldbuffer = state.buffer
        local buffer = oldbuffer or {}
        state.buffer = buffer
        updatedecpoint()
        local ret, msg = encode2 (value, state.indent, state.level or 0,
                         buffer, state.bufferlen or 0, state.tables or {}, state.keyorder, state)
        if not ret then
            error (msg, 2)
        elseif oldbuffer == buffer then
            state.bufferlen = ret
            return true
        else
            state.bufferlen = nil
            state.buffer = nil
            return concat (buffer)
        end
    end

    local function loc (str, where)
        local line, pos, linepos = 1, 1, 0
        while true do
            pos = strfind (str, "\n", pos, true)
            if pos and pos < where then
                line = line + 1
                linepos = pos
                pos = pos + 1
            else
                break
            end
        end
        return "line " .. line .. ", column " .. (where - linepos)
    end

    local function unterminated (str, what, where)
        return nil, strlen (str) + 1, "unterminated " .. what .. " at " .. loc (str, where)
        --
    end

    local function scanwhite (str, pos)
        while true do
            pos = strfind (str, "%S", pos)
            if not pos then return nil end
            local sub2 = strsub (str, pos, pos + 1)
            if sub2 == "\239\187" and strsub (str, pos + 2, pos + 2) == "\191" then
                -- UTF-8 Byte Order Mark
                pos = pos + 3
            elseif sub2 == "//" then
                pos = strfind (str, "[\n\r]", pos + 2)
                if not pos then return nil end
            elseif sub2 == "/*" then
                pos = strfind (str, "*/", pos + 2)
                if not pos then return nil end
                pos = pos + 2
            else
                return pos
            end
        end
    end

    local escapechars = {
        ["\""] = "\"", ["\\"] = "\\", ["/"] = "/", ["b"] = "\b", ["f"] = "\f",
        ["n"] = "\n", ["r"] = "\r", ["t"] = "\t"
    }

    local function unichar (value)
        if value < 0 then
            return nil
        elseif value <= 0x007f then
            return strchar (value)
        elseif value <= 0x07ff then
            return strchar (0xc0 + floor(value/0x40),
                            0x80 + (floor(value) % 0x40))
        elseif value <= 0xffff then
            return strchar (0xe0 + floor(value/0x1000),
                            0x80 + (floor(value/0x40) % 0x40),
                            0x80 + (floor(value) % 0x40))
        elseif value <= 0x10ffff then
            return strchar (0xf0 + floor(value/0x40000),
                            0x80 + (floor(value/0x1000) % 0x40),
                            0x80 + (floor(value/0x40) % 0x40),
                            0x80 + (floor(value) % 0x40))
        else
            return nil
        end
    end

    local function scanstring (str, pos)
        local lastpos = pos + 1
        local buffer, n = {}, 0
        while true do
            local nextpos = strfind (str, "[\"\\]", lastpos)
            if not nextpos then
                return unterminated (str, "string", pos)
            end
            if nextpos > lastpos then
                n = n + 1
                buffer[n] = strsub (str, lastpos, nextpos - 1)
            end
            if strsub (str, nextpos, nextpos) == "\"" then
                lastpos = nextpos + 1
                break
            else
                local escchar = strsub (str, nextpos + 1, nextpos + 1)
                local value
                if escchar == "u" then
                    value = tonumber (strsub (str, nextpos + 2, nextpos + 5), 16)
                    if value then
                        local value2
                        if 0xD800 <= value and value <= 0xDBff then
                        -- we have the high surrogate of UTF-16. Check if there is a
                        -- low surrogate escaped nearby to combine them.
                            if strsub (str, nextpos + 6, nextpos + 7) == "\\u" then
                                value2 = tonumber (strsub (str, nextpos + 8, nextpos + 11), 16)
                                    if value2 and 0xDC00 <= value2 and value2 <= 0xDFFF then
                                        value = (value - 0xD800)  * 0x400 + (value2 - 0xDC00) + 0x10000
                                    else
                                        value2 = nil -- in case it was out of range for a low surrogate
                                    end
                            end
                        end
                        value = value and unichar (value)
                        if value then
                            if value2 then
                                lastpos = nextpos + 12
                            else
                                lastpos = nextpos + 6
                            end
                        end
                    end
                end
                if not value then
                    value = escapechars[escchar] or escchar
                    lastpos = nextpos + 2
                end
                n = n + 1
                buffer[n] = value
            end
        end
        if n == 1 then
            return buffer[1], lastpos
        elseif n > 1 then
            return concat (buffer), lastpos
        else
            return "", lastpos
        end
    end

    local scanvalue -- forward declaration

    local function scantable (what, closechar, str, startpos, nullval, objectmeta, arraymeta)
        local len = strlen (str)
        local tbl, n = {}, 0
        local pos = startpos + 1
        if what == 'object' then
            setmetatable (tbl, objectmeta)
        else
            setmetatable (tbl, arraymeta)
        end
        while true do
            pos = scanwhite (str, pos)
            if not pos then return unterminated (str, what, startpos) end
            local char = strsub (str, pos, pos)
            if char == closechar then
                return tbl, pos + 1
            end
            local val1, err
            val1, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)
            if err then return nil, pos, err end
            pos = scanwhite (str, pos)
            if not pos then return unterminated (str, what, startpos) end
            char = strsub (str, pos, pos)
            if char == ":" then
                if val1 == nil then
                    return nil, pos, "cannot use nil as table index (at " .. loc (str, pos) .. ")"
                end
                pos = scanwhite (str, pos + 1)
                if not pos then return unterminated (str, what, startpos) end
                local val2
                val2, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)
                if err then return nil, pos, err end
                tbl[val1] = val2
                pos = scanwhite (str, pos)
                if not pos then return unterminated (str, what, startpos) end
                char = strsub (str, pos, pos)
            else
                n = n + 1
                tbl[n] = val1
            end
            if char == "," then
                pos = pos + 1
            end
        end
    end

    scanvalue = function (str, pos, nullval, objectmeta, arraymeta)
        pos = pos or 1
        pos = scanwhite (str, pos)
        if not pos then
            return nil, strlen (str) + 1, "no valid JSON value (reached the end)"
        end
        local char = strsub (str, pos, pos)
        if char == "{" then
            return scantable ('object', "}", str, pos, nullval, objectmeta, arraymeta)
        elseif char == "[" then
            return scantable ('array', "]", str, pos, nullval, objectmeta, arraymeta)
        elseif char == "\"" then
            return scanstring (str, pos)
        else
            local pstart, pend = strfind (str, "^%-?[%d%.]+[eE]?[%+%-]?%d*", pos)
            if pstart then
                local number = str2num (strsub (str, pstart, pend))
                    if number then
                        return number, pend + 1
                    end
            end
            pstart, pend = strfind (str, "^%a%w*", pos)
            if pstart then
                local name = strsub (str, pstart, pend)
                if name == "true" then
                    return true, pend + 1
                elseif name == "false" then
                    return false, pend + 1
                elseif name == "null" then
                    return nullval, pend + 1
                end
            end
            return nil, pos, "no valid JSON value at " .. loc (str, pos)
        end
    end

    local function optionalmetatables(...)
        if select("#", ...) > 0 then
            return ...
        else
            return {__jsontype = 'object'}, {__jsontype = 'array'}
        end
    end

    function json.decode (str, pos, nullval, ...)
        local objectmeta, arraymeta = optionalmetatables(...)
        return scanvalue (str, pos, nullval, objectmeta, arraymeta)
    end

    function json.use_lpeg ()
        local g = require ("lpeg")

        if g.version() == "0.11" then
            error "due to a bug in LPeg 0.11, it cannot be used for JSON matching"
        end

        local pegmatch = g.match
        local P, S, R = g.P, g.S, g.R

        local function ErrorCall (str, pos, msg, state)
            if not state.msg then
                state.msg = msg .. " at " .. loc (str, pos)
                state.pos = pos
            end
            return false
        end

        local function Err (msg)
            return g.Cmt (g.Cc (msg) * g.Carg (2), ErrorCall)
        end

        local SingleLineComment = P"//" * (1 - S"\n\r")^0
        local MultiLineComment = P"/*" * (1 - P"*/")^0 * P"*/"
        local Space = (S" \n\r\t" + P"\239\187\191" + SingleLineComment + MultiLineComment)^0

        local PlainChar = 1 - S"\"\\\n\r"
        local EscapeSequence = (P"\\" * g.C (S"\"\\/bfnrt" + Err "unsupported escape sequence")) / escapechars
        local HexDigit = R("09", "af", "AF")
        local function UTF16Surrogate (match, pos, high, low)
            high, low = tonumber (high, 16), tonumber (low, 16)
            if 0xD800 <= high and high <= 0xDBff and 0xDC00 <= low and low <= 0xDFFF then
                return true, unichar ((high - 0xD800)  * 0x400 + (low - 0xDC00) + 0x10000)
            else
                return false
            end
        end
        local function UTF16BMP (hex)
            return unichar (tonumber (hex, 16))
        end
        local U16Sequence = (P"\\u" * g.C (HexDigit * HexDigit * HexDigit * HexDigit))
        local UnicodeEscape = g.Cmt (U16Sequence * U16Sequence, UTF16Surrogate) + U16Sequence/UTF16BMP
        local Char = UnicodeEscape + EscapeSequence + PlainChar
        local String = P"\"" * g.Cs (Char ^ 0) * (P"\"" + Err "unterminated string")
        local Integer = P"-"^(-1) * (P"0" + (R"19" * R"09"^0))
        local Fractal = P"." * R"09"^0
        local Exponent = (S"eE") * (S"+-")^(-1) * R"09"^1
        local Number = (Integer * Fractal^(-1) * Exponent^(-1))/str2num
        local Constant = P"true" * g.Cc (true) + P"false" * g.Cc (false) + P"null" * g.Carg (1)
        local SimpleValue = Number + String + Constant
        local ArrayContent, ObjectContent

        -- The functions parsearray and parseobject parse only a single value/pair
        -- at a time and store them directly to avoid hitting the LPeg limits.
        local function parsearray (str, pos, nullval, state)
            local obj, cont
            local npos
            local t, nt = {}, 0
            repeat
                obj, cont, npos = pegmatch (ArrayContent, str, pos, nullval, state)
                if not npos then break end
                pos = npos
                nt = nt + 1
                t[nt] = obj
            until cont == 'last'
            return pos, setmetatable (t, state.arraymeta)
        end

        local function parseobject (str, pos, nullval, state)
            local obj, key, cont
            local npos
            local t = {}
        repeat
            key, obj, cont, npos = pegmatch (ObjectContent, str, pos, nullval, state)
            if not npos then break end
            pos = npos
            t[key] = obj
            until cont == 'last'
            return pos, setmetatable (t, state.objectmeta)
        end

        local Array = P"[" * g.Cmt (g.Carg(1) * g.Carg(2), parsearray) * Space * (P"]" + Err "']' expected")
        local Object = P"{" * g.Cmt (g.Carg(1) * g.Carg(2), parseobject) * Space * (P"}" + Err "'}' expected")
        local Value = Space * (Array + Object + SimpleValue)
        local ExpectedValue = Value + Space * Err "value expected"
        ArrayContent = Value * Space * (P"," * g.Cc'cont' + g.Cc'last') * g.Cp()
        local Pair = g.Cg (Space * String * Space * (P":" + Err "colon expected") * ExpectedValue)
        ObjectContent = Pair * Space * (P"," * g.Cc'cont' + g.Cc'last') * g.Cp()
        local DecodeValue = ExpectedValue * g.Cp ()

        function json.decode (str, pos, nullval, ...)
            local state = {}
            state.objectmeta, state.arraymeta = optionalmetatables(...)
            local obj, retpos = pegmatch (DecodeValue, str, pos, nullval, state)
            if state.msg then
                return nil, state.pos, state.msg
            else
                return obj, retpos
            end
        end

        -- use this function only once:
        json.use_lpeg = function () return json end

        json.using_lpeg = true

        return json -- so you can get the module using json = require "dkjson".use_lpeg()
    end

    if always_try_using_lpeg then
        pcall (json.use_lpeg)
    end

    return json
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Defines the Event class.

    if not Event then
        --- An event.
        Event = Class();

        --- Initialize the instance of the Event class.
        function Event:Constructor ()
            self.Handlers = {};
        end

        --- Add a handler to the event.
        -- @param Handler The new handler function.
        function Event:AddHandler (Handler)
            table.insert(self.Handlers, Handler);
        end

        --- Remove a handler from the event.
        -- @param Handler The handler function to remove.
        function Event:RemoveHandler (Handler)
            for Key, Value in pairs(self.Handlers) do
                if Value == Handler then
                    table.remove(self.Handlers, Key);
                    return;
                end
            end

            error("The handler was not found.");
        end

        --- Invoke the event, calling all of its handlers.
        -- @param ... The arguments for the handlers.
        function Event:Call (...)
            for Key, Handler in pairs(self.Handlers) do
                Handler(...);
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Defines the event manager.

    -- Used for every Events
    module.Events = {};
    module.EventFrame = CreateFrame("Frame");

    -- Used for Combat Log Events
    -- To be used with Combat Log Unfiltered
    module.CombatEvents = {};
    -- To be used with Combat Log Unfiltered with SourceGUID == PlayerGUID filter
    module.SelfCombatEvents = {};


    --- Register a handler for an event.
    -- @param Event The event name.
    -- @param Handler The handler function.
    function module:RegisterForEvent (Handler, ...)
        local EventsTable = {...};
        local Event;
        for i = 1, #EventsTable do
            Event = EventsTable[i];
            if not module.Events[Event] then
                module.Events[Event] = {Handler};
                module.EventFrame:RegisterEvent(Event);
            else
                table.insert(module.Events[Event], Handler);
            end
        end
    end

    --- Register a handler for a combat event.
    -- @param Event The combat event name.
    -- @param Handler The handler function.
    function module:RegisterForCombatEvent (Handler, ...)
        local EventsTable = {...};
        local Event;
        for i = 1, #EventsTable do
            Event = EventsTable[i];
            if not module.CombatEvents[Event] then
                module.CombatEvents[Event] = {Handler};
            else
                table.insert(module.CombatEvents[Event], Handler);
            end
        end
    end

    --- Register a handler for a self combat event.
    -- @param Event The combat event name.
    -- @param Handler The handler function.
    function module:RegisterForSelfCombatEvent (Handler, ...)
        local EventsTable = {...};
        local Event;
        for i = 1, #EventsTable do
            Event = EventsTable[i];
            if not module.SelfCombatEvents[Event] then
                module.SelfCombatEvents[Event] = {Handler};
            else
                table.insert(module.SelfCombatEvents[Event], Handler);
            end
        end
    end

    --- Unregister a handler from an event.
    -- @param Event The event name.
    -- @param Handler The handler function.
    function module:UnregisterForEvent (Handler, Event)
        if module.Events[Event] then
            for Index, Function in pairs(module.Events[Event]) do
                if Function == Handler then
                    table.remove(module.Events[Event], Index);
                    if #module.Events[Event] == 0 then
                        module.EventFrame:UnregisterEvent(Event);
                    end
                    return;
                end
            end
        end
    end

    --- Unregister a handler from a combat event.
    -- @param Event The combat event name.
    -- @param Handler The handler function.
    function module:UnregisterForCombatEvent (Handler, Event)
        if module.CombatEvents[Event] then
            for Index, Function in pairs(module.CombatEvents[Event]) do
                if Function == Handler then
                    table.remove(module.CombatEvents[Event], Index);
                    return;
                end
            end
        end
    end

    --- Unregister a handler from a combat event.
    -- @param Event The combat event name.
    -- @param Handler The handler function.
    function module:UnregisterForSelfCombatEvent (Handler, Event)
        if module.SelfCombatEvents[Event] then
            for Index, Function in pairs(module.SelfCombatEvents[Event]) do
                if Function == Handler then
                    table.remove(module.SelfCombatEvents[Event], Index);
                    return;
                end
            end
        end
    end

    -- OnEvent Frame
    module.EventFrame:SetScript("OnEvent",
        function (self, Event, ...)
            for Index, Handler in pairs(module.Events[Event]) do
                Handler(...);
            end
        end
    );
    -- Combat Log Event Unfiltered
    module:RegisterForEvent(
        function (TimeStamp, Event, ...)
            if module.CombatEvents[Event] then
                -- Unfiltered Combat Log
                for Index, Handler in pairs(module.CombatEvents[Event]) do
                    Handler(TimeStamp, Event, ...);
                end
            end
            if module.SelfCombatEvents[Event] then
                -- Unfiltered Combat Log with SourceGUID == PlayerGUID filter
                if select(2, ...) == C.PLAYERGUID then
                    for Index, Handler in pairs(module.SelfCombatEvents[Event]) do
                        Handler(TimeStamp, Event, ...);
                    end
                end
            end
        end
        , "COMBAT_LOG_EVENT_UNFILTERED"
    );
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Defines miscellaneous functions.

    if GetOSVersion() == "MacOSX" then ProfilesDirectoryChange = "/Profiles/"; ErrorsDirectoryChange = "/Errors/"; RotationsDirectoryChange = "/Purchased Rotations.txt"; TicketDirectoryChange = "/Ticket Information.txt"; SettingsDirectoryChange = "/Settings Dump.txt"; MacroCommandDirectoryChange = "/Macro Command.txt";end

    function module.GetTime (ForceRefresh)
        if not module.GetTimeMemorized or ForceRefresh then
            module.GetTimeMemorized = GetTime();
        end
        return module.GetTimeMemorized;
    end

    --- Print a message to the chat window.
    -- @param ... The values to print.
    function module.Print (...)
        if module.GetSetting("Enable Chat Notifications_Checked") ~= true then return; end
        print("[|cFF0099FFSoapbox Rotations|r]", ...);
    end
    function module.Free(...)
        if module.GetSetting("Enable Chat Notifications_Checked") ~= true then return; end
        print("[|cFF0099FFSoapbox Rotations|r]", ...);
    end
    function module.Command (...)
        print("[|cFFFF0000Commands|r]", ...);
        --
    end
    function module.QueueSystem (...)
        if module.GetSetting("Enable Chat Notifications_Checked") ~= true then return; end
        print("[|cFF64FE2EQueue System|r]", ...);
    end
    function module.StatusUpdate (...)
        if module.GetSetting("Enable Chat Notifications_Checked") ~= true then return; end
        print("[|cFFBE81F7Casting Engine|r]", ...);
    end
    function module.ProfileManager (...)
        if module.GetSetting("Enable Chat Notifications_Checked") ~= true then return; end
        print("[|cFFEEEB16Profile Manager|r]", ...);
    end
    function module.Error (...)
        if module.GetSetting("Enable Chat Notifications_Checked") ~= true then return; end
        print("[|cFFFF0000Soapbox ERROR|r]", ...);
    end
    function module.Bug (...)
        if module.GetSetting("Enable Chat Notifications_Checked") ~= true or not module.UseDebug() then return; end
        print("[|cFFFF0000Soapbox Debug|r]", ...);
     end

    function AccessGranted ()
        local PlayerSpec = GetSpecialization();

        if C.CLASSNAME == "DRUID" then
            -- Balance
            if PlayerSpec == 1 and not UserHasRotation("Druid-Balance") then
                return "product/balance-druid-2/";
            end
            -- Feral
            if PlayerSpec == 2 and not UserHasRotation("Druid-Feral") then
                return "product/feral-druid/";
            end
            -- Guardian
            if PlayerSpec == 3 and not UserHasRotation("Druid-Guardian") then
                return "product/guardian-druid-2/";
            end
            -- Restoration
            if PlayerSpec == 4 and not UserHasRotation("Druid-Restoration") then
                return "product/restoration-druid/";
            end
        end
        if C.CLASSNAME == "DEATHKNIGHT" then
            -- Blood
            if PlayerSpec == 1 and not UserHasRotation("DeathKnight-Blood") then
                return "product/blood-death-knight/";
            end
            -- Frost
            if PlayerSpec == 2 and not UserHasRotation("DeathKnight-Frost") then
                return "product/frost-death-knight/";
            end
            -- Unholy
            if PlayerSpec == 3 and not UserHasRotation("DeathKnight-Unholy") then
                return "product/unholy-death-knight-2/";
            end
        end
        if C.CLASSNAME == "DEMONHUNTER" then
            -- Havoc
            if PlayerSpec == 1 and not UserHasRotation("DemonHunter-Havoc") then
                return "product/demon-hunter-havoc/";
            end
            -- Vengeance
            if PlayerSpec == 2 and not UserHasRotation("DemonHunter-Vengeance") then
                return "product/demon-hunter-vengeance/";
            end
        end
        if C.CLASSNAME == "SHAMAN" then
            -- Elemental
            if PlayerSpec == 1 and not UserHasRotation("Shaman-Elemental") then
                return "product/elemental-shaman-2/";
            end
            -- Enhancement
            if PlayerSpec == 2 and not UserHasRotation("Shaman-Enhancement") then
                return "product/enhancement-shaman/";
            end
            -- Restoration
            if PlayerSpec == 3 and not UserHasRotation("Shaman-Restoration") then
                return "product/restoration-shaman-2/";
            end
        end
        if C.CLASSNAME == "HUNTER" then
            -- Beast Mastery
            if PlayerSpec == 1 and not UserHasRotation("Hunter-BeastMastery") then
                return "product/beast-mastery-hunter/";
            end
            -- Marksmanship
            if PlayerSpec == 2 and not UserHasRotation("Hunter-Marksmanship") then
                return "product/marksmanship-hunter/";
            end
            -- Survival
            if PlayerSpec == 3 and not UserHasRotation("Hunter-Survival") then
                return "product/survival-hunter/";
            end
        end
        if C.CLASSNAME == "MAGE" then
            -- Arcane
            if PlayerSpec == 1 and not UserHasRotation("Mage-Arcane") then
                return "product/arcane-mage-3/";
            end
            -- Fire
            if PlayerSpec == 2 and not UserHasRotation("Mage-Fire") then
                return "product/fire-mage/";
            end
            -- Frost
            if PlayerSpec == 3 and not UserHasRotation("Mage-Frost") then
                return "product/frost-mage/";
            end
        end
        if C.CLASSNAME == "MONK" then
            -- Brewmaster
            if PlayerSpec == 1 and not UserHasRotation("Monk-Brewmaster") then
                return "product/brewmaster-monk/";
            end
            -- Mistweaver
            if PlayerSpec == 2 and not UserHasRotation("Monk-Mistweaver") then
                return "product/mistweaver-monk/";
            end
            -- Windwalker
            if PlayerSpec == 3 and not UserHasRotation("Monk-Windwalker") then
                return "product/windwalker-monk/";
            end
        end
        if C.CLASSNAME == "PALADIN" then
            -- Holy
            if PlayerSpec == 1 and not UserHasRotation("Paladin-Holy") then
                return "product/holy-paladin/";
            end
            -- Protection
            if PlayerSpec == 2 and not UserHasRotation("Paladin-Protection") then
                return "product/protection-paladin/";
            end
            -- Retribution
            if PlayerSpec == 3 and not UserHasRotation("Paladin-Retribution") then
                return "product/retribution-paladin/";
            end
        end
        if C.CLASSNAME == "PRIEST" then
            -- Discipline
            if PlayerSpec == 1 and not UserHasRotation("Priest-Discipline") then
                return "product/discipline-priest-3/";
            end
            -- Holy
            if PlayerSpec == 2 and not UserHasRotation("Priest-Holy") then
                return "product/holy-priest-2/";
            end
            -- Shadow
            if PlayerSpec == 3 and not UserHasRotation("Priest-Shadow") then
                return "product/shadow-priest/";
            end
        end
        if C.CLASSNAME == "ROGUE" then
            -- Assassination
            if PlayerSpec == 1 and not UserHasRotation("Rogue-Assassination") then
                return "product/assassination-rogue/";
            end
            -- Combat
            if PlayerSpec == 2 and not (UserHasRotation("Rogue-Combat") or UserHasRotation("Rogue-Outlaw")) then
                return "product/outlaw-rogue/";
            end
            -- Subtlety
            if PlayerSpec == 3 and not UserHasRotation("Rogue-Subtlety") then
                return "product/subtlety-rogue/";
            end
        end
        if C.CLASSNAME == "WARLOCK" then
            -- Affliction
            if PlayerSpec == 1 and not UserHasRotation("Warlock-Affliction") then
                return "product/affliction-warlock/";
            end
            -- Demonology
            if PlayerSpec == 2 and not UserHasRotation("Warlock-Demonology") then
                return "product/demonology-warlock/";
            end
            -- Destruction
            if PlayerSpec == 3 and not UserHasRotation("Warlock-Destruction") then
                return "product/destruction-warlock/";
            end
        end
        if C.CLASSNAME == "WARRIOR" then
            -- Arms
            if PlayerSpec == 1 and not UserHasRotation("Warrior-Arms") then
                return "product/arms-warrior/";
            end
            -- Fury
            if PlayerSpec == 2 and not UserHasRotation("Warrior-Fury") then
                return "product/fury-warrior/";
            end
            -- Protection
            if PlayerSpec == 3 and not UserHasRotation("Warrior-Protection") then
                return "product/protection-warrior/";
            end
        end
        return true;
    end

    function DumpKey ()
        return GetMembershipKey();
        --
    end

    function APITest ()
        local APILoadFailed = nil;
        local FailedAPI = {};
        if not GetUnitCount then
            table.insert(FailedAPI, "GetUnitCount");
            APILoadFailed = true;
        end
        if not GetUnitByIndex then
            table.insert(FailedAPI, "GetUnitByIndex");
            APILoadFailed = true;
        end
        if not OpenURL then
            table.insert(FailedAPI, "OpenURL");
            APILoadFailed = true;
        end
        if not GetClientVersion then
            table.insert(FailedAPI, "GetClientVersion");
            APILoadFailed = true;
        end
        if not ReadFile then
            table.insert(FailedAPI, "ReadFile");
            APILoadFailed = true;
        end
        if not WriteFile then
            table.insert(FailedAPI, "WriteFile");
            APILoadFailed = true;
        end

        if not GetOSVersion then
            table.insert(FailedAPI, "GetOSVersion");
            APILoadFailed = true;
        end
        if not GetAutoAway then
            table.insert(FailedAPI, "GetAutoAway");
            APILoadFailed = true;
        end
        if not SetAutoAway then
            table.insert(FailedAPI, "SetAutoAway");
            APILoadFailed = true;
        end
        if not UserHasRotation then
            table.insert(FailedAPI, "UserHasRotation");
            APILoadFailed = true;
        end
        if not GetSetting then
            table.insert(FailedAPI, "GetSetting");
            APILoadFailed = true;
        end
        if not SetSetting then
            table.insert(FailedAPI, "SetSetting");
            APILoadFailed = true;
        end
        if not GetUnitPosition then
            table.insert(FailedAPI, "GetUnitPosition");
            APILoadFailed = true;
        end
        if not GetUnitFacing then
            table.insert(FailedAPI, "GetUnitFacing");
            APILoadFailed = true;
        end
        if not GetUnitBoundingRadius then
            table.insert(FailedAPI, "GetUnitBoundingRadius");
            APILoadFailed = true;
        end
        if not GetUnitCombatReach then
            table.insert(FailedAPI, "GetUnitCombatReach");
            APILoadFailed = true;
        end
        if not TraceLine then
            table.insert(FailedAPI, "TraceLine");
            APILoadFailed = true;
        end
        if not IsAoEPending then
            table.insert(FailedAPI, "IsAoEPending");
            APILoadFailed = true;
        end
        if not ClearPendingSpell then
            table.insert(FailedAPI, "ClearPendingSpell");
            APILoadFailed = true;
        end
        if not CastAtPosition then
            table.insert(FailedAPI, "CastAtPosition");
            APILoadFailed = true;
        end
        if not GetUnitNearPositionCount then
            table.insert(FailedAPI, "GetUnitNearPositionCount");
            APILoadFailed = true;
        end
        if not GetUnitNearPositionByIndex then
            table.insert(FailedAPI, "GetUnitNearPositionByIndex");
            APILoadFailed = true;
        end
        if not Is64Bit then
            table.insert(FailedAPI, "Is64Bit");
            APILoadFailed = true;
        end
        if not GetManagerDirectory then
            table.insert(FailedAPI, "GetManagerDirectory");
            APILoadFailed = true;
        end

        if not APILoadFailed then
            print("Success")
        else
            return FailedAPI;
        end
    end


    -- Addon Conflict Fix
    --[[local Secure = true;

    function issecure ()
        return Secure;
        --
    end

    local InterfaceOptions_AddCategory_Original = InterfaceOptions_AddCategory;
    function InterfaceOptions_AddCategory (...)
        Secure = false;
        InterfaceOptions_AddCategory_Original(...);
        Secure = true;
    end]]

    --- Get the numbers from a string.
    -- @param String The string.
    -- @return A table containing all of the numbers in the string.
    function module.NumbersInString (String)
        local Numbers = {};

        String = String:gsub("%,","");

        local Position = String:find("%d+");
        while Position do
            local Number = String:match("%d+");
            table.insert(Numbers, Number);
            String = String:sub(Position + Number:len());

            Position = String:find("%d+");
        end

        return Numbers;
    end

    function NotBoostedToon ()
        if UnitLevel("player") == 90 then
            local BoostedTable = {
            --Death Knight
            114866,
            130735,
            130736,
            165394,
            165395,
            --Druid
            165386,
            165387,
            165372,
            165374,
            --Hunter
            165396,
            165389,
            165378,
            --Mage
            165359,
            165360,
            165357,
            --Monk
            165397,
            165398,
            165379,
            --Paladin
            165381,
            165375,
            165380,
            --Priest
            165370,
            165376,
            165362,
            --Rogue
            76577,
            --Shaman
            165391,
            165399,
            165368,
            --Warlock
            165367,
            165392,
            165363,
            --Warrior
            165383,
            165365,
            165393
            };
            for i=1, #BoostedTable do
                if IsPlayerSpell(BoostedTable[i]) then
                    return true;
                end
            end
            message("You have used the Character Boost Service and it did not load all of your abilities. Joining an Arena, Battleground, Dungeon or Raid will fix this.");
            module.Error("You have used the Character Boost Service and it did not load all of your abilities. Joining an Arena, Battleground, Dungeon or Raid will fix this.");
            if GetSetting("Open Boosting URL") ~= "true" then
                OpenURL("https://forums.soapboxrotations.com/viewtopic.php?f=11&t=2474");
                SetSetting("Open Boosting URL", "true");
            end
        end
        return false;
    end

    function GetActiveGroupMembers ()
        if IsInGroup() then
            local Units = {};
            if IsInRaid() then
                for Index = 1, GetNumGroupMembers() do
                    local ThisUnit = module.Unit("Raid" .. Index);
                    if ThisUnit:Exists() and not ThisUnit:IsDeadOrGhost() and ThisUnit:IsConnected() then
                        table.insert(Units, ThisUnit);
                    end
                end
            else
                for Index = 1, GetNumGroupMembers() - 1 do
                    local ThisUnit = module.Unit("Party" .. Index);
                    if ThisUnit:Exists() and not ThisUnit:IsDeadOrGhost() and ThisUnit:IsConnected() then
                        table.insert(Units, ThisUnit);
                    end
                end

                if not module.Unit.Player:IsDeadOrGhost() then
                    table.insert(Units, module.Unit.Player);
                end
            end

            return #Units;
        else
            return 1;
        end
    end
    --- Get the numbers from the nGTT tooltip.
    -- @return The numbers in the tooltip.
    function module.GetNumbers ()
        local String = "";
        for Index = 1, 6 do
            local Text = _G["MyScanningTooltipTextLeft" .. Index];
            if Text then
                local TextString = Text:GetText();
                if TextString then
                    String = String .. TextString;
                else
                    break;
                end
            else
                break;
            end
        end

        return module.NumbersInString(String);
    end

    --- Get the numbers in an aura's tooltip.
    -- @param Unit The unit the aura is on.
    -- @param Index The index of the aura.
    -- @return The numbers in the tooltip.
    function module.GetNumbersForAuraIndex (Unit, Index)
        nGTT:SetUnitAura(Unit, Index, "Player");
        return module.GetNumbers();
    end

    --- Get the numbers in an aura's tooltip.
    -- @param Unit The unit the aura is on.
    -- @param SpellID The spell ID of the spell that caused the aura.
    -- @return The numbers in the tooltip.
    function module.GetNumbersForAura (Other, Spell)
        local SpellID = Spell:ID();
        for Index = 1, C.MAXIMUM_BUFFS do
            if select(11, UnitAura(Other.UnitID, Index)) == SpellID then
                return module.GetNumbersForAuraIndex(Other.UnitID, Index);
            end
        end
    end

    --- Get the numbers in a buff's tooltip.
    -- @param Unit The unit the buff is on.
    -- @param Index The index of the buff on the unit.
    -- @return The numbers in the tooltip.
    function module.GetNumbersForBuffIndex (Unit, Index)
        nGTT:SetUnitBuff(Unit, Index, "Player");
        return module.GetNumbers();
    end

    --- Get the numbers in a buff's tooltip.
    -- @param Unit The unit the buff is on.
    -- @param SpellID The spell ID of the spell that caused the buff.
    -- @return The numbers in the tooltip.
    function module.GetNumbersForBuff (Other, Spell)
        local SpellID = Spell:ID();
        for Index = 1, C.MAXIMUM_BUFFS do
            if select(11, UnitBuff(Other.UnitID, Index)) == SpellID then
                return module.GetNumbersForBuffIndex(Other.UnitID, Index);
            end
        end
    end

    --- Get the numbers in a debuff's tooltip.
    -- @param Unit The unit the debuff is on.
    -- @param Index The index of the debuff on the unit.
    -- @return The numbers in the tooltip.
    function module.GetNumbersForDebuffIndex (Unit, Index)
        nGTT:SetUnitDebuff(Unit, Index, "Player");
        return module.GetNumbers();
    end

    --- Get the numbers in a debuff's tooltip.
    -- @param Unit The unit the debuff is on.
    -- @param SpellID The spell ID of the spell that caused the debuff.
    -- @return The numbers in the tooltip.
    function module.GetNumbersForDebuff (Other, Spell)
        local SpellID = Spell:ID();
        for Index = 1, C.MAXIMUM_BUFFS do
            if select(11, UnitDebuff(Other.UnitID, Index)) == SpellID then
                return module.GetNumbersForDebuffIndex(Other.UnitID, Index);
            end
        end
    end
    function FrameRate()
        if Round(GetFramerate(), 0) < 20 then
            module.SetOutput("Framerate", "|cFFFF0000LOW");--[[GREEN]]
            --return Round(GetFramerate(), 0);
        elseif Round(GetFramerate(), 0) < 40 then
            module.SetOutput("Framerate", "|cFFFFFF00AVERAGE");--[[GREEN]]
            --return Round(GetFramerate(), 0);
        else
            module.SetOutput("Framerate", "|cFF00FF00HIGH");--[[GREEN]]
            --return Round(GetFramerate(), 0);
        end
    end

    local Lower, Upper = 0, 1;
    function module.MathRandom (SettingA, SettingB, Offset)
        if SettingA and type(module.GetSetting(SettingA)) == "number" then
            Lower = module.GetSetting(SettingA);
        else
            Lower = 0;
        end
        if SettingB and type(module.GetSetting(SettingB)) == "number" then
            Upper = module.GetSetting(SettingB);
        elseif SettingA and type(module.GetSetting(SettingA)) == "number" and Offset then
            Upper = module.GetSetting(SettingA)+Offset;
        else
            Upper = 1;
        end
        return math.random(Lower, Upper);
    end

    function module.GetLatency ()
        -- Ping + Offset
        return module.IsOptionEnabled("Latency Tolerance") and (select(4, GetNetStats()) + module.MathRandom("Latency Tolerance_Value2", nil, 5))/1000 or 0;
    end

    function module.GetTPSTime ()
        return 1/module.GetSecondOptionValue("TPS: Unit | Rotation");
        --
    end

    local CDTime, CDValue = 0, 0;
    function module.GlobalCooldown ()
        CDTime, CDValue = GetSpellCooldown(61304);

        if CDTime == 0 or module.GetTime()-module.GetLatency() >= CDTime+CDValue then
            return true;
        else
            return false;
        end
    end

    function RemoveUpdateButton ()
        Button[5][1]:Hide();
        LastSpec = GetSpecialization();
    end

    local WebsiteLaunched, Scanned, Scanned2, RunThisOnce = false, false, false, false;
    function WelcomeMessage ()
        -- Display Welcome Message Once
        if module.GetSetting("Enable Welcome Greeting_Checked") ~= false and not Scanned2 then
            print("Thank you for using |cFFFA5858Soapbox|cFF0080FF Rotations!")
            print("|cFFFF8000Patch: ".."|cFF893FBB"..ClientVersion);
            print("|cFFFF8000Rotation File Date: ".."|cFF893FBB"..RotationFileDate);
            local CommandName = module and module.CmdName or "soap"
            print("To load toggles into macros (you need 9 free character macro slots): |cFF0080FF/".. CommandName .." macros");
            print("For a list of commands type: |cFF0080FF/".. CommandName .." commands");
            -- ToggleQueue = false;
            Scanned2 = true;
        end

        -- Scan once via AccessGranted() if the player's level exceed leveling cap
        if not Scanned and UnitLevel("player") > ClientLevelingCap then
            local Granted = AccessGranted();
            local WarningMessage = "No purchased Rotation detected. Non-LFR Raids, Mythic Dungeons, Challenge Modes, and Proving Grounds will be disabled. Upgrade to remove this restriction";
            if Granted ~= true then
                module.StatusUpdate(WarningMessage);
            end
            Scanned = true;
        end

        -- Set the states to running once
        if not RunThisOnce then
            if module.IsRunning() == nil then
                module.SetRunning(true);
            end
            if module.UseCooldowns() == nil then
                module.SetCooldowns(true);
            end
            if module.UseAOE() == nil then
                module.SetAOE(true);
            end
            RunThisOnce = true;
        end
    end

    function module.LUAErrorHandler (errormsg)
        --if not string.find(errormsg, "script ran too long") then
            stacks = debugstack(2);
            if not ErrorTime or module.GetTime()-ErrorTime > 5 then
                ErrorTime = module.GetTime();
                local String = "";
                local function WriteLine (Line)
                    String = String .. Line .. "\n";
                end

                local Archetype = nil;
                if GetOSVersion() == "MacOSX" then
                    Archetype = "Mac [x64]";
                elseif Is64Bit then
                    if Is64Bit() then
                        Archetype = "Windows [x64]";
                    else
                        Archetype = "Windows [x86]";
                    end
                else
                    Archetype = "Archetype not available";
                end
                WriteLine("Operating System Version: " .. GetOSVersion() .." " .. Archetype);

                if module.IsOptionEnabled("Beta Version") and BetaEnabled then
                    WriteLine("Rotation: BETA");
                else
                    WriteLine("Rotation: LIVE");
                end

                local className = select(2, UnitClass("player"));
                local CurrentProfile = ProfileKey.." - "..ProfileName;

                WriteLine("Patch: " .. ClientVersion);
                WriteLine("Rotation File Date: " .. RotationFileDate);
                WriteLine("Character Level: " .. UnitLevel("player"));
                WriteLine("Race: " ..  UnitRace("player"));
                WriteLine("Class: " .. className);
                WriteLine("Spec: " .. currentSpecName);
                WriteLine("Profile: " .. CurrentProfile);
                WriteLine("Time Of Error: " .. date("%m/%d/%y %H:%M:%S"));
                WriteLine("Zone: " .. GetRealZoneText());
                WriteLine("Error Message: " .. errormsg);
                WriteLine("Stacks : " .. stacks);
                WriteFile(GetManagerDirectory() .. ErrorsDirectoryChange .. className .. " - ".. currentSpecName .. " - Error.txt", String);
                module.ToolboxError("Soapbox Rotations has encountered an Error that may affect performance. Please paste the contents of '" .. className .. " - ".. currentSpecName .. " - Error.txt' in your /Errors/ folder in a Ticket on our website to have this fixed.");
                module.Error("Soapbox Rotations has encountered an Error that may affect performance. Please paste the contents of '" .. className .. " - ".. currentSpecName .. " - Error.txt' in your /Errors/ folder in a Ticket on our website to have this fixed.");
            end
        --end
    end

    --- Get the numbers in a spell's tooltip.
    -- @param SpellID The spell ID
    -- @return The numbers in the tooltip.
    function module.GetNumbersForSpell (Spell)
        SpellID = Spell:ID();
        nGTT:SetSpellByID(SpellID);
        return module.GetNumbers();
    end

    function Round(number, decimal)
        local multiplier = 10^(decimal or 0)
        return math.floor(number * multiplier + 0.5) / multiplier
    end

    ---- Pulse Control ----
    --- Pulse Control variables
    module.IsInControl, module.QueuedControl, module.QueuedControlTime = "Loading Screen", true, GetTime();

    --- Pulse Control functions
    local function ControlPrint (State, Comments)
        if (module.GetOptionValue("Pulse Control") == "Chat" or module.GetOptionValue("Pulse Control") == "Both") and module.GetSetting("Enable Chat Notifications_Checked") then
            print(State .. Comments)
        end
        if (module.GetOptionValue("Pulse Control") == "Overlay" or module.GetOptionValue("Pulse Control") == "Both") and module.GetSetting("Enable Chat Overlay_Checked") then
            XRNOverlay(State)
        end
    end
    function module.DisableControl (Reason)
        module.IsInControl, module.QueuedControl = Reason, false;
        ControlPrint("|cffffffff[|cffcc0000Soapbox - Disabling Control|cffffffff]", " Temporarily for " .. module.IsInControl .. ".");
    end
    function module.QueueControl (Delay)
        module.QueuedControl, module.QueuedControlTime = true, GetTime() + Delay;
        ControlPrint("|cffffffff[|cffffcc00Soapbox - Recovering Control|cffffffff]", " In " .. Delay .. " seconds after " .. module.IsInControl .. ".");
    end
    function module.RestoreControl ()
        ControlPrint("|cffffffff[|cff00ff00Soapbox - Control Restored|cffffffff]", " After " .. module.IsInControl .. ".");
        module.IsInControl, module.QueuedControl, module.QueuedControlTime = true, false, 0;
    end

    --- Pulse Control events reader
    -- Loading Screen
    module:RegisterForEvent(
        function ()
            module.DisableControl("Loading Screen");
        end
        , "LOADING_SCREEN_ENABLED"
    );
    module:RegisterForEvent(

        function ()
            if module.IsInControl == "Loading Screen" then
                module.QueueControl(4);
            end
        end
        , "LOADING_SCREEN_DISABLED"
    );
    -- Looting
    module:RegisterForEvent(
        function ()
            module.DisableControl("Looting");
        end
        , "LOOT_OPENED"
    );
    module:RegisterForEvent(
        function ()
            if module.IsInControl == "Looting" and not module.QueuedControl then
                module.QueueControl(0.75);
            end
        end
        , "LOOT_CLOSED"
    );
    -- Gathering Skills
    module:RegisterForEvent(
        function (Arg1, Arg2, Arg3, Arg4, Arg5)
            if Arg1 == "player" and Event == "UNIT_SPELLCAST_START" then
                if Arg5 == 170691 then
                    module.DisableControl("Gathering Herb");
                end
                if Arg5 == 170599 then
                    module.DisableControl("Gathering Mineral");
                end
                if Arg5 == 158756 then
                    module.DisableControl("Skinning");
                end
            end
        end
        , "UNIT_SPELLCAST_START"
    );
    module:RegisterForEvent(
        function (Arg1, Arg2, Arg3, Arg4, Arg5)
            if Arg1 == "player" and Event == "UNIT_SPELLCAST_STOP" then
                if module.IsInControl == "Gathering Herb" and Arg5 == 170691 then
                    module.QueueControl(0.5);
                end
                if module.IsInControl == "Gathering Mineral" and Arg5 == 170599 then
                    module.QueueControl(0.5);
                end
                if module.IsInControl == "Skinning" and Arg5 == 158756 then
                    module.QueueControl(0.5);
                end
            end
        end
        , "UNIT_SPELLCAST_STOP"
    );

    module.CombatStarted = 0;
    module.CombatEnded = 1;
    -- Entering Combat
    module:RegisterForEvent(
        function ()
            module.CombatStarted = module.GetTime();
            module.CombatEnded = 0;
            -- Mannoroth Mythic CombatStart fix for classes that need it.
            if select(2,UnitClass("player")) == "ROGUE" and GetRealZoneText() == "Hellfire Citadel" and GetRaidDifficultyID() == 16 then
                if module.Unit.FirstWhere(function (ThisUnit) return ThisUnit:CreatureID() == 91305; end, "Enemy") then
                    module.CombatStarted = module.CombatStarted + 15.5;
                end
            end
            module.Bug("|cffFF0000Entering Combat");
            -- Reset summoning time on searing totem.
            if module.SearingTotem then
                module.SearingTotem.LastSummon = currentTime;
            end
        end
        , "PLAYER_REGEN_DISABLED"
    );

    -- Leaving Combat
    module:RegisterForEvent(
        function ()
            module.PotionUsed = false;
            module.CombatStarted = 0;
            module.CombatEnded = module.GetTime();
            module.Bug("|cff00FF00Leaving Combat");
            module.DisableControl("Leaving Combat");
            module.QueueControl(1);
        end
        , "PLAYER_REGEN_ENABLED"
    );

    -- Time since Combat Started
    function CombatTime ()
        if module.CombatStarted ~= 0 then CombatEntered = true; end
        return module.CombatStarted ~= 0 and module.GetTime()-module.CombatStarted or 0;
    end

    -- Time since Combat Ended
    function OutOfCombatTime ()
        return module.CombatEnded ~= 0 and module.GetTime()-module.CombatEnded or 0;
        --
    end

    -- DBM/BW Pull Timer
    module:RegisterForEvent(
        function (prefixe, message)
            if prefixe == "D4" and string.find(message, "PT") then
                BossModTime = tonumber(string.sub(message, 4, 5));
                BossModEndTime = module.GetTime() + BossModTime;
            end
        end
        , "CHAT_MSG_ADDON"
    );
    -- Function to know the Pull Timer
    function BMPullTime ()
        if not BossModTime or BossModTime == 0 or BossModEndTime-module.GetTime() < 0 then
            return 60;
        else
            return BossModEndTime-module.GetTime();
        end
    end

    --- Movement Handlers
    module.isMovingStartTime = 0;
    module.isStandingStartTime = 0;
    module:RegisterForEvent(
        function ()
            module.isStandingStartTime = 0
            module.isMovingStartTime = module.GetTime()
        end
        , "PLAYER_STARTED_MOVING"
    );
    module:RegisterForEvent(
        function ()
            module.isMovingStartTime = 0
            module.isStandingStartTime = module.GetTime();
        end
        , "PLAYER_STOPPED_MOVING"
    );

    -- Start Attack On target changed
    local AttackStarted;
    module:RegisterForEvent(
        function ()
            if module.IsRunning() and (module.GetSecondOptionValue("Target | Attack") == "Enabled" or (module.GetSecondOptionValue("Target | Attack") == nil and module.IsOptionEnabled("Auto Attack"))) and UnitCanAttack("target","player") and not UnitIsDeadOrGhost("target") and not IsMounted() and not Player:IsStealthed() and not UnitIsWildBattlePet("target") then
            RunMacroText("/StartAttack");
            AttackStarted = true;
            end
            if AttackStarted and Player:IsStealthed() then
                RunMacroText("/StopAttack");
                AttackStarted = false;
            end
        end
        , "PLAYER_TARGET_CHANGED"
        , "UPDATE_STEALTH"
        , "UPDATE_SHAPESHIFT_FORM"
    );

    -- Encounter Tracker
    module.EncounterID = 0;
    module.EncounterPhase = 0;
    module:RegisterForEvent(
        function (encounterID)
            module.EncounterDifficulty = select(3, GetInstanceInfo()); -- Normal:14, Heroic:15, Mythic:16
            module.EncounterID = encounterID;
            module.EncounterPhase = 0;
        end
        , "ENCOUNTER_START"
    );
    module:RegisterForEvent(
        function ()
            module.EncounterID = 0;
            module.DisableControl("Encounter Ended");
            module.QueueControl(1);
        end
        , "ENCOUNTER_END"
    );

    -- Group Tracker
    module.GroupUnits = {};
    module:RegisterForEvent(
        function ()
            wipe(module.GroupUnits);
            local GroupMembers, GroupType, GroupUnitsCount = GetNumGroupMembers() == 0 and 1 or GetNumGroupMembers(), IsInRaid() and "raid" or "party", 0;
            local Pointer, ThisGUID;
            for i = 1, GroupMembers do
                Pointer = (GroupType == "party" and i == 1 and "player") or (GroupType == "party" and "party"..i-1) or (GroupType == "raid" and "raid"..i);
                ThisGUID = UnitGUID(Pointer);
                module.GroupUnits[ThisGUID] = Pointer;
            end
        end
        , "GROUP_ROSTER_UPDATE"
        , "LOADING_SCREEN_DISABLED"
    );


    function resetLists (self, ...)
        if totemposition then totemposition = nil; end
        --
    end

    function TotemLocation ()
        if totemposition then
            return totemposition;
        else
            return { Y=9999, X=9999, Z=9999 };
        end
    end


    function TotemDistance ()
        local Blacklist = {
        120668,
        2062,
        2894
        }
        if not totemX or not totemY then
            totemX,totemY = 0,0;
        end
        for i=1, #Blacklist do
            local totemName = select(2,GetTotemInfo(1)) or select(2,GetTotemInfo(2));
            local blackList = GetSpellInfo(Blacklist[i]);
            if totemposition and totemName ~= blackList then
                if UnitExists("target") and UnitAffectingCombat("player", "target") then
                    targetposition = Target;
                else
                    targetposition = module.Player;
                end
                return totemposition:DistanceTo(targetposition:Position())-1.5-targetposition:CombatReach();
            else
                return 0;
            end
        end
    end

    function CastingRangeIncrease ()
        return _G[string.char(67,111,109,98,97,116,84,105,109,101)]()
        --
    end

    -- Chat Overlay
    local function UpdateOverlay(self,elapsed)
        self:SetSize(ChatFrame1:GetWidth(), 30)
        if self.time < GetTime() - 1 then
            if self:GetAlpha() == 0 then self:Hide() else self:SetAlpha(self:GetAlpha() - .05) end
        end
    end

    for i = 1, 10 do
        _G["Overlay" .. i] = CreateFrame("Frame",nil, _G["ChatFrame" .. i])
        _G["Overlay" .. i]:SetSize(_G["ChatFrame" .. i]:GetWidth(), 30)
        _G["Overlay" .. i]:Hide()
        _G["Overlay" .. i]:SetPoint("TOP",0,0)
        _G["Overlay" .. i].text = _G["Overlay" .. i]:CreateFontString(nil,"OVERLAY","MovieSubtitleFont")
        _G["Overlay" .. i].text:SetAllPoints()
        _G["Overlay" .. i].texture = _G["Overlay" .. i]:CreateTexture()
        _G["Overlay" .. i].texture:SetAllPoints()
        _G["Overlay" .. i].texture:SetTexture(0,0,0,.70)
        _G["Overlay" .. i].time = 0

        _G["Overlay" .. i]:SetScript("OnUpdate", UpdateOverlay)
    end

    function XRNOverlay (Message)
        if module.GetSetting("Enable Chat Overlay_Checked") then
            for i = 1, 10 do
                _G["Overlay" .. i]:SetSize(ChatFrame1:GetWidth(), 30)
                _G["Overlay" .. i].text:SetText(Message)
                _G["Overlay" .. i]:SetAlpha(1)
                _G["Overlay" .. i].time = GetTime()
                _G["Overlay" .. i]:Show()
            end
        end
    end

    function module.AddCommonOptions ()
        module.UpdateToolboxChangeSpec();
        module.UpdateCSChangeSpec();
        local IsMeleeHybrid = currentSpecName == "Windwalker" or currentSpecName == "Feral" and true or false;
        local IsMeleeNonHybrid = currentSpecName == "Subtlety" or currentSpecName == "Outlaw" or currentSpecName == "Assassination" or currentSpecName == "Havoc" or currentSpecName == "Vengeance" and true or false;
        -- Beta Toggle
        if BetaEnabled then
            module.AddOption("General Settings", "Beta Version", false, "If a beta version is available, this will execute the rotation with the (BETA) changes listed on the changelog. The 'Rotation' section in the status frame will change to 'BETA' if a Beta version is available.");
            module.AddSection("General Settings", " ");
            module.AddOutput("Rotation:");
        end
        -- Pet Battle Stuff
        if UserHasRotation("Pet-Battles") then
            module.PetBattles.UI();
        end
        -- Advanced Page
        module.AddPage("Advanced Settings");
        -- General
        module.AddSection("Advanced Settings", "|cFF9AFE2EGeneral");
        module.AddOption("Advanced Settings", "Anti AFK", false);
        module.AddOption("Advanced Settings", "Auto Accept LFG Proposal", false);
        if UnitLevel('player') < ClientMaxLevel then
            module.AddOption("Advanced Settings", "Use Level "..ClientMaxLevel.." Optimized Rotation", false, "This will override the Leveling rotation with the level 110 Rotation, may not work for some classes"..C.TOOLTIP_HINT("A '/reload' will be performed, it may occurs 2 times if it's the first time you switch."));
        end
        -- Security
        module.AddSection("Advanced Settings", "|cFF9AFE2ESecurity");
        module.AddOption("Advanced Settings", "Enable Welcome Greeting", true, "This will enable this display of the welcome greeting.");
        module.AddOption("Advanced Settings", "Enable Chat Notifications", false, "This will enable chat notifications.");
        module.AddOption("Advanced Settings", "Enable Chat Overlay", true, "This will enable overlay notifications.");
        module.AddOption("Advanced Settings", "Pause Rotation While In Chat", false, "This will pause the rotation while your chat box is open.");
        module.AddNewOption("Advanced Settings", "Pulse Control", 230, true, {4, "Chat", "Overlay", "Both", "None"}, nil, "Enable Pulse Control to allow the manager to stop pulsing for a short delay after specific events including dying, zoning, taking flight path, flying with mount, using vehicles, looting and gathering."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Chat", true).."Will display a notification in your chat."..C.TOOLTIP_SUBVALUE("Overlay").."Will display a notification in your overlay."..C.TOOLTIP_SUBVALUE("Both").."Will display a notification in both your chat and overlay."..C.TOOLTIP_SUBVALUE("None").."Will not display any notification about the Pulse State.");
        -- Advanced
        module.AddSection("Advanced Settings", "|cFF9AFE2EAdvanced");
        module.AddNewOption("Advanced Settings", "TPS: Unit | Rotation", 122, true, {5, 1, 10, 1}, {15, 1, 80, 1}, "Set the Tick per Second for the Units and the Rotation."..C.TOOLTIP_VALUE_1.."How many times per second the units around you are analyzed."..C.TOOLTIP_VALUE_2.."How many times per second the profile runs.");
        module.AddNewOption("Advanced Settings", "Latency Tolerance", 232, (IsMeleeHybrid or IsMeleeNonHybrid) and true or false, {1, "Cast Only", "Cast & Core"}, {5, 0, 50, 1}, "Enabled to use the Latency Tolerance."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Cast Only", true).."Cast abilities before the CD come back to queue them on server and then cast quickly."..C.TOOLTIP_SUBVALUE("Cast + Core").."Same as Cast Only + Will update Core infos at your latency rate. Recommended if your world latency is lower than 50 ms."..C.TOOLTIP_VALUE_2.."Set your latency jitter."..C.TOOLTIP_HINT("Works best with WoW built-in Latency Tolerance option enabled and set way higher than your world latency."));
        module.AddNewOption("Advanced Settings", "Ignore TTD Boss until %", 220, false, {20, 10, 40, 1}, nil, "Enable to ignore the result of TTD if the unit is a boss until a given % HP."..C.TOOLTIP_VALUE.."Set the given % HP."..C.TOOLTIP_HINT("Useful if you're in a raid with a Big Burst Comp to avoid letting fall off DoTs due to wrong TTD."));
        -- Blacklist
        module.AddOption("Advanced Settings", "Help Dark Simulacrum", true, "While this option is enabled, you will never interrupt spells that Deathknights are attempting to copy with their Dark Simulacrum.");
        module.AddSection("Advanced Settings", "Targetting", "Green");
        module.AddNewOption("Advanced Settings", "Target Priority", 230, true, {1, "|cffD9D9DBSkull", "|cffCC3122Cross", "|cff019EE0Square", "|cffB2D1DFMoon", "|cff0AE201Triangle", "|cffB731C8Diamond", "|cffD87E01Circle", "|cffFFEA00Star"}, nil, 'Check this to always priorise the target with the selected symbol when retargetting. If no target with this symbol can be found, the mode selected for the 1st option of "Target | Attack" will be used.');
        module.AddOption("Advanced Settings", "Blacklist Corrupted Souls", true, "Check this to avoid hitting Corrupted Souls during Gorefiend encounter in Hellfire Citadel.");
        if not IsMeleeNonHybrid then
            module.AddSection("Advanced Settings", "Healing Tweaks", "Green");
            module.AddOption("Advanced Settings", "Aura Of Contempt Support", true, "Check this to allow the manager to compensate for the Aura of Contempt debuff during Tyrant Velhari encounter.");
            module.AddNewOption("Advanced Settings", "Touch Of Mortality", 220, true, {50, 0, 100, 1}, nil, "If checked, the units under the effect of Touch of Mortality will be added x% health. This is meant to lower the priority of healing on these units.\n\n|cFF0066FFExample:|r\nIf the unit has 80% health and the value is define to 50, it will be considered at 130% health. It would only heal if the unit fall under 50%(100%).");
        end
        -- Testing Features
        if module.GetSetting("Range | Line Of Sight_Value1") == nil then
            module.SetSetting("Range | Line Of Sight_Value1", "Distance");
            module.SetSetting("Range | Line Of Sight_Value2", "Enabled");
        end
        if module.GetSetting("Range | Line Of Sight_Checked") == true then
            module.AddNewOption("Advanced Settings", "Range | Line Of Sight", 133, true, {2, "Disabled", "Distance", "WoW API"}, {2, "Disabled", "Enabled"}, "Hidden feature allowing to change Distance Check model and Disabling Line Of Sight check for testing purposes."..C.TOOLTIP_VALUE_1.."Distance check should always be preferred. If it do not work, fall back to WoW API check. If none will work, fall back to Disabled. If it still do not work, try with the Line Of Sight check disabled."..C.TOOLTIP_VALUE_2.."Line Of Sight check should always be Enabled. If it do not work, fall back to Disabled.");
        end
        -- Macros Page
        module.AddPage("Macros Settings");
        module.AddNewOption("Macros Settings", "Macro Command", 140, true, "", nil, "Set the macro command you want to use."..C.TOOLTIP_HINT("Default is 'soap'.").."\n\nIf you enter 'deus', then you will have to use '/deus toggle' to toggle the rotation for example.");
        module.AddSection("Macros Settings", "Engine", "Green");
        module.AddNewOption("Macros Settings", "Toggle", 140, true, "toggle", nil, "Set the replacement of the argument 'toggle'.");
        module.AddNewOption("Macros Settings", "CDs - AOE", 144, true, "cds", "aoe", "Set the replacement of the arguments."..C.TOOLTIP_VALUE_1.."Argument 'cds'."..C.TOOLTIP_VALUE_2.."Argument 'aoe'.");
        module.AddNewOption("Macros Settings", "Cast - Cancel", 144, true, "cast", "cancel", "Set the replacement of the arguments."..C.TOOLTIP_VALUE_1.."Argument 'cast'."..C.TOOLTIP_VALUE_2.."Argument 'cancel'.");
        module.AddNewOption("Macros Settings", "Cast Mouse", 140, true, "castmouse", nil, "Set the replacement of the argument 'castmouse'");
        module.AddNewOption("Macros Settings", "Al - Debug", 144, true, "al", "debug", "Set the replacement of the arguments."..C.TOOLTIP_VALUE_1.."Argument 'al'."..C.TOOLTIP_VALUE_2.."Argument 'debug'.");
        module.AddSection("Macros Settings", "UI", "Green");
        module.AddNewOption("Macros Settings", "LoadUI - SaveUI", 144, true, "loadui", "saveui", "Set the replacement of the arguments."..C.TOOLTIP_VALUE_1.."Argument 'loadui'."..C.TOOLTIP_VALUE_2.."Argument 'saveui'.");
        module.AddNewOption("Macros Settings", "LoadCIL - SaveCIL", 144, true, "loadcil", "savecil", "Commands used to save and load Custom Interrupts List.\nSet the replacement of the arguments."..C.TOOLTIP_VALUE_1.."Argument 'loadcil'."..C.TOOLTIP_VALUE_2.."Argument 'savecil'.");
        module.AddNewOption("Macros Settings", "CurrentUI - DefaultUI", 144, true, "currentui", "defaultui", "Set the replacement of the arguments."..C.TOOLTIP_VALUE_1.."Argument 'currentui'."..C.TOOLTIP_VALUE_2.."Argument 'defaultui'.");
        module.AddNewOption("Macros Settings", "UI - ToggleOption", 144, true, "ui", "toggleoption", "Set the replacement of the arguments."..C.TOOLTIP_VALUE_1.."Argument 'ui'."..C.TOOLTIP_VALUE_2.."Argument 'toggleoption'.");
        module.AddNewOption("Macros Settings", "Change Value", 140, true, "changevalue", nil, "Set the replacement of the argument 'changevalue'.");
        module.AddNewOption("Macros Settings", "ToggleOn - ToggleOff", 144, true, "toggleon", "toggleoff", "Set the replacement of the arguments."..C.TOOLTIP_VALUE_1.."Argument 'toggleon'."..C.TOOLTIP_VALUE_2.."Argument 'toggleoff'.");
        module.AddNewOption("Macros Settings", "TB - Status", 144, true, "tb", "status", "Set the replacement of the arguments."..C.TOOLTIP_VALUE_1.."Argument 'tb'."..C.TOOLTIP_VALUE_2.."Argument 'status'.");
        module.AddNewOption("Macros Settings", "CS", 140, true, "cs", nil, "Set the replacement of the argument 'cs'.");
        module.AddSection("Macros Settings", "Infos", "Green");
        module.AddNewOption("Macros Settings", "Ticket - Settings", 144, true, "ticket", "settings", "Set the replacement of the arguments."..C.TOOLTIP_VALUE_1.."Argument 'ticket'."..C.TOOLTIP_VALUE_2.."Argument 'settings'.");
        module.AddNewOption("Macros Settings", "Rotations", 140, true, "rotations", nil, "Set the replacement of the argument 'rotations'.");
        module.AddSection("Macros Settings", "When you're done, do a '/reload'.", "Red");
        module.ConsumableOptions();
        --LoadMorpherSettings();
        RotationInitialized = true;
    end

    function module.AddPresetOption (Name)
        -- General Settings - General
        if Name == "TargetAttack" then
            module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        elseif Name == "ReTarget" then
            module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        elseif Name == "BossCD" then
            module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        -- General Settings - Utility
        elseif Name == "Interrupt" then
            module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
            if ArcaneTorrent and ArcaneTorrent:Exists() then
                module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
            end
            module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
            module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        -- General Settings - Out of Combat
        elseif Name == "AutoResuscitate" then
            module.AddNewOption("General Settings", "Auto-Resuscitate Friends", 210, true, nil, nil, "Enable to auto resuscitate dead units from the group.");
        elseif Name == "AutoHeal" then
            local PowerType = C.CLASSINDEX == 10 and "energy" or "mana";
            module.AddNewOption("General Settings", "Auto-Heal OutOfCombat", 222, true, {90, 1, 100, 1}, {50, 1, 100, 1}, "Enable to auto heal you or units from the group when out of combat."..C.TOOLTIP_VALUE_1.."Set the health percentage to stop healing an unit."..C.TOOLTIP_VALUE_2.."Set the "..PowerType.." percentage to stop healing.");
        -- Offensive Settings - General
        elseif Name == "PrePot" then
            module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        -- Offensive Settings - Cooldowns
        elseif Name == "Trinket" then
            module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Always", "Cooldowns Only", "Disabled"}, {2, "Always", "Cooldowns Only", "Disabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        elseif Name == "Potion" then
            module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        -- Defensive Settings - Items
        elseif Name == "HealingItem" then
            module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Health Percentage to use Spinal Healing Injector / Healthstone / Healing Potion.");
        -- Defensive Settings - Abilities
        elseif Name == "HoPCancel" then
            module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, false, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        -- Defensive Settings - Cooldowns
        elseif Name == "GiftoftheNaaru" then
            if GiftOfTheNaaru and GiftOfTheNaaru:Exists() then
                module.AddNewOption("Defensive Settings", "Gift of the Naaru", 220, true, {50, 1, 95, 1}, nil, "Health Percentage to use Gift of the Naaru on self.");
            end
        end
    end

    function AddAllClassOptions ()
        module.AddCommonOptions();
        --
    end

    function module.TrinketOptions ()
        module.AddPresetOption("Trinket");
        --
    end

    function CreateMacros( ... )
        if (18 - select(2,GetNumMacros())) >= 9 then
            CreateMacro("TOGGLE", "inv_misc_bomb_04", "/"..module.CmdName.." "..module.CmdArgument.toggle, 1, 1);
            CreateMacro("CDs", "inv_misc_bomb_09", "/"..module.CmdName.." "..module.CmdArgument.cds, 1, 1);
            CreateMacro("AOE", "inv_misc_bomb_07", "/"..module.CmdName.." "..module.CmdArgument.aoe, 1, 1);
            CreateMacro("GUI", "trade_archaeology_highborne_scroll", "/"..module.CmdName.." "..module.CmdArgument.ui, 1, 1);
            CreateMacro("TB", "inv_glyph_minormage", "/"..module.CmdName.." "..module.CmdArgument.tb, 1, 1);
            CreateMacro("CS", "inv_glyph_majorpaladin", "/"..module.CmdName.." "..module.CmdArgument.cs, 1, 1);
            CreateMacro("STATUS", "inv_misc_note_06", "/"..module.CmdName.." "..module.CmdArgument.status, 1, 1);
            CreateMacro("Load Default UI", "Achievement_BG_AB_defendflags", "/"..module.CmdName.." "..module.CmdArgument.loadui.." Default", 1, 1);
            CreateMacro("Re-create Default UI", "Achievement_BG_returnXflags_def_WSG", "/"..module.CmdName.." "..module.CmdArgument.saveui.." Default", 1, 1);
            module.Print("Macros Loaded");
        else
            module.Error("Not enough Macro slots ('Character Specific Macros' tab)");
        end
    end


    (function ()
        local debug = module.debug

        module.timer = {}
        local timer = module.timer

        local timers = {}

        local function onUpdate(self, elapsed)
            for timer, struct in pairs(timers) do
                struct.last = struct.last + elapsed
                if (struct.last > struct.period) then
                    -- module.Bug('Timer Fire: ' .. timer , 'timer')
                    struct.event(elapsed)
                    struct.last = 0
                end
            end
        end

        local frame = CreateFrame('Frame')
        frame:SetScript('OnUpdate', onUpdate);

        function timer.register(tmodule, _event, _period)
            module.Bug('Timer Registered: ' .. tmodule, 'timer')
            if not tonumber(_period) then
                module.Bug('Timer Error: ' .. tmodule .. ' has no time period.')
                return
            end

            timers[tmodule] = {
                event = _event,
                period = (_period / 1000),
                last = 0
            }
        end

        function timer.unregister(tmodule)
            module.Bug('Timer Unregistered: ' .. tmodule, 'timer')
            timers[tmodule] = nil
        end

        function timer.updatePeriod(tmodule, period)
            timers[tmodule].period = (period / 1000)
        end
    end)();

    local function GetInstanceDifficulty ()

        local ID = select(3, GetInstanceInfo())
        local diff = "OutOfInstance"

        if ID == 0 then     diff = "OutOfInstance"
        elseif ID == 1 then diff = "Dungeon_Normal"
        elseif ID == 2 then diff = "Dungeon_Heroic"
        elseif ID == 3 then diff = "unknown"
        elseif ID == 4 then diff = "unknown"
        elseif ID == 5 then diff = "unknown"
        elseif ID == 6 then diff = "unknown"
        elseif ID == 7 then diff = "unknown"
        elseif ID == 8 then diff = "Dungeon_Challenge"  -- is not confirmed
        elseif ID == 9 then diff = "unknown"
        elseif ID == 10 then    diff = "unknown"
        elseif ID == 11 then    diff = "Scenario_Heroic"    -- is not confirmed
        elseif ID == 12 then    diff = "Scenario_Normal"
        elseif ID == 13 then    diff = "unknown"
        elseif ID == 14 then    diff = "Raid_Normal"
        elseif ID == 15 then    diff = "Raid_Heroic"
        elseif ID == 16 then    diff = "Raid_Mythic"
        elseif ID == 17 then    diff = "Raid_LFR"
        end

        return diff
    end

    function table.empty(tbl)
        for i, _ in ipairs(tbl) do tbl[i] = nil end
        --
    end

    module:RegisterForEvent(
        function ()
            GroupsByGUID = {};
            if IsInRaid() then
                for Index = 1, GetNumGroupMembers() do
                    GroupsByGUID[UnitGUID("Raid" .. Index)] = select(3, GetRaidRosterInfo(Index));
                end
            else
                for Index = 1, GetNumGroupMembers()-1 do
                    GroupsByGUID[UnitGUID("Party" .. Index)] = 1;
                end
            end
        end
        , "GROUP_ROSTER_UPDATE"
    );

    --Merq: added Spellsteal function
    function Spellsteal()
        --local targets = {"target","focus","mouseover","boss1","boss2","boss3","boss4","boss5"}
        if not UnitExists("target") or not UnitIsEnemy("player","target") or not UnitCanAttack("player","target") then return false end
        if UnitIsDeadOrGhost("target") then return false end
        for k=1,40 do
            if select(9,UnitBuff('target',k, "HELPFUL")) ~= nil then
                return true
            end
        end
    end

    --[[ NO LONGER USED
    --- Changelog Forum Parser
    -- You need to have the Changelog.txt in the Manager Directory.
    function GenerateChangelog ()
        local String = "";
        local function WriteLine (Line)
            String = String .. Line .. "\n";
        end

        local function SplitIntoLines (Str)
            local TableSplit = {};
            local Pos_A = 1
            while 1 do
                local Pos, Chars = Str:match('()([\r\n].?)', Pos_A);
                if Pos then
                    if Chars == '\r\n' then Pos = Pos + 1; end
                    local Line = Str:sub(Pos_A, Pos);
                    TableSplit[#TableSplit+1] = Line;
                    Pos_A = Pos + 1;
                else
                    local Line = Str:sub(Pos_A);
                    if Line ~= '' then TableSplit[#TableSplit+1] = Line; end
                    break;
                end
            end
            return TableSplit;
        end

        local Title = {
            {"DEATH KNIGHT",    "BLOOD DEATH KNIGHT",   "FROST DEATH KNIGHT",   "UNHOLY DEATH KNIGHT"                       },
            {"DRUID",           "BALANCE DRUID",        "FERAL DRUID",          "GUARDIAN DRUID",       "RESTORATION DRUID" },
            {"HUNTER",          "BEAST MASTERY HUNTER", "MARKSMANSHIP HUNTER",  "SURVIVAL HUNTER"                           },
            {"MAGE",            "ARCANE MAGE",          "FIRE MAGE",            "FROST MAGE"                                },
            {"MONK",            "BREWMASTER MONK",      "MISTWEAVER MONK",      "WINDWALKER MONK"                           },
            {"PALADIN",         "HOLY PALADIN",         "PROTECTION PALADIN",   "RETRIBUTION PALADIN"                       },
            {"PRIEST",          "DISCIPLINE PRIEST",    "HOLY PRIEST",          "SHADOW PRIEST"                             },
            {"ROGUE",           "ASSASSINATION ROGUE",  "COMBAT ROGUE",         "SUBTLETY ROGUE"                            },
            {"SHAMAN",          "ELEMENTAL SHAMAN",     "ENHANCEMENT SHAMAN",   "RESTORATION SHAMAN"                        },
            {"WARLOCK",         "AFFLICTION WARLOCK",   "DEMONOLOGY WARLOCK",   "DESTRUCTION WARLOCK"                       },
            {"WARRIOR",         "ARMS WARRIOR",         "FURY WARRIOR",         "GLADIATOR WARRIOR",    "PROTECTION WARRIOR"},
            {"ALL",             "GENERAL"                                                                                   }
        };
        local TitleColor = {
            "[color=#C41F3B]", -- DEATH KNIGHT
            "[color=#FF7D0A]", -- DRUID
            "[color=#ABD473]", -- HUNTER
            "[color=#69CCF0]", -- MAGE
            "[color=#00FF96]", -- MONK
            "[color=#F58CBA]", -- PALADIN
            "[color=#FFFFFF]", -- PRIEST
            "[color=#FFF569]", -- ROGUE
            "[color=#0070DE]", -- SHAMAN
            "[color=#9482C9]", -- WARLOCK
            "[color=#C79C6E]", -- WARRIOR
            "[color=#000000]"  -- ALL
        };
        local TitleStart = "[dropshadow=black][size=120][b]";
        local TitleEnd = "[/color][/b][/size][/dropshadow]";
        local DateMarker = "/%d%d%d%d";
        local DateStart = "[align=center][b][u]";
        local DateEnd = "[/u][/b][/align]";
        local RaidingMarker = "%(Raiding%)";
        local RaidingSub = "[i]([color=red]Raiding[/color])[/i]";
        local LevelingMarker = "%(Leveling%)";
        local LevelingSub = "[i]([color=blue]Leveling[/color])[/i]";
        local LevelingAndRaidingMarker = "%(Leveling & Raiding%)";
        local LevelingAndRaidingSub = "[i]([color=blue]Leveling[/color] & [color=red]Raiding[/color])[/i]";

        local File = ReadFile(GetManagerDirectory() .. "/../../../Changelog.txt");
        local FileSplit = SplitIntoLines(File);

        for Index in pairs(FileSplit) do
            local CurrentLine = FileSplit[Index];
            CurrentLine = string.gsub(CurrentLine, "\n", "");
            local Writed = false;
            for Class = 1, 12 do
                for Spec = 1, 5 do
                    if CurrentLine == Title[Class][Spec] then
                        WriteLine(TitleStart .. TitleColor[Class] .. CurrentLine .. TitleEnd);
                        Writed = true;
                    end
                end
            end
            if string.find(CurrentLine, RaidingMarker) then
                WriteLine(string.gsub(CurrentLine, RaidingMarker, RaidingSub));
            elseif string.find(CurrentLine, LevelingMarker) then
                WriteLine(string.gsub(CurrentLine, LevelingMarker, LevelingSub));
            elseif string.find(CurrentLine, LevelingAndRaidingMarker) then
                WriteLine(string.gsub(CurrentLine, LevelingAndRaidingMarker, LevelingAndRaidingSub));
            elseif string.find(CurrentLine, DateMarker) and string.len(CurrentLine) <= 15 then
                WriteLine(DateStart .. CurrentLine .. DateEnd);
            elseif not Writed then
                WriteLine(CurrentLine);
            end
        end

        WriteFile(GetManagerDirectory() .. "/../../../Changelog_Parsed.txt", String);
    end]]

    local SpecsStats = {
        -- Mage Arcane (Arcane Blast)
        [62] = { "Intellect" },
        -- Mage Fire (Fireball)
        [63] = { "Intellect" },
        -- Mage Frost (Frostbolt)
        [64] = { "Intellect" },
        -- Paladin Holy (Judgment)
        [65] = { "Intellect" },
        -- Paladin Protection (Crusader Strike)
        [66] = { "Strength", "Stamina" },
        -- Paladin Retribution (Crusader Strike)
        [70] = { "Strength" },
        -- Warrior Arms (Mortal Strike)
        [71] = { "Strength" },
        -- Warrior Fury (Bloodthirst)
        [72] = { "Strength" },
        -- Warrior Protection (Heroic Strike)
        [73] = { "Strength", "Stamina" },
        -- Druid Balance (Wrath)
        [102] = { "Intellect" },
        -- Druid Feral (Rake)
        [103] = { "Agility" },
        -- Druid Guardian (Lacerate)
        [104] = { "Agility", "Stamina" },
        -- Druid Resto (Wrath)
        [105] = { "Intellect" },
        -- Deathknight Blood (Plague Strike)
        [250] = { "Strength", "Stamina" },
        -- Deathknight Frost (Frost Strike)
        [251] = { "Strength" },
        -- Deathknight Unholy (Scourge Strike)
        [252] = { "Strength" },
        -- Hunter Beastmaster (Arcane Shot)
        [253] = { "Agility" },
        -- Hunter Marksmanship (Aimed Shot)
        [254] = { "Agility" },
        -- Hunter Survival (Arcane Shot)
        [255] = { "Agility" },
        -- priest Discipline (Smite)
        [256] = { "Intellect" },
        -- Priest Holy (Smite)
        [257] = { "Intellect" },
        -- Priest Shadow (Mind Blast)
        [258] = { "Intellect" },
        -- Rogue Assassination (Mutilate)
        [259] = { "Agility" },
        -- Rogue Outlaw (SinisterStrike)
        [260] = { "Agility" },
        -- Rogue Subtlety (Hemorrhage)
        [261] = { "Agility" },
        -- Shaman Elemental (Lightning Bolt)
        [262] = { "Intellect" },
        -- Shaman Enhancement (Stormstrike)
        [263] = { "Agility" },
        -- Shaman Restoration (Lightning Bolt)
        [264] = { "Intellect" },
        -- Warlock Affliction (Agony)
        [265] = { "Intellect" },
        -- Warlock Demonology (Corruption)
        [266] = { "Intellect" },
        -- Warlock Destruction (Immolate)
        [267] = { "Intellect" },
        -- Monk Bremaster (Tiger Palm)
        [268] = { "Agility", "Stamina" },
        -- Monk Windwalker (Tiger Palm)
        [269] = { "Agility" },
        -- Monk Mistweaver (Provoke)
        [270] = { "Intellect" },
        -- Demon Hunter Havoc
        [577] = { "Agility" },
        -- Demon Hunter Vengeance
        [581] = { "Agility", "Stamina" }
    }

    --Shapeshift values are different on mac for these
    local GetShapeshiftForm_Trampoline = GetShapeshiftForm;
    GetShapeshiftForm = function ()

        local ShapeshiftForm = GetShapeshiftForm_Trampoline();
        local Class = select(2, UnitClass("Player"));
        local Spec = GetSpecialization();

        if GetOSVersion() == "MacOSX" and ShapeshiftForm < 3 and ((Class == "PALADIN" and Spec == 3) or (Class == "MONK" and Spec == 2)) then
            if ShapeshiftForm == 1 then
                return 2;
            elseif ShapeshiftForm == 2 then
                return 1;
            end
        end

        return ShapeshiftForm;
    end

    -- Consumable Options - Added to every profiles as long as the user is level 100
    function module.ConsumableOptions ()
        if UnitLevel("player") >= 100 then
            local CurrentSpec = GetSpecialization();
            if CurrentSpec ~= nil then
                if Player:Level() < 110 then
                    module.AddNewOption("General Settings", "Augment Rune", 220, false, { 3.5, 0, 5, 0.05 }, nil, "Keep Augment Rune buff up. Will use Empowered Augment Rune as priority and otherwise use normal runes. \n\n|cFF0088FFValue:|r Time on Boss Mode timer at which we want to use Rune if we do not have the buff already.");
                end
                local ModeValue = SpecsStats[select(1, GetSpecializationInfo(CurrentSpec))]; -- Get Player current needs
                local FlaskValues = { 1, "Oralius" };
                for i = 1, #ModeValue do
                    table.insert(FlaskValues, ModeValue[i]);
                end
                module.AddNewOption("General Settings", "Flask", 232, true, FlaskValues, { 4.5, 0, 5, 0.05 }, "Use Flask in combat. \n\n|cFF0088FFValue 1:|r Which kind of Flask do we want to use. \n\n|cFF0088FFValue 2:|r Time on Boss Mode timer at which we want to use Flask if we do not have the buff already.");
            end
        end
    end

    -- Consumables Handler - Only pulse if the user is level 100
    function module.HandleConsumables ()
        if UnitLevel("player") >= 100 then
            local Player = module.Player;
            if Player:IsInCombat() or BMPullTime() < 5 then
                -- Runes
                if module.IsOptionEnabled("Augment Rune") and (Player:IsInCombat() or BMPullTime() < module.GetOptionValue("Augment Rune")) then
                    local ModeValue = SpecsStats[select(1, GetSpecializationInfo(GetSpecialization()))][1]; -- Get Player current needs
                    Player:Rune(module.IsOptionEnabled("Augment Rune"), ModeValue);
                end
                -- Flasks
                if module.IsOptionEnabled("Flask") and (Player:IsInCombat() or BMPullTime() < module.GetSecondOptionValue("Flask")) then
                    Player:Flask(module.IsOptionEnabled("Flask"), module.GetOptionValue("Flask"));
                end
            end
        end
    end

    module.Benchmark = {
        Mark = "Start",
        Time1 = 0,
        Time2 = 0,
        DS = nil,
        StartPos = nil,
        EndPos = nil,
        FuncName = "",
        CalledByName = "",
        Results = {},
        ResultsParsed = {},
        TableMean = function (Table) local Num = 0; table.foreach(Table, function (i,v) Num = Num + v; end) return Num / #Table; end,
        TableMedian = function (Table) table.sort(Table); if #Table%2 == 0 then return (Table[#Table/2] + Table[#Table/2+1]) / 2; end return Table[math.ceil(#Table/2)]; end,
        TabSpace = function (Len) if Len < 4 then return "\t\t\t\t\t\t\t\t"; elseif Len < 8 then return "\t\t\t\t\t\t\t"; elseif Len < 12 then return "\t\t\t\t\t\t"; elseif Len < 16 then return "\t\t\t\t\t"; elseif Len < 20 then return "\t\t\t\t"; elseif Len < 24 then return "\t\t\t"; elseif Len < 28 then return "\t\t"; elseif Len < 32 then return "\t"; else return ""; end end
    };
    --- Profile a function, call it at the start of the function, then call it again at the end with every arguments to get every stats.
    function module.BenchmarkThis (...)
        if module.Benchmark.Mark == "Start" then
            module.Benchmark.Mark = "End";
            module.Benchmark.Time1 = debugprofilestop();
            return;
        else
            module.Benchmark.Time2 = debugprofilestop();
            module.Benchmark.Mark = "Start";
        end

        -- Get Function Name.
        module.Benchmark.DS = debugstack(2, 1, 0);
        module.Benchmark.StartPos, module.Benchmark.EndPos = select(2, string.find(module.Benchmark.DS, "in function `")), string.find(module.Benchmark.DS, "'");
        module.Benchmark.FuncName = module.Benchmark.StartPos and module.Benchmark.EndPos and string.sub(module.Benchmark.DS, module.Benchmark.StartPos+1, module.Benchmark.EndPos-1) or "Unknown";
        module.Benchmark.StartPos, module.Benchmark.EndPos = nil, nil;

        -- Get the name of the Function wich called the one we benchmark.
        module.Benchmark.DS = debugstack(3, 1, 0)
        module.Benchmark.StartPos, module.Benchmark.EndPos = select(2, string.find(module.Benchmark.DS, "in function `")), string.find(module.Benchmark.DS, "'");
        module.Benchmark.CalledByName = module.Benchmark.StartPos and module.Benchmark.EndPos and string.sub(module.Benchmark.DS, module.Benchmark.StartPos+1, module.Benchmark.EndPos-1) or "Unknown";
        module.Benchmark.StartPos, module.Benchmark.EndPos = nil, nil;

        if ... and type(...) ~= "table" then
            table.insert(module.Benchmark.Results, {Func = module.Benchmark.FuncName, CalledBy = module.Benchmark.CalledByName, Time = module.Benchmark.Time2-module.Benchmark.Time1, Arguments = {...}});
        elseif ... then
            table.insert(module.Benchmark.Results, {Func = module.Benchmark.FuncName, CalledBy = module.Benchmark.CalledByName, Time = module.Benchmark.Time2-module.Benchmark.Time1, Arguments = ...});
        else
            table.insert(module.Benchmark.Results, {Func = module.Benchmark.FuncName, CalledBy = module.Benchmark.CalledByName, Time = module.Benchmark.Time2-module.Benchmark.Time1, Arguments = nil});
        end
    end

    --- Write in Benchmark Results.txt the Results.
    function module.BenchmarkResults ()
        if not module.Benchmark.Results[1] then print("No Results Found."); return; end

        module.Benchmark.ResultsParsed = {};
        local ThisFunc, ThisFuncCall, Args;
        local String = "";
        local function WriteLine (Line)
            String = String .. Line .. "\n";
        end

        -- Filter by Calls
        for i = 1, #module.Benchmark.Results do
            -- Create Func Sub Table
            ThisFunc = module.Benchmark.Results[i].Func;
            if not module.Benchmark.ResultsParsed[ThisFunc] then
                module.Benchmark.ResultsParsed[ThisFunc] = {Time = {}, Called = 0, Min = 0, Max = 0, Mean = 0, Median = 0};
            end
            -- Create Called By Sub Table
            ThisFuncCall = module.Benchmark.Results[i].CalledBy;
            if not module.Benchmark.ResultsParsed[ThisFunc][ThisFuncCall] then
                module.Benchmark.ResultsParsed[ThisFunc][ThisFuncCall] = {Time = {}, Called = 0, Min = 0, Max = 0, Mean = 0, Median = 0};
            end
            -- Create Arg Sub Table
            Args = "";
            if module.Benchmark.Results[i].Arguments then
                for Key, Value in pairs(module.Benchmark.Results[i].Arguments) do
                    if tostring(Key) ~= "LastCastTime" then -- Add Irrelevants Args there.
                        Args = Args..Key.."("..tostring(Value).."), ";
                    end
                end
                if string.len(Args) > 2 then
                    Args = string.sub(Args, 1, string.len(Args)-2); -- Remove ", "
                end
            else
                Args = "None";
            end
            if not module.Benchmark.ResultsParsed[ThisFunc][ThisFuncCall][Args] then
                module.Benchmark.ResultsParsed[ThisFunc][ThisFuncCall][Args] = {Time = {}, Called = 0, Min = 0, Max = 0, Mean = 0, Median = 0};
            end
            -- Compute Called
            module.Benchmark.ResultsParsed[ThisFunc].Called = module.Benchmark.ResultsParsed[ThisFunc].Called + 1;
            module.Benchmark.ResultsParsed[ThisFunc][ThisFuncCall].Called = module.Benchmark.ResultsParsed[ThisFunc][ThisFuncCall].Called + 1;
            module.Benchmark.ResultsParsed[ThisFunc][ThisFuncCall][Args].Called = module.Benchmark.ResultsParsed[ThisFunc][ThisFuncCall][Args].Called + 1;
            -- Add Time Table to each Sub Tables
            table.insert(module.Benchmark.ResultsParsed[ThisFunc].Time, module.Benchmark.Results[i].Time);
            table.insert(module.Benchmark.ResultsParsed[ThisFunc][ThisFuncCall].Time, module.Benchmark.Results[i].Time);
            table.insert(module.Benchmark.ResultsParsed[ThisFunc][ThisFuncCall][Args].Time, module.Benchmark.Results[i].Time);
        end

        -- Parse Results
        for Key, Value in pairs(module.Benchmark.ResultsParsed) do
            -- Filter Wrong Keys
            if Key ~= "Time" and Key ~= "Called" and Key ~= "Min" and Key ~= "Max" and Key ~= "Mean" and Key ~= "Median" then
                -- Write Function
                WriteLine(Key);
                -- Write Header
                WriteLine("\tCalled By\t\t\t\t\t\tMin\t\t\t\tMax\t\t\t\tMean\t\t\tMedian\t\t\tCalled\t\t\t\t\t\t\tArgs\n");
                -- Iterate over Called By
                for Key2, Value2 in pairs(module.Benchmark.ResultsParsed[Key]) do
                    -- Filter Wrong Keys
                    if Key2 ~= "Time" and Key2 ~= "Called" and Key2 ~= "Min" and Key2 ~= "Max" and Key2 ~= "Mean" and Key2 ~= "Median" then
                        -- Compute Results
                        module.Benchmark.ResultsParsed[Key][Key2].Min = math.min(unpack(Value2.Time));
                        module.Benchmark.ResultsParsed[Key][Key2].Max = math.max(unpack(Value2.Time));
                        module.Benchmark.ResultsParsed[Key][Key2].Mean = module.Benchmark.TableMean(Value2.Time);
                        module.Benchmark.ResultsParsed[Key][Key2].Median = module.Benchmark.TableMedian(Value2.Time);
                        -- Write Results
                        WriteLine("\n\t"..Key2..module.Benchmark.TabSpace(string.len(Key2))..string.format("%.3f", module.Benchmark.ResultsParsed[Key][Key2].Min).."\t\t\t"..string.format("%.3f", module.Benchmark.ResultsParsed[Key][Key2].Max).."\t\t\t"..string.format("%.3f", module.Benchmark.ResultsParsed[Key][Key2].Mean).."\t\t\t"..string.format("%.3f", module.Benchmark.ResultsParsed[Key][Key2].Median).."\t\t\t"..string.format("%d", module.Benchmark.ResultsParsed[Key][Key2].Called));
                        -- Iterate over Arguments
                        for Key3, Value3 in pairs(module.Benchmark.ResultsParsed[Key][Key2]) do
                            -- Filter Wrong Keys
                            if Key3 ~= "Time" and Key3 ~= "Called" and Key3 ~= "Min" and Key3 ~= "Max" and Key3 ~= "Mean" and Key3 ~= "Median" then
                                -- Compute Results
                                module.Benchmark.ResultsParsed[Key][Key2][Key3].Min = math.min(unpack(Value3.Time));
                                module.Benchmark.ResultsParsed[Key][Key2][Key3].Max = math.max(unpack(Value3.Time));
                                module.Benchmark.ResultsParsed[Key][Key2][Key3].Mean = module.Benchmark.TableMean(Value3.Time);
                                module.Benchmark.ResultsParsed[Key][Key2][Key3].Median = module.Benchmark.TableMedian(Value3.Time);
                                -- Write Results
                                WriteLine("\t\t\t\t\t\t\t\t\t"..string.format("%.3f", module.Benchmark.ResultsParsed[Key][Key2][Key3].Min).."\t\t\t"..string.format("%.3f", module.Benchmark.ResultsParsed[Key][Key2][Key3].Max).."\t\t\t"..string.format("%.3f", module.Benchmark.ResultsParsed[Key][Key2][Key3].Mean).."\t\t\t"..string.format("%.3f", module.Benchmark.ResultsParsed[Key][Key2][Key3].Median).."\t\t\t"..string.format("%d", module.Benchmark.ResultsParsed[Key][Key2][Key3].Called)..module.Benchmark.TabSpace(string.len(string.format("%d", module.Benchmark.ResultsParsed[Key][Key2][Key3].Called)))..Key3);
                            end
                        end
                    end
                end
                -- Compute Results
                module.Benchmark.ResultsParsed[Key].Min = math.min(unpack(Value.Time));
                module.Benchmark.ResultsParsed[Key].Max = math.max(unpack(Value.Time));
                module.Benchmark.ResultsParsed[Key].Mean = module.Benchmark.TableMean(Value.Time);
                module.Benchmark.ResultsParsed[Key].Median = module.Benchmark.TableMedian(Value.Time);
                -- Write Results
                WriteLine("\n\n\tTotal\t\t\t\t\t\t\t"..string.format("%.3f", module.Benchmark.ResultsParsed[Key].Min).."\t\t\t"..string.format("%.3f", module.Benchmark.ResultsParsed[Key].Max).."\t\t\t"..string.format("%.3f", module.Benchmark.ResultsParsed[Key].Mean).."\t\t\t"..string.format("%.3f", module.Benchmark.ResultsParsed[Key].Median).."\t\t\t"..string.format("%d", module.Benchmark.ResultsParsed[Key].Called).."\n\n");
            end
        end

        -- Write the File
        WriteFile(GetManagerDirectory() .. BenchmarkResultsDirectoryChange, String);
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Defines the command manager.
    module.Commands = {};
    module.CmdArgument = {};
    local ArgumentsInitialized = false;

    --- Register a command.
    -- @param Command The command.
    -- @param Function The function to be called with the arguments when the command is used.
    function module.RegisterCommand (Command, Function)
        module.Commands[Command:lower()] = Function;
    end

    --- Find every already registered command.
    local SlashRegisteredCommand = {};
    local function FindSlash ()
        if not SlashRegisteredCommand[1] then
            local Global = _G
            local Index = 1;
            for Key, Value in pairs(Global) do
                if type(Key) == "String" and string.sub(Key, 1, 6) == "SLASH_" and string.sub(Value, 1, 1) == "/" then
                    SlashRegisteredCommand[Index] = string.sub(Value, 2);
                    Index = Index + 1;
                end
            end
        end
    end

    -- Command Function
    local function CmdFunc (Message, EditBox)
        local Command = Message:sub(1, Message:find(" ") and Message:find(" ") - 1 or nil):lower();
        local Rest = Message:find(" ") and Message:sub(Message:find(" ") + 1) or "";

        if not Command then
            module.Print("Unknown command.");
        else
            local Handler = module.Commands[Command];
            if Handler then
                Handler(Rest);
            else
                module.Print("Unknown command: ", Command)
            end
        end
    end

    function module.InitCommand ()
        -- Fill our already Registered Slash table
        FindSlash();
        -- Check if we have a setting and this setting is correct or set a random one until user set a new value
        local CurrentCmd = module.GetSetting("Macro Command_Value1");
        local CmdValidate = true;
        if module.GetSetting("Macro Command_Value1") ~= nil then
            for i = 1, #SlashRegisteredCommand do
                if SlashRegisteredCommand[i] == CurrentCmd then
                    CmdValidate = false;
                    break;
                end
            end
            if module.GetSetting("Macro Command_Value1") == "" or module.GetSetting("Macro Command_Value1") == module.GetSetting("Macro Command_DefaultValue") or module.GetSetting("Macro Command_Value1") == "soap" then
                CmdValidate = false;
            end
        else
            CmdValidate = false;
        end
        if CmdValidate then
            module.CmdName = module.GetSetting("Macro Command_Value1");
        else
            if module.GetSetting("Macro Command_DefaultValue") then
                module.CmdName = module.GetSetting("Macro Command_DefaultValue");
            else
                -- Generate a 4chars random command
                module.CmdName = "";
                for i = 1, 4 do
                    module.CmdName = module.CmdName .. string.char(math.random(97, 122));
                end
                module.SetSetting("Macro Command_DefaultValue", module.CmdName);
                module.SetSetting("Macro Command_Value1", module.CmdName);
            end
            -- Show the Popup to ask user to set a new command.
            if module.CmdPopup then
                StaticPopupDialogs[module.CmdPopup].text = "|cFF0066FFSOAPBOX ROTATIONS|r\n|cFFFF7D0AMacro Command Customizing|r\n\n\nYou |cFFFF0044need to type a replacement|r for your current '|cFF0066FF"..module.GetSetting("Macro Command_Value1").."|r' command.\n\nYou |cFFFF0044cannot|r have '|cFF0066FFsoap|r' (Legacy Command), '|cFF0066FF"..module.GetSetting("Macro Command_DefaultValue").."|r' (Random Command generated on first login) or any Built-In Command (like '|cFF0066FFcast|r') as |cFFFF0044Macro Command|r prefix.\n\n|cFF0066FFYou will see this window until you change it to something else.|r\n\nThe Command will be written in '|cFF66FF00Macro Command.txt|r', as a reminder, in your program folder.\n\nYou can change it later in the '|cFF66FF00Macros Settings|r' tab of the |cFF66FF00UI|r.";
                StaticPopup_Show(module.CmdPopup);
            end
        end
        -- Command Dump
        local String = "";
        local function WriteLine (Line)
            String = String .. Line .. "\n";
        end
        WriteLine("Macro Command: "..module.CmdName);
        if ArgumentsInitialized then
            WriteLine("\nArguments:");
            WriteLine("toggle: "..module.CmdArgument.toggle);
            WriteLine("cds: "..module.CmdArgument.cds);
            WriteLine("aoe: "..module.CmdArgument.aoe);
            WriteLine("cast: "..module.CmdArgument.cast);
            WriteLine("cancel: "..module.CmdArgument.cancel);
            WriteLine("castmouse: "..module.CmdArgument.castmouse);
            WriteLine("al: "..module.CmdArgument.al);
            WriteLine("debug: "..module.CmdArgument.debug);
            WriteLine("loadui: "..module.CmdArgument.loadui);
            WriteLine("saveui: "..module.CmdArgument.saveui);
            WriteLine("loadcil: "..module.CmdArgument.loadcil);
            WriteLine("savecil: "..module.CmdArgument.savecil);
            WriteLine("currentui: "..module.CmdArgument.currentui);
            WriteLine("defaultui: "..module.CmdArgument.defaultui);
            WriteLine("ui: "..module.CmdArgument.ui);
            WriteLine("toggleoption: "..module.CmdArgument.toggleoption);
            WriteLine("toggleon: "..module.CmdArgument.toggleon);
            WriteLine("toggleoff: "..module.CmdArgument.toggleoff);
            WriteLine("tb: "..module.CmdArgument.tb);
            WriteLine("status: "..module.CmdArgument.status);
            WriteLine("cs: "..module.CmdArgument.cs);
            WriteLine("ticket: "..module.CmdArgument.ticket);
            WriteLine("settings: "..module.CmdArgument.settings);
            WriteLine("rotations: "..module.CmdArgument.rotations);
        end
        WriteFile(GetManagerDirectory() .. MacroCommandDirectoryChange, String);
        -- Command Init
        _G["SLASH_" .. strupper(module.CmdName) .. "1"] = "/"..strlower(module.CmdName);
        SlashCmdList[strupper(module.CmdName)] = CmdFunc;
        -- Fallback Command Init
        _G["SLASH_SOAP1"] = "/soap";
        SlashCmdList["SOAP"] = CmdFunc;
    end

    function module.InitArguments ()
        if not ArgumentsInitialized then
        -- Engine Commands
            -- Engine
                module.CmdArgument.toggle = module.GetOptionValue("Toggle") or "toggle";
                module.RegisterCommand(module.CmdArgument.toggle,
                    function (Parts)
                        module.ToggleCmd(Parts);
                    end
                );
            -- CDs
                module.CmdArgument.cds = module.GetOptionValue("CDs - AOE") or "cds";
                module.RegisterCommand(module.CmdArgument.cds,
                    function (Parts)
                        module.CDsCmd();
                    end
                );
            -- AOE
                module.CmdArgument.aoe = module.GetSecondOptionValue("CDs - AOE") or "aoe";
                module.RegisterCommand(module.CmdArgument.aoe,
                    function (Parts)
                        module.AOECmd();
                    end
                );
            -- Cast
                module.CmdArgument.cast = module.GetOptionValue("Cast - Cancel") or "cast";
                module.RegisterCommand(module.CmdArgument.cast,
                    function (Spell)
                        module.CastCmd(Spell);
                    end
                );
            -- Cast Mouse
                module.CmdArgument.castmouse = module.GetOptionValue("Cast Mouse") or "castmouse";
                module.RegisterCommand(module.CmdArgument.castmouse,
                    function (Spell)
                        module.CastMouseCmd(Spell);
                    end
                );
            -- Cancel Cast
                module.CmdArgument.cancel = module.GetSecondOptionValue("Cast - Cancel") or "cancel";
                module.RegisterCommand(module.CmdArgument.cancel,
                    function (self)
                        module.CancelCmd();
                    end
                );
            -- Action Log
                module.CmdArgument.al = module.GetOptionValue("Al - Debug") or "al";
                module.RegisterCommand(module.CmdArgument.al,
                    function (Parts)
                        module.AlCmd();
                    end
                );
            -- Debug Mode
                module.CmdArgument.debug = module.GetSecondOptionValue("Al - Debug") or "debug";
                module.RegisterCommand(module.CmdArgument.debug,
                    function (Parts)
                        module.DebugCmd();
                    end
                );
        -- UI Commands
            -- LoadUI
                module.CmdArgument.loadui = module.GetOptionValue("LoadUI - SaveUI") or "loadui";
                module.RegisterCommand(module.CmdArgument.loadui,
                    function (Name)
                        if not ReadFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. Name .. ".json") then
                            module.ProfileManager(Name .. " profile does not exist.");
                            XRNOverlay(Name .. " profile does not exist.");
                            return;
                        end
                        module.ProfileManager("Loading configuration |cFFEEEB16" .. Name .. ".");
                        XRNOverlay("Profile " .. Name .." Loaded");
                        module.SelectProfile(Name);
                        module.ClearOptions();
                        module.ClearOutputs();
                        module.GetActiveRotation():Initialize();
                        module.CreateUI();
                    end
                );
            -- SaveUI
                module.CmdArgument.saveui = module.GetSecondOptionValue("LoadUI - SaveUI") or "saveui";
                module.RegisterCommand(module.CmdArgument.saveui,
                    function (Name)
                        if Name == "" then
                            WriteFile(GetManagerDirectory() .. ProfilesDirectoryChange .. "All Class.json", json.encode(Settings.All));
                            WriteFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. ProfileName .. ".json", json.encode(Settings.Spec));
                            module.ProfileManager("Saved the current configuration to " .. "|cFFEEEB16".. ProfileName .. ".");
                            XRNOverlay("Profile " .. ProfileName .." Saved");
                        else
                            WriteFile(GetManagerDirectory() .. ProfilesDirectoryChange .. "All Class.json", json.encode(Settings.All));
                            WriteFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. Name .. ".json", json.encode(Settings.Spec));
                            module.ProfileManager("Saved the current configuration to " .. "|cFFEEEB16".. Name .. ".");
                            XRNOverlay("Profile " .. Name .." Saved");
                            if ProfileName ~= Name then
                                ProfileName = Name;
                                module.SelectProfile(Name);
                                module.ClearOptions();
                                module.ClearOutputs();
                                module.GetActiveRotation():Initialize();
                                module.CreateUI();
                            end
                        end
                    end
                );
            -- CurrentUI
                module.CmdArgument.currentui = module.GetOptionValue("CurrentUI - DefaultUI") or "currentui";
                module.RegisterCommand(module.CmdArgument.currentui,
                    function ()
                        module.ProfileManager("The current profile is: " .. "|cFFEEEB16"..module.GetProfile());
                    end
                );
            -- DefaultUI
                module.CmdArgument.defaultui = module.GetSecondOptionValue("CurrentUI - DefaultUI") or "defaultui";
                module.RegisterCommand(module.CmdArgument.defaultui,
                    function ()
                        if not ReadFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. "Default" .. ".json") then
                            module.ProfileManager("The profile does not exist.");
                            return;
                        end
                        module.SelectProfile("Default");
                        module.ClearOptions();
                        module.ClearOutputs();
                        module.GetActiveRotation():Initialize();
                        module.CreateUI();
                    end
                );
            -- UI
                module.CmdArgument.ui = module.GetOptionValue("UI - ToggleOption") or "ui";
                module.RegisterCommand(module.CmdArgument.ui,
                    function (Parts)
                        module.UICmd();
                    end
                );
            -- ToggleOption
                module.CmdArgument.toggleoption = module.GetSecondOptionValue("UI - ToggleOption") or "toggleoption";
                module.RegisterCommand(module.CmdArgument.toggleoption,
                    function (Name)
                        if module.IsOptionEnabled(Name) == nil then
                            module.Error("Invalid Option")
                        elseif module.IsOptionEnabled(Name) == true then
                            module.SetSetting(Name.."_Checked", false);
                            module.StatusUpdate(Name.." |cFFDF0101Disabled")
                            XRNOverlay(Name.." |cFFDF0101Disabled")
                        elseif module.IsOptionEnabled(Name) == false then
                            module.SetSetting(Name.."_Checked", true);
                            module.StatusUpdate(Name.." |cFF04B431Enabled")
                            XRNOverlay(Name.." |cFF04B431Enabled")
                        end
                        module.UpdateOptions();
                    end
                );
            -- ChangeValue
                module.CmdArgument.changevalue = module.GetSecondOptionValue("Change Value") or "changevalue";
                module.RegisterCommand(module.CmdArgument.changevalue,
                    function (Arg)
                        -- we will need to split values option name,value,newvalue
                        -- i.e. /soap changevalue Arcane Missiles,1,Always
                        -- /soap changevalue Arcane Missiles,1,Not During Burn
                        local function Split(Str, Pat)
                            local t = {};
                            local fpat = "(.-)" .. Pat;
                            local last_end = 1;
                            local s, e, cap = Str:find(fpat, 1);
                            while s do
                                if s ~= 1 or cap ~= "" then
                                    table.insert(t,cap);
                                end
                                last_end = e+1;
                                s, e, cap = Str:find(fpat, last_end);
                            end
                            if last_end <= #Str then
                                cap = Str:sub(last_end);
                                table.insert(t, cap);
                            end
                            return t;
                        end

                        local Arguments = Split(Arg, ",");
                        if Arguments[1] ~= nil and Arguments[2] ~= nil and Arguments[3] ~= nil then
                            if module.GetOptionValue(Arguments[1]) == nil then
                                module.Error("Invalid Option")
                            else
                                if Arguments[2] == "1" then
                                    module.SetSetting(Arguments[1] .. "_Value1", Arguments[3]);
                                    module.StatusUpdate(Arguments[1] .. " 1st value changed to " .. Arguments[3])
                                    XRNOverlay(Arguments[1] .. " 1st value changed to " .. Arguments[3])
                                    module.UpdateOptions();
                                elseif Arguments[2] == "2" then
                                    module.SetSetting(Arguments[1] .. "_Value2", Arguments[3]);
                                    module.StatusUpdate(Arguments[1] .. " 2nd value changed to " .. Arguments[3])
                                    XRNOverlay(Arguments[1] .. " 2nd value changed to " .. Arguments[3])
                                    module.UpdateOptions();
                                end
                            end
                        end
                    end
                );
            -- ToggleOn
                module.CmdArgument.toggleon = module.GetOptionValue("ToggleOn - ToggleOff") or "toggleon";
                module.RegisterCommand(module.CmdArgument.toggleon,
                    function (Name)
                        if module.IsOptionEnabled(Name) == nil then
                            module.Error("Invalid Option")
                        else
                            module.SetSetting(Name .. "_Checked", true);
                            module.StatusUpdate(Name .. " |cFF04B431Enabled")
                            XRNOverlay(Name .. " |cFF04B431Enabled")
                        end
                        module.UpdateOptions();
                    end
                );
            -- ToggleOn
                module.CmdArgument.toggleoff = module.GetSecondOptionValue("ToggleOn - ToggleOff") or "toggleoff";
                module.RegisterCommand(module.CmdArgument.toggleoff,
                    function (Name)
                        if module.IsOptionEnabled(Name) == nil then
                            module.Error("Invalid Option")
                        else
                            module.SetSetting(Name .. "_Checked", false);
                            module.StatusUpdate(Name .. " |cFFDF0101Disabled")
                            XRNOverlay(Name .. " |cFFDF0101Disabled")
                        end
                        module.UpdateOptions();
                    end
                );
            -- Tb (Toolbox)
                module.CmdArgument.tb = module.GetOptionValue("TB - Status") or "tb";
                module.RegisterCommand(module.CmdArgument.tb,
                    function (Parts)
                        module.TbCmd();
                    end
                );
            -- Status (From Toolbox)
                module.CmdArgument.status = module.GetSecondOptionValue("TB - Status") or "status";
                module.RegisterCommand(module.CmdArgument.status,
                    function (Parts)
                        module.StatusCmd();
                    end
                );
            -- CS (Custom Settings)
                module.CmdArgument.cs = module.GetOptionValue("CS") or "cs";
                module.RegisterCommand(module.CmdArgument.cs,
                    function (Parts)
                        module.CsCmd();
                    end
                );
        -- Infos Commands
            -- Display Commands
                module.CmdArgument.commands = "commands";
                module.RegisterCommand(module.CmdArgument.commands,
                    function(self)
                        module.Command("To Enable/Disable the rotation type: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.toggle .. "|r you can add argument |cFF0080FFon|r or |cFF0080FFoff|r to it to use it in a separate macro.");
                        module.Command("To Enable/Disable a GUI option: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.toggleoption.." OPTION_NAME");
                        module.Command("To Enable a GUI option: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.toggleon.." OPTION_NAME");
                        module.Command("To Disable a GUI option: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.toggleoff.." OPTION_NAME");
                        module.Command("To Change the Value of a GUI option: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.changevalue.." OPTION_NAME,OPTION_POSITION,NEW_VALUE |cffFFFFFFOption Name: The name of the option. Option Position: Position of the option (left = 1, right = 2, only one = 1). New Value: Must be a valid option. Arguments must be separated by coma (,) and must have no spaces before and after the coma. Example: |cFF0080FF/soap changevalue Target | Attack,1,Most HP");
                        module.Command("To Show/Hide the GUI type: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.ui);
                        module.Command("To Show/Hide the Toolbox type: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.tb);
                        module.Command("To Show/Hide the Custom Settings UI type: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.cs);
                        module.Command("To Show/Hide the status part of Toolbox type: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.status);
                        module.Command("To save UI settings: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.saveui.." NAME");
                        module.Command("To load a previously saved UI: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.loadui.." NAME");
                        module.Command("To save Custom Interrupts List: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.savecil.." NAME");
                        module.Command("To load a previously saved Custom Interrupts List: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.loadcil.." NAME");
                        module.Command("To load the default, auto-saving UI: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.defaultui);
                        module.Command("To Enable/Disable Automatic AOE handling: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.aoe);
                        module.Command("Cooldowns Toggle: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.cds);
                        module.Command("Queue a Spell, press twice to cancel: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.cast.." SPELL_NAME");
                        module.Command("Queue a Spell to cast it on your mouse cursor, press twice to cancel: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.castmouse.." SPELL_NAME");
                        module.Command("Cancel all queued spells: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.cancel);
                        module.Command("Show Action Log: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.al);
                        module.Command("To enable debug mode type : |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.debug);
                        module.Command("To Create a Ticket Log: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.ticket);
                        module.Command("To Create a file with a list of rotations you own: |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.rotations);
                        module.Command("To Create a file with a list of all your settings : |cFF0080FF/"..module.CmdName.." "..module.CmdArgument.settings);
                        module.Command("To automatically target the most appropriate unit: |cFF0080FF/"..module.CmdName.." target");
                    end
                );
            -- Create Macros
                module.CmdArgument.macros = "macros";
                module.RegisterCommand(module.CmdArgument.macros,
                    function(Arguments)
                        SetCVar("synchronizeMacros", "0");
                        CreateMacros();
                    end
                );
            -- Create a Ticket Log
                module.CmdArgument.ticket = module.GetOptionValue("Ticket - Settings") or "ticket";
                module.RegisterCommand(module.CmdArgument.ticket,
                    function (self)
                        module.TicketCmd();
                    end
                );
            -- Dump Settings
                module.CmdArgument.settings = module.GetSecondOptionValue("Ticket - Settings") or "settings";
                module.RegisterCommand(module.CmdArgument.settings,
                    function (self)
                        module.SettingsCmd();
                    end
                );
            -- Create a Rotations Log
                module.CmdArgument.rotations = module.GetOptionValue("Rotations") or "rotations";
                module.RegisterCommand(module.CmdArgument.rotations,
                    function (self)
                        module.RotationsCmd();
                    end
                );
            -- Load Interrupts List
                module.CmdArgument.loadcil = module.GetOptionValue("LoadCIL - SaveCIL") or "loadcil";
                module.RegisterCommand(module.CmdArgument.loadcil,
                    function (Name)
                        if Name == "" then
                            Name = "Default"
                        end
                        module.LoadCILCmd(Name);
                    end
                );
            -- Dump Interrupts List
                module.CmdArgument.savecil = module.GetSecondOptionValue("LoadCIL - SaveCIL") or "savecil";
                module.RegisterCommand(module.CmdArgument.savecil,
                    function (Name)
                        if Name == "" then
                            Name = "Default"
                        end
                        module.SaveCILCmd(Name);
                    end
                );
            -- Target Best Unit
                module.CmdArgument.target = "target";
                module.RegisterCommand(module.CmdArgument.target,
                    function ()
                        -- Common
                        local Spell = module.Spell;
                        -- Specs Spells
                        local SpecID = select(1, GetSpecializationInfo(GetSpecialization()));
                        -- List of spells to use to find targets. [Specialization ID] = Spell
                        local SpecsSpells = {
                            -- Mage Arcane (Arcane Blast)
                            [62] = 30451,
                            -- Mage Fire (Fireball)
                            [63] = 133,
                            -- Mage Frost (Frostbolt)
                            [64] = 116,
                            -- Paladin Holy (Judgment)
                            [65] = 20271,
                            -- Paladin Protection (Crusader Strike)
                            [66] = 35395,
                            -- Paladin Retribution (Crusader Strike)
                            [70] = 35395,
                            -- Warrior Arms (Mortal Strike)
                            [71] = 12294,
                            -- Warrior Fury (Bloodthirst)
                            [72] = 23881,
                            -- Warrior Protection (Heroic Strike)
                            [73] = 78,
                            -- Druid Balance (Wrath)
                            [102] = 5176,
                            -- Druid Feral (Rake)
                            [103] = 1822,
                            -- Druid Guardian (Lacerate)
                            [104] = 33745,
                            -- Druid Resto (Wrath)
                            [105] = 5176,
                            -- Deathknight Blood (Plague Strike)
                            [250] = 45462,
                            -- Deathknight Frost (Frost Strike)
                            [251] = 49143,
                            -- Deathknight Unholy (Scourge Strike)
                            [252] = 55090,
                            -- Hunter Beastmaster (Arcane Shot)
                            [253] = 3044,
                            -- Hunter Marksmanship (Aimed Shot)
                            [254] = 19434,
                            -- Hunter Survival (Arcane Shot)
                            [255] = 3044,
                            -- priest Discipline (Smite)
                            [256] = 585,
                            -- Priest Holy (Smite)
                            [257] = 585,
                            -- Priest Shadow (Mind Blast)
                            [258] = 8092,
                            -- Rogue Assassination (Mutilate)
                            [259] = 1329,
                            -- Rogue Combat (SinisterStrike)
                            [260] = 1752,
                            -- Rogue Subtlety (Hemorrhage)
                            [261] = 16511,
                            -- Shaman Elemental (Lightning Bolt)
                            [262] = 403,
                            -- Shaman Enhancement (Stormstrike)
                            [263] = 17364,
                            -- Shaman Restoration (Lightning Bolt)
                            [264] = 403,
                            -- Warlock Affliction (Agony)
                            [265] = 980,
                            -- Warlock Demonology (Corruption)
                            [266] = 172,
                            -- Warlock Destruction (Immolate)
                            [267] = 348,
                            -- Monk Bremaster (Tiger Palm)
                            [268] = 100787,
                            -- Monk Windwalker (Tiger Palm)
                            [269] = 100787,
                            -- Monk Mistweaver (Provoke)
                            [270] = 115546,
                        }
                        -- Find New Target
                        local NewTargetUnit = module.Unit.AutoTarget(Spell(SpecsSpells[SpecID], true, true, true), module.GetOptionValue("Target | Attack"));
                        if NewTargetUnit then
                            NewTargetUnit:Attack();
                            RunMacroText("/petattack target");
                            return;
                        end
                    end
                );
            -- Testing Mode
                module.RegisterCommand("testing",
                    function (Parts)
                        if module.GetSetting("Range | Line Of Sight_Checked") ~= true then
                            module.AddNewOption("Advanced Settings", "Range | Line Of Sight", 233, true, {2, "Disabled", "Distance", "WoW API"}, {2, "Disabled", "Enabled"}, "Hidden feature allowing to change Distance Check model and Disabling Line Of Sight check for testing purposes."..C.TOOLTIP_VALUE_1.."Distance check should always be preferred. If it do not work, fall back to WoW API check. If none will work, fall back to Disabled. If it still do not work, try with the Line Of Sight check disabled."..C.TOOLTIP_VALUE_2.."Line Of Sight check should always be Enabled. If it do not work, fall back to Disabled.");
                        end
                        module.SetSetting("Range | Line Of Sight_Checked", true);
                    end
                );

            ArgumentsInitialized = true;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Defines the settings manager.
    -- @author

    local function EncodeSetting (String)
        local Encoded = "";
        for Key, Value in pairs({ String:byte(1, String:len()) }) do
            Encoded = Encoded .. string.format("%X", Value);
        end

        return Encoded;
    end

    -- .json Writer Handler.
    local SettingsNeedAnUpdate, SettingsForceUpdate, SettingsForceReload, SettingsScriptReload = false, false, false, nil;
    module.JsonSettingUpdate = CreateFrame("Frame");
    module.JsonSettingUpdate.Update = 0;
    module.JsonSettingUpdate:SetScript("OnUpdate",
        function ()
            if (module.GetTime() > module.JsonSettingUpdate.Update or SettingsForceUpdate) and SettingsNeedAnUpdate then
                SettingsNeedAnUpdate = false;
                SettingsForceUpdate = false;
                SettingsScriptReload = SettingsForceReload;
                SettingsForceReload = false;
                WriteFile(ProfilePath_All, json.encode(Settings.All));
                WriteFile(ProfilePath_Spec, json.encode(Settings.Spec));
                module.UpdateSettings2();
                if SettingsScriptReload then
                    RunMacroText("/reload");
                end
                module.JsonSettingUpdate.Update = module.GetTime() + 1;
            end
        end
    );

    -- Used for Set/Get Setting.
    local Settings_AllClass = {
        "Anti AFK",
        "Auto Accept LFG Proposal",
        "Use Level "..ClientMaxLevel.." Optimized Rotation",
        "Enable Welcome Greeting",
        "Enable Chat Notifications",
        "Enable Chat Overlay",
        "Pause Rotation While In Chat",
        "Pulse Control",
        "TPS: Unit %| Rotation",
        "Latency Tolerance",
        "Target Priority",
        "Macro Command",
        "Toggle",
        "CDs %- AOE",
        "Cast %- Cancel",
        "Cast Mouse",
        "Al %- Debug",
        "LoadUI %- SaveUI",
        "LoadCIL %- SaveCIL",
        "CurrentUI %- DefaultUI",
        "UI %- ToggleOption",
        "Change Value",
        "ToggleOn %- ToggleOff",
        "TB %- Status",
        "CS_Checked",
        "CS_Value1",
        "Ticket %- Settings",
        "Rotations"
    };
    local Settings_RequireReload = {
        "Use Level "..ClientMaxLevel.." Optimized Rotation",
        "Macro Command_Value1"
    };
    local Settings_RequireUpdate = {
        "Toggle_Value1",
        "CDs %- AOE_Value1",
        "CDs %- AOE_Value2",
        "Cast %- Cancel_Value1",
        "Cast %- Cancel_Value2",
        "Cast Mouse_Value1",
        "Al %- Debug_Value1",
        "Al %- Debug_Value2",
        "LoadUI %- SaveUI_Value1",
        "LoadUI %- SaveUI_Value2",
        "LoadCIL %- SaveCIL_Value1",
        "LoadCIL %- SaveCIL_Value2",
        "CurrentUI %- DefaultUI_Value1",
        "CurrentUI %- DefaultUI_Value2",
        "UI %- ToggleOption_Value1",
        "UI %- ToggleOption_Value2",
        "Change Value_Value1",
        "ToggleOn %- ToggleOff_Value1",
        "ToggleOn %- ToggleOff_Value2",
        "TB %- Status_Value1",
        "TB %- Status_Value2",
        "CS_Value1",
        "Ticket %- Settings_Value1",
        "Ticket %- Settings_Value2",
        "Rotations_Value1"
    };

    --- Get the value of a setting.
    -- @param Name The name of the setting.
    -- @return The value of the setting, or an empty table if the setting does not exist.
    function module.GetSetting (Name)
        local EncodedName = EncodeSetting(Name);
        -- Check if the setting is in Settings_AllClass
        for i = 1, #Settings_AllClass do
            if string.find(Name, Settings_AllClass[i]) then
                return Settings.All[EncodedName];
            end
        end
        return Settings.Spec[EncodedName];
    end

    --- Set the value of a setting.
    -- @param Name The name of the setting.
    -- @param Value The new value of the setting.
    function module.SetSetting (Name, Value)
        local EncodedName = EncodeSetting(Name);
        local SettingsTable;
        -- Give the Spec Table by default.
        SettingsTable = Settings.Spec;
        -- Check if the setting is in Settings_AllClass and then gives the right table.
        for i = 1, #Settings_AllClass do
            if string.find(Name, Settings_AllClass[i]) then
                SettingsTable = Settings.All;
                break;
            end
        end
        -- Check if the setting require a reload.
        for i = 1, #Settings_RequireReload do
            if string.find(Name, Settings_RequireReload[i]) then
                SettingsForceUpdate = true;
                SettingsForceReload = true;
                break;
            end
        end
        -- Check if the setting needs an instant save.
        for i = 1, #Settings_RequireUpdate do
            if string.find(Name, Settings_RequireUpdate[i]) then
                SettingsForceUpdate = true;
                break;
            end
        end
        SettingsTable[EncodedName] = Value;
        -- Tell to the .json writer handler that settings need to be saved.
        if RotationInitialized then
            SettingsNeedAnUpdate = true;
        end
    end

    --- Get whether an option is enabled.
    -- @param Name The name of the option.
    -- @return Whether the option is enabled or nil if the option hasn't been set by the user.
    function module.IsOptionEnabled (Name)
        return module.GetSetting(Name .. "_Checked");
    end

    --- Get the value of an option.
    -- @param Name The name of the option.
    -- @return The value of the option or nil if the option hasn't been set by the user.
    function module.GetOptionValue (Name)
        return module.GetSetting(Name .. "_Value1");
    end

    --- Get the second value of an option.
    -- @param Name The name of the option.
    -- @return The second value of the option or nil if the option hasn't been set by the user.
    function module.GetSecondOptionValue (Name)
        return module.GetSetting(Name .. "_Value2");
    end

    --- @brief Select a profile.
    -- @param Name The name of the profile.
    function module.SelectProfile (Name)
        SetSetting(ProfileKey, Name);
        module.ProfileManager("Loaded Profile: " .. "|cFFEEEB16"..Name);
    end

    --- @brief Get the name of the profile.
    -- @return The name of the profile.
    function module.GetProfile ()
        return ProfileName;
    end

    function module.SettingsInit ()
        -- Etablish the right Profile Spec
        currentSpec = GetSpecialization();
        currentSpecName = currentSpec and select(2, GetSpecializationInfo(currentSpec)) or UnitClass("Player");
        ProfileKey = UnitLevel("Player") < ClientMaxLevel and "Leveling" .. " - " .. UnitClass("Player") .. " - " .. currentSpecName or "Raiding" .. " - " .. UnitClass("Player") .. " - " .. currentSpecName;
        ProfileName = GetSetting(ProfileKey);
        ProfileName = ProfileName == "" and "Default" or ProfileName;
        -- Profile Paths
        ProfilePath_All = GetManagerDirectory() .. ProfilesDirectoryChange .. "All Class.json";
        ProfilePath_Spec = GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. ProfileName .. ".json";
        -- Settings Table
        Settings = {};
        Settings.All = json.decode(ReadFile(ProfilePath_All) or "") or {};
        Settings.Spec = json.decode(ReadFile(ProfilePath_Spec) or "") or {};
    end

    module.SettingsInit();

    -- Check if the player is in leveling and then check if he wants the Level 110 rotation or not.
    if UnitLevel("Player") < ClientMaxLevel and module.GetSetting("Use Level "..ClientMaxLevel.." Optimized Rotation_Checked") then
        ProfileKey = "Raiding" .. " - " .. UnitClass("Player") .. " - " .. currentSpecName;
        ProfileName = GetSetting(ProfileKey);
        ProfileName = ProfileName == "" and "Default" or ProfileName;
        ProfilePath_Spec = GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. ProfileName .. ".json";
        Settings.Spec = json.decode(ReadFile(ProfilePath_Spec) or "") or {};
        UseMaxLvlRotation = true;
    else
        UseMaxLvlRotation = false;
    end

    -- Create Default profile and check if the Profile does exists.
    if currentSpecName == UnitClass("Player") then
        if not ReadFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. "Default" .. ".json") then
            WriteFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. "Default" .. ".json", json.encode(Settings.Spec));
        end
        if not ReadFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. ProfileName .. ".json") then
            ProfileName = "Default";
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Manage the Rotations.
    -- File Variables Init
    module.Rotations = {};
    module.AurasInfos = {};

    --- Get the rotation for the active spec.
    -- @return The rotation for the active spec, or nil if there is none.
    function module.GetActiveRotation ()
        if not RunOnceMessage then
            RunOnceMessage = true;
        end
        local SpecID = UnitClass("Player");
        local SpecInfo = select(2,UnitClass("Player"));
        if GetSpecialization() and UnitLevel("Player") >= 10 then
            SpecID = GetSpecialization();
            SpecInfo = select(1, GetSpecializationInfo(SpecID));

            if SpecInfo and UnitLevel("Player") < ClientMaxLevel and not UseMaxLvlRotation then
                SpecInfo = "_"..SpecInfo;
            end
        end
        return SpecID and module.Rotations[SpecInfo];
    end

    --- Get the rotation for a spec ID.
    -- @param SpecID The spec ID.
    -- @return The rotation for it, or nil if there is none.
    function module.GetRotation (SpecID)
        return module.Rotations[SpecID];
        --
    end

    --- Set the rotation for a spec ID.
    -- @param SpecID The spec ID.
    -- @param Rotation The rotation.
    function module.SetRotation (SpecID, Rotation)
        module.Rotations[SpecID] = Rotation;
        --
    end

    --- Macros Command_Start
    --
    --- Engine Toggle
    module.Running = module.GetSetting("Running");
    module.MouseCast = 0;
    --- Get whether the active rotation is running.
    -- @return Whether the active rotation is running.
    function module.IsRunning ()
        return module.Running;
        --
    end

    --- Set whether the active rotation is running.
    -- @param Running Whether the active rotation is running.
    function module.SetRunning (Running)
        module.Running = Running;
        module.SetSetting("Running", Running);
        module.StatusUpdate(Running and "|cFF40FF00Started." or "|cFFFF0000Stopped.");
        XRNOverlay(Running and "|cFF40FF00Started" or "|cFFFF0000Stopped");
    end

    --- Function used when the Command is used (or via the Toolbox button).
    function module.ToggleCmd (Parts)
        local Parts = Parts ~= nil and string.lower(Parts) or nil;
        if Parts == "off" and module.IsRunning() then
            module.SetRunning(false);
        elseif Parts == "on" and not module.IsRunning() then
            module.SetRunning(true);
        elseif Parts ~= "off" and Parts ~= "on" then
            local Running = not module.IsRunning();
            module.SetRunning(Running);
        end
    end

    --- Engine CDs
    module.Cooldowns = module.GetSetting("cds");
    --- Do not use in rotation, use CooldownsAllowed instead (because it checks if the target is a boss or not).
    function module.UseCooldowns ()
        return module.Cooldowns;
        --
    end

    --- Get whether cooldowns are currently allowed.
    -- @return Whether cooldowns are currently allowed.
    function module.CooldownsAllowed ()
        return module.UseCooldowns() and (not module.IsOptionEnabled("Cooldowns Only On Bosses") or module.Unit.Target:IsBoss());
        --
    end

    --- Set whether cooldowns are enabled.
    -- @param Cooldowns Whether cooldowns are to be used.
    function module.SetCooldowns (Cooldowns)
        module.Cooldowns = Cooldowns;
        module.SetSetting("cds", Cooldowns);
    end

    --- Function used when the Command is used (or via the Toolbox button).
    function module.CDsCmd ()
        local Cooldowns = not module.UseCooldowns();
        module.SetCooldowns(Cooldowns);

        module.StatusUpdate(Cooldowns and "Cooldowns have been |cFF40FF00enabled." or "Cooldowns have been |cFFFF0000disabled.");
        XRNOverlay(Cooldowns and "Cooldowns |cFF40FF00Enabled" or "Cooldowns |cFFFF0000Disabled");
    end

    --- Engine AOE
    module.AOE = module.GetSetting("AOE");
    function module.UseAOE ()
        return module.AOE;
        --
    end

    function module.SetAOE (AOE)
        module.AOE = AOE;
        module.SetSetting("AOE", AOE);
    end

    --- Function used when the Command is used (or via the Toolbox button).
    function module.AOECmd ()
        local AOE = not module.UseAOE();
        module.SetAOE(AOE);

        module.StatusUpdate(AOE and "Automatic AOE has been |cFF40FF00enabled." or "Automatic AOE has been |cFFFF0000disabled.");
        XRNOverlay(AOE and "Automatic AOE |cFF40FF00Enabled" or "Automatic AOE |cFFFF0000Disabled");
    end

    --- Debug Command
    module.Debug = module.GetSetting("Debug");

    function module.UseDebug ()
        return module.Debug;
        --
    end

    function module.SetDebug (Debug)
        module.Debug = Debug;
        module.SetSetting("Debug", Debug);
    end

    --- Function used when the Command is used (or via the Toolbox button).
    function module.DebugCmd ()
        local Debug = not module.UseDebug();
        module.SetDebug(Debug);

        module.StatusUpdate(Debug and "Debug text has been |cFF40FF00enabled." or "Debug text has been |cFFFF0000disabled.");
        XRNOverlay(Debug and "Debug Text |cFF40FF00Enabled" or "Debug Text |cFFFF0000Disabled");
    end

    --- Ticket Command
    --- Function used when the Command is used (or via the Toolbox button).
    function module.TicketCmd ()
        local Race = UnitRace("player")
        local Archetype = nil;

        if GetOSVersion() == "MacOSX" then
            Archetype = "Mac [x64]";
        elseif Is64Bit then
            if Is64Bit() then
                Archetype = "Windows [x64]";
            else
                Archetype = "Windows [x86]";
            end
        else
            Archetype = "Archetype not available";
        end

        local Locale = GetLocale();
        local Level = UnitLevel("player");
        local Class = select(2, UnitClass("player"));
        local ilvl = select(2,GetAverageItemLevel());
        local Spec = select(2, UnitClass("player"));
        local SpecName = select(2, UnitClass("player"));
        if GetSpecialization() then
            Spec = GetSpecialization();
            SpecName = select(2,GetSpecializationInfo(Spec));
        end
        local CurrentProfile = ProfileKey.." - "..ProfileName;
        local weekday, month, day, year = CalendarGetDate();
        local hours,minutes = GetGameTime();
        local ClassIndex = select(3,UnitClass("player"));
        local TalentsURL = "http://us.battle.net/wow/en/tool/talent-calculator#";
        if ClassIndex == 1 then -- Warrior
            TalentsURL = TalentsURL .. "Z"
        elseif ClassIndex == 2 then -- Paladin
            TalentsURL = TalentsURL .. "b"
        elseif ClassIndex == 3 then -- Hunter
            TalentsURL = TalentsURL .. "Y"
        elseif ClassIndex == 4 then -- Rogue
            TalentsURL = TalentsURL .. "c"
        elseif ClassIndex == 5 then -- Priest
            TalentsURL = TalentsURL .. "X"
        elseif ClassIndex == 6 then -- DeathKnight
            TalentsURL = TalentsURL .. "d"
        elseif ClassIndex == 7 then -- Shaman
            TalentsURL = TalentsURL .. "W"
        elseif ClassIndex == 8 then -- Mage
            TalentsURL = TalentsURL .. "e"
        elseif ClassIndex == 9 then -- Warlock
            TalentsURL = TalentsURL .. "V"
        elseif ClassIndex == 10 then -- Monk
            TalentsURL = TalentsURL .. "f"
        elseif ClassIndex == 11 then -- Druid
            TalentsURL = TalentsURL .. "U"
        end

        if Spec == 1 then
            TalentsURL = TalentsURL .. "aa!";
        elseif Spec == 2 then
            TalentsURL = TalentsURL .. "Za!";
        elseif Spec == 3 then
            TalentsURL = TalentsURL .. "ba!";
        elseif Spec == 4 then
            TalentsURL = TalentsURL .. "Ya!";
        end

        -- tier / column / active specialisation
        for tier = 1,7 do
            local talentFound = false
            for col = 1,3 do
                talentFound = select(4,GetTalentInfo(tier,col,GetActiveSpecGroup(false, "player")))
                if talentFound then
                    TalentsURL = TalentsURL .. tostring(col-1);
                    break;
                end
            end
            if not talentFound then
                TalentsURL = TalentsURL .. "."
            end
        end

        -- Talents
        --local Talent1 = select(2,GetTalentRowSelectionInfo(1))
        --local Talent2 = select(2,GetTalentRowSelectionInfo(2))
        --local Talent3 = select(2,GetTalentRowSelectionInfo(3))
        --local Talent4 = select(2,GetTalentRowSelectionInfo(4))
        --local Talent5 = select(2,GetTalentRowSelectionInfo(5))
        --local Talent6 = select(2,GetTalentRowSelectionInfo(6))
        --local Talent7 = select(2,GetTalentRowSelectionInfo(7))
        --local Tier1 = Talent1 and select(2,GetTalentInfoByID(Talent1, Spec)) or "EMPTY";
        --local Tier2 = Talent2 and select(2,GetTalentInfoByID(Talent2, Spec)) or "EMPTY";
        --local Tier3 = Talent3 and select(2,GetTalentInfoByID(Talent3, Spec)) or "EMPTY";
        --local Tier4 = Talent4 and select(2,GetTalentInfoByID(Talent4, Spec)) or "EMPTY";
        --local Tier5 = Talent5 and select(2,GetTalentInfoByID(Talent5, Spec)) or "EMPTY";
        --local Tier6 = Talent6 and select(2,GetTalentInfoByID(Talent6, Spec)) or "EMPTY";
        --local Tier7 = Talent7 and select(2,GetTalentInfoByID(Talent7, Spec)) or "EMPTY";

        local UnitPulseSetting = module.GetOptionValue("TPS: Unit | Rotation");
        local RotationPulseSetting = module.GetSecondOptionValue("TPS: Unit | Rotation");

        local CooldownsOnlyOnBosses = module.IsOptionEnabled("Cooldowns Only On Bosses");
        local CooldownsAllowed = module.UseCooldowns(); -- UseCooldowns instead of CooldownsAllowed because we do not have a target
        local UseAOE = module.UseAOE();

        local String = "";
        local function WriteLine (Line)
            String = String .. Line .. "\n";
        end
        if module.IsOptionEnabled("Beta Version") and BetaEnabled then
            WriteLine("Rotation: BETA");
        else
            WriteLine("Rotation: LIVE");
        end
        WriteLine("Operating System Version: " .. GetOSVersion() .." " .. Archetype);
        WriteLine("Patch: " .. ClientVersion);
        WriteLine("Rotation File Date: " .. RotationFileDate);
        WriteLine("Locale: " .. Locale);
        WriteLine("Level: " .. Level);
        WriteLine("Class: " .. Class);
        WriteLine("Spec: " .. SpecName .. " - " .. Spec);
        WriteLine("Profile: " .. CurrentProfile);
        WriteLine("Race: " .. Race);
        WriteLine("Zone: " .. GetRealZoneText());
        WriteLine("Time: " .. hours .. ":" .. minutes);
        WriteLine("Date: " .. month .. "/" .. day .. "/" .. year);
        WriteLine("Item Level: " .. ilvl);
        --WriteLine("TALENTS: " .. Tier1 .. ", " .. Tier2 .. ", " .. Tier3 .. ", " .. Tier4 .. ", " .. Tier5 .. ", " .. Tier6 .. ", " .. Tier7);
        WriteLine("TALENTS URL: " .. TalentsURL);
        WriteLine("Unit Pulse: " .. UnitPulseSetting .. " TPS");
        WriteLine("Rotation Pulse: " .. RotationPulseSetting .. " TPS");
        WriteLine("Cooldowns Only On Bosses: " .. tostring(CooldownsOnlyOnBosses));
        WriteLine("Cooldowns Allowed: " .. tostring(CooldownsAllowed));
        WriteLine("Use AOE: " .. tostring(UseAOE));
        WriteFile(GetManagerDirectory() .. TicketDirectoryChange, String);
        module.StatusUpdate("Ticket Information Created! Please check your Manager folder.");

        return;
    end

    --- Rotations Command
    --- Function used when the Command is used (or via the Toolbox button).
    function module.RotationsCmd ()
        local String = "";
        local function WriteLine (Line)
            String = String .. Line .. "\n";
        end
        if UserHasRotation("Priest-Holy") or UserHasRotation("Priest-Discipline") or UserHasRotation("Priest-Shadow") then
            WriteLine("*** PRIEST ***");
            if UserHasRotation("Priest-Holy") then WriteLine("- Holy -"); end
            if UserHasRotation("Priest-Discipline") then WriteLine("- Discipline -"); end
            if UserHasRotation("Priest-Shadow") then WriteLine("- Shadow -"); end
            WriteLine("");
        end
        if UserHasRotation("Paladin-Holy") or UserHasRotation("Paladin-Protection") or UserHasRotation("Paladin-Retribution") then
            WriteLine("*** PALADIN ***");
            if UserHasRotation("Paladin-Holy") then WriteLine("- Holy -"); end
            if UserHasRotation("Paladin-Protection") then WriteLine("- Protection -"); end
            if UserHasRotation("Paladin-Retribution") then WriteLine("- Retribution -"); end
            WriteLine("");
        end
        if UserHasRotation("Rogue-Assassination") or UserHasRotation("Rogue-Subtlety") or (UserHasRotation("Rogue-Combat") or UserHasRotation("Rogue-Outlaw")) then
            WriteLine("*** ROGUE ***");
            if UserHasRotation("Rogue-Assassination") then WriteLine("- Assassination -"); end
            if UserHasRotation("Rogue-Subtlety") then WriteLine("- Subtlety -"); end
            if (UserHasRotation("Rogue-Combat") or UserHasRotation("Rogue-Outlaw")) then WriteLine("- Outlaw -"); end
            WriteLine("");
        end
        if UserHasRotation("DemonHunter-Havoc") or UserHasRotation("DemonHunter-Vengeance") then
            WriteLine("*** DEMON HUNTER ***");
            if UserHasRotation("DemonHunter-Havoc") then WriteLine("- Havoc -"); end
            if UserHasRotation("DemonHunter-Vengeance") then WriteLine("- Vengeance -"); end
            WriteLine("");
        end
        if UserHasRotation("Warrior-Arms") or UserHasRotation("Warrior-Fury") or UserHasRotation("Warrior-Protection") then
            WriteLine("*** WARRIOR ***");
            if UserHasRotation("Warrior-Arms") then WriteLine("- Arms -"); end
            if UserHasRotation("Warrior-Fury") then WriteLine("- Fury -"); end
            if UserHasRotation("Warrior-Protection") then WriteLine("- Protection -"); end
            WriteLine("");
        end
        if UserHasRotation("Monk-Windwalker") or UserHasRotation("Monk-Brewmaster") or UserHasRotation("Monk-Mistweaver") then
            WriteLine("*** MONK ***");
            if UserHasRotation("Monk-Windwalker") then WriteLine("- Windwalker -"); end
            if UserHasRotation("Monk-Brewmaster") then WriteLine("- Brewmaster -"); end
            if UserHasRotation("Monk-Mistweaver") then WriteLine("- Mistweaver -"); end
            WriteLine("");
        end
        if UserHasRotation("DeathKnight-Unholy") or UserHasRotation("DeathKnight-Frost") or UserHasRotation("DeathKnight-Blood") then
            WriteLine("*** DEATH KNIGHT ***");
            if UserHasRotation("DeathKnight-Unholy") then WriteLine("- Unholy -"); end
            if UserHasRotation("DeathKnight-Frost") then WriteLine("- Frost -"); end
            if UserHasRotation("DeathKnight-Blood") then WriteLine("- Blood -"); end
            WriteLine("");
        end
        if UserHasRotation("Hunter-BeastMastery") or UserHasRotation("Hunter-Marksmanship") or UserHasRotation("Hunter-Survival") then
            WriteLine("*** HUNTER ***");
            if UserHasRotation("Hunter-BeastMastery") then WriteLine("- Beast Mastery -"); end
            if UserHasRotation("Hunter-Marksmanship") then WriteLine("- Marksmanship -"); end
            if UserHasRotation("Hunter-Survival") then WriteLine("- Survival -"); end
            WriteLine("");
        end
        if UserHasRotation("Druid-Guardian") or UserHasRotation("Druid-Feral") or UserHasRotation("Druid-Balance") or UserHasRotation("Druid-Restoration") then
            WriteLine("*** DRUID ***");
            if UserHasRotation("Druid-Guardian") then WriteLine("- Guardian -"); end
            if UserHasRotation("Druid-Feral") then WriteLine("- Feral -"); end
            if UserHasRotation("Druid-Balance") then WriteLine("- Balance -"); end
            if UserHasRotation("Druid-Restoration") then WriteLine("- Restoration -"); end
            WriteLine("");
        end
        if UserHasRotation("Warlock-Affliction") or UserHasRotation("Warlock-Destruction") or UserHasRotation("Warlock-Demonology") then
            WriteLine("*** WARLOCK ***");
            if UserHasRotation("Warlock-Affliction") then WriteLine("- Affliction -"); end
            if UserHasRotation("Warlock-Destruction") then WriteLine("- Destruction -"); end
            if UserHasRotation("Warlock-Demonology") then WriteLine("- Demonology -"); end
            WriteLine("");
        end
        if UserHasRotation("Shaman-Enhancement") or UserHasRotation("Shaman-Elemental") or UserHasRotation("Shaman-Restoration") then
            WriteLine("*** SHAMAN ***");
            if UserHasRotation("Shaman-Enhancement") then WriteLine("- Enhancement -"); end
            if UserHasRotation("Shaman-Elemental") then WriteLine("- Elemental -"); end
            if UserHasRotation("Shaman-Restoration") then WriteLine("- Restoration -"); end
            WriteLine("");
        end
        if UserHasRotation("Mage-Frost") or UserHasRotation("Mage-Fire") or UserHasRotation("Mage-Arcane") then
            WriteLine("*** MAGE ***");
            if UserHasRotation("Mage-Frost") then WriteLine("- Frost -"); end
            if UserHasRotation("Mage-Fire") then WriteLine("- Fire -"); end
            if UserHasRotation("Mage-Arcane") then WriteLine("- Arcane -"); end
            WriteLine("");
        end
        WriteFile(GetManagerDirectory() .. RotationsDirectoryChange, String);
        module.StatusUpdate("Rotation Information Created! Please check your Manager folder.");
        return;
    end

    --- Spell Queue Command (Start & Cancel)
    --- Function used when the Command is used.
    local SpellToCast = nil;
    LastSpell = nil;
    function module.CastCmd (Spell)
        if GetSpellInfo(Spell) then
            local Start, Duration = GetSpellCooldown(Spell);
            --[[if TriggerTime ~= nil and module.GetTime() - TriggerTime < 1.4 and Spell == LastSpell then
                module.QueueSystem(Spell, "Already Queued, Preventing Double Cast");
                return;
            end]]
            TriggerTime = module.GetTime();
            if SpellToCast and SpellToCast == Spell then
                SpellToCast = nil;
                module.QueueSystem(Spell, "Queue Canceled");
                return;
            end
            if Start == 0 then
                SpellToCast = Spell;
            elseif Start + Duration - module.GetTime() < 1.4 then
                SpellToCast = Spell;
                module.QueueSystem("Queued " .. Spell);
            else
                module.QueueSystem(Spell, "On Cooldown");
            end
        else
            module.QueueSystem("Unknown spell: " .. Spell);
        end
    end

    --- Spell Queue Command (Start & Cancel)
    --- Function used when the Command is used.
    function module.CastMouseCmd (Spell)
        module.MouseCast = module.GetTime() + 5;
        if GetSpellInfo(Spell) then
            local Start, Duration = GetSpellCooldown(Spell);
            TriggerTime = module.GetTime();
            if SpellToCast and SpellToCast == Spell then
                SpellToCast = nil;
                module.QueueSystem(Spell, "Queue Canceled");
                return;
            end
            if Start == 0 then
                SpellToCast = Spell;
            elseif Start + Duration - module.GetTime() < 1.4 then
                SpellToCast = Spell;
                module.QueueSystem("Queued " .. Spell);
            else
                module.QueueSystem(Spell, "On Cooldown");
            end
        else
            module.QueueSystem("Unknown spell: " .. Spell);
        end
    end

    --- Function used when the Command is used (or via the Toolbox button).
    function module.CancelCmd ()
        if SpellToCast then
            SpellToCast = nil;
            module.QueueSystem("Queue Canceled");
        else
            module.QueueSystem("No Queued Spell");
        end
    end
    --
    --- Macros Command_End
    function module.UpdateSettings()
        BetaEnabled = false;
        RunUpdatedSettings = true;
        module.SettingsInit();
        if currentSpecName ~= UnitClass("Player") then
            if not FirstRun2 then
                if not ReadFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. "Default" .. ".json") then
                    WriteFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. "Default" .. ".json", json.encode(Settings));
                    NewProfileMade = true;
                end
                if not ReadFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. ProfileName .. ".json") then
                    if ReadFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. "Default" .. ".json") then
                        module.SelectProfile("Default");
                    end
                end
            end
            if FirstRun2 and (Spec and GetSpecialization() ~= Spec) then
                local NewProfileMade2 = nil;
                if not ReadFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. "Default" .. ".json") then
                    WriteFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. "Default" .. ".json", json.encode(Settings));
                    NewProfileMade2 = true;
                end
                if (ProfileName ~= "Default" or not NewProfileMade2) and ReadFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. ProfileName .. ".json") then
                    module.SelectProfile(ProfileName);
                elseif not NewProfileMade2 and ReadFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. "Default" .. ".json") then
                    ProfileName = "Default";
                    module.SelectProfile("Default");
                end
            end
            if not Printed then
                if not ReadFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. ProfileName .. ".json") then
                    ProfileName = "Default";
                end
                module.ProfileManager("Loaded Profile: " .. "|cFFEEEB16"..ProfileName);
                Printed = true;
            end
            FirstRun2 = true;
            Spec = GetSpecialization();
        end
    end

    function module.UpdateSettings2()
        RunUpdatedSettings = true;
        module.SettingsInit();
        if currentSpecName ~= UnitClass("Player") then
            if not FirstRun2 then
                if not ReadFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. "Default" .. ".json") then
                    WriteFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. "Default" .. ".json", json.encode(Settings));
                    NewProfileMade = true;
                end
            end
            if FirstRun2 and (Spec and GetSpecialization() ~= Spec) then
                local NewProfileMade2 = nil;
                if not ReadFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. "Default" .. ".json") then
                    WriteFile(GetManagerDirectory() .. ProfilesDirectoryChange .. ProfileKey .. " - " .. "Default" .. ".json", json.encode(Settings));
                    NewProfileMade2 = true;
                end
            end
            if not Printed then
                module.ProfileManager("Loaded Profile: " .. "|cFFEEEB16"..ProfileName);
                Printed = true;
            end
            FirstRun2 = true;
            Spec = GetSpecialization();
        end
    end

    local function RotationAccessGranted ()
        local PlayerSpec = GetSpecialization();
        local Granted = false;

        if C.CLASSNAME == "DRUID" then
            -- Balance
            if PlayerSpec == 1 and GetSpecializationInfo(1) == 102 and UserHasRotation("Druid-Balance") then Granted = true; end
            -- Feral
            if PlayerSpec == 2 and GetSpecializationInfo(2) == 103 and UserHasRotation("Druid-Feral") then Granted = true; end
            -- Guardian
            if PlayerSpec == 3 and GetSpecializationInfo(3) == 104 and UserHasRotation("Druid-Guardian") then Granted = true; end
            -- Restoration
            if PlayerSpec == 4 and GetSpecializationInfo(4) == 105 and UserHasRotation("Druid-Restoration") then Granted = true; end
        end
        if C.CLASSNAME == "DEATHKNIGHT" then
            -- Blood
            if PlayerSpec == 1 and GetSpecializationInfo(1) == 250 and UserHasRotation("DeathKnight-Blood") then Granted = true; end
            -- Frost
            if PlayerSpec == 2 and GetSpecializationInfo(2) == 251 and UserHasRotation("DeathKnight-Frost") then Granted = true; end
            -- Unholy
            if PlayerSpec == 3 and GetSpecializationInfo(3) == 252 and UserHasRotation("DeathKnight-Unholy") then Granted = true; end
        end
        if C.CLASSNAME == "DEMONHUNTER" then
            -- Havoc
            if PlayerSpec == 1 and GetSpecializationInfo(1) == 577 and UserHasRotation("DemonHunter-Havoc") then Granted = true; end
            -- Vengeance
            if PlayerSpec == 2 and GetSpecializationInfo(2) == 581 and UserHasRotation("DemonHunter-Vengeance") then Granted = true; end
        end
        if C.CLASSNAME == "SHAMAN" then
            -- Elemental
            if PlayerSpec == 1 and GetSpecializationInfo(1) == 262 and UserHasRotation("Shaman-Elemental") then Granted = true; end
            -- Enhancement
            if PlayerSpec == 2 and GetSpecializationInfo(2) == 263 and UserHasRotation("Shaman-Enhancement") then Granted = true; end
            -- Restoration
            if PlayerSpec == 3 and GetSpecializationInfo(3) == 264 and UserHasRotation("Shaman-Restoration") then Granted = true; end
        end
        if C.CLASSNAME == "HUNTER" then
            -- Beast Mastery
            if PlayerSpec == 1 and GetSpecializationInfo(1) == 253 and UserHasRotation("Hunter-BeastMastery") then Granted = true; end
            -- Marksmanship
            if PlayerSpec == 2 and GetSpecializationInfo(2) == 254 and UserHasRotation("Hunter-Marksmanship") then Granted = true; end
            -- Survival
            if PlayerSpec == 3 and GetSpecializationInfo(3) == 255 and UserHasRotation("Hunter-Survival") then Granted = true; end
        end
        if C.CLASSNAME == "MAGE" then
            -- Arcane
            if PlayerSpec == 1 and GetSpecializationInfo(1) == 62 and UserHasRotation("Mage-Arcane") then Granted = true; end
            -- Fire
            if PlayerSpec == 2 and GetSpecializationInfo(2) == 63 and UserHasRotation("Mage-Fire") then Granted = true; end
            -- Frost
            if PlayerSpec == 3 and GetSpecializationInfo(3) == 64 and UserHasRotation("Mage-Frost") then Granted = true; end
        end
        if C.CLASSNAME == "MONK" then
            -- Brewmaster
            if PlayerSpec == 1 and GetSpecializationInfo(1) == 268 and UserHasRotation("Monk-Brewmaster") then Granted = true; end
            -- Mistweaver
            if PlayerSpec == 2 and GetSpecializationInfo(2) == 270 and UserHasRotation("Monk-Mistweaver") then Granted = true; end
            -- Windwalker
            if PlayerSpec == 3 and GetSpecializationInfo(3) == 269 and UserHasRotation("Monk-Windwalker") then Granted = true; end
        end
        if C.CLASSNAME == "PALADIN" then
            -- Holy
            if PlayerSpec == 1 and GetSpecializationInfo(1) == 65 and UserHasRotation("Paladin-Holy") then Granted = true; end
            -- Protection
            if PlayerSpec == 2 and GetSpecializationInfo(2) == 66 and UserHasRotation("Paladin-Protection") then Granted = true; end
            -- Retribution
            if PlayerSpec == 3 and GetSpecializationInfo(3) == 70 and UserHasRotation("Paladin-Retribution") then Granted = true; end
        end
        if C.CLASSNAME == "PRIEST" then
            -- Discipline
            if PlayerSpec == 1 and GetSpecializationInfo(1) == 256 and UserHasRotation("Priest-Discipline") then Granted = true; end
            -- Holy
            if PlayerSpec == 2 and GetSpecializationInfo(2) == 257 and UserHasRotation("Priest-Holy") then Granted = true; end
            -- Shadow
            if PlayerSpec == 3 and GetSpecializationInfo(3) == 258 and UserHasRotation("Priest-Shadow") then Granted = true; end
        end
        if C.CLASSNAME == "ROGUE" then
            -- Assassination
            if PlayerSpec == 1 and GetSpecializationInfo(1) == 259 and UserHasRotation("Rogue-Assassination") then Granted = true; end
            -- Combat
            if PlayerSpec == 2 and GetSpecializationInfo(2) == 260 and (UserHasRotation("Rogue-Combat") or UserHasRotation("Rogue-Outlaw")) then Granted = true; end
            -- Subtlety
            if PlayerSpec == 3 and GetSpecializationInfo(3) == 261 and UserHasRotation("Rogue-Subtlety") then Granted = true; end
        end
        if C.CLASSNAME == "WARLOCK" then
            -- Affliction
            if PlayerSpec == 1 and GetSpecializationInfo(1) == 265 and UserHasRotation("Warlock-Affliction") then Granted = true; end
            -- Demonology
            if PlayerSpec == 2 and GetSpecializationInfo(2) == 266 and UserHasRotation("Warlock-Demonology") then Granted = true; end
            -- Destruction
            if PlayerSpec == 3 and GetSpecializationInfo(3) == 267 and UserHasRotation("Warlock-Destruction") then Granted = true; end
        end
        if C.CLASSNAME == "WARRIOR" then
            -- Arms
            if PlayerSpec == 1 and GetSpecializationInfo(1) == 71 and UserHasRotation("Warrior-Arms") then Granted = true; end
            -- Fury
            if PlayerSpec == 2 and GetSpecializationInfo(2) == 72 and UserHasRotation("Warrior-Fury") then Granted = true; end
            -- Protection
            if PlayerSpec == 3 and GetSpecializationInfo(3) == 73 and UserHasRotation("Warrior-Protection") then Granted = true; end
        end
        return Granted;
    end

    local function ContentEnabled ()
        local PremiumLocation = false;
        local InstanceType = select(2,IsInInstance());
        local RaidDifficulty = GetRaidDifficultyID();
        local RBG = IsRatedBattleground();
        local ZoneText = GetRealZoneText();
        local DungeonDifficulty = GetDungeonDifficultyID();

        --Rated Battleground Lockout
        if RBG then
            PremiumLocation = true;
        end

        --Arena Lockout
        local Arenas = {"Nagrand Arena", "Blade's Edge Arena", "Ruins of Lordaeron", "Dalaran Sewers", "Tol'viron Arena", "The Tiger's Peak" };
        for h=1, #Arenas do
            if ZoneText == Arenas[h] then
                PremiumLocation = true;
            end
        end

        --Raid and Proving Grounds Lockout
        if InstanceType ~= "party" and RaidDifficulty ~= 17 and RaidDifficulty ~= 7 then
            local PremiumRaids = {"Highmaul", "Blackrock Foundry", "Hellfire Citadel", "Proving Grounds", "The Nighthold", "Emerald Nightmare" };
            for i=1, #PremiumRaids do
                if ZoneText == PremiumRaids[i] then
                    PremiumLocation = true;
                end
            end
        --Challenge Modes(8) and Mythic Dungeons(23)
        elseif InstanceType == "party" then
            local PremiumAreas = { 8, 23 };
            for i=1, #PremiumAreas do
                if DungeonDifficulty == PremiumAreas[i] then
                    PremiumLocation = true;
                end
            end
        end

        if PremiumLocation and not string.find(ClientVersion, "Beta") then
            local Access = RotationAccessGranted();
            return Access;
        else
            return true;
        end
    end

    local IsPremiumCheck = false;
    local CurrentPremiumSpec = nil;
    local LastCheck = nil;
    local function IsPremium ()
        local Time = module.GetTime();
        local Spec = GetSpecialization();

        if not LastCheck or Time-LastCheck > 10 or CurrentPremiumSpec ~= Spec then
            local AccessAllowed = ContentEnabled();
            IsPremiumCheck = false;
            LastCheck = module.GetTime();
            CurrentPremiumSpec = Spec;
            if AccessAllowed then
                IsPremiumCheck = true;
            end
        end

        return IsPremiumCheck;
    end

    local DeniedAccess = nil;
    local function EvaluateDeniedAccess ()
        if DeniedAccess == nil then
            DeniedAccess = false;
            local List = {--[["--USERNAME--"]]};
            for i = 1, #List do
                if UserHasRotation(List[i]) then
                    --DeniedAccess = true;
                end
            end
        end

        return DeniedAccess;
    end

    --- Pulse On Update
    local CurrentInstanceInfo = nil;
    local RunOnceOnLoad = nil;
    module.PulseHandler = {
        Update = 0; -- Last Pulse
        UnitTPS = 5; -- Unit TPS (from Option)
        UnitUpdate = 0; -- Last Unit Fetch Pulse
        RotationTPS = 15; -- Rotation TPS (from Option)
        RotationUpdate = 0; -- Last Rotation Pulse
        Premium = nil; -- Is Premium ?
        Rotation = nil; -- Rotation object
        URLOpened = false; -- Website opened when not premium
        DebugFrameInitialized = false; -- DebugFrame Init Check
    };
    local function PulseOnUpdate ()
        xpcall(
            function ()
                if module.GetTime(true) > module.PulseHandler.Update then
                    -- Set the next pulse, 50ms later (limiter) or less if latency is < 50ms and Core Latency Tolerance is enabled.
                    module.PulseHandler.Update = module.IsOptionEnabled("Latency Tolerance") and module.GetOptionValue("Latency Tolerance") == "Cast & Core" and module.GetTime() + math.min(module.GetLatency(), 50)/1000 or module.GetTime() + 0.050;
                    -- Reset Buffs Table
                    module.AurasInfos = {};
                    module.SpellsInfos = {};

                    if not UserHasRotation("Success") then
                        if module.IsRunning() then
                            module.SetRunning(false);
                            message("[Soapbox Rotations] No active membership detected.");

                            if not module.PulseHandler.URLOpened then
                                module.PulseHandler.URLOpened = true;
                                OpenURL("http://www.soapboxrotations.com/plans-and-pricing/");
                            end
                            return;
                        end
                        return;
                    end

                    module.PulseHandler.Premium = IsPremium();
                    if not module.PulseHandler.Premium then
                        module.StatusUpdate("|cFFFE2E2EPremium Content Detected|r |cFFF7FE2E(Non-LFR Raid, Challenge Mode, Mythic Dungeon, Proving Grounds)|r. Rotation Disabled, no Premium Upgrade detected. Error Code: |cFFFE2E2E" .. select(2,IsInInstance()) .. " - " .. GetRealZoneText() .. " - " .. GetRaidDifficultyID() .. " - " .. GetDungeonDifficultyID());
                        module.SetRunning(false);
                        return;
                    end

                    -- Welcome Message
                    if not RunOnceOnLoad then
                        RunOnceOnLoad = true;
                        if not ChatEdit_GetActiveWindow() or not module.IsOptionEnabled("Pause Rotation While In Chat") then
                            WelcomeMessage();
                        end
                        -- Disable Synchronising Macros
                        if GetCVar("synchronizeMacros") ~= "0" then
                            SetCVar("synchronizeMacros", "0")
                        end
                    end

                    -- Pause While casting
                    if module.PauseRotation then
                        if SpellStartCastingTime and module.GetTime()-SpellStartCastingTime > .5+select(4,GetSpellInfo(StartedSpell))/1000 then
                            module.Bug("Spell Timed Out: |cFF0040FFRotation Resumed. SpellID: " .. StartedSpell); module.PauseRotation = false;
                        end
                        return;
                    end

                    -- Queued Spell
                    if SpellToCast then
                        local Start, Duration = GetSpellCooldown(SpellToCast);
                        if module.Player:IsReady() and Start < 1.5 then
                            module.QueueSystem("Casting " .. SpellToCast);
                            CastSpellByName(SpellToCast);
                            LastSpell = SpellToCast;
                            SpellToCast = nil;
                            if module.MouseCast > module.GetTime() then
                                if SpellIsTargeting() then
                                    CameraOrSelectOrMoveStart();
                                    CameraOrSelectOrMoveStop();
                                    SpellStopTargeting();
                                    module.MouseCast = 0;
                                    return true;
                                end
                            end
                        end
                    end

                    -- Stop Rotation while Chat opened option
                    if module.IsOptionEnabled("Pause Rotation While In Chat") and ChatEdit_GetActiveWindow() then
                        return;
                        --
                    end

                    -- Pulse Control Handler
                    if module.GetSetting("Pulse Control_Checked") then
                        if module.IsInControl == true or module.QueuedControl == true then
                            -- Set false if we are on Gryphon
                            if UnitOnTaxi("player") then
                                module.DisableControl("Flight Path");
                            end
                            -- Set false if we start flying
                            if not module.Player:IsInCombat() and IsFlying() then
                                module.DisableControl("Flying");
                            end
                            -- Set false if we die
                            if module.Player:IsDeadOrGhost() then
                                module.DisableControl("Dying");
                            end
                            -- Set false if we are in a vehicle
                            if not module.Player:IsInCombat() and module.Player:InVehicle() then
                                module.DisableControl("Vehicle");
                            end
                        end
                        if module.QueuedControl == false then
                            if module.IsInControl == "Flight Path" and not UnitOnTaxi("player") then
                                module.QueueControl(2);
                            end
                            if module.IsInControl == "Flying" and not IsFlying() and not IsMounted() and not IsFalling() then
                                module.QueueControl(2);
                            end
                            if module.IsInControl == "Dying" and not module.Player:IsDeadOrGhost() then
                                module.QueueControl(2);
                            end
                            if module.IsInControl == "Vehicle" and not module.Player:InVehicle() then
                                module.QueueControl(2);
                            end
                        end
                        -- When the queue ends, give back control.
                        if module.IsInControl ~= true and module.QueuedControl == true and module.QueuedControlTime < GetTime() then
                            module.RestoreControl();
                        end
                        module.Control = (module.IsInControl == true and "Complete") or (module.IsInControl ~= true and module.QueuedControl == true and "Recovering") or "Disabled";

                        -- Prevent pulsing when we lose control of character, mainly for loading screens and flight
                        if module.IsOptionEnabled("Pulse Control") and module.Control ~= "Complete" then return; end
                    end

                    if module.Running then
                        module.PulseHandler.Rotation = module.GetActiveRotation();
                        if module.PulseHandler.Rotation and module.PulseHandler.Rotation.Pulse then

                            --Anti-AFK
                            if GetAutoAway then
                                if module.IsOptionEnabled("Anti AFK") and GetAutoAway() ~= 1 then
                                    SetAutoAway(1);
                                elseif not module.IsOptionEnabled("Anti AFK") and GetAutoAway() == 1 then
                                    SetAutoAway(0);
                                end
                            end

                            -- Auto Accept Queue
                            if module.IsOptionEnabled("Auto Accept LFG Proposal") and GetLFGProposal() then
                                AcceptProposal();
                                --
                            end

                            -- Init Rotation if not done already
                            if not module.PulseHandler.Rotation.Initialized and module.PulseHandler.Rotation.Initialize then
                                module.ClearOptions();
                                module.ClearOutputs();
                                module.PulseHandler.Rotation:Initialize();
                                module.CreateUI();
                                module.PulseHandler.Rotation.Initialized = true;
                            end

                            -- Return if player is mounted and not in combat to avoid crashes
                            if not UnitAffectingCombat('player') and module.Player:IsMounted() then
                                return;
                                --
                            end

                            -- Fetch handler
                            if module.GetTime() > module.PulseHandler.UnitUpdate then
                                module.PulseHandler.UnitTPS = (module.GetOptionValue("TPS: Unit | Rotation") and 1/module.GetOptionValue("TPS: Unit | Rotation")) or 0.2;
                                module.PulseUnitTimer = module.GetTime() + module.PulseHandler.UnitTPS;
                                module.Fetch();
                                wipe(module.StoredPositions);
                            end

                            -- TimeToDie Handler
                            if module.GetTime() > module.TTD.Throttle then
                                module.TTD.Throttle = module.GetTime() + module.TTD.Settings.Refresh;
                                module.TTDRefresh();
                            end

                            -- Debug Frame Handler
                            if module.DebugFrame:IsVisible() then
                                if not module.PulseHandler.DebugFrameInitialized then
                                    module.DebugFrame.Initialize();
                                    module.PulseHandler.DebugFrameInitialized = true;
                                end
                                module.DebugFrame.Refresh()
                            end

                            -- Pet Battle Handler
                            if UserHasRotation and UserHasRotation("Pet-Battles") and not module.Player:IsInCombat() then
                                PetBattles.Rotation();
                                --
                            end

                            if EvaluateDeniedAccess() then
                                return;
                                --
                            end

                            -- Rotation Pulse
                            if module.GetTime() > module.PulseHandler.RotationUpdate and module.PulseHandler.Premium then
                                module.PulseHandler.RotationTPS = (module.GetSecondOptionValue("TPS: Unit | Rotation") and 1/module.GetSecondOptionValue("TPS: Unit | Rotation")) or 0.66;
                                module.PulseHandler.RotationUpdate = module.GetTime() + module.PulseHandler.RotationTPS;
                                module.HandleConsumables();
                                if module.IsOptionEnabled("Beta Version") and BetaEnabled then
                                    if not OutputSetLive or select(8, GetInstanceInfo()) ~= CurrentInstanceInfo then
                                        module.SetOutput("Rotation:", "BETA");
                                        OutputSetLive = true;
                                        OutputSetBeta = false;
                                        CurrentInstanceInfo = select(8, GetInstanceInfo());
                                    end
                                    module.PulseHandler.Rotation:PulseBeta();
                                else
                                    if not OutputSetBeta or select(8, GetInstanceInfo()) ~= CurrentInstanceInfo then
                                        module.SetOutput("Rotation:", "LIVE");
                                        OutputSetLive = false;
                                        OutputSetBeta = true;
                                        CurrentInstanceInfo = select(8, GetInstanceInfo());
                                    end
                                    module.PulseHandler.Rotation:Pulse();
                                end
                            end
                        end
                    end
                end
            end
            , module.LUAErrorHandler
        );
    end
    CreateFrame("Frame"):SetScript("OnUpdate", PulseOnUpdate); -- Not possible to use anonymous function with xpcall().

    --- OnTalentSpecUpdate
    module:RegisterForEvent(
        function ()
            if not module.UISpec or module.UISpec ~= GetSpecialization() then
                local Rotation = module.GetActiveRotation();
                if Rotation and Rotation.Initialize then
                    module.ClearOptions();
                    module.ClearOutputs();
                    module.InitCommand();
                    Rotation:Initialize();
                    module.CreateUI();
                    module.InitArguments();
                    module.InitCommand();
                    module.Running = module.GetSetting("Running");
                    module.Cooldowns = module.GetSetting("cds");
                    module.AOE = module.GetSetting("AOE");
                    module.Debug = module.GetSetting("Debug");
                    Rotation.Initialized = true;
                end
            end
        end
        , "ACTIVE_TALENT_GROUP_CHANGED", "PLAYER_TALENT_UPDATE"
    );
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Defines the Vector3 Class Methods.
    --- Get the Vector3 as a string.
    -- @return The Vector3 as a string.
    function Vector3:ToString ()
        return self.X .. ", " .. self.Y .. ", " .. self.Z;
    end

    --- Unary minus operator
    -- @return The negated Vector3.
    function Vector3:UnaryMinus ()
        return Vector3(-self.X, -self.Y, -self.Z);
    end

    --- Addition operator
    -- @param Other The other Vector3.
    -- @return The resulting Vector3.
    function Vector3:Add (Other)
        return Vector3(self.X + Other.X, self.Y + Other.Y, self.Z + Other.Z);
    end

    --- Subtraction operator
    -- @param Other The other Vector3.
    -- @return The resulting Vector3.
    function Vector3:Subtract (Other)
        return Vector3(self.X - Other.X, self.Y - Other.Y, self.Z - Other.Z);
    end

    --- Multiplication operator
    -- @param Factor The other factor.
    -- @return The resulting Vector3.
    function Vector3:Multiply (Factor)
        return Vector3(self.X * Factor, self.Y * Factor, self.Z * Factor);
    end

    --- Division operator
    -- @param Divisor The divisor.
    -- @return The resulting Vector3.
    function Vector3:Divide (Divisor)
        return Vector3(self.X / Divisor, self.Y / Divisor, self.Z / Divisor);
    end

    --- Power operator
    -- @param Exponent The exponent.
    -- @return The resulting Vector3.
    function Vector3:Power (Exponent)
        return Vector3(self.X ^ Exponent, self.Y ^ Exponent, self.Z ^ Exponent);
    end

    --- Equality operator
    -- @param Other The other Vector3.
    -- @return Whether The Vector3s are equal.
    function Vector3:Equals (Other)
        return self.X == Other.X and self.Y == Other.Y and self.Z == Other.Z;
    end

    --- Get the distance to another Vector3.
    -- @param Other The other Vector3.
    -- @return The distance between the Vector3s.
    function Vector3:DistanceTo (Other)
        return Other.X and Other.Y and Other.Z and self.X and self.Y and self.Z and math.sqrt(((Other.X - self.X) ^ 2) + ((Other.Y - self.Y) ^ 2) + ((Other.Z - self.Z) ^ 2)) or 100;
    end

    --- Get the horizontal angle to another Vector3.
    -- @param Other The other Vector3.
    -- @return The horizontal angle from the first Vector3 to the second Vector3.
    function Vector3:AngleTo (Other)
        return math.atan2(Other.Y - self.Y, Other.X - self.X) % (math.pi * 2);
    end

    --- Get the vertical angle to another Vector3.
    -- @param Other The other Vector3.
    -- @return The vertical angle from the first Vector3 to the second Vector3.
    function Vector3:PitchTo (Other)
        return math.atan((Other.Z - self.Z) / math.sqrt(((Other.X - self.X) ^ 2) + ((Other.Y - self.Y) ^ 2))) % math.pi;
    end

    --- Project the Vector3 horizontally a distance in a direction.
    -- @param Direction The direction in radians.
    -- @param Distance The distance.
    -- @return The resulting Vector3.
    function Vector3:Project (Direction, Distance)
        return Vector3(self.X + math.cos(Direction) * Distance, self.Y + math.sin(Direction) * Distance, self.Z);
    end

    --- Get the length of the Vector3.
    -- @return The length of the Vector3.
    function Vector3:Length ()
        return math.sqrt(self.X ^ 2 + self.Y ^ 2 + self.Z ^ 2);
    end

    --- Get the normalized Vector3.
    -- @return The normalized Vector3.
    function Vector3:Normalize ()
        return self / self:Length();
    end

    --- Get the dot product of the Vector3 and another.
    -- @param Other The other Vector3.
    -- @return The dot product of the two Vector3s.
    function Vector3:DotProduct (Other)
        return self.X * Other.X + self.Y * Other.Y + self.Z * Other.Z;
    end

    --- Get the cross product of the Vector3 and another.
    -- @param Other The other Vector3.
    -- @return The cross product of the two Vector3s.
    function Vector3:CrossProduct (Other)
        return Vector3(self.Y * Other.Z - self.Z * Other.Y, self.Z * Other.X - self.X * Other.Z, self.X * Other.Y - self.Y * Other.X);
    end

    --- Get the scalar triple product of the Vector3 and two others.
    -- @param Second The second Vector3.
    -- @param Third The third Vector3.
    -- @return The scalar triple product of the three Vector3s.
    function Vector3:ScalarTripleProduct (Second, Third)
        return self:DotProduct(Second:CrossProduct(Third));
    end

    --- Get a vector that is made of the largest components of the Vector3 and another.
    -- @param Other The other Vector3.
    -- @return A Vector3 made from the largest components of the Vector3s.
    function Vector3:Max (Other)
        return Vector3(math.max(self.X, Other.X), math.max(self.Y, Other.Y), math.max(self.Z, Other.Z));
    end

    --- Get a vector that is made of the smallest components of the Vector3 and another.
    -- @param Other The other Vector3.
    -- @return A Vector3 made from the smallest components of the Vector3s.
    function Vector3:Min (Other)
        return Vector3(math.min(self.X, Other.X), math.min(self.Y, Other.Y), math.min(self.Z, Other.Z));
    end

    --- Get a Vector3 between the Vector3 and another.
    -- @param Other The other Vector3.
    -- @param Distance The distance from the Vector3.
    -- @return The Vector3 that is directly between the two Vector3s and Distance from the first Vector3.
    function Vector3:Between (Other, Distance)
        local Angle = self:AngleTo(Other);
        return self:Project(Angle, Distance);
    end

    --- Expand the Vector3 to three values instead of a table.
    -- @return The X, Y, and Z coordinates.
    function Vector3:Expand ()
        return self.X, self.Y, self.Z;
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Defines the Unit class.
    --- Get the number of units in the object manager.
    -- @return The number of units in the object manager.
    function Unit.Count ()
        return GetUnitCount();
    end

    --- Get units from the Object Manager and filter them.
    -- @return Nothing but fill 4 global tables : module.Units, module.UnitsInfos, module.EnemyUnits, module.FriendlyUnits
    -- module.Units contains every unit in the Object Manager.
    -- module.UnitsInfos contains every static infos about Units from module.Units (use the GUID as key) : CreatureID, IsInCombat, ...
    -- module.EnemyUnits contains every unit that the Player can attack.
    -- module.FriendlyUnits contains every unit that the Player cannot attack (so mostly friendly ones).
    -- module.HealingUnits contains only the units we want to heal - Players in our Group - Specific NPCs
    module.Units, module.UnitsInfos, module.EnemyUnits, module.FriendlyUnits, module.HealingUnits, module.GroupUnits = {}, {}, {}, {}, {}, {};
    function module.Fetch ()
        -- Wipe the Tables
        wipe(module.Units); wipe(module.UnitsInfos); wipe(module.EnemyUnits); wipe(module.FriendlyUnits); wipe(module.HealingUnits);
        -- Init Loop Variables
        local ThisUnit, Attack, CreatureType;
        local UnitsCount, EnemyCount, FriendlyCount, HealingCount = 1, 1, 1, 1;
        local Player = Unit.Player;
        -- Fetch Units based on what the manager returns.
        local X, Y, Z = GetUnitPosition("Player");
        local SortPlayers = GetPVPDesired() == false and not IsInInstance() or false;
        for Index = 1, GetUnitNearPositionCount(X, Y, Z, 70) do
            ThisUnit = Unit(GetUnitNearPositionByIndex(Index));
            CreatureType = ThisUnit:CreatureType(); -- CreatureType need to be adapted due to Locale (Only working on English Client)
            if ThisUnit:Exists() and CreatureType ~= "Critter" and CreatureType ~= "Wild Pet" and CreatureType ~= "Totem" and not ThisUnit:IsPet() then
                Attack = Player:CanAttack(ThisUnit, true);
                module.Units[UnitsCount] = ThisUnit;
                UnitsCount = UnitsCount + 1;
                module.UnitsInfos[ThisUnit:GUID()] = {CreatureID = ThisUnit:CreatureID(true), CanAttack = Attack, IsInCombat = ThisUnit:IsInCombat(true)};
                if Attack and (not SortPlayers or not ThisUnit:IsPlayer()) then
                    --print(CreatureType .. " " .. ThisUnit:Name())
                    module.EnemyUnits[EnemyCount] = ThisUnit;
                    EnemyCount = EnemyCount + 1;
                else
                    -- We will use a smaller table with only valid Heal units for healing methods
                    if module.GroupUnits[ThisUnit:GUID()] ~= nil or module.KnownNPCs[ThisUnit:CreatureID()] then
                        module.HealingUnits[HealingCount] = ThisUnit;
                        HealingCount = HealingCount + 1;
                    end
                    --print(CreatureType .. " " .. ThisUnit:Name())
                    module.FriendlyUnits[FriendlyCount] = ThisUnit;
                    FriendlyCount = FriendlyCount + 1;
                end
            end
        end
    end
    -- Known NPCs that we want to add to the valid Heal Units
    module.KnownNPCs = {
        [72293] = "Speedy" -- Proving Ground - Hunter Pet - Test
    };

    --- Get the first unit for which a function is true.
    -- @param Function The function. It must take one argument (the unit) and return one value (whether the function is true for the unit).
    -- @return The first unit for which the function was true, or nil if it was not true for any.
    function Unit.FirstWhere (Function, Type)
        local Units = nil;
        if Type == "Enemy" then Units = module.EnemyUnits;
        elseif Type == "Friendly" then Units = module.FriendlyUnits;
        else Units = module.Units; end
        for Index = 1, #Units do
            local ThisUnit = Units[Index];
            if ThisUnit:Exists() and Function(ThisUnit) then
                return ThisUnit;
            end
        end
        return nil;
    end

    --- Get units in the player's group for which a function is true.
    -- @param Function The function. It must take one argument (the unit) and return one value (whether the function is true for the unit).
    -- @param IncludePlayer Whether to consider the player part of the player's group.
    -- @return The units in the player's group for which the function was true.
    function Unit.GroupWhere (Function, IncludePlayer)
        if IsInGroup() then
            local Units = {};
            if IsInRaid() then
                for Index = 1, GetNumGroupMembers() do
                    local ThisUnit = Unit("Raid" .. Index);
                    if ThisUnit:Exists() and (IncludePlayer or ThisUnit ~= Unit.Player) and Function(ThisUnit) then
                        table.insert(Units, ThisUnit);
                    end
                end
            else
                for Index = 1, GetNumGroupMembers() - 1 do
                    local ThisUnit = Unit("Party" .. Index);
                    if ThisUnit:Exists() and Function(ThisUnit) then
                        table.insert(Units, ThisUnit);
                    end
                end

                if IncludePlayer and Function(Unit.Player) then
                    table.insert(Units, Unit.Player);
                end
            end

            return Units;
        else
            return (IncludePlayer and Function(Unit.Player)) and { Unit.Player } or { };
        end
    end

    --- Get the first unit in the player's group for which a function is true.
    -- @param Function The function. It must take one argument (the unit) and return one value (whether the function is true for the unit).
    -- @param IncludePlayer Whether to consider the player part of the player's group.
    -- @return The first unit in the player's group for which the function was true, or nil if it was not true for any.
    function Unit.FirstGroupWhere (Function, IncludePlayer)
        if IsInGroup() then
            local Units = {};
            if IsInRaid() then
                for Index = 1, GetNumGroupMembers() do
                    local ThisUnit = Unit("Raid" .. Index);
                    if ThisUnit:Exists() and (IncludePlayer or ThisUnit ~= Unit.Player) and Function(ThisUnit) then
                        return ThisUnit;
                    end
                end
            else
                for Index = 1, GetNumGroupMembers() - 1 do
                    local ThisUnit = Unit("Party" .. Index);
                    if ThisUnit:Exists() and Function(ThisUnit) then
                        return ThisUnit;
                    end
                end

                if IncludePlayer and Function(Unit.Player) then
                    return Unit.Player;
                end
            end

            return nil;
        else
            return (IncludePlayer and Function(Unit.Player)) and Unit.Player or nil;
        end
    end

    --- Get the player enemies within a distance of the unit.
    -- @param Distance The maximum distance from the unit.
    -- @param PlayerCenteredAoE If the distance is for an AoE Spell casted by the Player, set it to true.
    -- @param BypassCCAndCombat Set to true to bypass Crowd Controlled Units
    -- @return The player enemies within the distance of the unit.
    function Unit:EnemiesWithinDistance (Distance, PlayerCenteredAoE, BypassCCAndCombat)
        local EnemyUnitsWithinDistance = {}; -- Initialize the Tables that we will return.
        local Units = module.EnemyUnits; -- Localize the Global Enemy Unit Table to save time.

        for Index = 1, #Units do
            local ThisUnit = Units[Index];
            if ThisUnit:Exists() and not ThisUnit:IsDeadOrGhost() and self:DistanceTo(ThisUnit, false, PlayerCenteredAoE) <= Distance and not ThisUnit:IsHardBlacklisted() and not ThisUnit:Blacklist() and not ThisUnit:IsMissable() and (BypassCCAndCombat or ThisUnit:IsInCombat()) and Unit.Player:CanAttack(ThisUnit) and (BypassCCAndCombat or not ThisUnit:IsCrowdControlled()) then
                table.insert(EnemyUnitsWithinDistance, ThisUnit);
            end
        end
        return EnemyUnitsWithinDistance;
    end

    --- Filter an already existant Enemy Table by distance.
    -- @param Distance The maximum distance from the unit.
    -- @param PlayerCenteredAoE If the distance is for an AoE Spell casted by the Player, set it to true.
    -- @return The enemies within the distance of the unit.
    function Unit:FilterEnemiesByDistance (Table, Distance, PlayerCenteredAoE)
        local EnemyUnitsWithinDistance = {};
        local Units = Table;

        for Index = 1, #Units do
            local ThisUnit = Units[Index];
            if self:DistanceTo(ThisUnit, false, PlayerCenteredAoE) <= Distance then
                table.insert(EnemyUnitsWithinDistance, ThisUnit);
            end
        end
        return EnemyUnitsWithinDistance;
    end

    --- Filter an already existant Enemy Table by debuff.
    -- @param Debuff Spell object of the debuff we want to track.
    -- @return The enemies with the specified debuff.
    function Unit:FilterEnemiesByDebuff (Table, Debuff)
        local EnemyUnitsWithDebuff = {}
        local Units = Table;

        for Index = 1, #Units do
            local ThisUnit = Units[Index];
            if ThisUnit:Debuff(Debuff) then
                table.insert(EnemyUnitsWithDebuff, ThisUnit);
            end
        end
        return EnemyUnitsWithDebuff;
    end

    function Unit:GroupUnitsWithBuff2 (Spell)
        return Unit.GroupWhere(
            function (ThisUnit)
                return ThisUnit:Exists() and ThisUnit:Buff(Spell);
            end
        , true);
    end

    function Unit:GroupUnitsAvailableForHealing (Health, IncludePlayer, Distance, IncludeSelf, NoMovement)
        if not Distance then Distance = 99; end
        return Unit.GroupWhere(
            function (ThisUnit)
                return (not NoMovement or not ThisUnit:IsMoving()) and (IncludeSelf == true or not ThisUnit:Equals(self)) and ThisUnit:Exists() and not ThisUnit:IsDeadOrGhost() and ThisUnit:HealthPercentage() <= Health and (not Distance or (Distance and self:DistanceTo(ThisUnit) <= Distance));
            end
        , IncludePlayer);
    end

    --- Get the first unit in the player's group within range of a spell that doesn't have a buff caused by it.
    -- @param Spell The spell ID of the spell causing the buff.
    -- @param IncludePlayer Whether to consider the player part of the player's group.
    -- @return The first unit in the player's group within the distance that doesn't have the buff, or nil if it was not true for any.
    function Unit.FirstGroupUnitAvailableForBuff (Spell, IncludePlayer)
        return Unit.FirstGroupWhere(
            function (ThisUnit)
                return ThisUnit:Exists() and not ThisUnit:Buff(Spell) and not ThisUnit:IsDeadOrGhost() and Unit.Player:IsWithinCastRange(ThisUnit, Spell)
                and Unit.Player:InLineOfSight(ThisUnit)
                ;
            end
        , IncludePlayer);
    end

    function Unit.FirstGroupUnitAvailableForBuffWithDistance (Spell, Distance, IncludePlayer)
        if not Distance then Distance = 40; end
        return Unit.FirstGroupWhere(
            function (ThisUnit)
                return ThisUnit:Exists() and not ThisUnit:IsDeadOrGhost() and not ThisUnit:Buff(Spell) and module.Player:DistanceTo(ThisUnit) <= Distance and Unit.Player:IsWithinCastRange(ThisUnit, Spell)
                and Unit.Player:InLineOfSight(ThisUnit)
                ;
            end
        , IncludePlayer);
    end

    -- Table for Custom Dispels.
    --@ debuff(SpellID): Debuff that we dont want to dispel
    --@ buffNeeded(SpellID): Buff on player that will cancel the ignore
    local CustomDispels = {
      { debuff = 184449 }, -- Dia Darkwhisper - Mark of the Necromancer - (purple icon - the initial debuff applied by Dia before she hits 30% health)
      { debuff = 184676 }, -- Dia Darkwhisper - Mark of the Necromancer - (purple icon - the initial debuff applied by Dia after she reaches 30% health)
      { debuff = 184450 }, -- Dia Darkwhisper - Mark of the Necromancer - (purple icon - the weak form of the debuff that is applied when it jumps after being dispelled)
      { debuff = 185065 }, -- Dia Darkwhisper - Mark of the Necromancer - (yellow icon - the medium strength debuff)
      { debuff = 179219 }, -- Shadow Lord Iskar - Phantasmal Fel Bomb
      { debuff = 181753, buffNeeded = 179202 }, -- Shadow Lord Iskar - Fel Bomb only if Eye of Anzu
      { debuff = 180166 }, -- Tyrant Velhari - Touch of Harm
      { debuff = 156954 }, -- Teron'gor - Unstable Affliction
      { debuff = 162185 }, -- Ko'ragh - Expel Magic: Fire
      { debuff = 144351 }, -- Sha of Pride - Mark of Arrogance
      { debuff = 142913 } -- Malkorok - Displaced Energy
      --{ debuff = 145206, buffNeeded = 642 } -- PG test - Debuff if not Divine Shield
    }
    -- Returns True if the unit should be dispelled
    -- @Types - An array of Types we want to cure ie: { "Poison", "Disease" } - Let it blanck for normal healers, use it for other specs as they cant use on magic.
    function Unit:CanDispel (Types)
        for i = 1, 40 do
            local debuffName, _, _, _, dispelType, duration, expires, _, _, _, spellID, _, isBossDebuff, _, _, _ = UnitDebuff(self.UnitID, i)
            if dispelType and ((Types == nil and ((select(2,UnitClass("player")) == "PRIEST" and (dispelType == 'Magic' or dispelType == 'Disease'))
                or ((select(2,UnitClass("player")) == "MONK" or select(2,UnitClass("player")) == "PALADIN") and (dispelType == 'Poison' or dispelType == 'Magic' or dispelType == 'Disease'))
                or (select(2,UnitClass("player")) == "SHAMAN" and (dispelType == 'Magic' or dispelType == 'Curse'))
                or (select(2,UnitClass("player")) == "DRUID" and (dispelType == 'Poison' or dispelType == 'Magic' or dispelType == 'Curse'))))
                or (Types ~= nil and (Types[1] == dispelType or Types[2] == dispelType))) then
                local ignore = false
                -- check custom dispels
                for j = 1, #CustomDispels do
                    local ThisDispel = CustomDispels[j];
                    if spellID == ThisDispel.debuff and (not ThisDispel.buffNeeded or not UnitBuff("player", GetSpellInfo(ThisDispel.buffNeeded))) then
                        ignore = true
                        break
                    end
                end
                if not ignore then
                    return true;
                end
            end
            if not debuffName then
                break
            end
        end
        return false
    end

    function Unit.Dispel (Spell, Types)
        return Unit.FirstGroupWhere(
            function (ThisUnit)
                return ThisUnit:Exists() and ThisUnit:CanDispel(Types) and not ThisUnit:IsDeadOrGhost() and (ThisUnit:Equals(Unit.Player) or Unit.Player:IsWithinCastRange(ThisUnit, Spell)) and Unit.Player:InLineOfSight(ThisUnit);
            end
        , true);
    end

    function Unit.Resurrect (Spell)
        return Unit.FirstGroupWhere(
            function (ThisUnit)
                return ThisUnit:IsDeadOrGhost() and Unit.Player:IsWithinCastRange(ThisUnit, Spell) and Unit.Player:InLineOfSight(ThisUnit) and ThisUnit:ResurrectCheck();
            end
        , false);
    end

    function Unit:ResurrectCheck (Wipe)
        ResTable = ResTable or {};
        if Wipe then ResTable = {}; return; end
        if TableContains(ResTable, "units", self) then
            return false;
        else
            table.insert(ResTable, {units = self});
            return true;
        end
    end

    function Unit:Disease (mod)
        local Spell = module.Spell;
        if mod == nil then mod = "min" end
        local mod = tostring(mod)
        local FrostFever = Spell(55095, false, false, true);
        if self:Debuff(FrostFever) then
            ff = self:DebuffRemains(FrostFever)
        else
            ff = 0
        end
        local BloodPlague = Spell(55078, false, false, true);
        if self:Debuff(BloodPlague) then
            bp = self:DebuffRemains(BloodPlague)
        else
            bp = 0
        end
        local NecroticPlague = Spell(155159, false, false, true);
        if self:Debuff(NecroticPlague) then
            np = self:DebuffRemains(NecroticPlague)
        else
            np = 0
        end
        if mod == "min" then
            if self:Debuff(NecroticPlague) then
                return np
            elseif ff <= bp then
                return ff
            else
                return bp
            end
        elseif mod == "max" then
            if self:Debuff(NecroticPlague) then
                return np
            elseif ff <= bp then
                return bp
            else
                return ff
            end
        end
    end


    GroupsByGUID = {};
    local Frame = CreateFrame("Frame");
    Frame:SetScript("OnEvent",
        function (self, Event, ...)
            if Event == "GROUP_ROSTER_UPDATE" then
                GroupsByGUID = {};
                if IsInRaid() then
                    for Index = 1, GetNumGroupMembers() do
                        local Subgroup = select(3, GetRaidRosterInfo(Index));
                        GroupsByGUID[UnitGUID("Raid" .. Index)] = Subgroup;
                    end
                else
                    for Index = 1, GetNumGroupMembers() - 1 do
                        GroupsByGUID[UnitGUID("Party" .. Index)] = 1;
                    end
                end
            end
        end
    );
    Frame:RegisterEvent("GROUP_ROSTER_UPDATE");

    function BlacklistGroundCastAdd ()
        if UnitExists("target") then
            local TargetCreatureID = Target:CreatureID();
            for i=1, #BlacklistGroundCastTargets do
                if TableContains(BlacklistGroundCastTargets, "guid", TargetCreatureID) then
                    module.Print("|cffa901db"..Target:Name().."|r |cfffaa500Already|r on Blacklist.");
                else
                    table.insert(BlacklistGroundCastTargets, {guid = TargetCreatureID, name = Target:Name()});
                    module.Print("|cffa901db"..Target:Name().."|r |cff00ff00Added|r to Blacklist.");
                end
                module.SetSetting("BlacklistGroundCastTargets", BlacklistGroundCastTargets);
                return;
            end
        end
        module.Print("|cffff0000Nothing to Add.|r");
    end

    function BlacklistGroundCastRemove ()
        if UnitExists("target") then
            local TargetCreatureID = Target:CreatureID();
            for i=1, #BlacklistGroundCastTargets do
                if BlacklistGroundCastTargets[i].guid == TargetCreatureID then
                    tremove(BlacklistGroundCastTargets, i);
                    module.Print("|cffa901db"..Target:Name().."|r |cffff0000Removed|r from Blacklist.");
                    module.SetSetting("BlacklistGroundCastTargets", BlacklistGroundCastTargets);
                    return;
                end
            end
        end
        module.Print("|cffff0000Nothing to Remove.|r");
    end

    function BlacklistAdd (NpcId)
        if NpcId then
            NpcId = tonumber(NpcId);
            if TableContains(BlacklistTargets, "id", NpcId) then
                module.Print("NpcId: " .. NpcId .. ", |cfffaa500Already|r on Blacklist.");
            else
                table.insert(BlacklistTargets, {id = NpcId, name = "Added by user"});
                module.Print("NpcId: " .. NpcId .. ", |cff00ff00Added|r to Blacklist.");
            end
            module.SetSetting("BlacklistTargets", BlacklistTargets);
            return;
        end
        if Target:Exists() then
            if Target:IsPlayer() then
                local TargetGUID = Target:GUID();
                if TableContains(BlacklistTargets, "id", TargetGUID) then
                    module.Print("|cffa901db"..Target:Name().."|r |cfffaa500Already|r on Blacklist.");
                else
                    table.insert(BlacklistTargets, {id = TargetGUID, name = Target:Name()});
                    module.Print("|cffa901db"..Target:Name().."|r |cff00ff00Added|r to Blacklist.");
                end
                module.SetSetting("BlacklistTargets", BlacklistTargets);
                return;
            elseif not Target:IsPlayer() then
                local TargetCreatureID = Target:CreatureID();
                if TableContains(BlacklistTargets, "id", TargetCreatureID) then
                    module.Print("|cffa901db"..Target:Name().."|r |cfffaa500Already|r on Blacklist.");
                else
                    table.insert(BlacklistTargets, {id = TargetCreatureID, name = Target:Name()});
                    module.Print("|cffa901db"..Target:Name().."|r |cff00ff00Added|r to Blacklist.");
                end
                module.SetSetting("BlacklistTargets", BlacklistTargets);
                return;
            end
        else
            module.Print("|cffff0000Nothing to Add.|r");
        end
    end

    function BlacklistRemove (NpcId)
        if NpcId then
            NpcId = tonumber(NpcId);
            for i=1, #BlacklistTargets do
                if BlacklistTargets[i].id == NpcId then
                    tremove(BlacklistTargets, i);
                    module.Print("NpcId: " .. NpcId .. ", |cffff0000Removed|r from Blacklist.");
                    module.SetSetting("BlacklistTargets", BlacklistTargets);
                    return;
                end
            end
            module.Print("NpcId: " .. NpcId .. ", |cffff0000is not|r in the Blacklist.");
        end
        if Target:Exists() then
            if Target:IsPlayer() then
                local TargetGUID = Target:GUID();
                for i=1, #BlacklistTargets do
                    if BlacklistTargets[i].id == TargetGUID then
                        tremove(BlacklistTargets, i);
                        module.Print("|cffa901db"..Target:Name().."|r |cffff0000Removed|r from Blacklist.");
                        module.SetSetting("BlacklistTargets", BlacklistTargets);
                        return;
                    end
                end
            elseif not Target:IsPlayer() then
                local TargetCreatureID = Target:CreatureID();
                for i=1, #BlacklistTargets do
                    if BlacklistTargets[i].id == TargetCreatureID then
                        tremove(BlacklistTargets, i);
                        module.Print("|cffa901db"..Target:Name().."|r |cffff0000Removed|r from Blacklist.");
                        module.SetSetting("BlacklistTargets", BlacklistTargets);
                        return;
                    end
                end
            end
            module.Print("|cffa901db"..Target:Name().."|r |cffff0000is not|r in the Blacklist.");
        else
            module.Print("|cffff0000Nothing to Remove.|r");
        end
    end

    function BlacklistReset ()
        if not BlacklistTargets[1] then
            module.Print("Blacklist is |cfffaa500already empty|r.");
        else
            BlacklistTargets = {};
            module.SetSetting("BlacklistTargets", BlacklistTargets);
            module.Print("Blacklist is now |cffff0000empty|r.");
        end
    end

    function BlacklistShow ()
        if not BlacklistTargets[1] then
            module.Print("|cffff0000No Blacklisted units.|r");
        else
            for Key, Value in pairs(BlacklistTargets) do
                module.Print(Value["name"]);
            end
        end
    end

    function TableContains (Table, ValueOrKey, ValueIfKey)
        local ValueOrKey, ValueIfKey = ValueOrKey, ValueIfKey;
        local Table = Table or {};
        if ValueIfKey then
            for Key, Value in pairs(Table) do
                if Value[ValueOrKey] == ValueIfKey then
                    return true;
                end
            end
        else
            for Key, Value in pairs(Table) do
                if Value == ValueOrKey then
                    return true;
                end
            end
        end

        return false;
    end

    BlacklistTargets = module.GetSetting("BlacklistTargets"); --or {};  <- Resets every logins... CustomSettings 387 will be more appropriate for the creation.

    BlacklistGroundCastTargets = {
        86227,
        75452,
        76143,
        77692,
        76585,
        76379,
        76267
    };

    function Unit:Blacklist ()
        if self:IsPlayer() then
            local GUID = self:GUID();
            return TableContains(BlacklistTargets, "id", GUID);
        elseif not self:IsPlayer() then
            local ThisCreature = self:CreatureID();
            return TableContains(BlacklistTargets, "id", ThisCreature);
        else
            return false;
        end
    end

    InterruptTargets = module.GetSetting("InterruptTargets") -- or {}; <- will be handled in CustomSettings.lua at line 571 for persistence
    function CustomInterruptListAdd (spellId)
        if spellId ~= "" then
            local spellId = tonumber(spellId);
            local spellName = select(1, GetSpellInfo(spellId));
            if spellName then
                if TableContains(InterruptTargets, "id", spellId) then
                    module.Print("|cffa901db"..spellName.."|r (|cFF0099FF"..spellId.."|r) |cfffaa500Already|r in Custom Interrupt List.");
                else
                    table.insert(InterruptTargets, {id = spellId, name = select(1, GetSpellInfo(spellId))});
                    for i = 1, #InterruptTargets do
                        for j = 2, #InterruptTargets do
                            if InterruptTargets[j].id < InterruptTargets[j-1].id then
                                local TempSpell = InterruptTargets[j]
                                InterruptTargets[j] = InterruptTargets[j-1]
                                InterruptTargets[j-1] = TempSpell
                            end
                        end
                    end
                    module.Print("|cffa901db"..spellName.."|r (|cFF0099FF"..spellId.."|r) |cff00ff00Added|r to Custom Interrupt List.");
                end
                module.SetSetting("InterruptTargets", InterruptTargets);
            else
                module.Print("|cFF0099FF"..spellId.."|r Is not a valid Spell ID.");
            end
            return;
        else
            module.Print("|cffff0000You did not have entered a Spell ID.|r");
        end
    end

    function CustomInterruptListRemove (spellId)
        if spellId ~= "" then
            local spellId = tonumber(spellId);
            local spellName = select(1, GetSpellInfo(spellId));
            for i=1, #InterruptTargets do
                if InterruptTargets[i].id == spellId then
                    tremove(InterruptTargets, i);
                    module.Print("|cffa901db"..spellName.."|r (|cFF0099FF"..spellId.."|r) |cffff0000Removed|r from Custom Interrupt List.");
                    module.SetSetting("InterruptTargets", InterruptTargets);
                    return;
                end
            end
            module.Print("|cffa901db"..spellName.."|r (|cFF0099FF"..spellId.."|r) |cffff0000is not|r in the Custom Interrupt List.");
        else
            module.Print("|cffff0000You did not have entered a Spell ID.|r");
        end
    end

    function CustomInterruptListReset ()
        if not InterruptTargets[1] then
            module.Print("Custom Interrupt List is |cfffaa500already empty|r.");
        else
            InterruptTargets = {};
            module.SetSetting("InterruptTargets", InterruptTargets);
            module.Print("Custom Interrupt List is now |cffff0000empty|r.");
        end
    end

    function CustomInterruptListShow ()
        if not InterruptTargets[1] then
            module.Print("Custom Interrupt List is empty.");
        else
            for Key, Value in pairs(InterruptTargets) do
                module.Print("ID : " .. Value["id"] .. " Name : " .. Value["name"]);
            end
        end
    end

    function Unit.FriendliesNearMushroom (Distance)
        local FriendliesNearTheMushroom = {};
        if not ShroomX then return 0; end

        for Index = 1, GetUnitNearPositionCount(ShroomX, ShroomY, ShroomZ, Distance) do
            local GUID = GetUnitNearPositionByIndex(Index);

            if Unit(GUID):Exists() and not UnitIsDeadOrGhost(GUID) and UnitInParty(GUID) then
                table.insert(FriendliesNearTheMushroom, Unit(GUID));
            end
        end

        return #FriendliesNearTheMushroom;
    end

    function Unit.FriendliesNearTotem (Totem, TheseUnits, Distance)
        local ThisUnit, UnitsCount = nil, 0;
        for i = 1, #TheseUnits do
            ThisUnit = TheseUnits[i];
            if Totem:DistanceTo(ThisUnit) <= Distance then
                UnitsCount = UnitsCount + 1;
            end
        end
        return UnitsCount;
    end

    function Unit:Attack ()
        return TargetUnit(self.UnitID);
    end

    function Unit.FirstUnitAvailableForBlacklistGroundCastException (Spell, Radius, IncludePlayer)
        local Units = {};
        local X, Y, Z = GetUnitPosition("Player");

        for Index = 1, GetUnitNearPositionCount(X, Y, Z, 60) do
            local ThisUnit = Unit(GetUnitNearPositionByIndex(Index));
            if ThisUnit:Exists() and not ThisUnit:BlacklistGroundCast() and not ThisUnit:IsCrowdControlled() and Unit.Target:DistanceTo(ThisUnit) <= Radius and Unit.Player:InLineOfSight(ThisUnit) then
                return ThisUnit;
            end
        end

        return nil;
    end

    function Unit.AutoTarget (Spell, Mode)
        -- Legacy Find
        if not Mode then
            return Unit.FirstWhere(
                function (ThisUnit)
                    return ThisUnit:IsInCombat() and ThisUnit:Exists() and Unit.Player:CanAttack(ThisUnit) and Unit.Player:InLineOfSight(ThisUnit) and Unit.Player:IsFacing(ThisUnit) and Unit.Player:IsWithinCastRange(ThisUnit, Spell) and not ThisUnit:IsDeadOrGhost();
                end
            );
        else
            local TargetOption = module.GetOptionValue("Target Priority")
            local TargetPriority = module.IsOptionEnabled("Target Priority") and ((TargetOption == "|cffD9D9DBSkull" and 8) or (TargetOption == "|cffCC3122Cross" and 7) or (TargetOption == "|cff019EE0Square" and 6) or (TargetOption == "|cffB2D1DFMoon" and 5) or (TargetOption == "|cff0AE201Triangle" and 4) or (TargetOption == "|cffB731C8Diamond" and 3) or (TargetOption == "|cffD87E01Circle" and 2) or (TargetOption == "|cffFFEA00Star" and 1)) or 9
            local Mode = Mode;
            if Mode == "Target Closest" and not Unit.Target:Exists() then Mode = "Most HP"; end
            -- Find the closest target of the player.
            if Mode == "Closest" then
                local Units, Player, PotentialUnits, Count = module.EnemyUnits, Unit.Player, {}, 1;
                local ThisUnit;
                for i = 1, #Units do
                    ThisUnit = Units[i];
                    if ThisUnit:IsInCombat() and not ThisUnit:IsHardBlacklisted() and not ThisUnit:Blacklist() and Player:InLineOfSight(ThisUnit) and Player:IsFacing(ThisUnit) and not ThisUnit:IsDeadOrGhost() and Player:IsWithinCastRange(ThisUnit, Spell) then
                        if GetRaidTargetIndex(ThisUnit.UnitID) == TargetPriority then
                            return ThisUnit;
                        end
                        PotentialUnits[Count] = {Unit = ThisUnit, Distance = Player:DistanceTo(ThisUnit)};
                        Count = Count + 1;
                    end
                end
                table.sort(PotentialUnits, function(a, b) return a.Distance < b.Distance; end);
                if #PotentialUnits >= 1 then return PotentialUnits[1].Unit; end
            -- Find the unit closest to the old target (assuming you have one, else it is the most HP one).
            elseif Mode == "Target Closest" then
                local Units, Player, Target, PotentialUnits, Count = module.EnemyUnits, Unit.Player, Unit.Target, {}, 1;
                local ThisUnit;
                for i = 1, #Units do
                    ThisUnit = Units[i];
                    if ThisUnit:IsInCombat() and not ThisUnit:IsHardBlacklisted() and not ThisUnit:Blacklist() and Player:InLineOfSight(ThisUnit) and Player:IsFacing(ThisUnit) and not ThisUnit:IsDeadOrGhost() and Player:IsWithinCastRange(ThisUnit, Spell) then
                        if GetRaidTargetIndex(ThisUnit.UnitID) == TargetPriority then
                            return ThisUnit;
                        end
                        PotentialUnits[Count] = {Unit = ThisUnit, Distance = Target:DistanceTo(ThisUnit)};
                        Count = Count + 1;
                    end
                end
                table.sort(PotentialUnits, function(a, b) return a.Distance < b.Distance; end);
                if #PotentialUnits >= 1 then return PotentialUnits[1].Unit; end
            -- Target the unit with Most HP.
            elseif Mode == "Most HP" then
                local Units, Player, PotentialUnits, Count = module.EnemyUnits, Unit.Player, {}, 1;
                local ThisUnit;
                for i = 1, #Units do
                    ThisUnit = Units[i];
                    if ThisUnit:IsInCombat() and not ThisUnit:IsHardBlacklisted() and not ThisUnit:Blacklist() and Player:InLineOfSight(ThisUnit) and Player:IsFacing(ThisUnit) and not ThisUnit:IsDeadOrGhost() and Player:IsWithinCastRange(ThisUnit, Spell) then
                        if GetRaidTargetIndex(ThisUnit.UnitID) == TargetPriority then
                            return ThisUnit;
                        end
                        PotentialUnits[Count] = {Unit = ThisUnit, Health = ThisUnit:Health()};
                        Count = Count + 1;
                    end
                end
                table.sort(PotentialUnits, function(a, b) return a.Health > b.Health; end);
                if #PotentialUnits >= 1 then return PotentialUnits[1].Unit; end
            -- Target the unit with Least HP.
            elseif Mode == "Least HP" then
                local Units, Player, PotentialUnits, Count = module.EnemyUnits, Unit.Player, {}, 1;
                local ThisUnit;
                for i = 1, #Units do
                    ThisUnit = Units[i];
                    if ThisUnit:IsInCombat() and not ThisUnit:IsHardBlacklisted() and not ThisUnit:Blacklist() and Player:InLineOfSight(ThisUnit) and Player:IsFacing(ThisUnit) and not ThisUnit:IsDeadOrGhost() and Player:IsWithinCastRange(ThisUnit, Spell) then
                        if GetRaidTargetIndex(ThisUnit.UnitID) == TargetPriority then
                            return ThisUnit;
                        end
                        PotentialUnits[Count] = {Unit = ThisUnit, Health = ThisUnit:Health()};
                        Count = Count + 1;
                    end
                end
                table.sort(PotentialUnits, function(a, b) return a.Health < b.Health; end);
                if #PotentialUnits >= 1 then return PotentialUnits[1].Unit; end
            -- If current Target is Tanked, we find another unit that is not.
            elseif Mode == "Untanked" then
                local MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();
                -- local Units, Player, PotentialUnits, Count = module.EnemyUnits, Unit.Player, {}, 1;
                local Units, Player, Count = module.EnemyUnits, Unit.Player, 1;
                PotentialUnits = {};
                local ThisUnit;
                if Player:IsTanking(Target) or Player:DistanceTo(Target) > 5 or (PlayerPet:Exists() and PlayerPet:IsTank() and PlayerPet:IsTanking(Target)) or (MainTank and MainTank:Exists() and MainTank:IsTanking(Target)) or (OffTank and OffTank:Exists() and OffTank:IsTanking(Target)) then
                    local TargetInCastRange = Player:IsWithinCastRange(Target, Spell);
                    for i = 1, #Units do
                        ThisUnit = Units[i];
                        if ThisUnit:IsInCombat() and not ThisUnit:IsHardBlacklisted() and not ThisUnit:Blacklist() and Player:InLineOfSight(ThisUnit) and Player:IsFacing(ThisUnit) and not ThisUnit:IsDeadOrGhost() and Player:IsWithinCastRange(ThisUnit, Spell) then
                            -- Check if the Unit Is Tanked
                            if not TargetInCastRange or (not Player:IsTanking(ThisUnit) and not (PlayerPet:Exists() and PlayerPet:IsTank() and PlayerPet:IsTanking(ThisUnit)) and not (MainTank and MainTank:Exists() and MainTank:IsTanking(ThisUnit)) and not (OffTank and OffTank:Exists() and OffTank:IsTanking(ThisUnit))) then
                                if GetRaidTargetIndex(ThisUnit.UnitID) == TargetPriority then
                                    return ThisUnit;
                                end
                                PotentialUnits[Count] = {Unit = ThisUnit, Health = ThisUnit:Health()};
                                Count = Count + 1;
                            end
                        end
                    end
                    table.sort(PotentialUnits, function(a, b) return a.Health < b.Health; end);
                    if #PotentialUnits >= 1 then return PotentialUnits[1].Unit; end
                end
            -- Find the biggest cluster of units and target the one with most HP.
            elseif Mode == "Biggest Cluster" then
            end
            return nil;
        end
    end

    function Unit.FirstEnemyAvailableToInterrupt (FunctionSpellToCast, Value, InterruptList)
        local InterruptTargets = module.GetSetting("InterruptTargets") or {};
        local DarkSimSupport = module.IsOptionEnabled("Help Dark Simulacrum");
        local CustomFunction = function (ThisUnit) return not ThisUnit:IsDeadOrGhost() and ThisUnit:IsInCombat() and ThisUnit:IsInterruptible() and Unit.Player:IsWithinCastRange(ThisUnit, FunctionSpellToCast) and Unit.Player:CanAttack(ThisUnit) and (not InterruptList or TableContains(InterruptTargets, "name", select(1, ThisUnit:IsCasting()))) and ThisUnit:CastedPercent() >= Value and (not DarkSimSupport or not (ThisUnit:DebuffAny(module.Spell(77606)) and module.DarkSimList[UnitCreatureID(ThisUnit.UnitID)] and module.DarkSimList[UnitCreatureID(ThisUnit.UnitID)][select(1, ThisUnit:IsCasting())])); end;
        return Unit.FirstWhere(CustomFunction, "Enemy");
    end

    --- Find a unit valid under or over a specific health threshold in a provided units table
    -- @param Enemies - A units Table
    -- @param Spell - Spell to be checked against the units
    -- @param Health - Health Percent threshold to look for
    -- @param Inverted - Set to true to find units higher than the set threshold
    function Unit.LightEnemyAvailableForSpellHP (Enemies, Spell, Health, Inverted)
        for i = 1, #Enemies do
            local ThisUnit = Enemies[i];
            if (ThisUnit:HealthPercentage() < Health or Inverted and ThisUnit:HealthPercentage() > Health) and not ThisUnit:IsMissable() and (ThisUnit:IsInCombat() or ThisUnit:IsDummy()) and ThisUnit:Exists() and not ThisUnit:IsHardBlacklisted() and not ThisUnit:IsCrowdControlled() and Unit.Player:CanAttack(ThisUnit) and Unit.Player:IsWithinCastRange(ThisUnit, Spell) and Unit.Player:InLineOfSight(ThisUnit) then
                return ThisUnit;
            end
        end
    end
    -- Wrong Design, use LightEnemyAvailableForSpellHP instead.
    function Unit.FirstEnemyAvailableForSpellHP (Spell, Health)
        local X, Y, Z = GetUnitPosition("Player");
        for Index = 1, GetUnitNearPositionCount(X, Y, Z, 60) do
            local ThisUnit = Unit(GetUnitNearPositionByIndex(Index));
            if ThisUnit:HealthPercentage() < Health and not ThisUnit:IsMissable() and (ThisUnit:IsInCombat() or ThisUnit:IsDummy()) and ThisUnit:Exists() and not ThisUnit:IsHardBlacklisted() and not ThisUnit:IsCrowdControlled() and Unit.Player:CanAttack(ThisUnit) and Unit.Player:IsWithinCastRange(ThisUnit, Spell) and Unit.Player:InLineOfSight(ThisUnit) then
                return ThisUnit;
            end
        end
    end
    -- Wrong Design, use LightEnemyAvailableForSpellHP instead.
    function Unit.FirstEnemyAvailableForSpellHPInverted (Spell, Health)
        local X, Y, Z = GetUnitPosition("Player");
        for Index = 1, GetUnitNearPositionCount(X, Y, Z, 60) do
            local ThisUnit = Unit(GetUnitNearPositionByIndex(Index));
            if ThisUnit:HealthPercentage() > Health and not ThisUnit:IsMissable() and (ThisUnit:IsInCombat() or ThisUnit:IsDummy()) and ThisUnit:Exists() and not ThisUnit:IsHardBlacklisted() and not ThisUnit:IsCrowdControlled() and Unit.Player:CanAttack(ThisUnit) and Unit.Player:IsWithinCastRange(ThisUnit, Spell) and Unit.Player:InLineOfSight(ThisUnit) then
                return ThisUnit;
            end
        end
    end

    function Unit:IsMissable ()
        return UnitLevel('player') < 100 and UnitLevel(self.UnitID) == -1 and self:IsDummy();
    end

    --- Get the best enemy within range of a spell that doesn't have a debuff.
    -- @param TheseUnits - The units to cycle - Units Table
    -- @param Spell - The Spell - Spell Object
    -- @param Spell - The Debuff - Spell Object
    -- @param Duration - The total duration of the spell - Number
    -- @param OptionName - The name of the option in the UI - String
    -- @param ExcludeTarget - Set to true to avoid Applying on the current Target
    -- @param ApplyOnce - Set to true to never refresh the Debuff
    -- @return The best unit to apply the debuff on. Returns nil if none were found.
    function Unit.DotCycle (TheseUnits, Spell, Debuff, Duration, OptionName, ExcludeTarget, ApplyOnce)
        local OptionValue1, OptionValue2 = module.GetOptionValue(OptionName), IsInInstance() and module.GetSecondOptionValue(OptionName)*1000000 or 0;
        local BestUnit, BestUnitHealth, BestUnitDuration;
        local DebuffsCount, MinimumDuration = 0, Duration * 0.3 - Spell:CastTime();
        for i = 1, #TheseUnits do
            local ThisUnit = TheseUnits[i];
            local ThisUnitHealth, ThisUnitDuration = ThisUnit:Health(), ThisUnit:DebuffRemains(Debuff);
            DebuffsCount = ThisUnitDuration ~= 0 and ThisUnitDuration > MinimumDuration and DebuffsCount + 1 or DebuffsCount;
            if (not ApplyOnce or not ThisUnit:Debuff(Debuff)) and (not ExcludeTarget or not ThisUnit:Equals(ExcludeTarget)) and ThisUnit:CanCast(Spell) and ThisUnit:IsInCombat() and ThisUnit:Exists() and not ThisUnit:IsHardBlacklisted() and not ThisUnit:IsCrowdControlled() and Unit.Player:CanAttack(ThisUnit) and Unit.Player:IsWithinCastRange(ThisUnit, Spell) and ThisUnitHealth >= OptionValue2 and Unit.Player:InLineOfSight(ThisUnit) and (ThisUnitDuration < MinimumDuration or ThisUnitDuration == 0) then
                if (not BestUnit or ThisUnitDuration <= BestUnitDuration) and (not BestUnit or ThisUnitHealth >= BestUnitHealth) then
                    BestUnit, BestUnitHealth, BestUnitDuration = ThisUnit, ThisUnitHealth, ThisUnitDuration;
                end
            end
        end
        return DebuffsCount < OptionValue1 and BestUnit or nil;
    end

    --- Get if the unit is another unit.
    -- @param Other The other unit.
    -- @return Whether the unit is the other unit.
    function Unit:Equals (Other)
        return UnitIsUnit(self.UnitID, Other.UnitID);
    end

    --- Get the unit as a string.
    -- @return The unit's unit ID.
    function Unit:ToString ()
        return self.UnitID;
    end

    --- Get whether the unit exists.
    -- @return Whether the unit exists.
    function Unit:Exists ()
        return UnitExists(self.UnitID) and UnitIsVisible(self.UnitID);
    end

    --- Get the unit's position.
    -- @return The unit's position as a Vector3.
    -- whenever we call this function, we want to first check if we have this unit position stored
    -- if we dont have it, we will find it and store it into the global table
    module.StoredPositions = {};
    function Unit:Position ()
        -- see if we got the unit position cached
        if module.StoredPositions[self.UnitID] == nil then
            -- add to global table
            module.StoredPositions[self.UnitID] = module.Vector3(GetUnitPosition(self.UnitID));
        end
        -- return position
        return module.StoredPositions[self.UnitID];
    end

    --- Get the unit's position.
    -- @return The unit's position as a Vector3.
    function Unit:IsConnected ()
        return UnitIsConnected(self.UnitID);
    end
    --- Get the unit's facing direction.
    -- @return The unit's facing direction, in radians, with zero being north.
    function Unit:Facing ()
        -- TODO: Possibly needs fixed for NPCs in combat. They'll always be facing their targets.
        return GetUnitFacing(self.UnitID);
    end

    --- Get the unit's bounding radius.
    -- @return The unit's bounding radius.
    function Unit:BoundingRadius ()
        return GetUnitBoundingRadius(self.UnitID);
    end

    --- Get the unit's combat reach.
    -- @return The unit's combat reach.
    function Unit:CombatReach ()
        return GetUnitCombatReach(self.UnitID);
    end

    --- Get the unit's name.
    -- @return The unit's name.
    function Unit:Name ()
        return UnitName(self.UnitID);
    end


    function Unit:Tapped ()
        return UnitIsTapped(self.UnitID);
    end


    function Unit:TappedByPlayer ()
        return UnitIsTappedByPlayer(self.UnitID);
    end
    --- Get the units threat percent
    -- Verify threat table, if not lets create one
    -- @return the percent of threat on the unit
    function Unit:Threat (Other)
        if UnitThreatSituation(self.UnitID, Other.UnitID) then
            local isTanking, status, scaledPercent, rawPercent, threatValue = UnitDetailedThreatSituation(self.UnitID, Other.UnitID)
            return scaledPercent;
        end
        return 0;
    end

    --- Get the Unit Threath Situation against every enemies.
    -- @return the threath situation
    -- 0 - Green - Safe
    -- 1 - Yellow - Someone else currently tanking but almost taking aggro
    -- 2 - Orange - We are tanking but almost losing aggro
    -- 3 - Red - We are tanking and far from losing aggro
    function Unit:ThreatSituation ()
        return UnitThreatSituation(self.UnitID) or 0;
    end

    --- Check if a unit is tanking another specific Unit
    -- @param Other The second unit that we want to see if we are tanking
    -- @return true if the unit is tanking the other unit.
    function Unit:IsTanking (Other)
        if UnitThreatSituation(self.UnitID, Other.UnitID) then
            local isTanking, status, scaledPercent, rawPercent, threatValue = UnitDetailedThreatSituation(self.UnitID, Other.UnitID)
            return isTanking;
        end
        return false;
    end
    --- Get the unit's name.
    -- @return The unit's name.
    function Unit:Name ()
        return UnitName(self.UnitID);
    end

    --- Cast a spell on the unit. If it's an AoE, it will be targeted at the unit's position.
    -- @param Spell The spell.
    -- @param OverridePowerCheck Whether to override the power check.
    -- @param AoERadius The radius of the AoE effect if the spell is an AoE spell.
    -- @param RandomRange Number of yards around position to cast at random positions.
    function Unit:Cast (Spell, OverridePowerCheck, AoERadius, RandomRange)
        local MinimumTimeBetweenCasts = 0.2;
        SavedTargetGUID = self.UnitID;
        SavedTargetNAME = self:Name();
        SavedTargetGUID2 = self:GUID();

        if UnitChannelInfo('player') then PlayerIsChanneling = true; else PlayerIsChanneling = false; end

        DestinationGUID = UnitGUID(self.UnitID);
        CastSpellByName(Spell:Name(), self.UnitID);

        current_spell = Spell:Name();
        if IsAoEPending() and (not SpellToCast or SpellToCast ~= Spell) then
            local PlayerPosition, SelfPosition = Unit.Player:Position(), self:Position();
            local RandomRange = RandomRange or 2;
            local PositionX, PositionY, PositionZ = SelfPosition["X"] + math.random(-100,100)/100*RandomRange, SelfPosition["Y"] + math.random(-100,100)/100*RandomRange, SelfPosition["Z"];
            local Distance = math.sqrt(((PlayerPosition["X"] - PositionX) ^ 2) + ((PlayerPosition["Y"] - PositionY) ^ 2) + ((PlayerPosition["Z"] - PositionZ) ^ 2))
            if Spell:MaximumRange() > Distance then
                -- add some randomness to avoid looking bottish.
                CastAtPosition(PositionX, PositionY, PositionZ);
            end
        end

        ClearPendingSpell();
        -- Comment this out to disable debug spell output.
        if not Casted or (Casted ~= Spell:Name() or module.GetTime()-UpdatedTime1 > 0.7) then
            module.Bug("|cFF58ACFA" .. Spell:Name() .. " |cFFFFFFFFon " .. "|cFF58FA82" .. self:Name() .. " |cFFF5A9A9(" .. self.UnitID .. ")");
            Casted = Spell:Name();
            UpdatedTime1 = module.GetTime();
        end
    end


    --- Cast a spell between multiple units
    -- @param Spell The spell.
    -- @param Units The table of units we want to cast on
    function Unit:CastGroundHeal (Spell, Units, NoMovement)
        local MidX, MidY, MidZ, TotalX, TotalY, TotalZ, UnitsCount, ThisUnit, ThisPosition = 0, 0, 0, 0, 0, 0, 0, nil, nil;
        if #Units > 1 then
            -- find middle
            for i = 1, #Units do
                ThisUnit = Units[i];
                if ThisUnit:Exists() and (not NoMovement or not ThisUnit:IsMoving()) then
                    UnitsCount = UnitsCount + 1;
                    ThisPosition = ThisUnit:Position()
                    TotalX, TotalY, TotalZ = TotalX + ThisPosition["X"], TotalY + ThisPosition["Y"], TotalZ + ThisPosition["Z"];
                end
            end
            if UnitsCount >= 1 then
                MidX, MidY, MidZ = TotalX/UnitsCount, TotalY/UnitsCount, TotalZ/UnitsCount
                CastSpellByName(Spell:Name(), self.UnitID);
                if IsAoEPending() then
                    if (Spell:ID() == 145205 or Spell:ID() == 147349 or SpellID == 115313) then
                        ShroomX, ShroomY, ShroomZ = MidX, MidY, MidZ;
                    end
                    module.Bug("|cFF58ACFA" .. Spell:Name() .. " |cFFFFFFFFon |cFF58FA82injured units");
                    CastAtPosition(MidX, MidY, MidZ);
                    return;
                end
            end
        elseif #Units == 1 and Units[1]:Exists() then
            ThisPosition = Units[1]:Position()
            local MidX, MidY, MidZ = ThisPosition["X"],ThisPosition["Y"],ThisPosition["Z"];
            CastSpellByName(Spell:Name(), self.UnitID);
            if IsAoEPending() then
                if (Spell:ID() == 145205 or Spell:ID() == 147349) then
                    ShroomX, ShroomY, ShroomZ = MidX, MidY, MidZ;
                end
                module.Bug("|cFF58ACFA" .. Spell:Name() .. " |cFFFFFFFFon |cFF58FA82injured units");
                CastAtPosition(MidX, MidY, MidZ);
                return;
            end
        end
    end

    function Unit:WithoutCombatFlags ()
        local CreatureID = UnitCreatureID(self.UnitID);
        if CreatureID == nil then return false end;
        return CreatureID == 77252 or CreatureID == 77893 or CreatureID == 86752 or CreatureID == 78583 or CreatureID == 77665  -- Ore Crate (Oregorger) - Grasping Earth & Stone Pillar (Kromog) - Dominator Turret (Iron Maidens) - Iron Soldier (Blackhand)
            or CreatureID == 90410 or CreatureID == 90485 or CreatureID == 91103 or CreatureID == 93435 or CreatureID == 90432  -- Felfire Crusher & Felfire Artillery & Felfire Demolisher & Felfire Transporter & Felfire Flamebelcher (HellFire Assault)
            or CreatureID == 93717 or CreatureID == 94312 or CreatureID == 94326 or CreatureID == 94322 or CreatureID == 94955  -- Volatile Firebomb & Quick-Fuse Firebomb & Reactive Firebomb & Burning Firebomb & Reinforced Firebomb (Iron Reaver)
            or CreatureID == 93838 or CreatureID == 93839 or CreatureID == 90387 or CreatureID == 95656 or CreatureID == 92208  -- Grasping Hand & Dragging Hand (Kormrok) - Shadowy Construct (Gorefiend) - Carrion Swarm (Socrethar) - Doomfire Spirit (Archimonde)
            or CreatureID == 44566; -- Ozuma (Throne of the Tide - Cataclysm Dungeon - Timewalking)
    end

    --- Get whether the unit is in combat.
    -- @return Whether the unit is in combat.
    function Unit:IsInCombat (BypassUnitTable)
        if BypassUnitTable then
            return UnitAffectingCombat(self.UnitID) or self:IsDummy() or self:WithoutCombatFlags();
        else
            local GUID = UnitGUID(self.UnitID)
            if GUID then
                if module.UnitsInfos[GUID] then
                    return module.UnitsInfos[GUID].IsInCombat;
                else
                    return UnitAffectingCombat(self.UnitID) or self:IsDummy() or self:WithoutCombatFlags();
                end
            else
                return nil;
            end
        end
    end

    --- Get whether the unit is a dummy.
    -- @return Whether the unit is a dummy.im sayi the users
    function Unit:IsDummy ()
        return UnitIsDummy(self.UnitID);
    end

    local DummiesUnits = {
        [31144] = true,
        [31146] = true,
        [32542] = true,
        [32543] = true,
        [32545] = true,
        [32546] = true,
        [32666] = true,
        [32667] = true,
        [33229] = true,
        [33272] = true,
        [46647] = true,
        [54344] = true,
        [67127] = true,
        [83546] = true,
        [87317] = true,
        [87318] = true,
        [87320] = true,
        [87322] = true,
        [87761] = true,
        [87762] = true,
        [88288] = true,
        [88314] = true,
        [88967] = true
    }
    function UnitIsDummy (UnitID)
        local CreatureID = UnitCreatureID(UnitID);
        return CreatureID ~= nil and DummiesUnits[CreatureID] == true;
    end

    function Unit:IsCreature (ID)
        local CreatureID = self:CreatureID();
        return CreatureID == ID;
    end

    local HardBlacklistedUnits = {
        [43612] = {Buff = 82320}, -- Lost City of the Tol'vir - High Prophet Barim : Repentance (Immune shield)
        [44819] = {Buff = 84589}, -- Lost City of the Tol'vir - Siamat : Deflecting Winds (Damage reduced by 90%)
        [71064] = {Buff = 142174, Facing = true}, -- Large Illusionary Guardian if shielded and Facing
        [71079] = {Buff = 142174, Facing = true}, -- Small Illusionary Guardian if shielded and Facing
        [76806] = {Health = 100}, -- (BRF) Blast Furnace: Heart of the Mountain Stage 1+2 (Unit exist but we can't cast on it)
        [76815] = {Buff = 155176}, -- (BRF) Blast Furnace: Primal Elementalist can't be damaged while they got "Damage Shield" buff
        [76829] = {Health = 0}, -- (BRF) Blast Furnace: Slag Elemental Stage 2+3 (When the unit is at 0% it becomes immune)
        [81305] = {Buff = 164426}, -- Iron Docks - Fleshrender Nok'gar : Reckless Provocation (Fear when hit)
        [90269] = {Buff = 180040}, -- (HFC) Tyrant Velhari : Sovereign's Ward (3rd Add Alive -> Damage reduced by 90%)
        [90486] = {Always = true}, -- (Tanaan Jungle) Inferno Shot Doodle (Considered as NPC in Tanaan Jungle, but they're object)
        [92330] = {Buff = 184053}, -- (HFC) Socrethar : Fel Barrier (Dominator Alive -> Immune Shield)
        [93233] = {Buff = 184658}, -- (HFC) Lord Aram'el : Demonic Barrier (Trash between Socrethar & Velhari -> Immune Shield)
        [93288] = {Option = "Blacklist Corrupted Souls"} -- (HFC) Gorefiend - Corrupted Soul - if option is enabled
    };

    --- Check if the unit is hard coded as blacklisted or not.
    -- Uses the HardBlacklistedUnits table to define if a unit should be avoided or not. Add entries to the HardBlacklistedUnits table according to what you need
    -- @return True if the unit is blacklisted, false otherwise.
    function Unit:IsHardBlacklisted ()
        local ThisCreature, BlacklistUnit = self:CreatureID(), false;
        if ThisCreature and HardBlacklistedUnits[ThisCreature] ~= nil then
            -- Blacklist only if the option is enabled
            if HardBlacklistedUnits[ThisCreature].Option then
                BlacklistUnit = module.IsOptionEnabled(HardBlacklistedUnits[ThisCreature].Option);
            -- Blacklist only if the unit have specific buff
            elseif HardBlacklistedUnits[ThisCreature].Buff then
                BlacklistUnit = self:BuffAny(Spell(HardBlacklistedUnits[ThisCreature].Buff));
                -- Cancel Blacklist when unit is not facing with Frontal Shields
                if HardBlacklistedUnits[ThisCreature].Facing then
                    BlacklistUnit = self:IsFacing(Player) == HardBlacklistedUnits[ThisCreature].Facing;
                end
            -- Blacklist only if the unit have specific health
            elseif HardBlacklistedUnits[ThisCreature].Health then
                BlacklistUnit = self:HealthPercentage() == HardBlacklistedUnits[ThisCreature].Health;
            -- No conditions, Always blacklist this unit
            elseif HardBlacklistedUnits[ThisCreature].Always then
                BlacklistUnit = true;
            end
        end
        return BlacklistUnit;
    end

    --- Check if the unit is coded as blacklisted for Marked for Death (Rogue) or not.
    -- @return True if the unit is blacklisted, false otherwise.
    -- Same type of function as HardBlacklisted().
    function Unit:IsMfdBlacklisted ()
        local ThisCreature = self:CreatureID();
        if ThisCreature == nil then return false; end

        --- Warlord of Draenor (WoD)
            ----- HellFire Citadel (T18 - 6.2 Patch) -----
            -- Hellfire Assault : Mar'Tak doesn't die and leave fight at 50% (blocked at 1hp anyway).
            if ThisCreature == 93023 then return true; end

            ----- Dungeons (6.0 Patch) -----
            -- Shadowmoon Burial Grounds - Carrion Worm : They doesn't die but leave the area at like 10%.
            if ThisCreature == 88769 or ThisCreature == 76057 then return true; end

        return false;
    end

    --- Get whether the unit can attack another unit.
    -- @param Other The other unit.
    -- @return Whether the unit can attack the other unit.
    function Unit:CanAttack (Other, BypassUnitTable)
        if BypassUnitTable then
            return UnitCanAttack(self.UnitID, Other.UnitID);
        else
            local GUID = Other:GUID();
            if GUID then
                if module.UnitsInfos[GUID] then
                    return module.UnitsInfos[GUID].CanAttack;
                else
                    return UnitCanAttack(self.UnitID, Other.UnitID);
                end
            else
                return nil;
            end
        end
    end

    --- Check if creature type is Totem.
    -- @return true if the unit is a totem.
    function Unit:IsTotem ()
        return UnitCreatureType(self.UnitID) == "Totem";
    end

    --- Get the distance between the unit and another unit.
    -- @param Other The other unit.
    -- @return The distance between the units.
    function Unit:DistanceTo (Other, AbsoluteDistance, PlayerCenteredAoE)
        if Other == nil or not Other:Exists() then return 100; end
        local SelfPosition = self:Position();
        local OtherPosition = Other:Position();
        if AbsoluteDistance then
            return SelfPosition:DistanceTo(OtherPosition);
        end
        local Reach1 = self:CombatReach() or 0;
        local Reach2 = Other:CombatReach() or 0;
        local MeleeRange = self:MeleeRange(Other);
        local WeirdZone = math.min(MeleeRange+0.1, 7.9);
        local DistanceMelee = SelfPosition:DistanceTo(OtherPosition)/MeleeRange*5;
        local DistanceReach = SelfPosition:DistanceTo(OtherPosition)-(Reach1+Reach2);
        local DistancePlayerCenteredAoE = SelfPosition:DistanceTo(OtherPosition)-Reach2;
        if PlayerCenteredAoE then
            return DistancePlayerCenteredAoE;
        elseif DistanceMelee <= 5 then
            return DistanceMelee;
        elseif DistanceReach <= WeirdZone then
            return WeirdZone;
        else
            return DistanceReach;
        end
    end

    --- Get the distance between the unit and another unit.
    -- @param Other The other unit.
    -- @return The distance between the units.
    function Unit:RangeTo (Position)
        return self:Position():DistanceTo(Position);
    end

    --- Get whether the unit is in a vehicle.
    -- @return Whether the unit is in a vehicle.
    local VehicleSpell = {
        157059, -- Rune of Grasping Earth (Hand on Kromog in BlackRock Foundry)
        187819, -- Crush (Hand on Kormrok in HellFire Citadel)
        181345 -- Foul Crush (Tank Hand on Kormrok in HellFire Citadel)
    };
    local VehiclePetMount = {
        87082, -- Silverperlt
        87078, -- Icehoof
        87081, -- Rocktusk
        87080, -- Riverwallow
        87079, -- Meadowstomper
        87076 -- Snarler
    };
    function Unit:InVehicle ()
        for i = 1, #VehicleSpell do
            if self:DebuffAny(module.Spell(VehicleSpell[i])) then return false; end
        end
        if IsPetActive() then
            for i = 1, #VehiclePetMount do
                if PlayerPet:CreatureID() == VehiclePetMount[i] then
                    return false;
                end
            end
        end
        return UnitInVehicle(self.UnitID);
    end

    --- Get the unit's health.
    -- @return The unit's health.
    function Unit:Health ()
        return UnitHealth(self.UnitID);
    end

    --- Get the unit's maximum health.
    -- @return The unit's maximum health.
    function Unit:MaxHealth ()
        return UnitHealthMax(self.UnitID);
    end

    local ancientBarrierDebuffs = { GetSpellInfo(142861), GetSpellInfo(142863), GetSpellInfo(142864), GetSpellInfo(142865) }
    local function ancientBarrier (unit)
        if not UnitDebuff(unit, ancientBarrierDebuffs[1]) then
            return false
        end

        local amount
        for i = 2, 4 do
            amount = select(15, UnitDebuff(unit, ancientBarrierDebuffs[i]))
            if amount then
                return amount
            end
        end

        return false
    end

    function Unit:SpecialHealthPercentage (Spell)
        -- if the unit is blacklisted then we return 100 right away so this unit wont be healed.
        if self:Blacklist() or not Unit.Player:InLineOfSight(self) then
            return 101;
        end
        local TotalHealth = 100;
        local incomingHeals = UnitGetIncomingHeals(self.UnitID) or 0
        local absorbs = not self:BuffAny(module.Spell(47788)) and UnitGetTotalHealAbsorbs(self.UnitID) or 0
        local health = UnitHealth(self.UnitID) + incomingHeals - absorbs
        local maxHealth = UnitHealthMax(self.UnitID)
        -- Max Health tweak for Velhari
        if module.IsOptionEnabled("Aura Of Contempt Support") and module.EncounterID == 1784 then
            local VelhariAura = select(15, UnitAura("boss1", GetSpellInfo(179986)))
            if VelhariAura then
                maxHealth = maxHealth * VelhariAura / 100
            end
        end

        local ancientBarrierShield = ancientBarrier(self.UnitID)
        if ancientBarrierShield then
            health = ancientBarrierShield
        end
        healthaftermod = health;
        if maxHealth == 0 then return 100; end
        if healthaftermod / maxHealth * 100 > 100 then
            TotalHealth = 100;
        else
            TotalHealth = healthaftermod / maxHealth * 100;
        end
        -- Touch of Mortality
        if module.IsOptionEnabled("Touch Of Mortality") then
            if self:DebuffAny(module.Spell(184587)) then
                TotalHealth = TotalHealth + module.GetOptionValue("Touch Of Mortality");
            end
        end
        -- Bestow Faith (Paladin Talent that heal for 8-10% when it finishes)
        if self:BuffAny(module.Spell(223306)) and TotalHealth > 50 then
            TotalHealth = TotalHealth + 8;
        end
        return TotalHealth;
    end

    --- Get the unit's health as a percentage.
    -- @return The unit's health as a percentage.
    function Unit:HealthPercentage ()
        return UnitHealthMax(self.UnitID) == 0 and 0 or UnitHealth(self.UnitID) / UnitHealthMax(self.UnitID) * 100;
    end

    --- Get whether the unit is facing another unit.
    -- @param Other The other unit.
    -- @return Whether the unit is facing the other unit.
    function Unit:IsFacing (Other)
        local sX, sY, sZ = GetUnitPosition(self.UnitID);
        local sF = self:Facing();
        local oX, oY, oZ = GetUnitPosition(Other.UnitID);
        local angle = sX and sY and sZ and oX and oY and oZ and sF and ((sX - oX) * math.cos(-sF)) - ((sY - oY) * math.sin(-sF)) or 0
        return angle < 0;
    end

    -- You can use this for example to check if the player is in front of the unit or not. @Foxey
    -- @param Other The other unit.
    -- @return Whether the unit is in front of the other unit.
    function Unit:IsFront (Other)
        local sX, sY, _ = GetUnitPosition(self.UnitID);
        local oX, oY, _ = GetUnitPosition(Other.UnitID);
        local oFRaw = GetUnitFacing(Other.UnitID);
        if not sX or not sY or not oX or not oY or not oFRaw or sX - oX == 0 then
            return "No Information";
        end
        local oF = math.deg(oFRaw);
        local angle = math.deg(math.atan((sY-oY) / (sX-oX)))
        if oX < sX then
            angle = angle + 180;
        end
        if oF <= 180 then oF = oF+180; elseif oF > 180 then oF = oF-180; end
        if angle > 359 then angle = angle - 360; end
        if angle < 0 then angle = 360-(angle*-1); end
        return (angle > oF-45 and angle < oF+45)
    end

    --- Get whether the unit is behind another unit.
    -- @param Other The other unit.
    -- @return Whether the unit is behind the other unit.
    function Unit:IsBehind (Other)
        local IsFrontResult = self:IsFront(Other);
        if IsFrontResult == "No Information" then
            return IsFrontResult;
        else
            return not IsFrontResult;
        end
    end

    function Unit:IsBehindPulsed (Other)
        if not PositionBehindPulsedTimer or module.GetTime() >= PositionBehindPulsedTimer then
            PositionBehindPulsedTimer = module.GetTime() + module.GetOptionValue("TPS: Unit | Rotation")/1000;
            PositionBehindPulsed = self:IsBehind(Other)
        end
        return PositionBehindPulsed;
    end

    --- Get whether the unit is a player.
    -- @return Whether the unit is a player.
    function Unit:IsPlayer ()
        return UnitIsPlayer(self.UnitID);
    end

    --- Get the unit's level.
    -- @return The unit's level.
    function Unit:Level ()
        return UnitLevel(self.UnitID);
    end

    --- Get whether the unit is a boss.
    -- @return Whether the unit is a boss.
    function Unit:IsBoss ()
        local UnitIsBoss = false;
        for i = 1, 4 do
            if UnitIsUnit(self.UnitID, "Boss" .. i) then
                UnitIsBoss = true;
                break;
            end
        end
        if UnitLevel(self.UnitID) == -1 or (not IsInRaid() and UnitLevel(self.UnitID) > 92 and UnitLevel("player") < 91) or (not IsInRaid() and UnitLevel(self.UnitID) > 103 and UnitLevel("player") < 101) or (not IsInRaid() and UnitLevel(self.UnitID) > 113) then
            UnitIsBoss = true;
        end
        return UnitIsBoss;
    end

    --- Get the unit's speed.
    -- @return The unit's current speed, run speed, flight speed, and swim speed.
    function Unit:Speed ()
        return GetUnitSpeed(self.UnitID);
    end

    --- Get the unit's speed percent.
    -- @return the unit's current speed compared to it's max speed
    function Unit:SpeedPercent()
        return (select(1, GetUnitSpeed(self.UnitID)) / select(2, GetUnitSpeed(self.UnitID)))*100;
    end

    -- Buffs that cause unit to not be considered moving.
    local SpiritWalkersGraceBuff = Spell(79206);
    local IceFloesBuff = Spell(108839);
    local StellarDriftBuff = Spell(202461);
    local VoidFormBuff = Spell(194249);
    local SurrenderToMadnessBuff = Spell(193223);
    --- Get whether the unit is moving.
    function Unit:IsMoving ()
        return self:Speed() > 0 and not self:BuffAny(SpiritWalkersGraceBuff) and not self:BuffAny(IceFloesBuff) and not self:BuffAny(StellarDriftBuff) and not (self:BuffAny(VoidFormBuff) and self:BuffAny(SurrenderToMadnessBuff));
    end

    --- Get the unit's anticipated position at a time in the future.
    -- @param Time The time in the future to get the position, in seconds.
    -- @return The position that the unit is anticipated to be in at the time.
    function Unit:PositionIn (Time)
        return self:Position():Project(self:Facing(), Time * self:Speed());
    end

    --- Get the unit's reaction toward another.
    -- @param Other The other unit.
    -- @return The unit's reaction toward the other unit. See http://wowprogramming.com/docs/api/UnitReaction for more information.
    function Unit:ReactionTo (Other)
        return UnitReaction(self.UnitID, Other.UnitID);
    end

    --- Get the unit's GUID.
    -- @return The unit's GUID.
    function Unit:GUID ()
        return UnitGUID(self.UnitID);
    end


    function Unit:CreatureType ()
        return UnitCreatureType(self.UnitID);
    end
    function Unit:IsTank ()
        return UnitGroupRolesAssigned(self.UnitID) == "TANK" or self:CreatureID() == 72218 or self:CreatureID() == 73967; -- 72218 = Oto the Protector (PG Tank) - 73967 = Niuzao (Brew Monk Pet)
    end
    function Unit:IsHealer ()
        return UnitGroupRolesAssigned(self.UnitID) == "HEALER";
    end
    function Unit:IsCaster ()
        return self:MaxPower() == 160000;
    end

    --- Get all the Auras from the Unit and put it into the Master Aura Table.
    function Unit:GetAuras (GUID)
        if not module.AurasInfos[GUID] then module.AurasInfos[GUID] = {}; end
        module.AurasInfos[GUID].Auras = {};
        local Infos;
        for Index = 1, C.MAXIMUM_BUFFS do
            Infos = {UnitAura(GUID, Index)};
            if not Infos[11] then break; end
            table.insert(module.AurasInfos[GUID].Auras, Infos);
        end
        module.AurasInfos[GUID].Auras = true;
    end

    --- Get an aura on the unit caused by a spell from the player.
    -- @param Spell The spell that caused the aura.
    -- @return Information about the aura (see UnitAura) or nil if the unit doesn't have it.
    function Unit:Aura (Spell)
        local GUID = self:GUID();
        if not GUID then return nil; end
        if not module.AurasInfos[GUID] or not module.AurasInfos[GUID].Auras then
            self:GetAuras(GUID);
        end
        if module.AurasInfos[GUID].Auras then
            local SpellID = Spell:ID();
            local Table = module.AurasInfos[GUID].Auras;
            local Caster;
            for Index = 1, #Table do
                Caster = Table[Index][8];
                if Caster and SpellID == Table[Index][11] and (UnitIsUnit(Caster, "Player") or UnitIsUnit(Caster, "PlayerPet")) then
                    return unpack(Table[Index]);
                end
            end
        end
        return nil;
    end

    function Unit:AuraCount (Spell)
        return select(4, self:Aura(Spell)) or 0;
    end

    --- Get an aura on the unit caused by a spell.
    -- @param Spell The spell that caused the aura.
    -- @return Information about the aura (see UnitAura) or nil if the unit doesn't have it.
    function Unit:AuraAny (Spell)
        local GUID = self:GUID();
        if not GUID then return nil; end
        if not module.AurasInfos[GUID] or not module.AurasInfos[GUID].Auras then
            self:GetAuras(GUID);
        end
        if module.AurasInfos[GUID].Auras then
            local SpellID = Spell:ID();
            local Table = module.AurasInfos[GUID].Auras;
            for Index = 1, #Table do
                if SpellID == Table[Index][11] then
                    return unpack(Table[Index]);
                end
            end
        end
        return nil;
    end

    --- Get all the Buffs from the Unit and put it into the Master Aura Table.
    function Unit:GetBuffs (GUID)
        if not module.AurasInfos[GUID] then module.AurasInfos[GUID] = {}; end
        module.AurasInfos[GUID].Buffs = {};
        local Infos;
        for Index = 1, C.MAXIMUM_BUFFS do
            Infos = {UnitBuff(GUID, Index)};
            if not Infos[11] then break; end
            table.insert(module.AurasInfos[GUID].Buffs, Infos);
        end
        module.AurasInfos[GUID].Buff = true;
    end

    --- Get a buff on the unit caused by a spell from the player.
    -- @param Spell The spell that caused the buff.
    -- @return Information about the buff (see UnitBuff) or nil if the unit doesn't have it.
    function Unit:Buff (Spell)
        local GUID = self:GUID();
        if not GUID then return nil; end
        if not module.AurasInfos[GUID] or not module.AurasInfos[GUID].Buff then
            self:GetBuffs(GUID);
        end
        if module.AurasInfos[GUID].Buff then
            local SpellID = Spell:ID();
            local Table = module.AurasInfos[GUID].Buffs;
            local Caster;
            for Index = 1, #Table do
                Caster = Table[Index][8];
                if Caster and SpellID == Table[Index][11] and (UnitIsUnit(Caster, "Player") or UnitIsUnit(Caster, "PlayerPet")) then
                    return unpack(Table[Index]);
                end
            end
        end
        return nil;
    end

    function Unit:BuffRemains (Spell)
        local ExpirationTime = select(7, self:Buff(Spell));
        return ExpirationTime and ExpirationTime - module.GetTime() or 0;
    end

    function Unit:BuffDuration (Spell)
        return select(6, self:Buff(Spell)) or 0;
    end

    function Unit:BuffCount (Spell)
        return select(4, self:Buff(Spell)) or 0;
    end

    --- Get the numbers in a buff's tooltip.
    -- @param Spell - The Buff ID to look for - Spell Object
    -- @return The numbers in the tooltip or 0 if the buff is not found.
    function Unit:BuffValue (Spell)
        if self:Buff(Spell) then
            return module.GetNumbersForBuff(self, Spell)[1]*1;
        else
            return 0;
        end
    end

    --- Get a buff on the unit caused by a spell.
    -- @param Spell The spell that caused the buff.
    -- @return Information about the buff (see UnitBuff) or nil if the unit doesn't have it.
    function Unit:BuffAny (Spell)
        local GUID = self:GUID();
        if not GUID then return nil; end
        if not module.AurasInfos[GUID] or not module.AurasInfos[GUID].Buff then
            self:GetBuffs(GUID);
        end
        if module.AurasInfos[GUID].Buff then
            local SpellID = Spell:ID();
            local Table = module.AurasInfos[GUID].Buffs;
            for Index = 1, #Table do
                if SpellID == Table[Index][11] then
                    return unpack(Table[Index]);
                end
            end
        end
        return nil;
    end

    function Unit:BuffRemainsAny (Spell)
        local ExpirationTime = select(7, self:BuffAny(Spell));
        return ExpirationTime and ExpirationTime - module.GetTime() or 0;
    end

    function Unit:BuffDuration (Spell)
        return select(6, self:BuffAny(Spell)) or 0;
    end

    function Unit:BuffCountAny (Spell)
        return select(4, self:BuffAny(Spell)) or 0;
    end

    --- Get all the Debuffs from the Unit and put it into the Master Aura Table.
    function Unit:GetDebuffs (GUID)
        if not module.AurasInfos[GUID] then module.AurasInfos[GUID] = {}; end
        module.AurasInfos[GUID].Debuffs = {};
        local Infos;
        for Index = 1, C.MAXIMUM_BUFFS do
            Infos = {UnitDebuff(GUID, Index)};
            if not Infos[11] then break; end
            table.insert(module.AurasInfos[GUID].Debuffs, Infos);
        end
        module.AurasInfos[GUID].Debuff = true;
    end

    --- Get a debuff on the unit caused by a spell from the player.
    -- @param Spell The spell hat caused the debuff.
    -- @return Information about the debuff (see UnitDebuff) or nil if the unit doesn't have it.
    function Unit:Debuff (Spell)
        local GUID = self:GUID();
        if not GUID then return nil; end
        if not module.AurasInfos[GUID] or not module.AurasInfos[GUID].Debuff then
            self:GetDebuffs(GUID);
        end
        if module.AurasInfos[GUID].Debuff then
            local SpellID = Spell:ID();
            local Table = module.AurasInfos[GUID].Debuffs;
            local Caster;
            for Index = 1, #Table do
                Caster = Table[Index][8];
                if Caster and SpellID == Table[Index][11] and (UnitIsUnit(Caster, "Player") or UnitIsUnit(Caster, "PlayerPet")) then
                    return unpack(Table[Index]);
                end
            end
        end
        return nil;
    end

    --- Get the time remaining on a debuff on the unit caused by a spell from the player.
    -- @param Spell The spell that caused the debuff.
    -- @return The time remaining, in seconds, on the debuff caused by the spell.
    function Unit:DebuffRemains (Spell)
        local ExpirationTime = select(7, self:Debuff(Spell));
        return ExpirationTime and ExpirationTime - module.GetTime() or 0;
    end

    --- Get the duration of a debuff on the unit caused by a spell from the player.
    -- @param Spell The spell that caused the debuff.
    -- @return The duration, in seconds, of the debuff caused by the spell.
    function Unit:DebuffDuration (Spell)
        return select(6, self:Debuff(Spell)) or 0;
    end

    --- Get whether the debuff is refreshable (under the pandemic threshold).
    -- @param Spell The spell that caused the debuff.
    -- @return Whether the debuff is refreshable.
    function Unit:DebuffRefreshable (Spell)
        if not self:Debuff(Spell) then return true; end
        return self:DebuffRemains(Spell) < self:DebuffDuration(Spell)*0.3;
    end

    function Unit:DebuffCount (Spell)
        return select(4, self:Debuff(Spell)) or 0;
    end

    --- Get the numbers in a debuff's tooltip.
    -- @param Spell - The Debuff ID to look for - Spell Object
    -- @return The numbers in the tooltip or 0 if the debuff is not found.
    function Unit:DebuffValue (Spell)
        if self:Debuff(Spell) then
            return module.GetNumbersForDebuff(self, Spell)[1]*1;
        else
            return 0;
        end
    end

    --- Get a debuff on the unit caused by a spell.
    -- @param Spell The spell hat caused the debuff.
    -- @return Information about the debuff (see UnitDebuff) or nil if the unit doesn't have it.
    function Unit:DebuffAny (Spell)
        local GUID = self:GUID();
        if not GUID then return nil; end
        if not module.AurasInfos[GUID] or not module.AurasInfos[GUID].Debuff then
            self:GetDebuffs(GUID);
        end
        if module.AurasInfos[GUID].Debuff then
            local SpellID = Spell:ID();
            local Table = module.AurasInfos[GUID].Debuffs;
            for Index = 1, #Table do
                if SpellID == Table[Index][11] then
                    return unpack(Table[Index]);
                end
            end
        end
        return nil;
    end

    --- Get the time remaining on a debuff on the unit caused by a spell.
    -- @param Spell The spell that caused the debuff.
    -- @return The time remaining, in seconds, on the debuff caused by the spell.
    function Unit:DebuffRemainsAny (Spell)
        local ExpirationTime = select(7, self:DebuffAny(Spell));
        return ExpirationTime and ExpirationTime - module.GetTime() or 0;
    end

    --- Get the duration of a debuff on the unit caused by a spell.
    -- @param Spell The spell that caused the debuff.
    -- @return The duration, in seconds, of the debuff caused by the spell.
    function Unit:DebuffDurationAny (Spell)
        return select(6, self:DebuffAny(Spell)) or 0;
    end

    function Unit:DebuffCountAny (Spell)
        return select(4, self:DebuffAny(Spell)) or 0;
    end

    function Unit:BossDebuffCount()
    local BossDebuffs = {143436, 146124,144358, 147029, 144467, 144215, 143494, 142990, 143766, 143780, 143773, 143767, 143385, 145183, 145195, 124275};
        for i=1, #BossDebuffs do
            if UnitDebuff(self.UnitID, GetSpellInfo(BossDebuffs[i])) then
                return select(4,UnitDebuff(self.UnitID, GetSpellInfo(BossDebuffs[i])));
            end
        end
        return 0;
    end

    function Unit:IsCrowdControlled (Breakable)
        local CC = not Breakable and {
            3355, -- Freezing Trap (Hunter)
            118, -- Polymorph (Mage)
            51514, -- Hex (Shaman)
            115078, -- Paralysis (Monk)
            6770, -- Sap (Rogue)
            20066, -- Repentance (Paladin)
            710, -- Banish (Warlock)
            5782, -- Fear (Warlock)
            118699, -- Fear (Warlock)
            339, -- Entangling Roots (Druid)
            --113770, -- Entangling Roots Force of Nature (Druid)
            102359, -- Mass Entanglement (Druid)
            19386, -- Wyvern Sting (Hunter)
            9484, -- Shackle Undead (Priest)
            10326, -- Turn Evil (Paladin)
            8122, -- Psychic Scream (Priest)
            2094, -- Blind (Rogue)
            82691, -- Ring of Frost (Mage)
            5246, -- Intimidating Shout (Warrior)
            5484, -- Howl of Terror (Warlock)
            6358, -- Seduction (Warlock Succubus)
            115268, -- Mesmerize (Warlock Shivarra)
            33786, -- Cyclone (Druid)
            28272, -- Polymorph Pig (Mage)
            28271, -- Polymorph Turtle (Mage)
            61305, -- Polymorph Black Cat (Mage)
            61721, -- Polymorph Rabbit (Mage)
            161353, -- Polymorph Polar Bear Cub (Mage)
            161354, -- Polymorph Monkey (Mage)
            161355, -- Polymorph Penguin (Mage)
            161372, -- Polymorph Peacock (Mage)
            61780, -- Polymorph Turkey (Mage)
            61025, -- Polymorph Serpent (Mage)
            126819 -- Polymorph Porcupine (Mage)
            --64044, -- Psychic Horror (Priest)
            --6789, -- Mortal Coil (Warlock)
            --137143, -- Blood Horror (Warlock)
            --1776, -- Gouge (Rogue)
            --107079, -- Quaking Palm (Pandaren Racial)
        } or {
            3355, -- Freezing Trap (Hunter)
            118, -- Polymorph (Mage)
            51514, -- Hex (Shaman)
            115078, -- Paralysis (Monk)
            6770, -- Sap (Rogue)
            20066, -- Repentance (Paladin)
            339, -- Entangling Roots (Druid)
            19386, -- Wyvern Sting (Hunter)
            9484, -- Shackle Undead (Priest)
            2094, -- Blind (Rogue)
            6358, -- Seduction (Warlock Succubus)
            115268, -- Mesmerize (Warlock Shivarra)
            28272, -- Polymorph Pig (Mage)
            28271, -- Polymorph Turtle (Mage)
            61305, -- Polymorph Black Cat (Mage)
            61721, -- Polymorph Rabbit (Mage)
            161353, -- Polymorph Polar Bear Cub (Mage)
            161354, -- Polymorph Monkey (Mage)
            161355, -- Polymorph Penguin (Mage)
            161372, -- Polymorph Peacock (Mage)
            61780, -- Polymorph Turkey (Mage)
            61025, -- Polymorph Serpent (Mage)
            126819 -- Polymorph Porcupine (Mage)
        };
        for i = 1, #CC do
            if self:BuffAny(module.Spell(CC[i])) then return false; end
        end
        return false;
    end

    --- Get whether the unit is in the player's party.
    -- @return Whether the unit is in the player's party.
    function Unit:IsInParty ()
        return UnitInParty(self.UnitID) or UnitIsUnit(self.UnitID, "Player");
    end

    --- Get whether the unit is in the player's raid.
    -- @return Whether the unit is in the player's raid.
    function Unit:IsInRaid ()
        return UnitInRaid(self.UnitID) ~= nil;
    end

    function Unit:Assist ()
        return AssistUnit(self.UnitID);
    end
    --- Get whether the unit is in the player's group.
    -- @return Whether the unit is in the player's group.
    function Unit:IsInGroup ()
        return self:IsInParty() or self:IsInRaid();
    end

    --- Get whether the unit is interruptible.
    -- @return Whether the unit is interruptible.
    function Unit:IsInterruptible ()
        local castName,_,_,_,_,endTime,_,_,notInterruptibleCast = UnitCastingInfo(self.UnitID)
        local channelName,_,_,_,_,endTime,_,notInterruptibleChannel = UnitChannelInfo(self.UnitID)
        if notInterruptibleCast == false or notInterruptibleChannel == false then
        return true
        end
        return false
    end

    function RoundUp(number, decimal)
        local multiplier = 10^(decimal or 0)
        return math.floor(number * multiplier + 1) / multiplier
    end

    -- TODO: implement this properly into tanking rotations, would be good to have spell damage mitigation as well
    function Unit:ActivateMitigation ()
        local ActiveMitigation = {153794}
        for i = 1, #ActiveMitigation do
            if UnitCastingInfo(self.UnitID) == GetSpellInfo(ActiveMitigation[i]) then
                return true;
            end
        end
        return false;
    end

    function Unit:BlacklistGroundCast ()
        local ThisCreature = self:CreatureID();
        for i = 1, #BlacklistGroundCastTargets do
            if ThisCreature == BlacklistGroundCastTargets[i] then
                return true;
            end
        end
        return false
    end

    --- Check if the Unit is Casting a specific spell
    -- @param Spell - The spell Object
    -- @return true if the unit is casting the spell
    function Unit:Casting (Spell)
        if Spell ~= nil then
            return UnitCastingInfo(self.UnitID) == GetSpellInfo(Spell:ID());
        else
            return UnitCastingInfo(self.UnitID) ~= nil;
        end
    end

    --- Check if the Unit is Channeling a specific spell
    -- @param Spell - The spell Object
    -- @return true if the unit is channeling the spell
    function Unit:Channeling (Spell)
        if Spell ~= nil then
            return UnitChannelInfo(self.UnitID) == GetSpellInfo(Spell:ID());
        else
            return UnitChannelInfo(self.UnitID);
        end
    end

    --- Get information about what the unit is casting.
    -- @return Information about what the unit is casting, or nil if the unit is not casting.
    function Unit:IsCasting ()
        return UnitCastingInfo(self.UnitID);
    end

    --- Get information about what the unit is Channeling.
    -- @return Information about what the unit is channeling, or nil if the unit is not channeling.
    function Unit:IsChanneling ()
        return UnitChannelInfo(self.UnitID);
    end

    function Unit:CastingPercentLeft (Spell)
        if UnitChannelInfo(self.UnitID) then
            if (Spell and UnitChannelInfo(self.UnitID) == GetSpellInfo(Spell:ID())) or not Spell then
                local spell, rank, displayName, icon, startTime, endTime, isTradeSkill, castID, interrupt = UnitChannelInfo(self.UnitID)
                local castLength = (endTime - startTime) / 1000
                local secondsLeft = endTime / 1000  - module.GetTime()
                return ((secondsLeft/castLength)*100);
            end
        end
        if UnitCastingInfo(self.UnitID) then
            if (Spell and UnitCastingInfo(self.UnitID) == GetSpellInfo(Spell:ID())) or not Spell then
                local spell, rank, displayName, icon, startTime, endTime, isTradeSkill, castID, interrupt = UnitCastingInfo(self.UnitID)
                local castLength = (endTime - startTime) / 1000
                local secondsLeft = endTime / 1000  - module.GetTime()
                return ((secondsLeft/castLength)*100);
            end
        end
    end

    function Unit:CastedPercent (Spell)
        if UnitChannelInfo(self.UnitID) then
            if (Spell and UnitChannelInfo(self.UnitID) == GetSpellInfo(Spell.Identifier)) or not Spell then
                local spell, rank, displayName, icon, startTime, endTime, isTradeSkill, castID, interrupt = UnitChannelInfo(self.UnitID)
                local castLength = (endTime - startTime) / 1000
                local secondsLeft = endTime / 1000  - module.GetTime()
                return ((secondsLeft/castLength)*100);
            end
            return 0;
        end
        if UnitCastingInfo(self.UnitID) then
            if (Spell and UnitCastingInfo(self.UnitID) == GetSpellInfo(Spell.Identifier)) or not Spell then
                local spell, rank, displayName, icon, startTime, endTime, isTradeSkill, castID, interrupt = UnitCastingInfo(self.UnitID)
                local castLength = (endTime - startTime) / 1000
                local secondsLeft = endTime / 1000  - module.GetTime()
                return 100-((secondsLeft/castLength)*100);
            end
        end
        return 0;
    end

    function Unit:ChannelingPercentLeft (Spell)
        if UnitChannelInfo(self.UnitID) and (not Spell or UnitChannelInfo(self.UnitID) == GetSpellInfo(Spell:ID())) then
            local spell, rank, displayName, icon, startTime, endTime, isTradeSkill, castID, interrupt = UnitChannelInfo(self.UnitID)
            local castLength = (endTime - startTime) / 1000
            local secondsLeft = endTime / 1000  - module.GetTime()
            return ((secondsLeft/castLength)*100);
        end
        return 0;
    end

    function Unit:ChannelingTimeLeft (Spell)
        if UnitChannelInfo(self.UnitID) and (not Spell or UnitChannelInfo(self.UnitID) == GetSpellInfo(Spell:ID())) then
            local spell, rank, displayName, icon, startTime, endTime, isTradeSkill, castID, interrupt = UnitChannelInfo(self.UnitID)
            local castLength = (endTime - startTime) / 1000
            local secondsLeft = endTime / 1000  - module.GetTime()
            return secondsLeft;
        end
        return 0;
    end

    function Unit:InCastRange (Spell)
        if self == Unit.Player then return true; end
        local spellIndex, spellBook = Spell:BookIndex()
        if not spellIndex then return false end
        return spellIndex and IsSpellInRange(spellIndex, spellBook, self.UnitID) == 1;
    end

    --- Verify if a spell is in range of a Specific unit
    -- @param Other - The other unit object
    -- @param Spell - The spell object
    -- @param ByPassWoWAPI - Set to true to use pure DistanceTo check with the spell's range attribute
    -- @return true is the spell check passed
    function Unit:IsWithinCastRange (Other, Spell)
        if not Spell then return false; end
        -- Standard WoW API Check
        if module.GetOptionValue("Range | Line Of Sight") == "WoW API" then
            return Other:InCastRange(Spell);
        -- Disabled
        elseif module.GetOptionValue("Range | Line Of Sight") == "Disabled" then
            return true;
        -- Custom API Check
        else
            -- Temp Feral Fix *---*
            if S and S.Rake and S.BalanceAffinity:Exists() then
                return Other:InCastRange(Spell);
            end
            -- Range Check
            local Range = Spell:MaximumRange();
            if Spell:IsMelee() then
                Range = 5;
            else
                Range = Range + ((self:IsMoving() and Other:IsMoving()) and 2 or 0);
            end

            -- DistanceTo Check
            return self:DistanceTo(Other) <= Range;
        end
    end

    --- Get the unit's melee range toward another unit.
    -- @param Other The other unit.
    -- @return The unit's melee range toward the other unit.
    function Unit:MeleeRange (Other)
        return self:CombatReach() and Other:CombatReach() and math.max(self:CombatReach() + Other:CombatReach() + 4 / 3 + ((self:IsMoving() and Other:IsMoving()) and 8 / 3 or 0), 5) or 1;
    end


    -- Phased Debuffs List
    local PhasedDebuffsList = {
        [89890] = 179407, -- Fel Lord Zakuun - Disembodied
        [90378] = 181488, -- Vision of Death
        [91809] = 181295 -- Gorefiend - Digest
    };
    -- Heal Immunity Debuffs List
    local HealImmunityDebuffsList = {
        [78491] = 159220, -- Necrotic Breath - Brakenspore
        [92330] = 190466, -- Soul of Socrethar - Soulbound Construct (Soulbound Construct unit ID is 90296)
        [91005] = 199176 -- Spiked Tongue - Naraxas - Neltharion's Lair
    };

    --- Check if a heal can be used on an allied unit
    -- @verify phased debuffs + bad debuffs depending on encounters
    -- @return true if the unit can be healed normally
    function Unit:PreventHealingChecks ()
        -- Get Boss ID
        local BossID = Boss1:Exists() and Boss1:CreatureID() or 0;
        -- Phased Debuffs
        local PhaseDebuff = BossID ~= 0 and PhasedDebuffsList[BossID] or nil;
        if PhaseDebuff then
            -- if player and self dont have the same phase debuff status then player wont be able to see self.
            if Player:DebuffAny(Spell(PhaseDebuff)) ~= self:DebuffAny(Spell(PhaseDebuff)) then
                return true;
            end
        end
        -- Immunity Debuffs
        local ImmunityDebuff = BossID ~= 0 and HealImmunityDebuffsList[BossID] or nil;
        if ImmunityDebuff then
            if self:DebuffAny(Spell(ImmunityDebuff)) then
                return true;
            end
        end
        return false;
    end

    --- Get whether the unit can cast a spell on another unit.
    -- Checks cooldown, attackability, and distance.
    -- @param Spell The spell.
    -- @return Whether the unit can cast the spell on the other unit.
    function Unit:CanCast (Spell, BypassMovingCheck, BypassUsable, BypassCrowdControl, BypassCooldown)
        -- Check if the Spell was properly passed along
        if Spell then
            -- Check if the Unit is Valid
            if self:Exists() then
                -- Check if the Spell can be used
                if BypassUsable or Spell:IsUsable() then
                    -- Check if spell is not on Cooldown
                    if BypassCooldown or not Spell:IsOnCooldown() then
                        -- Check if we are Standing or spell is Instant or can be cast while moving
                        if BypassMovingCheck or not module.Player:IsMoving() or Spell:CastTime() == 0 then
                            -- Check if the Spell Cannot be Interrupted by enemy disrupting spells
                            if Spell:InterruptFree() then
                                -- Check if on Player or Line Of Sight + Range + Facing + CC + BlackList
                                if self == Player or (Player:InLineOfSight(self) and Player:IsWithinCastRange(self, Spell) and (not Spell:IsFacingRequired() or Player:IsFacing(self)) and (BypassCrowdControl or not self:IsCrowdControlled()) and not self:Blacklist()) then
                                    -- Healing oriented Checks, if it's an allied cast then we need to check the debuffs lists
                                    if not Spell:IsHostile() then
                                        if (self == Player or Player:CanSupport(self)) and (Spell:IsResurrect() or not self:IsDeadOrGhost()) then
                                            if not self:PreventHealingChecks() then
                                                return true;
                                            end
                                        end
                                    elseif not self:IsDead() and Player:CanAttack(self) then
                                        return true;
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    function Unit:CanHeal (Spell, BypassMovingCheck, BypassUsable, BypassCrowdControl, BypassCooldown)
        return self:CanCast(Spell, BypassMovingCheck, BypassUsable, BypassCrowdControl, BypassCooldown);
    end



    function Unit:OldCanCast (Spell, BypassMovingCheck, BypassUsable, BypassCrowdControl, BypassCooldown)
        if not Spell then return false; end
        if not self:Exists() then return false; end
        if not BypassUsable and not Spell:IsUsable() then return false; end
        if not BypassCooldown and Spell:IsOnCooldown() then return false; end
        if not BypassMovingCheck and module.Player:IsMoving() and Spell:CastTime() > 0 then return false; end
        if not Spell:InterruptFree() then return false; end
        -- Prevent Being interrupted by bosses/dangerous spells
        if module.StopCastingSpells == true and module.GetTime() + Spell:CastTime() > module.StopCastingBefore then
            --module.Bug("|cffFFDD11Spell Interrupt - Prevent Casting|r " .. Spell:Name());
            return false;
        end

        if self ~= Unit.Player then
            if not Unit.Player:InLineOfSight(self) then return false; end
            if not Unit.Player:IsWithinCastRange(self, Spell) then return false; end
            if Spell:IsFacingRequired() and not Unit.Player:IsFacing(self) then return false; end
            if not BypassCrowdControl and self:IsCrowdControlled() then return false; end
            if self:Blacklist() then return false; end
        end

        local PhaseDebuff = module.Spell(181488);
        local Boss1 = module.Unit.Boss1;
        if Boss1:Exists() then
            local BossID = Boss1:CreatureID();
            -- Kilrog
            if BossID == 91809 then
                -- Digest
                PhaseDebuff = module.Spell(181295);
            -- Fel Lord Zakuun
            elseif BossID == 89890 then
                -- Disembodied
                PhaseDebuff = module.Spell(179407);
            end
        end
        local ConstructDebuff = module.Spell(190466); -- Socrethar Construct
        if (Unit.Player:CanSupport(self) and self:CreatureID() == 90296) or self:DebuffAny(ConstructDebuff) or self:BuffAny(ConstructDebuff) then return false; end -- Socrethar Construct
        if self:IsPlayer() and Unit.Player:DebuffAny(PhaseDebuff) and not self:DebuffAny(PhaseDebuff) then return false; end
        return ((self == Unit.Player and not Spell:IsHostile())
        or (Unit.Player:CanSupport(self) and self:IsDeadOrGhost() and Spell:IsResurrect())
        or (Unit.Player:CanAttack(self) and Spell:IsHostile() and not self:IsDead())
        or (Unit.Player:CanSupport(self) and not Spell:IsHostile() and not self:IsDeadOrGhost() and not Spell:IsResurrect()))
    end


    function Unit:DevCanCast (Spell, BypassMovingCheck, BypassUsable, BypassCrowdControl)
        if not Spell then print("Spell is left blank"); return false; end
        if not self:Exists() then print("Unit does not Exist"); return false; end
        if not BypassUsable and not Spell:IsUsable() then print("Spell is not Usable"); return false; end
        if Spell:IsOnCooldown() then print("Spell is on Cooldown"); return false; end
        if not BypassMovingCheck and module.Player:IsMoving() and Spell:CastTime() > 0 then print("Spell has a cast time and we are moving"); return false; end
        if not Spell:InterruptFree() then print("Spell is not Interrupt Free"); return false; end

        if self ~= Unit.Player then
            if not Unit.Player:InLineOfSight(self) then print("Unit not in Line of Sight"); return false; end
            if not Unit.Player:IsWithinCastRange(self, Spell) then print("Unit not in cast range"); return false; end
            if (not FacingEnabled() or Spell:CastTime() > 0) and Spell:IsFacingRequired() and not Unit.Player:IsFacing(self) then print("Not Facing Unit"); return false; end
            if not BypassCrowdControl and self:IsCrowdControlled() then print("Unit is Crowd Controlled"); return false; end
            if self:Blacklist() then print("Unit is Blacklisted"); return false; end
        end

        return ((self == Unit.Player and not Spell:IsHostile())
        or (Unit.Player:CanSupport(self) and self:IsDeadOrGhost() and Spell:IsResurrect())
        or (Unit.Player:CanAttack(self) and Spell:IsHostile() and not self:IsDead())
        or (Unit.Player:CanSupport(self) and not Spell:IsHostile() and not self:IsDeadOrGhost() and not Spell:IsResurrect()));
    end

    --- Get whether the unit can cast a spell on another unit.
    -- Checks cooldown, attackability, and distance.
    -- @param Spell The spell.
    -- @return Whether the unit can cast the spell on the other unit.
    function Unit:PetCanCast (Spell)
        return Spell:IsUsable() and not Spell:IsOnCooldown() and ((self == Unit.Player and not Spell:IsHostile()) or (Unit.Player:CanAttack(self) == Spell:IsHostile()) or (Unit.Player:CanSupport(self) ~= Spell:IsHostile())) and Unit.PlayerPet:IsWithinCastRange(self, Spell) and Unit.PlayerPet:InLineOfSight(self);-- and Spell:IsHostile() ~= self:IsDeadOrGhost();
    end

    --- Get whether the unit can support another unit.
    -- @param Other The other unit.
    -- @return Whether the unit can support the other unit.
    function Unit:CanSupport (Other)
        -- TODO: More accurate method.
        return not self:CanAttack(Other);
    end

    --- Get whether the unit is dead.
    -- @return Whether the unit is dead.
    function Unit:IsDead ()
        return UnitIsDead(self.UnitID);
    end

    --- Get whether the unit is a ghost.
    -- @return Whether the unit is a ghost.
    function Unit:IsGhost ()
        return UnitIsGhost(self.UnitID);
    end

    --- Get whether the unit is dead or a ghost.
    -- @return Whether the unit is dead or a ghost.
    function Unit:IsDeadOrGhost ()
        return UnitIsDeadOrGhost(self.UnitID);
    end

    --- Get the unit's creature ID.
    -- @return The unit's creature ID, or nil if the unit is a player.
    function Unit:CreatureID (BypassUnitTable)
        if BypassUnitTable then
            return UnitCreatureID(self.UnitID);
        else
            local GUID = UnitGUID(self.UnitID)
            if GUID then
                if module.UnitsInfos[GUID] then
                    return module.UnitsInfos[GUID].CreatureID;
                else
                    return UnitCreatureID(self.UnitID);
                end
            else
                return nil;
            end
        end
    end

    function UnitCreatureID (UnitID)
        local Parts = {};
        if not UnitGUID(UnitID) then return nil; end
        for Part in string.gmatch(UnitGUID(UnitID), "([^-]+)") do
            table.insert(Parts, Part);
        end

        if Parts[1] == "Creature" or "Pet" or "Vehicle" then
            return tonumber(Parts[6]);
        else
            return nil;
        end
    end

    --- Tell if an Unit is a Pet
    -- @return true if the unit is a Pet
    function Unit:IsPet ()
        local Parts = {};
        if not UnitGUID(self.UnitID) then return nil; end
        for Part in string.gmatch(UnitGUID(self.UnitID), "([^-]+)") do
            table.insert(Parts, Part);
        end
        return Parts[1] == "Pet";
    end

    function Unit:RakeDamage ()
        return module.BleedTable.Rake[self:GUID()] or 0.5;
    end

    function Unit:RipDamage ()
        return module.BleedTable.Rip[self:GUID()] or 0.5;
    end

    --- Get whether a unit is in line of sight of another unit.
    -- @param Other The other unit. Player if nil or not passed.
    -- @return Whether the unit is in line of sight of the other unit.
    local LoSExceptions = {
        { Id = 46753 }, -- Al Akir
        { Id = 56754 }, -- Shado-Pan Monastery - Azure Serpent
        { Id = 72156 }, -- Borrok the Devourer (Frostfire Ridge)
        { Id = 76267 }, -- Solar Zealot (Skyreach)
        { Id = 76379 }, -- Rukhran (Skyreach)
        { Id = 76585 }, -- Ragewing the Untamed (UBRS)
        { Id = 76973 }, -- Hans'gar (BRF)
        { Id = 76974 }, -- Franzok (BRF)
        { Id = 77182 }, -- Oregorger (BRF)
        { Id = 91331, Phase = 3 }, -- Archimonde Phase 3 (HFC)
        { Id = 91005 }, -- Neltharion's Lair - Naraxas
        { Id = 91808 }, -- Eye of Azshara - Serpentrix
        { Id = 96028 }, -- Eye of Azshara - Wrath of Azshara
        { Id = 97259 }, -- Eye of Azshara - Blazing Hydra Spawn (Serpentrix)
        { Id = 97260 }, -- Eye of Azshara - Arcane Hydra Spawn (Serpentrix)
        { Id = 96759 }, -- Helmouth Cliffs - Helya
        { Id = 98363 }, -- Helmouth Cliffs - Grasping Tentacle
        { Id = 98696 }, -- Black Rook Hold - Illysanna Ravencrest
        { Id = 99801 }, -- Helmouth Cliffs - Destructor Tentacle
        { Id = 100354 }, -- Helmouth Cliffs - Grasping Tentacle
        { Id = 100360 } -- Helmouth Cliffs - Grasping Tentacle
    }
    local losFlags =  bit.bor(0x10, 0x100)
    function Unit:InLineOfSight (Other)
        if module.GetSecondOptionValue("Range | Line Of Sight") == "Disabled" then
            return true;
        else
            if not Other.UnitID then return false; end
            if not GetUnitPosition(Other.UnitID) then return false; end
            if not self.UnitID then return false; end
            if not GetUnitPosition(self.UnitID) then return false; end
            local ThatCreature = Other:CreatureID();
            -- Line of Sight Exceptions - Cycle LoSExceptions Table
            for i = 1, #LoSExceptions do
                if ThatCreature == LoSExceptions[i].Id and (LoSExceptions[i].Phase == nil or LoSExceptions[i].Phase == module.EncounterPhase) then
                    return true;
                end
            end
            local sX, sY, sZ = GetUnitPosition(self.UnitID);
            local oX, oY, oZ = GetUnitPosition(Other.UnitID);
            return TraceLine(sX, sY, sZ + 2.25, oX, oY, oZ + 2.25, losFlags--[[0x111]]) == nil;
        end
    end

    function Unit:IsLineOfSight (time)
        local GUID = UnitGUID(self.UnitID)
        LoSTable = {};
        Soapbox_LOSLog = CreateFrame('Frame')
        Soapbox_LOSLog:RegisterEvent("COMBAT_LOG_EVENT_UNFILTERED")
            function LOSCheck(self, event, ...)
            local AlreadyTabled = false;
            local type, _, sourceGUID, sourceNAME, _, _, destGUID, destNAME = select(2, ...)
                if (event=="COMBAT_LOG_EVENT_UNFILTERED") then
                    if sourceGUID == UnitGUID("player") then
                        if type=="SPELL_CAST_FAILED" then
                            local Log = {...};
                            if Log[15] == SPELL_FAILED_LINE_OF_SIGHT then
                                for i=1, #LoSTable do
                                    if GUID == LoSTable[i].unit then
                                        AlreadyTabled = true
                                    end
                                end
                                if not AlreadyTabled then
                                    table.insert(LoSTable, { unit=GUID, time=module.GetTime() } )
                                end
                            end
                        end
                    end
                end
            end
        Soapbox_CombatLog:SetScript('OnEvent', LOSCheck)
        LOSLog = true

        local time=time or 5
        if GUID == nil then return false; end
        for j=1, #LoSTable do
            if time < (module.GetTime() - LoSTable[j].time) then
                table.remove(LoSTable, j)
                break
            end
        end

        for k=1, #LoSTable do
            if GUID and GUID == LoSTable[k].unit then
                return false
            end
         end
        return true
    end

    --- Get the group member with the lowest health.
    -- @return The group member with the lowest health.
    function Unit.Lowest (ExcludedMainTank, ExcludedOffTank)
        local Lowest = nil;
        local LowestHealth = nil;
        local SpecialDebuff = false;
        local TouchOfHarm = module.Spell(180166);
        local PhaseDebuff = module.Spell(181488);
        local Boss1 = module.Unit.Boss1;
        if Boss1:Exists() then
            local BossID = Boss1:CreatureID();
            -- Kilrog
            if BossID == 91809 then
                -- Digest
                PhaseDebuff = module.Spell(181295);
            -- Fel Lord Zakuun
            elseif BossID == 89890 then
                -- Disembodied
                PhaseDebuff = module.Spell(179407);
            end
        end
        if select(3,UnitClass("player")) == 8 then CasterID = module.Spell(30455, false, false, true) -- Mage
        elseif select(3,UnitClass("player")) == 9 then CasterID = module.Spell(1490, false, false, true) -- Warlock
        elseif select(3,UnitClass("player")) == 5 then CasterID = module.Spell(2061, false, false, true) -- Priest
        elseif select(3,UnitClass("player")) == 11 then CasterID = module.Spell(5185, false, false, true) -- Druid
        elseif select(3,UnitClass("player")) == 7 then CasterID = module.Spell(8004, false, false, true) -- Shaman
        elseif select(3,UnitClass("player")) == 6 then CasterID = module.Spell(45477, false, false, true) -- Death Knight
        elseif select(3,UnitClass("player")) == 2 then CasterID = module.Spell(82326, false, false, true) -- Paladin
        elseif select(3,UnitClass("player")) == 1 then CasterID = module.Spell(355, false, false, true) -- Warrior
        elseif select(3,UnitClass("player")) == 10 then CasterID = module.Spell(116694, false, false, true) -- Monk
        elseif select(3,UnitClass("player")) == 3 then CasterID = module.Spell(3044, false, false, true) -- Hunter
        elseif select(3,UnitClass("player")) == 4 then CasterID = module.Spell(1776, false, false, true) -- Rogue
        elseif select(3,UnitClass("player")) == 2 then CasterID = module.Spell(4987, false, false, true) -- Paladin
        end
        Unit.FirstGroupWhere(
            function (Unit)
                if Unit:Exists() and (not ExcludedMainTank or not Unit:Equals(ExcludedMainTank)) and (not ExcludedOffTank or not Unit:Equals(ExcludedOffTank)) and (not Lowest or Unit:SpecialHealthPercentage() < LowestHealth) and not Unit:IsDeadOrGhost() and Unit.Player:IsWithinCastRange(Unit, CasterID) and Unit.Player:InLineOfSight(Unit) and (not Unit:DebuffAny(TouchOfHarm) or UnitIsUnit(Unit.UnitID, 'focus')) and ((not Unit.Player:DebuffAny(PhaseDebuff) and not Unit:DebuffAny(PhaseDebuff)) or (Unit.Player:DebuffAny(PhaseDebuff) and Unit:DebuffAny(PhaseDebuff))) then
                    Lowest = Unit;
                    LowestHealth = Unit:SpecialHealthPercentage();
                end

                return false;
            end,
        true);
        return Lowest;
    end

    function Unit.MainTank ()
            local Tanks = Unit.GroupWhere(
            function (Unit)
                return UnitGroupRolesAssigned(Unit.UnitID) == "TANK" or Unit:CreatureID() == 72218;
            end,
        true);

        if #Tanks == 1 then
            return Tanks[1];
        elseif #Tanks > 1 then
            table.sort(Tanks,
                function (Left, Right)
                    return Left:MaxHealth() > Right:MaxHealth();
                end
            );

            return Tanks[1];
        else
            return nil;
        end
    end


    function Unit.OffTank ()
            local Tanks = Unit.GroupWhere(
            function (Unit)
                return UnitGroupRolesAssigned(Unit.UnitID) == "TANK" and not UnitIsUnit(Unit.UnitID, 'focus') and not Unit:CreatureID() ~= 72218;
            end,
        true);
        if #Tanks == 1 then
            return Tanks[1];
        elseif #Tanks > 1 then
            table.sort(Tanks,
                function (Left, Right)
                    return Left:MaxHealth() < Right:MaxHealth();
                end
            );

            return Tanks[1];
        else
            return nil;
        end
    end

    --- Get The Main Tanks
    -- @returns MainTank, MainTankTarget, OffTank, OffTankTarget
    function Unit.GetMainTanks ()
        local Player, Focus, Unit = module.Player, module.Unit.Focus, module.Unit;
        local MainTank, MainTankTarget, OffTank, OffTankTarget;
        local TheseUnits, AllTanks = {}, {};

        if IsInRaid() then
            for Index = 1, GetNumGroupMembers() do
                local ThisUnit = Unit("Raid" .. Index);
                if ThisUnit:Exists() then
                    table.insert(TheseUnits, ThisUnit);
                end
            end
        else
            for Index = 1, GetNumGroupMembers() - 1 do
                local ThisUnit = Unit("Party" .. Index);
                if ThisUnit:Exists() then
                    table.insert(TheseUnits, ThisUnit);
                end
            end
            table.insert(TheseUnits, Unit.Player);
        end

        -- Get Table of Tanks
        for i = 1, #TheseUnits do
            local ThisUnit = TheseUnits[i];
            if ThisUnit:Exists() and not ThisUnit:IsDeadOrGhost() and Player:InLineOfSight(ThisUnit) and (UnitGroupRolesAssigned(ThisUnit.UnitID) == "TANK" or ThisUnit:CreatureID() == 72218) then
                table.insert(AllTanks, ThisUnit);
            end
        end
        table.sort(AllTanks, function (x, y) return x:MaxHealth() > y:MaxHealth(); end );

        -- If we have a focus, we set it main tank
        if module.IsOptionEnabled("Focus Assignation") and Focus:Exists() and not Focus:IsDeadOrGhost() and (Player:CanSupport(Focus) or Player:Equals(Focus)) then
            if module.GetOptionValue("Focus Assignation") == "Main Tank" then
                MainTank = Focus;
            else
                OffTank = Focus;
            end
        end

        -- Find a Main Tank if we have no Focus
        MainTank = not MainTank and IsInGroup() and AllTanks[1] or MainTank;
        MainTankTarget = MainTank and Unit(MainTank.UnitID .. "target") or nil;

        -- Find an Off Tank if we have a Main Tank
        if not OffTank and MainTank and AllTanks[1] and IsInGroup() and not MainTank:Equals(AllTanks[1]) then
            OffTank = AllTanks[1];
        elseif not OffTank then
            OffTank = AllTanks[2];
        end
        OffTankTarget = OffTank and Unit(OffTank.UnitID .. "target") or nil;

        MainTank = MainTank and OffTank and OffTank:Equals(MainTank) and AllTanks[2] or MainTank;

        -- Define the Outputs
        module.SetOutput("|cFF9A2EFEMain Tank:", MainTank and MainTank:Name() or "No Main Tank");
        module.SetOutput("|cFF9A2EFEOff Tank:", OffTank and OffTank:Name() or "No Off Tank");

        return MainTank, MainTankTarget, OffTank, OffTankTarget;
    end


    -- In a run once environment we shall create the Tooltip that we will be reading
    -- all of the spell details from
    nGTT = CreateFrame( "GameTooltip", "MyScanningTooltip", nil, "GameTooltipTemplate" ); -- Tooltip name cannot be nil
    nGTT:SetOwner( WorldFrame, "ANCHOR_NONE" );
    -- Allow tooltip SetX() methods to dynamically add new lines based on these
    nGTT:AddFontStrings(
       nGTT:CreateFontString( "$parentTextLeft1", nil, "GameTooltipText" ),
       nGTT:CreateFontString( "$parentTextRight1", nil, "GameTooltipText" ) );
    module.nDbDmg = nil
    --print(issecure()) -- before function is ran, but after TT is created
    function nDbDmg(tar, spellID, player)
       --print(UnitDebuff2(tar, spellID, player))
       if GetCVar("DotDamage") == nil then
          RegisterCVar("DotDamage", 0)
       end
       nGTT:ClearLines()
       for i=1, 40 do
          debuff,_,_,count,_,_,expires,caster,_,_,id,_,_,_,power = _G['UnitDebuff'](tar, i, player)
          if player==nil then player = "player" end
          if id == spellID and player == "player" then
             nGTT:SetUnitDebuff(tar, i, player)
             scanText=_G["MyScanningTooltipTextLeft2"]:GetText()
             local DoTDamage = scanText:match("([0-9]+%.?[0-9]*)")
       --if not issecure() then print(issecure()) end -- function is called inside the profile
             SetCVar("DotDamage", tonumber(DoTDamage))
             return tonumber(GetCVar("DotDamage"))
          end
       end
    end

    local UnitAura_Trampoline = UnitAura;
    function UnitAuraAll (...)
        return UnitAura(...);
    end

    local UnitBuff_Trampoline = UnitBuff;
    function UnitBuffAll (...)
        return UnitBuff_Trampoline(...);
    end

    local UnitDebuff_Trampoline = UnitDebuff;
    function UnitDebuffAll (...)
        return UnitDebuff_Trampoline(...);
    end

    --- Function to get the best cluster of mobs to cast on, this is for Sunfire/Hand of Gul'dan/Flame Strike
    -- @param Debuff - the debuff we are looking to apply
    -- @param Remains - maximum remaining on dots to reapply
    -- @param Radius - maximum radius of clusters
    -- @param Facing - requires facing
    function Unit:BestClusterOfMobsToDot(Debuff, Remains, Radius, Facing)
        -- we need to make sure the unit is in range (40 yards)
        local allUnits = {};
        -- this is our position, we will use it to gather all the units around us
        local uX, uY, uZ = GetUnitPosition(self.UnitID);
        -- this will give us the count of units that are in our range
        local allUnitsAround = GetUnitNearPositionCount(uX, uY, uZ, 40);
        -- for each units in our range we will add them to the table of units if they are valid
        for i = 1, allUnitsAround do
            local ThisUnit = GetUnitNearPositionByIndex(i);
            if (Facing ~= true or self:IsFacing(Unit(ThisUnit))) and Unit(ThisUnit):Exists() and not UnitIsDeadOrGhost(ThisUnit) and self:DistanceTo(Unit(ThisUnit)) <= 40 and not Unit(ThisUnit):IsHardBlacklisted() and (UnitAffectingCombat(ThisUnit) or UnitIsDummy(ThisUnit)) and UnitCanAttack("Player", ThisUnit) and not Unit(ThisUnit):IsCrowdControlled() then
                table.insert(allUnits, Unit(ThisUnit));
            end
        end
        -- now we get our table built, we are going to recycle it to check all the units against eachother
        local bestUnit = nil;
        local bestUnitCount = 0;
        for i = 1, #allUnits do
            local ThisUnit = allUnits[i];
            local thisUnitCount = 0;
            for j = 1, #allUnits do
                local ThisUnit2 = allUnits[j];
                if ThisUnit:DistanceTo(ThisUnit2) <= Radius and ThisUnit:DebuffRemains(Debuff) < Remains then
                    thisUnitCount = thisUnitCount + 1;
                end
            end
            -- if this unit beat best then select this one
            if thisUnitCount > bestUnitCount then
                bestUnit = ThisUnit;
                bestUnitCount = thisUnitCount;
            end
        end
        return bestUnit;
    end

    --- Function to get the best cluster of allies to cast AoE Heal on, this is for Holy Radiance
    -- @MinimumUnits - Number of units that need to be in range of the spell to be valid
    -- @MinimumHealth - Health threshold under wich units are considered valid
    -- @Radius - maximum radius of clusters
    -- @GroupCheck - true to use with group checks
    function Unit:BestClusterOfAlliesToHeal (MinimumUnits, MinimumHealth, Radius, GroupCheck, BuffCheck)
        local inRaid = IsInRaid();
        -- we need to make sure the unit is in range (40 yards)
        local allUnits = self:HealUnitsAround(MinimumHealth, 40);
        -- now we get our table built, we are going to recycle it to check all the units against eachother
        local bestUnit = nil;
        local bestUnitCount = 0;
        for i = 1, #allUnits do
            local ThisUnit = allUnits[i];
            local thisUnitCount = 0;
            local unitGroup = 0;
            if not BuffCheck or ThisUnit:BuffRemains(BuffCheck) < 3 then
                if GroupCheck then
                    if inRaid and UnitInRaid(ThisUnit) ~= nil then
                        unitGroup = select(3,GetRaidRosterInfo(UnitInRaid(ThisUnit)))
                    end
                end
                for j = 1, #allUnits do
                    local ThisUnit2 = allUnits[j];
                    local unit2Group = 0;
                    if GroupCheck then
                        if inRaid and UnitInRaid(ThisUnit2) ~= nil then
                            unit2Group = select(3,GetRaidRosterInfo(UnitInRaid(ThisUnit2)))
                        end
                    end
                    if ThisUnit:DistanceTo(ThisUnit2) <= Radius and (not GroupCheck or unit2Group == unitGroup) then
                        thisUnitCount = thisUnitCount + 1;
                    end
                end
                -- if this unit beat best then select this one
                if thisUnitCount >= MinimumUnits and thisUnitCount >= bestUnitCount then
                    bestUnit = ThisUnit;
                    bestUnitCount = thisUnitCount;
                end
            end
        end
        return bestUnit;
    end

    -- Cast Ground Method Spell, Minimum Units,                 Radius, Range from player, Allow in-movement,
    -- Player:CastGround(Earthquake, module.GetOptionValue(Earthquake:Name()), 8, 30, false);
    function Unit:CastGround (Spell, MinimumUnits, Radius, RangeFromPlayer, AllowInMovement)

        --Bypass checking units if we dont need to
        if self == Unit.Player and (not MinimumUnits or MinumumUnits == nil or MinumumUnits == 0) then
            local ThisPosition = Unit.Player:Position();
             local pX,pY,pZ = ThisPosition["X"],ThisPosition["Y"],ThisPosition["Z"];
            CastSpellByName(Spell:Name(), self.UnitID);
            if IsAoEPending() then
                CastAtPosition(pX,pY,pZ);
                return true;
            end
            return false;
        end

        local CurrentTarget = Target;
        module.CenteredSpellList[Spell:ID()] = module.CenteredSpellList[Spell:ID()] or true;
        -- we need to make sure the unit is in range (40 yards)
         allUnits = {};
        -- this will give us the units that are in our range
        allUnitsAround = module.Player:EnemiesWithinDistance(40, true, true);
        -- for each units in our range we will add them to the table of units if they are valid
        for i = 1, #allUnitsAround do
            local ThisUnit = allUnitsAround[i];
            if CurrentTarget:DistanceTo(ThisUnit) <= Radius*2 and (AllowInMovement or not ThisUnit:IsMoving()) and ThisUnit:Exists() and UnitCanAttack("Player", ThisUnit.UnitID)
              and not ThisUnit:IsDeadOrGhost() and module.Player:DistanceTo(ThisUnit) <= RangeFromPlayer and (ThisUnit:IsInCombat() or ThisUnit:IsDummy())
              and not ThisUnit:IsHardBlacklisted() and not ThisUnit:IsCrowdControlled() and not ThisUnit:BlacklistGroundCast() then
                table.insert(allUnits, ThisUnit);
            end
        end
        -- now we get our table built, we are going to recycle it to check all the units against eachother
        local bestUnits = {};
        for i = 1, #allUnits do
            local ThisUnit = allUnits[i];
            local theseUnits = {};
            for j = 1, #allUnits do
                local ThisUnit2 = allUnits[j];
                if ThisUnit:DistanceTo(ThisUnit2) <= Radius then
                    table.insert(theseUnits, ThisUnit2);
                end
            end
            -- if this unit beat best then select this one
            if #theseUnits >= MinimumUnits and #theseUnits >= #bestUnits then
                bestUnits = theseUnits;
            end
        end
        -- now that we know what group of mobs we want to cast on, let's cast
        if #bestUnits > 0 then
            if #bestUnits > 1 then
                -- find middle
                local MidX, MidY, MidZ, TotalX, TotalY, TotalZ, UnitsCount, ThisPosition = 0, 0, 0, 0, 0, 0, 0, nil;
                for i = 1, #bestUnits do
                    UnitsCount = UnitsCount + 1;
                    ThisPosition = bestUnits[i]:Position()
                    TotalX, TotalY, TotalZ = TotalX + ThisPosition["X"], TotalY + ThisPosition["Y"], TotalZ + ThisPosition["Z"];
                end
                if UnitsCount > 0 then
                    MidX, MidY, MidZ = TotalX/UnitsCount, TotalY/UnitsCount, TotalZ/UnitsCount
                    CastSpellByName(Spell:Name(), self.UnitID);
                    if IsAoEPending() then
                        CastAtPosition(MidX,MidY,MidZ);
                        return true;
                    end
                end
            else
                local ThisPosition = bestUnits[1]:Position()
                local MidX, MidY, MidZ = ThisPosition["X"], ThisPosition["Y"], ThisPosition["Z"];
                CastSpellByName(Spell:Name(), self.UnitID);
                if IsAoEPending() then
                    CastAtPosition(MidX, MidY, MidZ);
                    return true;
                end
            end
        end
    end

    --- Cast Ground with dropdown options
    -- @param ThisSpell The spell we want to cast - ConsecrationGlyph
    -- @param OptionName The name of the option we use in the UI - "Consecration"
    -- @param Radius The radius of the spell's area - 6
    -- module.AddNewOption("Offensive Settings", "Consecration", {7, 1, 10, 1}, true, "Use Spell on Target or Centered Between Units, Standing means spell will be used only if units are not moving", { "Target", "Target Standing", "Centered", "Centered Standing" }, 1);
    -- Target:CastGroundSpell(ConsecrationGlyph, "Consecration", 6);
    module.CenteredSpellFailed = 0;
    function Unit:CastGroundSpell (ThisSpell, OptionName, Radius)
        local Target, Player, MaxRange = Target, module.Player, ThisSpell:MaximumRange();
        local Mode, UnitsOption = module.GetOptionValue(OptionName), module.GetSecondOptionValue(OptionName);
        -- If mode is "Target" then we use on target
        if Mode == "Target" or (Mode == "Target Standing" and (not Target:IsMoving() or Player:DistanceTo(Target) < Radius)) or ((Mode == "Centered" or Mode == "Centered Standing") and module.CenteredSpellFailed > GetTime()) then
            local TargetUnits = Target:EnemiesWithinDistance(Radius);
            if not Target:BlacklistGroundCast() and #TargetUnits >= UnitsOption and Target:CanCast(ThisSpell) and Player:DistanceTo(Target) <= MaxRange then
                Target:Cast(ThisSpell, nil, 8, 1.2);
                return true;
            end
        end
        if Mode == "Centered" or Mode == "Centered Standing" then
            local AllowInMovement = Mode == "Centered Standing" and false or true
            if Target:CastGround(ThisSpell, UnitsOption, Radius, MaxRange, AllowInMovement) then
                return true;
            end
        end
    end

    --- Cast a Chained Spell if possible based on Arguments given.
    -- @return True if we casted the Chained Spell.
    function Unit:Chain (Spell, MinimumUnits, Bounce, RangeFromPlayer, AllowInMovement)
        -- Local Variables
        local Units = {};
        local MaxRange = RangeFromPlayer+Bounce*(MinimumUnits-1);
        local ThisUnit, ThisUnit2, MinDistance, MinDistanceKey;
        -- Get Units from MaxRange (Range from Player + Bounce*Bounced_Units)
        local UnitsAround = Player:EnemiesWithinDistance(MaxRange, false, true);
        -- Add Unit and Distance from Player in the table if they are valid units.
        for i = 1, #UnitsAround do
            ThisUnit = UnitsAround[i];
            if (AllowInMovement or not ThisUnit:IsMoving()) and (ThisUnit:IsInCombat() or ThisUnit:IsDummy()) and not ThisUnit:IsCrowdControlled() then
                table.insert(Units, {Unit = ThisUnit, Distance = Player:DistanceTo(ThisUnit)});
            end
        end
        -- Sort Units by Distance.
        table.sort(Units, function(a, b) return a.Distance < b.Distance; end);
        -- Check Units + Bounced Units then Cast if possible.
        for i = 1, #Units do
            ThisUnit = Units[i].Unit;
            if ThisUnit:CanCast(Spell) then
                if MinimumUnits == 1 then
                    ThisUnit:Cast(Spell);
                    return true;
                else
                    -- 1st Bounce
                    MinDistance, MinDistanceKey = Bounce, nil;
                    for j = 1, #Units do
                        if i ~= j then
                            ThisUnit2 = Units[j].Unit;
                            ThisUnit2Distance = ThisUnit:DistanceTo(ThisUnit2, true);
                            if ThisUnit2Distance <= Bounce and ThisUnit2Distance < MinDistance then
                                MinDistance, MinDistanceKey = ThisUnit2Distance, j;
                            end
                        end
                    end
                    if MinDistanceKey then
                        if MinimumUnits == 2 then
                            ThisUnit:Cast(Spell);
                            return true;
                        else
                            -- 2nd Bounce
                            for k = 1, #Units do
                                if i ~= k and MinDistanceKey ~= k then
                                    if Units[MinDistanceKey].Unit:DistanceTo(Units[k].Unit, true) <= Bounce then
                                        ThisUnit:Cast(Spell);
                                        return true;
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        return false;
    end

    --- Return a Unit that needs to be resurrected that was not already resurrected by anyone in the last 30 seconds.
    -- @param - Spell - The spell we want to use to resurrect this unit - Spell Object
    local ResurrectUnit, ResurrectUnitDelay;
    function Unit.ResurrectCycle (Spell)
        if not ResurrectUnit then
            ResurrectUnit, ResurrectUnitDelay = Unit.FirstGroupWhere(
                function (ThisUnit)
                    return ThisUnit:IsDeadOrGhost() and Unit.Player:IsWithinCastRange(ThisUnit, Spell) and Unit.Player:InLineOfSight(ThisUnit) and not ThisUnit:HasPendingResurrection();
                end
            , false), module.GetTime() + 1;
        end
        if ResurrectUnit and ResurrectUnitDelay < module.GetTime() and module.Player:Standing() >= 0.2 and ResurrectUnit:CanCast(Spell) then
            ResurrectUnit:Cast(Spell);
            module.LastResurrectionTarget = select(2, ResurrectUnit:Name()) and select(1, ResurrectUnit:Name()) .. "-" .. select(2, ResurrectUnit:Name()) or ResurrectUnit:Name();
            module.LastResurrectionTime, ResurrectUnit, ResurrectUnitDelay = module.GetTime(), nil, module.GetTime() + 5;
            return true;
        else
            return false;
        end
    end

    -- Pending Resurrection tied with Events
    function Unit:HasPendingResurrection ()
        if select(2, self:Name()) then
            return (module.ResurrectedUnits[select(1, self:Name()) .. "-" .. select(2, self:Name())] and module.ResurrectedUnits[select(1, self:Name()) .. "-" .. select(2, self:Name())] > module.GetTime() - 30) or false;
        else
            return (module.ResurrectedUnits[self:Name()] and module.ResurrectedUnits[self:Name()] > module.GetTime()) or false;
        end
    end


    -- Units we want to focus heal when we target them
    module.ShouldBeHealedUnits = {
        ["88289"] = 100, -- Horde Dummy
        ["88316"] = 100, -- Horde Dummy
        ["90388"] = 100 -- Gorefiend - Tortured Essence
    };
    -- Returns true if the current target should be healed as top priority
    function Unit:ShouldBeHealed ()
        local ThisUnitID = select(6,strsplit("-", self:GUID() or ""))
        return module.ShouldBeHealedUnits[ThisUnitID] or 0;
    end

    local function GetAnglesBetweenPositions (X1, Y1, Z1, X2, Y2, Z2)
        local Angle = math.sqrt(math.pow(X1 - X2, 2) + math.pow(Y1 - Y2, 2))
        if Angle == 0 then Angle = 1 end
        return math.atan2(Y2 - Y1, X2 - X1) % (math.pi * 2), math.atan((Z1 - Z2) / Angle) % math.pi;
    end

    local function GetAnglesBetweenObjects (Object1, Object2)
        local X1, Y1, Z1 = GetUnitPosition(Object1);
        local X2, Y2, Z2 = GetUnitPosition(Object2);
        return GetAnglesBetweenPositions(X1, Y1, Z1, X2, Y2, Z2);
    end

    --- Get table with units in a frontal cone of a given unit
    -- @param Unit - Unit Object
    -- @param Unit - Maximum Range of ability
    -- @param Angle - Defined 360 degrees related value
    function Unit:UnitsInFrontConeAroundUnit (Unit, Range, Angle)
        -- My angle compared to my target on the field
        local X1,Y1,Z1 = self:Position():Expand();
        local X2,Y2,Z2 = Unit:Position():Expand();
        if not X1 or not X2 then return {}; end
        local MyAngleToTarget = GetAnglesBetweenPositions(X1, Y1, Z1, X2, Y2, Z2);
        local ConeUnits = {};
        local TheseEnemies = self:EnemiesWithinDistance(Range, true);
        for i = 1, #TheseEnemies do
            local ThisUnit = TheseEnemies[i];
            if not self:Equals(ThisUnit) then
                -- My angle compared to other units
                local X3,Y3,Z3 = ThisUnit:Position():Expand();
                if X1 and X3 then
                    local MyAngleToOtherUnit = GetAnglesBetweenPositions(X1, Y1, Z1, X3, Y3, Z3);
                    -- Compare both, trick the calc for NW cadran
                    local AnglesDifference = MyAngleToTarget > MyAngleToOtherUnit and MyAngleToTarget - MyAngleToOtherUnit or MyAngleToOtherUnit - MyAngleToTarget
                    -- Find shortest path in rad
                    local AnglesBetweenUnits = AnglesDifference < math.pi and AnglesDifference or math.pi*2 - AnglesDifference;
                    -- We want to define the maxvalue on /360 to make it viable for every quarters directly from 360 degrees values
                    local FinalAngle = AnglesBetweenUnits/math.pi*360;
                    if (FinalAngle < Angle or (self:DistanceTo(ThisUnit) < 3 and self:IsFacing(ThisUnit))) then
                        table.insert(ConeUnits, ThisUnit);
                    end
                end
            end
        end
        return ConeUnits;
    end

    --- Get table with units in a frontal cone of a given unit
    -- @param Range - Maximum Range of ability
    -- @param Angle - Defined 360 degrees related value
    function Unit:UnitsInFrontCone (Range, Angle, Allies, AlliesHealth)
        local X1,Y1,Z1 = self:Position():Expand();
        local MyAngle = self:Facing();
        local ConeUnits = {};
        local TheseEnemies = Allies and self:HealUnitsAround(AlliesHealth, Range) or self:EnemiesWithinDistance(Range, true);
        for i = 1, #TheseEnemies do
            local ThisUnit = TheseEnemies[i];
            if not self:Equals(ThisUnit) and (ThisUnit:Health() > 100 or ThisUnit:IsDummy()) then
                -- My angle compared to other units
                local X3,Y3,Z3 = ThisUnit:Position():Expand();
                if X1 and X3 then
                    local MyAngleToOtherUnit = GetAnglesBetweenPositions(X1, Y1, Z1, X3, Y3, Z3);
                    -- Compare both, trick the calc for NW cadran
                    local AnglesDifference = MyAngle > MyAngleToOtherUnit and MyAngle - MyAngleToOtherUnit or MyAngleToOtherUnit - MyAngle
                    -- Find shortest path in rad
                    local AnglesBetweenUnits = AnglesDifference < math.pi and AnglesDifference or math.pi*2 - AnglesDifference
                    -- We want to define the maxvalue on /360 to make it viable for every quarters directly from 360 degrees values
                    local FinalAngle = AnglesBetweenUnits/math.pi*360
                    if FinalAngle < Angle then
                        table.insert(ConeUnits, ThisUnit);
                    end
                end
            end
        end
        if Allies and self:SpecialHealthPercentage() <= AlliesHealth then table.insert(ConeUnits, self); end
        return ConeUnits;
    end

    --- Get table with units in a frontal rectangle
    -- @param Range - Maximum Range of ability - numeric
    -- @param Width - Width of the area on each sides - numeric
    -- @param Allies - true if we need to check in the allies table - Boolean
    -- @param AlliesHealth - Health of Allies we want to include - numeric
    function Unit:UnitsInFrontRectangle (Range, Width, Allies, AlliesHealth)
        local X1,Y1,Z1 = self:Position():Expand();
        local MyAngle = self:Facing();
        local RectangleUnits = {};
        local TheseEnemies = Allies and self:HealUnitsAround(AlliesHealth, Range) or self:EnemiesWithinDistance(Range, true);
        -- Left Projection
        local Left90 = MyAngle - math.pi/2
        Left90 = Left90 < 0 and Left90 + math.pi*2 or Left90
        local LeftProjX, LeftProjY = X1 + math.cos(Left90) * Width, Y1 + math.sin(Left90) * Width
        -- Right Projection
        local Right90 = MyAngle + math.pi/2
        Right90 = Right90 < math.pi*2 and Right90 or Right90 - math.pi*2
        local RightProjX, RightProjY = X1 + math.cos(Right90) * Width, Y1 + math.sin(Right90) * Width
        for i = 1, #TheseEnemies do
            local ThisUnit = TheseEnemies[i];
            if not self:Equals(ThisUnit) and (ThisUnit:Health() > 100 or ThisUnit:IsDummy()) then
                -- ThisUnit Position
                local X2, Y2, Z2 = ThisUnit:Position():Expand()
                if X2 then
                    -- Get Left Projection Angle to ThisUnit
                    local LeftProjAngleToOtherUnit = GetAnglesBetweenPositions(LeftProjX, LeftProjY, Z1, X2, Y2, Z2);
                    -- Get Right Projection Angle to ThisUnit
                    local RightProjAngleToOtherUnit = GetAnglesBetweenPositions(RightProjX, RightProjY, Z1, X2, Y2, Z2);
                    local IsLeftOK = MyAngle > math.pi/2*3 and LeftProjAngleToOtherUnit < math.pi/2 and LeftProjAngleToOtherUnit + math.pi*2 - MyAngle < math.pi/2 or LeftProjAngleToOtherUnit - MyAngle > 0
                    local IsRightOK = MyAngle < math.pi/2 and RightProjAngleToOtherUnit > math.pi/2*3 and MyAngle + math.pi*2 - RightProjAngleToOtherUnit < math.pi/2 or MyAngle - RightProjAngleToOtherUnit > 0

                    if self:IsFacing(ThisUnit) and IsLeftOK and IsRightOK then
                        table.insert(RectangleUnits, ThisUnit);
                    end
                end
            end
        end
        if Allies and self:SpecialHealthPercentage() <= AlliesHealth then table.insert(RectangleUnits, self); end
        return RectangleUnits;
    end

    --- Freedom handler - Returns true if the user is slowed
    local SlowDebuffs = {
        -- Bloodmaul Slag Mines
        150751, -- Crushing Leap (Rooted)
        151566, -- Molten Binding (70%)
        152073, -- Shock Bola (50%)
        -- Shadowmoon Burial Grounds
        152819, -- Shadow Word: Frailty (50%)
        -- Upper Blackrock Spire
        155505, -- Debilitating Ray (20%)
        161199, -- Debilitating Fixation (25%)
        -- Grimrail Depot
        162065, -- Freezing Snare (Rooted)
        -- Auchindoun
        164841, -- Curse of Exhaustion (70%)
        -- Everbloom
        167966, -- Bramble Patch (55%)
        -- Hellfire Citadel
        180491, -- Nexus of Souls (50%)
        182003, -- Fuel Streak (40%)
        182031, -- Gazing Shadows (50%)
        182218, -- Felblaze Residue (75%)
        182668, -- Fuel Streak (30%)
        189544, -- Cripple (50%)
        -- Tanaan Jungle
        183872 -- Iron Front - Demonic Grasp (75%)
    }
    function Unit:IsSlowed ()
        local Spell = module.Spell
        for i = 1, #SlowDebuffs do
            local ThisDebuff = SlowDebuffs[i];
            if self:DebuffAny(Spell(ThisDebuff)) and self:DebuffRemainsAny(Spell(ThisDebuff)) > 1.5 then
                return true;
            end
        end
    end

    local EnrageBuffs = {
        -- Bloodmaul Slag Mines
        151965, -- Slaver's Rage
        -- Iron Docks
        164835, -- Bloodletting Howl
        -- UBRS
        155620, -- Burning Rage
        -- Blackrock Foundry
        155198, -- Savage Howl
        -- Tanaan Jungle
        172781, -- Enrage
        183863, -- Demonblood Vial
        183883, -- Howl of Rage
        176249, -- Wooden Fists (Rendarr)
        174768, -- Rock Skin (Rendarr)
        155620, -- Ragewing
        81173 -- Ogre Enrage
    }

    function Unit:IsEnraged ()
        local Spell = module.Spell
        for i = 1, #EnrageBuffs do
            if self:BuffAny(Spell(EnrageBuffs[i])) then
                return true;
            end
        end
        return false;
    end

    local MagicBuffs = {
        -- Auchindoun
        160312, -- Void Shell
        -- Bloodmaul Slag Mines
        164597, -- Stone Bulwark
        151548, -- Blood Rage
        150678, -- Molten Core
        -- Everbloom
        168041, -- Briarskin
        168105, -- Rapid Tides
        -- UBRS
        161203, -- Rejuvenating Serum
        155498, -- Rejuvenating Serum
        -- Blackrock Foundry
        155173, -- Reactive Earth Shield
        160140, -- Cauterizing Bolt
        -- Hellfire Citadel
        180025, -- Harbinger's Mending
        174768, -- Rock Skin (Rendarr)
        -- Tanaan Jungle
        183863 -- Demonblood Vial
    }

    function Unit:IsMagicBuffed ()
        local Spell = module.Spell
        for i = 1, #MagicBuffs do
            if self:BuffAny(Spell(MagicBuffs[i])) then
                return true;
            end
        end
        return false;
    end

    --- Get the table of units under Health threshold within Distance around Unit
    --@param HealthThreshold - Maximum Health of Unit - numeric
    --@param Distance - Maximum Distance from self - numeric
    module.HealingEngine = {}
    function Unit:HealUnitsAround (HealthThreshold, Distance)
        if not module.HealingEngine[self.UnitID] or module.HealingEngine[self.UnitID].Refresh < module.GetTime() then
            if module.HealingEngine[self.UnitID] then wipe(module.HealingEngine[self.UnitID]); else module.HealingEngine[self.UnitID] = {}; end
            module.HealingEngine[self.UnitID].Refresh = module.GetTime() + 1
            local HealingUnits = module.HealingUnits;
            for i = 1, #HealingUnits do
                local ThisUnit = HealingUnits[i];
                if ThisUnit:Exists() and not ThisUnit:IsDeadOrGhost() then
                    table.insert(module.HealingEngine[self.UnitID], {
                        Unit = ThisUnit,
                        Health = ThisUnit:SpecialHealthPercentage(),
                        Distance = self:DistanceTo(ThisUnit)
                    });
                end
            end
        end
        local HealingEngineTable, HealingEngineUnits, AllHealingEngineUnits, ThisUnit = module.HealingEngine[self.UnitID], {}, {}, nil;
        for i = 1, #HealingEngineTable do
            ThisUnit = HealingEngineTable[i];
            if ThisUnit.Distance <= Distance then
                if ThisUnit.Health <= HealthThreshold then
                    table.insert(HealingEngineUnits, ThisUnit.Unit);
                end
                table.insert(AllHealingEngineUnits, ThisUnit.Unit);
            end
        end
        return HealingEngineUnits, AllHealingEngineUnits;
    end

    --- Get the best table of units on which we should use a ground spell
    function Unit:BestGroundHealUnits (HealUnits, HealthThreshold, Distance)
        local BestHealUnits, AllBestHealUnits = {}, {};
        for i = 1, #HealUnits do
            local ThisUnit = HealUnits[i];
            if not ThisUnit:IsMoving() then
                local TheseHealUnits, AllTheseHealUnits = ThisUnit:HealUnitsAround(HealthThreshold, Distance);
                if #TheseHealUnits > #BestHealUnits then
                    BestHealUnits, AllBestHealUnits = TheseHealUnits, AllTheseHealUnits;
                end
            end
        end
        return #BestHealUnits, AllBestHealUnits;
    end

    --- Get the table of units with Buff
    --@param TheseUnits - Units to be scanned - Table
    --@param ThisBuff - Buff Spell we are looking for - Spell Object
    --@param ThisDuration - Minimum remaining duration - numeric
    function Unit:UnitsWithBuff (TheseUnits, ThisBuff, ThisDuration)
        local ThisDuration = ThisDuration or 0;
        local UnitsTable = {};
        for i = 1, #TheseUnits do
            local ThisUnit = TheseUnits[i];
            if ThisUnit:Exists() and ThisUnit:BuffRemains(ThisBuff) >= ThisDuration then
                table.insert(UnitsTable, ThisUnit);
            end
        end
        return UnitsTable;
    end

    function Unit:PetAttack ()
        return PetAttack(self.UnitID) and PetIsAttacking == self:CreatureID();
    end

    function Unit:PetAttacking ()
        return PetIsAttacking and PetIsAttacking == self:CreatureID() or false;
    end

    --- Dark Simulacrum Spells
    module.DarkSimList = {
        -- Auchindoun
        [79510] = { -- Cackling Pyromaniac
            [GetSpellInfo(154221)] = "Damage" -- Felblast
        },
        [76260] = { -- Cackling Pyromaniac
            [GetSpellInfo(154221)] = "Damage" -- Felblast
        },
        [76177] = { -- Soulbinder Nyami
            [GetSpellInfo(154415)] = "Damage", -- Mind Spike
            [GetSpellInfo(154477)] = "Damage" -- Shadow Word: Pain
        },
        [78437] = { -- Gul'kosh
            [GetSpellInfo(156829)] = "Damage", -- Shadow Bolt
            [GetSpellInfo(156854)] = "Damage", -- Drain Life
            [GetSpellInfo(156954)] = "Damage" -- Unstable Affliction
        },
        [77734] = { -- Teron'gor
            [GetSpellInfo(156842)] = "Damage", -- Corruption
            [GetSpellInfo(156854)] = "Damage", -- Drain Life
            [GetSpellInfo(156965)] = "Damage", -- Doom
            [GetSpellInfo(156975)] = "Damage" -- Chaos Bolt
        },
        [77889] = { -- Grom'tash the Destructor
            [GetSpellInfo(157049)] = "Damage", -- Immolate
            [GetSpellInfo(157051)] = "Damage" -- Incinerate
        },
        [77890] = { -- Durag the Dominator
            [GetSpellInfo(157053)] = "Damage" -- Shadow Bolt
        },
        -- Bloodmaul Slag Mines
        [74366] = { -- Magmolatus Adds
            [GetSpellInfo(150011)] = "Damage" -- Magma Barrage
        },
        [74790] = { -- Gug'rokk
            [GetSpellInfo(150677)] = "Damage" -- Molten Blast
        },
        -- Everbloom
        [81820] = { -- Everbloom Mender
            [GetSpellInfo(164887)] = "Heal" -- Healing Waters
        },
        [81985] = { -- Everbloom Tender
            [GetSpellInfo(165213)] = "Buff", -- Enraged Growth
            [GetSpellInfo(164973)] = "Damage" -- Dancing Thorns
        },
        [82682] = { -- Archmage Sol
            [GetSpellInfo(166464)] = "Damage", -- Fireball
            [GetSpellInfo(166465)] = "Damage" -- Frostbolt
        },
        [83893] = { -- Earthshaper Telu
            [GetSpellInfo(167966)] = "Damage" -- Bramble Patch
        },
        [84957] = { -- Putrid Pyromancer
            [GetSpellInfo(169843)] = "Damage", -- Dragon's Breath
            [GetSpellInfo(169844)] = "Damage" -- Dragon's Breath
        },
        -- Hellfire Citadel
        [92522] = { -- Assault - Gorebound Terror
            [GetSpellInfo(183449)] = "Damage", -- Felfire Volley
            [GetSpellInfo(181155)] = "Damage" -- Incinerate
        },
        [90316] = { -- Shadow-Lord Iskar
            [GetSpellInfo(185343)] = "Damage" -- Riposte
        },
        [91259] = { -- Mannoroth - Fel Imp
            [GetSpellInfo(185343)] = "Damage" -- Riposte
        },
        -- Iron Docks
        [80816] = { -- Ahri'ok Dugru
            [GetSpellInfo(165122)] = "Damage" -- Blood Bolt
        },
        -- Skyreach
        [76266] = { -- High Sage Viryx
            [GetSpellInfo(154396)] = "Damage" -- Solar Burst
        },
        [78933] = { -- Herald Of Sunrise
            [GetSpellInfo(152894)] = "Heal" -- Flash Heal
        },
        [79462] = { -- Solar Flare
            [GetSpellInfo(157020)] = "Damage" -- Wrath
        },
        [79463] = { -- Solar Flare
            [GetSpellInfo(157020)] = "Damage" -- Wrath
        },
        [79466] = { -- Initiate of the Rising Sun
            [GetSpellInfo(152894)] = "Heal" -- Flash Heal
        },
        -- Shadowmoon Burial Grounds
        [75506] = { --Shadowmoon Loyalist
            [GetSpellInfo(152814)] = "Damage" -- Shadow Bolt
        },
        [75713] = { --Shadowmoon Bone-Mender
            [GetSpellInfo(152814)] = "Damage" -- Shadow Bolt
        },
        [76446] = { -- Shadowmoon Enslaver
            [GetSpellInfo(156776)] = "Damage" -- Rending Voidlash
        }
    };

    --- Taunt Manager options
    function module.TauntManagerOptions (SpellName)
        module.AddSection("General Settings", "Taunt Manager", "Green");
        module.AddNewOption("General Settings", SpellName, 230, false, {1, "Any Unit", "Target Only"}, nil, "Use "..SpellName.." on ennemies that are not tanked."..C.TOOLTIP_VALUE_2.."Enable taunting target that is not tanked. Use Any Unit to taunt Any unit within 30 yard or Target only to only check current Target.");
    end

    --- Taunt Manager - Tank algorythm to taunt non tanked mobs
    -- @param TauntSpell - Spell Object - The spell declared in the rotation
    -- @param OptionName - String - Name of the option declared atop the rotation
    -- @param TargetUnit - Unit Object - Current Target of the Player
    -- @param EnemiesTable - Table of Units Objects - Enemies within 40 yard of the Player
    -- @param PlayerPetTank - Unit Object - The pet that is offtanking (Monk Niuzao)
    function Unit:TauntManager (TauntSpell, OptionName, TargetUnit, EnemiesTable, PlayerPetTank)
        -- Define Main Tanks
        local MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();
        -- Taunt Manager
        if TauntSpell:Exists() and module.IsOptionEnabled(OptionName) and not TauntSpell:IsOnCooldown() then
            if module.GetOptionValue(OptionName) == "Target Only" then
                if not TargetUnit:IsDummy() and (not self:IsTanking(TargetUnit)) and (not PlayerPetTank or not PlayerPetTank:IsTanking(TargetUnit)) and (not MainTank or not MainTank:IsTanking(TargetUnit)) and (not OffTank or not OffTank:IsTanking(TargetUnit)) and TargetUnit:CanCast(TauntSpell) then
                    module.Bug("|cff9D00FFTaunt Manager|r - Single Target Taunt");
                    TargetUnit:Cast(TauntSpell);
                    return true;
                end
            else
                local ThisUnit;
                for i = 1, #EnemiesTable do
                    ThisUnit = EnemiesTable[i];
                    if not ThisUnit:IsDummy() and (not self:IsTanking(ThisUnit)) and (not PlayerPetTank or not PlayerPetTank:IsTanking(TargetUnit)) and (not MainTank or not MainTank:IsTanking(ThisUnit)) and (not OffTank or not OffTank:IsTanking(ThisUnit)) and ThisUnit:CanCast(TauntSpell) then
                        module.Bug("|cff9D00FFTaunt Manager|r - Multi Target Taunt");
                        ThisUnit:Cast(TauntSpell);
                        return true;
                    end
                end
            end
        end
        return false;
    end

    -- Lifebloom T18
    function Unit:GroupUnitsWithLifebloom (Spell)
        return Unit.GroupWhere(
            function (ThisUnit)
                return ThisUnit:Exists() and ThisUnit:Buff(Spell);
            end
        , true);
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Defines the Player table.
    --- Get whether the player is ready to cast.
    -- @return Whether the player is ready to cast.
    function Player:IsReadyNoChannel ()
        local ChanneledMana = module.Spell(156432)
        if Player:DebuffAny(ChanneledMana) then
            return false;
        end
        if UnitChannelInfo('player') == GetSpellInfo(740) then
            return false;
        end
        if IsAoEPending() then
            return false;
        end
        if UnitIsDeadOrGhost("player") then
            return false;
        end
        local Latency = select(4, GetNetStats());
        local Time = module.GetTime() * 1000;

        local CastEndTime = select(6, self:IsCasting());
        if HealerInRange and not HealerInRange() then
            return false;
        end

        return not self:Casting() or CastEndTime - Time <= Latency;
    end

    function Player:IsReady ()
        local ChanneledMana = module.Spell(156432);
        local InvisibilityPotion = module.Spell(175833);
        local OldInvisibilityPotion = module.Spell(11392);
        if Player:DebuffAny(ChanneledMana) or Player:BuffAny(InvisibilityPotion) or Player:BuffAny(OldInvisibilityPotion) then
            return false;
        end

        if UnitChannelInfo('player') == GetSpellInfo(740) then
            return false;
        end

        if IsAoEPending() then
            return false;
        end

        if UnitIsDeadOrGhost("player") then
            return false;
        end

        local Latency = select(4, GetNetStats());
        local Time = module.GetTime() * 1000;
        local CastEndTime = select(6, self:IsCasting());
        -- if self:Casting() then
        --  return false
        -- end

        local ChannelEndTime = select(6, self:Channeling());
        if HealerInRange and not HealerInRange() then
            return false;
        end

        if self:Casting() and CastEndTime - Time > Latency then return false; end

        local ChannelEndTime = select(6, self:Channeling());

        return not ChannelEndTime or ChannelEndTime - Time <= Latency;
    end

    -- Return the time Player has been moving.
    function Player:Moving ()
        return module.isMovingStartTime ~= 0 and module.GetTime() - module.isMovingStartTime or 0;
        --
    end

    -- Return the time Player has been standing.
    function Player:Standing ()
        return module.isStandingStartTime ~= 0 and module.GetTime() - module.isStandingStartTime or 0;
        --
    end

    -- Buffs that cause the player to be considered mounted.
    local DruidTravelFormBuff = Spell(783);
    local DruidFlightFormBuff = Spell(165962);
    local DemonHunterGlideBuff = Spell(131347);
    --- Get wether the player is mounted.
    function Player:IsMounted ()
        return (IsMounted() and not self:MountedCombat()) or self:BuffAny(DruidTravelFormBuff) or self:BuffAny(DruidFlightFormBuff) or self:BuffAny(DemonHunterGlideBuff) or false;
        --
    end

    function Player:Level ()
        return UnitLevel("player");
        --
    end

    function Player:AttackSpeed ()
        return UnitAttackSpeed("player");
        --
    end

    function Player:GCD ()
        if C.CLASSNAME == "DEATHKNIGHT" or C.CLASSNAME == "DEMONHUNTER" or C.CLASSNAME == "HUNTER" or C.CLASSNAME == "ROGUE" or currentSpecName == "Feral" or currentSpecName == "Brewmaster" or currentSpecName == "Windwalker" then
            return 1;
        else
            local GCD = 1.5/(1+(self:Haste()/100));
            if GCD > 1 then
                return GCD;
            else
                return 1;
            end
        end
    end

    --- Get whether the player is stealthed.
    -- @param Abilities Do you want to check Combat Stealth Abilities also ?
    -- @return Whether the player is stealthed.
    local IsStealthedBuff = {
        -- Normal Stealth
        {
            -- Rogue
            Spell(1784), -- Stealth
            Spell(115191), -- Stealth w/ Subterfuge Talent
            -- Feral
            Spell(5215) -- Prowl
        },
        -- Combat Stealth
        {
            -- Rogue
            Spell(11327), -- Vanish
            Spell(115193), -- Vanish w/ Subterfuge Talent
            Spell(115192), -- Subterfuge Buff
            Spell(185422), -- Stealth from Shadow Dance
            -- Feral
            Spell(102547) -- Prowl w/ Incarnation Buff
        },
        -- Special Stealth
        {
            -- Night Elf
            Spell(58984) -- Shadowmeld
        }
    };
    function Player:IsStealthed (Abilities, Special)
        for i = 1, #IsStealthedBuff[1] do
            if self:Buff(IsStealthedBuff[1][i]) then
                return true;
            end
        end
        if Abilities then
            for i = 1, #IsStealthedBuff[2] do
                if self:Buff(IsStealthedBuff[2][i]) then
                    return true;
                end
            end
        end
        if Special then
            for i = 1, #IsStealthedBuff[3] do
                if self:Buff(IsStealthedBuff[3][i]) then
                    return true;
                end
            end
        end
        return false;
    end

    -- execute_time returns whichever is greater: gcd or cast_time
    function Player:ExecuteTime()
        local imCasting,_,_,_,_,castEndTime = UnitCastingInfo("player");
        local imChanelling,_,_,_,_,channelEndTime = UnitChannelInfo("player");
        local currentTime = module.GetTime();
        local currentGCDEnds = module.GCDEnds - currentTime;
        if currentGCDEnds <= 0 then
          currentGCDEnds = 0;
        end
        if imCasting then
            -- i need to convert the time to module.GetTime() format
            local castingTime = castEndTime/1000 - currentTime;
            if castingTime > currentGCDEnds then
                return castingTime;
            else
                return currentGCDEnds;
            end
        elseif imChanelling then
            local channelTime = channelEndTime/1000 - currentTime;
            if channelTime > currentGCDEnds then
                return channelTime;
            else
                return currentGCDEnds;
            end
        else
            return currentGCDEnds;
        end
    end

    local CombatMounts = {165803, 164222};
    function Player:MountedCombat ()
        for i = 1, #CombatMounts do
            if UnitBuff('player', GetSpellInfo(CombatMounts[i])) then
                return true;
            end
        end
        return false;
    end

    function Player:TotemDuration (Spell)
        for index = 1, 4 do
            local _, totemName, startTime, duration = GetTotemInfo(index)
            if totemName == select(1,GetSpellInfo(Spell:ID())) then
                return floor(startTime + duration - module.GetTime());
            end
        end
        return 0;
    end

    --- Damage Taken in the last x seconds
    -- @param Lapse - Numeric - Number of second to check up to 15 seconds
    -- Use: Player:RecentDamageTaken(5);
    -- /dump Engine.Player:RecentDamageTaken(15)
    function Player:RecentDamageTaken (Lapse)
        local TotalDamageTaken = 0;
        for Key, Value in pairs(module.DamageTakenTable) do
            if module.GetTime() - module.DamageTakenTable[Key][1] < Lapse then
                TotalDamageTaken = TotalDamageTaken + module.DamageTakenTable[Key][2];
            end
        end
        return TotalDamageTaken;
    end

    --------------------------------------------------------------------------------------
    -------------------------------- CHARACTER RESSOURCES --------------------------------
    --------------------------------------------------------------------------------------

    -----------------------
    --- Power Functions --- <- DEPRECATED, will no longer work without a PowerType (still possible to add UnitPowerType() as PowerType tho).
    -----------------------
    --- Get the player's maximum power.
    -- @return The player's maximum power.
    function Player:PowerMax ()
        return UnitPowerMax(self.UnitID);
    end
    --- Get the player's power.
    -- @return The player's power.
    function Player:Power ()
        return UnitPower(self.UnitID);
    end
    --- Get the player pet's power.
    -- @return The player pet's power.
    function PlayerPet:Power ()
        return UnitPower(self.UnitID);
    end
    --- Get the player's power as a percentage.
    -- @return The player's power as a percentage.
    function Player:PowerPercentage ()
        return (self:Power() / self:PowerMax()) * 100;
    end
    --- Get the player's power deficit.
    -- @return The player's power deficit.
    function Player:PowerDeficit ()
        return self:PowerMax() - self:Power();
    end
    --- Get the player's power deficit.
    -- @return The player's power deficit.
    function Player:PowerDeficitPercentage ()
        return (self:PowerDeficit() / self:PowerMax()) * 100;
    end
    --- Get the player's active absolute power regen or decay rate.
    -- @return The player's active absolute power regen or decay rate.
    function Player:PowerRegen ()
        return select(2, GetPowerRegen(self.UnitID));
    end
    --- Get the player's active percentage power regen or decay rate.
    -- @return The player's active percentage power regen or decay rate.
    function Player:PowerRegenPercentage ()
        return (self:PowerRegen() / self:PowerMax()) * 100;
    end
    --- Get the player's time to be at maximum power.
    -- @return The player's time to be at maximum power.
    function Player:PowerTimeToMax ()
        return self:PowerDeficit() * (1 / self:PowerRegen());
    end
    --- Get the player's time to be at the given absolute amount of power.
    -- @param The desired amount of power in plain.
    -- @return The player's time to be at the given absolute amount of power.
    function Player:PowerTimeToX (Amount)
        if self:PowerRegen() > 0 then
            return Amount > self:Power() and (Amount - self:Power()) * (1 / self:PowerRegen()) or 0;
        elseif self:PowerRegen() < 0 then
            return Amount < self:Power() and (self:Power() - Amount ) * (1 / self:PowerRegen()) or 0;
        else
            return -1;
        end
    end
    --- Get the player's time to be at the given relative amount of power.
    -- @param The desired amount of power in percentage.
    -- @return The player's time to be at the given relative amount of power.
    function Player:PowerTimeToXPercentage (Amount)
        if self:PowerRegen() > 0 then
            return Amount > self:PowerPercentage() and (Amount - self:PowerPercentage()) * (1 / self:PowerRegenPercentage()) or 0;
        elseif self:PowerRegen() < 0 then
            return Amount < self:PowerPercentage() and (self:PowerPercentage() - Amount) * (1 / self:PowerRegenPercentage()) or 0;
        else
            return -1;
        end
    end

    --------------------------
    --- 0 | Mana Functions --- <= Druid & Mage & Mistweaver Monk & Paladin & Priest & Restoration Shaman & Warlock
    --------------------------
    --- Get the player's maximum mana.
    -- @return The player's maximum mana.
    function Player:ManaMax ()
        return UnitPowerMax(self.UnitID, SPELL_POWER_MANA);
    end
    --- Get the player's mana.
    -- @return The player's mana.
    function Player:Mana ()
        return UnitPower(self.UnitID, SPELL_POWER_MANA);
    end
    --- Get the player's mana as a percentage.
    -- @return The player's mana as a percentage.
    function Player:ManaPercentage ()
        return (self:Mana() / self:ManaMax()) * 100;
    end
    --- Get the player's mana deficit.
    -- @return The player's mana deficit.
    function Player:ManaDeficit ()
        return self:ManaMax() - self:Mana();
    end
    --- Get the player's mana deficit.
    -- @return The player's mana deficit.
    function Player:ManaDeficitPercentage ()
        return (self:ManaDeficit() / self:ManaMax()) * 100;
    end
    --- Get the player's active absolute mana regen.
    -- @return The player's active absolute mana regen.
    function Player:ManaRegen ()
        return select(2, GetPowerRegen(self.UnitID));
    end
    --- Get the player's active percentage mana regen.
    -- @return The player's active percentage mana regen.
    function Player:ManaRegenPercentage ()
        return (self:ManaRegen() / self:ManaMax()) * 100;
    end
    --- Get the player's time to be at maximum mana.
    -- @return The player's time to be at maximum mana.
    function Player:ManaTimeToMax ()
        return self:ManaDeficit() * (1 / self:ManaRegen());
    end
    --- Get the player's time to be at the given absolute amount of mana.
    -- @param The desired amount of mana in plain.
    -- @return The player's time to be at the given absolute amount of mana.
    function Player:ManaTimeToX (Amount)
        if self:ManaRegen() == 0 then return -1; end
        return Amount > self:Mana() and (Amount - self:Mana()) * (1 / self:ManaRegen()) or 0;
    end
    --- Get the player's time to be at the given relative amount of mana.
    -- @param The desired amount of mana in percentage.
    -- @return The player's time to be at the given relative amount of mana.
    function Player:ManaTimeToXPercentage (Amount)
        if self:ManaRegen() == 0 then return -1; end
        return Amount > self:ManaPercentage() and (Amount - self:ManaPercentage()) * (1 / self:ManaRegenPercentage()) or 0;
    end

    --------------------------
    --- 1 | Rage Functions --- <= Warrior
    --------------------------
    --- Get the player's maximum rage.
    -- @return The player's maximum rage.
    function Player:RageMax ()
        return UnitPowerMax(self.UnitID, SPELL_POWER_RAGE);
    end
    --- Get the player's rage.
    -- @return The player's rage.
    function Player:Rage ()
        return UnitPower(self.UnitID, SPELL_POWER_RAGE);
    end
    --- Get the player's rage as a percentage.
    -- @return The player's rage as a percentage.
    function Player:RagePercentage ()
        return (self:Rage() / self:RageMax()) * 100;
    end
    --- Get the player's rage deficit.
    -- @return The player's rage deficit.
    function Player:RageDeficit ()
        return self:RageMax() - self:Rage();
    end
    --- Get the player's rage deficit.
    -- @return The player's rage deficit.
    function Player:RageDeficitPercentage ()
        return (self:RageDeficit() / self:RageMax()) * 100;
    end
    --- Get the player's active absolute rage decay rate.
    -- @return The player's active absolute rage decay rate.
    function Player:RageRegen ()
        return select(2, GetPowerRegen(self.UnitID));
    end
    --- Get the player's active percentage rage decay rate.
    -- @return The player's active percentage rage decay rate.
    function Player:RageRegenPercentage ()
        return (self:RageRegen() / self:RageMax()) * 100;
    end
    --- Get the player's time to be at maximum rage.
    -- @return The player's time to be at maximum rage.
    function Player:RageTimeToMax ()
        return self:RageDeficit() * (1 / self:RageRegen());
    end
    --- Get the player's time to be at the given absolute amount of rage.
    -- @param The desired amount of rage in plain.
    -- @return The player's time to be at the given absolute amount of rage.
    function Player:RageTimeToX (Amount)
        if self:RageRegen() == 0 then return -1; end
        return Amount < self:Rage() and (self:Rage() - Amount ) * (1 / self:RageRegen()) or 0;
    end
    --- Get the player's time to be at the given relative amount of rage.
    -- @param The desired amount of rage in percentage.
    -- @return The player's time to be at the given relative amount of rage.
    function Player:RageTimeToXPercentage (Amount)
        if self:RageRegen() == 0 then return -1; end
        return Amount < self:RagePercentage() and (self:RagePercentage() - Amount) * (1 / self:RageRegenPercentage()) or 0;
    end

    ---------------------------
    --- 2 | Focus Functions --- <= Hunter
    ---------------------------
    --- Get the player's maximum focus.
    -- @return The player's maximum focus.
    function Player:FocusMax ()
        return UnitPowerMax(self.UnitID, SPELL_POWER_FOCUS);
    end
    --- Get the player's focus.
    -- @return The player's focus.
    function Player:Focus ()
        return UnitPower(self.UnitID, SPELL_POWER_FOCUS);
    end
    --- Get the player's focus as a percentage.
    -- @return The player's focus as a percentage.
    function Player:FocusPercentage ()
        return (self:Focus() / self:FocusMax()) * 100;
    end
    --- Get the player's focus deficit.
    -- @return The player's focus deficit.
    function Player:FocusDeficit ()
        return self:FocusMax() - self:Focus();
    end
    --- Get the player's focus deficit.
    -- @return The player's focus deficit.
    function Player:FocusDeficitPercentage ()
        return (self:FocusDeficit() / self:FocusMax()) * 100;
    end
    --- Get the player's active absolute focus regen.
    -- @return The player's active absolute focus regen.
    function Player:FocusRegen ()
        return select(2, GetPowerRegen(self.UnitID));
    end
    --- Get the player's active percentage focus regen.
    -- @return The player's active percentage focus regen.
    function Player:FocusRegenPercentage ()
        return (self:FocusRegen() / self:FocusMax()) * 100;
    end
    --- Get the player's time to be at maximum focus.
    -- @return The player's time to be at maximum focus.
    function Player:FocusTimeToMax ()
        return self:FocusDeficit() * (1 / self:FocusRegen());
    end
    --- Get the player's time to be at the given absolute amount of focus.
    -- @param The desired amount of focus in plain.
    -- @return The player's time to be at the given absolute amount of focus.
    function Player:FocusTimeToX (Amount)
        if self:FocusRegen() == 0 then return -1; end
        return Amount > self:Focus() and (Amount - self:Focus()) * (1 / self:FocusRegen()) or 0;
    end
    --- Get the player's time to be at the given relative amount of focus.
    -- @param The desired amount of focus in percentage.
    -- @return The player's time to be at the given relative amount of focus.
    function Player:FocusTimeToXPercentage (Amount)
        if self:FocusRegen() == 0 then return -1; end
        return Amount > self:FocusPercentage() and (Amount - self:FocusPercentage()) * (1 / self:FocusRegenPercentage()) or 0;
    end

    ----------------------------
    --- 3 | Energy Functions --- <= Rogue & Feral Druid & Monk
    ----------------------------
    --- Get the player's maximum energy.
    -- @return The player's maximum energy.
    function Player:EnergyMax ()
        return UnitPowerMax(self.UnitID, SPELL_POWER_ENERGY);
    end
    --- Get the player's energy.
    -- @return The player's energy.
    function Player:Energy ()
        return UnitPower(self.UnitID, SPELL_POWER_ENERGY);
    end
    --- Get the player's energy as a percentage.
    -- @return The player's energy as a percentage.
    function Player:EnergyPercentage ()
        return (self:Energy() / self:EnergyMax()) * 100;
    end
    --- Get the player's energy deficit.
    -- @return The player's energy deficit.
    function Player:EnergyDeficit ()
        return self:EnergyMax() - self:Energy();
    end
    --- Get the player's energy deficit.
    -- @return The player's energy deficit.
    function Player:EnergyDeficitPercentage ()
        return (self:EnergyDeficit() / self:EnergyMax()) * 100;
    end
    --- Get the player's active absolute energy regen.
    -- @return The player's active absolute energy regen.
    function Player:EnergyRegen ()
        return select(2, GetPowerRegen(self.UnitID));
    end
    --- Get the player's active percentage energy regen.
    -- @return The player's active percentage energy regen.
    function Player:EnergyRegenPercentage ()
        return (self:EnergyRegen() / self:EnergyMax()) * 100;
    end
    --- Get the player's time to be at maximum energy.
    -- @return The player's time to be at maximum energy.
    function Player:EnergyTimeToMax ()
        return self:EnergyDeficit() * (1 / self:EnergyRegen());
    end
    --- Get the player's time to be at the given absolute amount of energy.
    -- @param The desired amount of energy in plain.
    -- @return The player's time to be at the given absolute amount of energy.
    function Player:EnergyTimeToX (Amount)
        if self:EnergyRegen() == 0 then return -1; end
        return Amount > self:Energy() and (Amount - self:Energy()) * (1 / self:EnergyRegen()) or 0;
    end
    --- Get the player's time to be at the given relative amount of energy.
    -- @param The desired amount of energy in percentage.
    -- @return The player's time to be at the given relative amount of energy.
    function Player:EnergyTimeToXPercentage (Amount)
        if self:EnergyRegen() == 0 then return -1; end
        return Amount > self:EnergyPercentage() and (Amount - self:EnergyPercentage()) * (1 / self:EnergyRegenPercentage()) or 0;
    end

    ----------------------------------
    --- 4 | Combo Points Functions --- <= Rogue & Feral Druid
    ----------------------------------
    --- Get the player's maximum combo points.
    -- @return The player's maximum combo points.
    function Player:ComboPointsMax ()
        return UnitPowerMax(self.UnitID, SPELL_POWER_COMBO_POINTS);
    end
    --- Get the player's combo points.
    -- @return The player's combo points.
    function Player:ComboPoints ()
        return UnitPower(self.UnitID, SPELL_POWER_COMBO_POINTS);
    end
    --- Get the player's combo points deficit.
    -- @return The player's combo points deficit.
    function Player:ComboPointsDeficit ()
        return self:ComboPointsMax() - self:ComboPoints();
    end

    ---------------------------
    --- 5 | Runes Functions --- <= Death Knight
    ---------------------------
    --- Get the player's runes.
    -- @return - RuneCount - Total runes ready with next partial rune as decimal.
    -- @return - NextRuneReady - How long until the next rune is ready.
    function Player:Runes ()
        local RuneCount = 6;
        local NextRuneReady = 9;
        local RechargeDuration;
        for i = 1, 6 do
            local Start, Duration, RuneReady = GetRuneCooldown(i);
            if not RuneReady then
                RuneCount = RuneCount - 1;
                local ReadyIn = Start + Duration - module.GetTime();
                NextRuneReady = ReadyIn < NextRuneReady and ReadyIn or NextRuneReady
            end
            RechargeDuration = Duration;
        end
        RuneCount = RuneCount == 6 and RuneCount or RuneCount + 1 - NextRuneReady/RechargeDuration;
        return RuneCount, NextRuneReady;
    end

    ---------------------------------
    --- 6 | Runic Power Functions --- <= Death Knight
    ---------------------------------
    --- Get the player's maximum runic power.
    -- @return The player's maximum runic power.
    function Player:RunicPowerMax ()
        return UnitPowerMax(self.UnitID, SPELL_POWER_RUNIC_POWER);
    end
    --- Get the player's runic power.
    -- @return The player's runic power.
    function Player:RunicPower ()
        return UnitPower(self.UnitID, SPELL_POWER_RUNIC_POWER);
    end
    --- Get the player's runic power as a percentage.
    -- @return The player's runic power as a percentage.
    function Player:RunicPowerPercentage ()
        return (self:RunicPower() / self:RunicPowerMax()) * 100;
    end
    --- Get the player's runic power deficit.
    -- @return The player's runic power deficit.
    function Player:RunicPowerDeficit ()
        return self:RunicPowerMax() - self:RunicPower();
    end
    --- Get the player's runic power deficit.
    -- @return The player's runic power deficit.
    function Player:RunicPowerDeficitPercentage ()
        return (self:RunicPowerDeficit() / self:RunicPowerMax()) * 100;
    end
    --- Get the player's active absolute runic power decay rate.
    -- @return The player's active absolute runic power decay rate.
    function Player:RunicPowerRegen ()
        return select(2, GetPowerRegen(self.UnitID));
    end
    --- Get the player's active percentage runic power decay rate.
    -- @return The player's active percentage runic power decay rate.
    function Player:RunicPowerRegenPercentage ()
        return (self:RunicPowerRegen() / self:RunicPowerMax()) * 100;
    end
    --- Get the player's time to be at maximum runic power.
    -- @return The player's time to be at maximum runic power.
    function Player:RunicPowerTimeToMax ()
        return self:RunicPowerDeficit() * (1 / self:RunicPowerRegen());
    end
    --- Get the player's time to be at the given absolute amount of runic power.
    -- @param The desired amount of runic power in plain.
    -- @return The player's time to be at the given absolute amount of runic power.
    function Player:RunicPowerTimeToX (Amount)
        if self:RunicPowerRegen() == 0 then return -1; end
        return Amount < self:RunicPower() and (self:RunicPower() - Amount ) * (1 / self:RunicPowerRegen()) or 0;
    end
    --- Get the player's time to be at the given relative amount of runic power.
    -- @param The desired amount of runic power in percentage.
    -- @return The player's time to be at the given relative amount of runic power.
    function Player:RunicPowerTimeToXPercentage (Amount)
        if self:RunicPowerRegen() == 0 then return -1; end
        return Amount < self:RunicPowerPercentage() and (self:RunicPowerPercentage() - Amount) * (1 / self:RunicPowerRegenPercentage()) or 0;
    end

    ---------------------------------
    --- 7 | Soul Shards Functions --- <= Warlock
    ---------------------------------
    --- Get the player's maximum soul shards.
    -- @return The player's maximum soul shards.
    function Player:SoulShardsMax ()
        return UnitPowerMax(self.UnitID, SPELL_POWER_SOUL_SHARDS);
    end
    --- Get the player's soul shards.
    -- @return The player's soul shards.
    function Player:SoulShards ()
        return UnitPower(self.UnitID, SPELL_POWER_SOUL_SHARDS);
    end
    --- Get the player's soul shards as a percentage.
    -- @return The player's soul shards as a percentage.
    function Player:SoulShardsPercentage ()
        return (self:SoulShards() / self:SoulShardsMax()) * 100;
    end
    --- Get the player's soul shards deficit.
    -- @return The player's soul shards deficit.
    function Player:SoulShardsDeficit ()
        return self:SoulShardsMax() - self:SoulShards();
    end
    --- Get the player's soul shards deficit.
    -- @return The player's soul shards deficit.
    function Player:SoulShardsDeficitPercentage ()
        return (self:SoulShardsDeficit() / self:SoulShardsMax()) * 100;
    end

    ----------------------------------
    --- 8 | Astral Power Functions --- <= Balance Druid
    ----------------------------------
    --- Default UI does use SPELL_POWER_LUNAR_POWER instead of SPELL_POWER_ASTRAL_POWER as of 7.0.3.21996.
    --- Get the player's maximum astral power.
    -- @return The player's maximum astral power.
    function Player:AstralPowerMax ()
        return UnitPowerMax(self.UnitID, SPELL_POWER_LUNAR_POWER);
    end
    --- Get the player's astral power.
    -- @return The player's astral power.
    function Player:AstralPower ()
        return UnitPower(self.UnitID, SPELL_POWER_LUNAR_POWER);
    end
    --- Get the player's astral power as a percentage.
    -- @return The player's astral power as a percentage.
    function Player:AstralPowerPercentage ()
        return (self:AstralPower() / self:AstralPowerMax()) * 100;
    end
    --- Get the player's astral power deficit.
    -- @return The player's astral power deficit.
    function Player:AstralPowerDeficit ()
        return self:AstralPowerMax() - self:AstralPower();
    end
    --- Get the player's astral power deficit.
    -- @return The player's astral power deficit.
    function Player:AstralPowerDeficitPercentage ()
        return (self:AstralPowerDeficit() / self:AstralPowerMax()) * 100;
    end

    --------------------------------
    --- 9 | Holy Power Functions --- <= Retribution Paladin
    --------------------------------
    --- Get the player's maximum holy power.
    -- @return The player's maximum holy power.
    function Player:HolyPowerMax ()
        return UnitPowerMax(self.UnitID, SPELL_POWER_HOLY_POWER);
    end
    --- Get the player's holy power.
    -- @return The player's holy power.
    function Player:HolyPower ()
        return UnitPower(self.UnitID, SPELL_POWER_HOLY_POWER);
    end
    --- Get the player's holy power as a percentage.
    -- @return The player's holy power as a percentage.
    function Player:HolyPowerPercentage ()
        return (self:HolyPower() / self:HolyPowerMax()) * 100;
    end
    --- Get the player's holy power deficit.
    -- @return The player's holy power deficit.
    function Player:HolyPowerDeficit ()
        return self:HolyPowerMax() - self:HolyPower();
    end
    --- Get the player's holy power deficit.
    -- @return The player's holy power deficit.
    function Player:HolyPowerDeficitPercentage ()
        return (self:HolyPowerDeficit() / self:HolyPowerMax()) * 100;
    end

    --------------------------------------
    --- 10 | Alternate Power Functions --- <= Should support every Alternate Power (like Souls Shards on Warlock or Holy Power on Paladin)
    --------------------------------------
    --- Get the player's maximum alternate power.
    -- @return The player's maximum alternate power.
    function Player:AlternatePowerMax ()
        return UnitPowerMax(self.UnitID, SPELL_POWER_ALTERNATE_POWER);
    end
    --- Get the player's alternate power.
    -- @return The player's alternate power.
    function Player:AlternatePower ()
        return UnitPower(self.UnitID, SPELL_POWER_ALTERNATE_POWER);
    end
    --- Get the player's alternate power as a percentage.
    -- @return The player's alternate power as a percentage.
    function Player:AlternatePowerPercentage ()
        return (self:AlternatePower() / self:AlternatePowerMax()) * 100;
    end
    --- Get the player's alternate power deficit.
    -- @return The player's alternate power deficit.
    function Player:AlternatePowerDeficit ()
        return self:AlternatePowerMax() - self:AlternatePower();
    end
    --- Get the player's alternate power deficit.
    -- @return The player's alternate power deficit.
    function Player:AlternatePowerDeficitPercentage ()
        return (self:AlternatePowerDeficit() / self:AlternatePowerMax()) * 100;
    end

    --------------------------------
    --- 11 | Maelstrom Functions --- <= Elemental & Enhancement Shaman
    --------------------------------
    --- Get the player's maximum maelstrom.
    -- @return The player's maximum maelstrom.
    function Player:MaelstromMax ()
        return UnitPowerMax(self.UnitID, SPELL_POWER_MAELSTROM);
    end
    --- Get the player's maelstrom.
    -- @return The player's maelstrom.
    function Player:Maelstrom ()
        return UnitPower(self.UnitID, SPELL_POWER_MAELSTROM);
    end
    --- Get the player's maelstrom as a percentage.
    -- @return The player's maelstrom as a percentage.
    function Player:MaelstromPercentage ()
        return (self:Maelstrom() / self:MaelstromMax()) * 100;
    end
    --- Get the player's maelstrom deficit.
    -- @return The player's maelstrom deficit.
    function Player:MaelstromDeficit ()
        return self:MaelstromMax() - self:Maelstrom();
    end
    --- Get the player's maelstrom deficit.
    -- @return The player's maelstrom deficit.
    function Player:MaelstromDeficitPercentage ()
        return (self:MaelstromDeficit() / self:MaelstromMax()) * 100;
    end

    --------------------------
    --- 12 | Chi Functions --- <= Monk
    --------------------------
    --- Get the player's maximum chi.
    -- @return The player's maximum chi.
    function Player:ChiMax ()
        return UnitPowerMax(self.UnitID, SPELL_POWER_CHI);
    end
    --- Get the player's chi.
    -- @return The player's chi.
    function Player:Chi ()
        return UnitPower(self.UnitID, SPELL_POWER_CHI);
    end
    --- Get the player's chi as a percentage.
    -- @return The player's chi as a percentage.
    function Player:ChiPercentage ()
        return (self:Chi() / self:ChiMax()) * 100;
    end
    --- Get the player's chi deficit.
    -- @return The player's chi deficit.
    function Player:ChiDeficit ()
        return self:ChiMax() - self:Chi();
    end
    --- Get the player's chi deficit.
    -- @return The player's chi deficit.
    function Player:ChiDeficitPercentage ()
        return (self:ChiDeficit() / self:ChiMax()) * 100;
    end

    -------------------------------
    --- 13 | Insanity Functions --- <= Shadow Priest
    -------------------------------
    --- Get the player's maximum insanity.
    -- @return The player's maximum insanity.
    function Player:InsanityMax ()
        return UnitPowerMax(self.UnitID, SPELL_POWER_INSANITY);
    end
    --- Get the player's insanity.
    -- @return The player's insanity.
    function Player:Insanity ()
        return UnitPower(self.UnitID, SPELL_POWER_INSANITY);
    end
    --- Get the player's insanity as a percentage.
    -- @return The player's insanity as a percentage.
    function Player:InsanityPercentage ()
        return (self:Insanity() / self:InsanityMax()) * 100;
    end
    --- Get the player's insanity deficit.
    -- @return The player's insanity deficit.
    function Player:InsanityDeficit ()
        return self:InsanityMax() - self:Insanity();
    end
    --- Get the player's insanity deficit.
    -- @return The player's insanity deficit.
    function Player:InsanityDeficitPercentage ()
        return (self:InsanityDeficit() / self:InsanityMax()) * 100;
    end

    -------------------------------
    --- 14 | Obsolete Functions --- <= Was Destruction Burning Embers
    -------------------------------
    --------------------------------
    --- 15 | Obsolete2 Functions --- <= Was Demonology Demonic Fury
    --------------------------------

    -------------------------------------
    --- 16 | Arcane Charges Functions --- <= Arcane Mage
    -------------------------------------
    --- Get the player's maximum arcanes charges.
    -- @return The player's maximum arcanes charges.
    function Player:ArcaneChargesMax ()
        return UnitPowerMax(self.UnitID, SPELL_POWER_ARCANE_CHARGES);
    end
    --- Get the player's arcanes charges.
    -- @return The player's arcanes charges.
    function Player:ArcaneCharges ()
        return UnitPower(self.UnitID, SPELL_POWER_ARCANE_CHARGES);
    end
    --- Get the player's arcanes charges as a percentage.
    -- @return The player's arcanes charges as a percentage.
    function Player:ArcaneChargesPercentage ()
        return (self:ArcaneCharges() / self:ArcaneChargesMax()) * 100;
    end
    --- Get the player's arcanes charges deficit.
    -- @return The player's arcanes charges deficit.
    function Player:ArcaneChargesDeficit ()
        return self:ArcaneChargesMax() - self:ArcaneCharges();
    end
    --- Get the player's arcanes charges deficit.
    -- @return The player's arcanes charges deficit.
    function Player:ArcaneChargesDeficitPercentage ()
        return (self:ArcaneChargesDeficit() / self:ArcaneChargesMax()) * 100;
    end

    ---------------------------
    --- 17 | Fury Functions --- <= Havoc Demon Hunter
    ---------------------------
    --- Get the player's maximum fury.
    -- @return The player's maximum fury.
    function Player:FuryMax ()
        return UnitPowerMax(self.UnitID, SPELL_POWER_FURY);
    end
    --- Get the player's fury.
    -- @return The player's fury.
    function Player:Fury ()
        return UnitPower(self.UnitID, SPELL_POWER_FURY);
    end
    --- Get the player's fury as a percentage.
    -- @return The player's fury as a percentage.
    function Player:FuryPercentage ()
        return (self:Fury() / self:FuryMax()) * 100;
    end
    --- Get the player's fury deficit.
    -- @return The player's fury deficit.
    function Player:FuryDeficit ()
        return self:FuryMax() - self:Fury();
    end
    --- Get the player's fury deficit.
    -- @return The player's fury deficit.
    function Player:FuryDeficitPercentage ()
        return (self:FuryDeficit() / self:FuryMax()) * 100;
    end

    ---------------------------
    --- 18 | Pain Functions --- <= Vengeance Demon Hunter
    ---------------------------
    --- Get the player's maximum pain.
    -- @return The player's maximum pain.
    function Player:PainMax ()
        return UnitPowerMax(self.UnitID, SPELL_POWER_PAIN);
    end
    --- Get the player's pain.
    -- @return The player's pain.
    function Player:Pain ()
        return UnitPower(self.UnitID, SPELL_POWER_PAIN);
    end
    --- Get the player's pain as a percentage.
    -- @return The player's pain as a percentage.
    function Player:PainPercentage ()
        return (self:Pain() / self:PainMax()) * 100;
    end
    --- Get the player's pain deficit.
    -- @return The player's pain deficit.
    function Player:PainDeficit ()
        return self:PainMax() - self:Pain();
    end
    --- Get the player's pain deficit.
    -- @return The player's pain deficit.
    function Player:PainDeficitPercentage ()
        return (self:PainDeficit() / self:PainMax()) * 100;
    end


    ---------------------------------------------------------------------------------
    -------------------------------- CHARACTER STATS --------------------------------
    ---------------------------------------------------------------------------------

    function Player:AttackPower ()
        local APBase, APPos, APNeg = UnitAttackPower("player");
        return APBase+APPos+APNeg;
    end

    function Player:Mastery ()
        return (1 + GetMasteryEffect() / 100);
    end

    function Player:SpellHaste ()
        return 1/(1+UnitSpellHaste("player")/100);
    end

    function Player:Haste ()
        return UnitSpellHaste("player");
    end
    function Player:BonusDamage ()
        return select(7, UnitDamage("player"));
    end

    function Player:HasHero ()
        local heroismBuffs = { 32182, 90355, 80353, 2825, 178207 }
      for i = 1, #heroismBuffs do
        if UnitBuff('player', GetSpellInfo(heroismBuffs[i])) then
          return true
        end
      end
      return false
    end

    function Player:HeroDuration ()
      local heroismBuffs = { 32182, 90355, 80353, 2825, 178207 }
      for i = 1, #heroismBuffs do
        if UnitBuff('player', GetSpellInfo(heroismBuffs[i])) then
          local ExpirationTime = select(7, UnitBuff("player", GetSpellInfo(heroismBuffs[i])));
          return ExpirationTime and ExpirationTime - module.GetTime() or 0;
        end
      end
      return 0
    end

    --- Get whether the unit has sated (unable to get Heroism buff).
    -- @return Whether the unit has sated.
    function Player:HasSated ()
        local satedBuffs = { 80354, 57724 }
        for i = 1, #satedBuffs do
            if UnitDebuff('player', GetSpellInfo(satedBuffs[i])) then
                return true;
            end
        end
        return false;
    end

    --- Get whether the unit is eating.
    -- @return Whether the unit is eating.
    local FoodTable = {
            select(1, GetSpellInfo(104935)), -- Food
            select(1, GetSpellInfo(104270)), -- Drink
            select(1, GetSpellInfo(174303)) -- Refreshment
        };
    function Player:IsEating ()
        local GUID = self:GUID();
        if not GUID then return nil; end

        if not module.AurasInfos[GUID] or not module.AurasInfos[GUID].Buff then
            self:GetBuffs(GUID);
        end
        if module.AurasInfos[GUID].Buff then
            local Table = module.AurasInfos[GUID].Buffs;
            for i = 1, #FoodTable do
                for j = 1, #Table do
                    if FoodTable[i] == Table[j][1] then
                        return true;
                    end
                end
            end
        end
        return false;
    end

    function Player:HasImmunity ()
        local CantInterrupt = {
            104773 -- Unending Resolve
        };
        for i = 1, #CantInterrupt do
            if UnitBuff('player', GetSpellInfo(CantInterrupt[i])) then
                return true;
            end
        end
        return false;
    end


    ---------------------------------------------------------------------------------
    -------------------------------- CHARACTER PROCS --------------------------------
    ---------------------------------------------------------------------------------

    --- Iterate over Buffs to check each procs (+ their weights) and if it's greater overall than a threshold.
    -- @return Whether there is enough procs.
    local function ProcIteration (Spell, PTable, VTrigger, Duration)
        local CastTime = 0;
        if Spell then CastTime = Spell:CastTime(); elseif Duration then CastTime = Duration; end
        if not module.AurasInfos[C.PLAYERGUID] or not module.AurasInfos[C.PLAYERGUID].Buff then
            module.Unit.Player:GetBuffs(C.PLAYERGUID);
        end
        local ValueProc = 0;
        if module.AurasInfos[C.PLAYERGUID].Buff then
            local Table = module.AurasInfos[C.PLAYERGUID].Buffs;
            for i = 1, #PTable do
                for j = 1, #Table do
                    if PTable[i].BuffID == Table[j][11] and Table[j][7]-module.GetTime() > CastTime then
                        if PTable[i].CountBuffID then
                            if PTable[i].CountBuffID == PTable[i].BuffID then
                                ValueProc = ValueProc + Table[j][4]*PTable[i].Coef;
                            else
                                for k = 1, #Table do
                                    if PTable[i].CountBuffID == Table[k][11] then
                                        ValueProc = ValueProc + Table[k][4]*PTable[i].Coef;
                                        break;
                                    end
                                end
                            end
                        else
                            ValueProc = ValueProc + PTable[i].Coef;
                        end
                        break;
                    end
                end
            end
        end
        return VTrigger and ValueProc >= VTrigger or ValueProc >= 1;
    end

    --- Get whether the unit has any proc.
    -- @return Whether the unit has any proc.
    function Player:HasAnyProc (Spell, ValueToTrigProc, Duration)
        return self:HasDmgProc(Spell, ValueToTrigProc, Duration) or self:HasAgiProc(Spell, ValueToTrigProc, Duration) or self:HasIntProc(Spell, ValueToTrigProc, Duration) or self:HasStrProc(Spell, ValueToTrigProc, Duration) or self:HasCritProc(Spell, ValueToTrigProc, Duration) or self:HasHasteProc(Spell, ValueToTrigProc, Duration) or self:HasMasteryProc(Spell, ValueToTrigProc, Duration) or self:HasVersaProc(Spell, ValueToTrigProc, Duration) or self:HasHealthProc(Spell, ValueToTrigProc, Duration);
    end

    --- Get whether the unit has a Damage Modifier proc.
    -- @return Whether the unit has a Damage Modifier proc.
    local DmgPTable = {
        {BuffID = 187615, Coef = 1}, -- Maalus (Agi), Legendary Ring On Use Effect iLvL 735-795 (Use)
        {BuffID = 187611, Coef = 1}, -- Nithramus (Int), Legendary Ring On Use Effect iLvL 735-795 (Use)
        {BuffID = 187614, Coef = 1}, -- Thorasus (Str), Legendary Ring On Use Effect iLvL 735-795 (Use)
        {BuffID = 184293, Coef = 1} -- Spirit Shift, Soul Capacitor iLvL 695-725 (Proc)
    };
    function Player:HasDmgProc (Spell, ValueToTrigProc, Duration)
        return ProcIteration(Spell, DmgPTable, ValueToTrigProc, Duration);
    end

    --- Get whether the unit has an Agility Modifier proc.
    -- @return Whether the unit has an Agility Modifier proc.
    local AgiPTable = {
        {BuffID = 156423, Coef = 1}, -- Draenic Agility Potion (Use)
        {BuffID = 182059, Coef = 1}, -- Surge of Conquest, PvP Trinket iLvL 620 (Proc)
        {BuffID = 182068, Coef = 1}, -- Surge of Conquest, PvP Trinket iLvL 660 (Proc)
        {BuffID = 60233, Coef = 1}, -- Draenic Philosopher's Stone, Alchemy Crafted Trinket iLvl 620/640/655/670/680 (Proc)
        {BuffID = 177597, Coef = 1}, -- Lucky Double-Sided Coin, BoE Trinket iLvL 665 (Use)
        {BuffID = 177161, Coef = 1}, -- Legendary Ring Proc 10% iLvL 690 (Proc)
        {BuffID = 177172, Coef = 1} -- Legendary Ring Proc 15% iLvL 710 (Proc)
    };
    function Player:HasAgiProc (Spell, ValueToTrigProc, Duration)
        return ProcIteration(Spell, AgiPTable, ValueToTrigProc, Duration);
    end

    --- Get whether the unit has an Intelligence Modifier proc.
    -- @return Whether the unit has an Intelligence Modifier proc.
    local IntPTable = {
        {BuffID = 156426, Coef = 1}, -- Draenic Intellect Potion (Use)
        {BuffID = 182057, Coef = 1}, -- Surge of Dominance, PvP Trinket iLvL 620 (Proc)
        {BuffID = 182067, Coef = 1}, -- Surge of Dominance, PvP Trinket iLvL 660 (Proc)
        {BuffID = 60234, Coef = 1}, -- Draenic Philosopher's Stone, Alchemy Crafted Trinket iLvl 620/640/655/670/680 (Proc)
        {BuffID = 177159, Coef = 1}, -- Legendary Ring Proc 10% iLvL 690 (Proc)
        {BuffID = 177176, Coef = 1}, -- Legendary Ring Proc 15% iLvL 710 (Proc)
        {BuffID = 183775, Coef = 1}, -- Desecrated Shadowmoon Insignia - (Proc)
        {BuffID = 183924, Coef = 1} -- Desecrated Shadowmoon Insignia - (Proc)
    };
    function Player:HasIntProc (Spell, ValueToTrigProc, Duration)
        return ProcIteration(Spell, IntPTable, ValueToTrigProc, Duration);
    end

    --- Get whether the unit has a Strength Modifier proc.
    -- @return Whether the unit has a Strength Modifier proc.
    local StrPTable = {
        {BuffID = 156428, Coef = 1}, -- Draenic Strength Potion (Use)
        {BuffID = 182062, Coef = 1}, -- Surge of Victory, PvP Trinket iLvL 620 (Proc)
        {BuffID = 182069, Coef = 1}, -- Surge of Victory, PvP Trinket iLvL 660 (Proc)
        {BuffID = 60229, Coef = 1}, -- Draenic Philosopher's Stone, Alchemy Crafted Trinket iLvl 620/640/655/670/680 (Proc)
        {BuffID = 177189, Coef = 1}, -- Scabbard of Kyanos, BoE Trinket iLvL 665 (Use)
        {BuffID = 177160, Coef = 1}, -- Legendary Ring Proc 10% iLvL 690 (Proc)
        {BuffID = 177175, Coef = 1} -- Legendary Ring Proc 15% iLvL 710 (Proc)
    };
    function Player:HasStrProc (Spell, ValueToTrigProc, Duration)
        return ProcIteration(Spell, StrPTable, ValueToTrigProc, Duration);
    end

    --- Get whether the unit has a Crit Modifier proc.
    -- @return Whether the unit has a Crit Modifier proc.
    local CritPTable = {
        {BuffID = 159234, Coef = 1}, -- Mark of the Thunderlord (Proc - Enchant)
        {BuffID = 159676, Coef = 1}, -- Mark of the Frostwolf (Proc - Enchant)
        {BuffID = 177067, Coef = 0.125, CountBuffID = 177067}, -- Humming Blackiron Trigger (Proc w/ Stacks)
        {BuffID = 177063, Coef = 1}, -- Elementalist's Shielding Talisman (Proc)
        {BuffID = 165832, Coef = 1}, -- Coagulated Genesaur Blood (Proc)
        {BuffID = 176878, Coef = 1}, -- Beating Heart of the Mountain (Use)
        {BuffID = 177046, Coef = 1}, -- Goren Soul Repository (Proc)
        {BuffID = 176982, Coef = 1}, -- Stoneheart Idol (Proc)
        {BuffID = 165542, Coef = 1}, -- Gor'ashan's Lodestone Spike (Use)
        {BuffID = 177040, Coef = 1}, -- Tectus' Beating Heart (Proc)
        {BuffID = 176881, Coef = 1}, -- Turbulent Emblem (Use)
        {BuffID = 162917, Coef = 1}, -- Knight's Badge (Proc)
        {BuffID = 176978, Coef = 1}, -- Immaculate Living Mushroom (Proc)
        {BuffID = 162915, Coef = 1}, -- Skull of War (Proc)
        {BuffID = 162919, Coef = 1}, -- Nightmare Fire (Proc)
        {BuffID = 162920, Coef = 1}, -- Sandman's Pouch (Proc)
        {BuffID = 165532, Coef = 1} -- Voidmender's Shadowgem (Use) and Bonemaw's Big Toe (Use)
    };
    function Player:HasCritProc (Spell, ValueToTrigProc, Duration)
        return ProcIteration(Spell, CritPTable, ValueToTrigProc, Duration);
    end

    --- Get whether the unit has an Haste Modifier proc.
    -- @return Whether the unit has an Haste Modifier proc.
    local HastePTable = {
        {BuffID = 159675, Coef = 1}, -- Mark of Warsong (Proc - Enchant)
        {BuffID = 177051, Coef = 1}, -- Darmac's Unstable Talisman (Proc)
        {BuffID = 177086, Coef = 0.125, CountBuffID = 177086}, -- Auto-Repairing Autoclave (Proc w/ Stacks)
        {BuffID = 177035, Coef = 1}, -- Meaty Dragonspine Trophy (Proc)
        {BuffID = 177102, Coef = 0.125, CountBuffID = 177102}, -- Battering Talisman (Proc w/ Stacks)
        {BuffID = 176879, Coef = 1}, -- Emblem of Caustic Healing (Use)
        {BuffID = 176984, Coef = 1}, -- Blackheart Enforcer's Medallion (Proc)
        {BuffID = 176943, Coef = 1}, -- Formidable Censer of Faith (Proc)
        {BuffID = 176937, Coef = 1}, -- Formidable Relic of Blood (Proc)
        {BuffID = 176874, Coef = 1}, -- Vial of Convulsive Shadows (Use)
        {BuffID = 176980, Coef = 1}, -- Furyheart Talisman (Proc)
        {BuffID = 176875, Coef = 1}, -- Shards of Nothing (Use)
        {BuffID = 165822, Coef = 1}, -- Witherbark's Branch (Proc)
        {BuffID = 176882, Coef = 1}, -- Turbulent Focusing Crystal (Use)
        {BuffID = 176885, Coef = 1}, -- Turbulent Seal of Defiance (Use)
        {BuffID = 165531, Coef = 1}, -- Fleshrender's Meathook (Use)
        {BuffID = 165822, Coef = 1} -- Spores of Alacrity (Proc)
    };
    function Player:HasHasteProc (Spell, ValueToTrigProc, Duration)
        return ProcIteration(Spell, HastePTable, ValueToTrigProc, Duration);
    end

    --- Get whether the unit has a Mastery Modifier proc.
    -- @return Whether the unit has a Mastery Modifier proc.
    local MasteryPTable = {
        {BuffID = 173322, Coef = 1}, -- Mark of Bleeding Hollow (Proc - Enchant)
        {BuffID = 177096, Coef = 0.125, CountBuffID = 177096}, -- Forgemaster's Insignia (Proc w/ Stacks)
        {BuffID = 177081, Coef = 0.125, CountBuffID = 177083}, -- Blackiron Micro Crucible (Proc w/ Stacks)
        {BuffID = 177038, Coef = 1}, -- Scales of Doom (Proc)
        {BuffID = 176935, Coef = 1}, -- Formidable Fang (Proc)
        {BuffID = 177056, Coef = 1}, -- Blast Furnace Door (Proc)
        {BuffID = 177042, Coef = 1}, -- Horn of Screaming Spirits (Proc)
        {BuffID = 176939, Coef = 1}, -- Formidable Jar of Doom (Proc)
        {BuffID = 176941, Coef = 1}, -- Formidable Orb of Putrescence (Proc)
        {BuffID = 165824, Coef = 1}, -- Petrified Flesh-Eating Spore (Proc) and Xeri'tac's Unhatched Egg Sac (Proc)
        {BuffID = 176876, Coef = 1}, -- Pol's Blinded Eye (Use)
        {BuffID = 165535, Coef = 1}, -- Kyrak's Vileblood Serum (Use)
        {BuffID = 176883, Coef = 1}, -- Turbulent Vial of Toxin (Use)
        {BuffID = 176884, Coef = 1}, -- Turbulent Relic of Mendacity (Use)
        {BuffID = 165535, Coef = 1}, -- Tharbek's Lucky Pebble (Use)
        {BuffID = 165485, Coef = 1}, -- Kihra's Adrenaline Injector (Use)
        {BuffID = 201410, Coef = 1} -- Orb of Voidsight
    };
    function Player:HasMasteryProc (Spell, ValueToTrigProc, Duration)
        return ProcIteration(Spell, MasteryPTable, ValueToTrigProc, Duration);
    end

    --- Get whether the unit has a Versatility Modifier proc.
    -- @return Whether the unit has a Versatility Modifier proc.
    local VersaPTable = {
        {BuffID = 159679, Coef = 1}, -- Mark of Blackrock (Proc - Enchant)
        {BuffID = 159678, Coef = 1}, -- Mark of Shadowmoon (Proc - Enchant)
        {BuffID = 170397, Coef = 1}, -- Rapid Adaptation (All iLvL 660 PvP Trinket Versa Use)
        {BuffID = 176974, Coef = 1}, -- Mote of the Mountain (Proc)
        {BuffID = 165543, Coef = 1}, -- Ragewing's Firefang (Use)
        {BuffID = 177060, Coef = 1}, -- Ironspike Chew Toy (Proc)
        {BuffID = 165833, Coef = 1}, -- Leaf of the Ancient Protectors (Proc)
        {BuffID = 162913, Coef = 1}, -- Winged Hourglass (Proc)
        {BuffID = 176873, Coef = 1}, -- Tablet of Turnbuckle Teamwork (Use)
        {BuffID = 165543, Coef = 1}, -- Emberscale Talisman (Use)
        {BuffID = 177053, Coef = 1}, -- Evergaze Arcane Eidolon (Proc)
        {BuffID = 165534, Coef = 1}, -- Enforcer's Stun Grenade (Use)
        {BuffID = 182073, Coef = 1}, -- Rapid Adaptation (All iLvL 620 PvP Trinket Versa Use)
        {BuffID = 187613, Coef = 1} -- Sanctus (Tanks), Legendary Ring On Use Effect iLvL 735-795 (Use)
    };
    function Player:HasVersaProc (Spell, ValueToTrigProc, Duration)
        return ProcIteration(Spell, VersaPTable, ValueToTrigProc, Duration);
    end

    --- Get whether the unit has an Health Modifier proc.
    -- @return Whether the unit has an Health Modifier proc.
    local HealthPTable = {
        {BuffID = 176460, Coef = 1}, -- Kyb's Foolish Perseverance (Use)
        {BuffID = 181706, Coef = 1} -- Savage Fortitude (All iLvL 620 & 660 PvP Trinket Health Use)
    };
    function Player:HasHealthProc (Spell, ValueToTrigProc, Duration)
        return ProcIteration(Spell, HealthPTable, ValueToTrigProc, Duration);
    end

    --- Add Position & Range Outputs to Status. (Mostly used by Melees)
    function Player:AddCommonMeleeStatus ()
        module.AddOutput("Position");
        module.AddOutput("Range");
    end

    --- Check the values of the Position & Range Outputs from Status and adjust them. (Mostly used by Melees)
    function Player:SetCommonMeleeStatus ()
        if Target:Exists() and not self:Equals(Target) then
            local IsBehind = self:IsBehindPulsed(Target);
            if IsBehind == "No Information" then
                module.SetOutput("Position", "|CFF939393No Information|r");
            elseif not IsBehind then
                module.SetOutput("Position", "|CFFFE9A2EFront|r");
            else
                module.SetOutput("Position", "|CFF2E64FEBack|r");
            end
            if self:DistanceTo(Target) <= 5 then
                module.SetOutput("Range", "|cFF00FF00In Melee|r");
            else
                module.SetOutput("Range", "|cFFFF0000Not In Melee|r");
            end
        else
            module.SetOutput("Range", "|CFF939393No Information|r");
            module.SetOutput("Position", "|CFF939393No Information|r");
        end
    end

    --- Handle the interrupt for one spell + arcane torrent.
    -- @param SpellToCast : The Spell to Cast to Interrupt (For rogue it would be "Kick").
    -- @param ArcaneTorrentSpell : The Arcane Torrent spell for the class (it is usually defined as ArcaneTorrent).
    local IHT = { -- Interrupt Handler Table
        DarkSimSupport = false,
        PercentageTimer = 0,
        LowValue = 40,
        HighValue = 60,
        RandomValue = math.random(),
        Percentage = 50,
        CustomInterruptListEnabled = false,
        ArcaneTorrentEnabled = false,
        CustomFunction = function (ThisUnit) return false; end,
        InterruptibleUnit = nil
    };
    function Player:UseInterrupt (SpellToCast, ArcaneTorrentSpell, PetInterrupt)
        if module.IsOptionEnabled("Interrupt between %") then
            -- Update Percentage Value every 200ms
            if module.GetTime() >= IHT.PercentageTimer then
                IHT.LowValue, IHT.HighValue, IHT.RandomValue = module.GetOptionValue("Interrupt between %") or 40, module.GetSecondOptionValue("Interrupt between %") or 60, math.random();
                IHT.Percentage = IHT.LowValue and IHT.HighValue and IHT.RandomValue and IHT.LowValue + (IHT.RandomValue*(IHT.HighValue - IHT.LowValue)) or 50;
                IHT.PercentageTimer = module.GetTime() + 0.2;
            end
            -- Get Options Values
            IHT.DarkSimSupport = module.IsOptionEnabled("Help Dark Simulacrum");
            IHT.CustomInterruptListEnabled = module.IsOptionEnabled("Custom Interrupt List");
            IHT.ArcaneTorrentEnabled = ArcaneTorrentSpell and ArcaneTorrentSpell:Exists() and module.IsOptionEnabled("Arcane Torrent Interrupt") or false;
            -- Target
            if Target:Exists() and Target:IsInterruptible() and (not IHT.CustomInterruptListEnabled or TableContains(InterruptTargets, "name", select(1, Target:IsCasting()))) and Target:CastedPercent() >= IHT.Percentage and (not DarkSimSupport or not (Target:DebuffAny(Spell(77606)) and module.DarkSimList[Target:CreatureID()] and module.DarkSimList[Target:CreatureID()][select(1, Target:IsCasting())])) then
                -- Class Spell
                if Target:CanCast(SpellToCast) or (PetInterrupt and Target:PetCanCast(SpellToCast)) then
                    Target:Cast(SpellToCast);
                    return;
                -- Arcane Torrent
                elseif IHT.ArcaneTorrentEnabled and self:DistanceTo(Target) < 5 and self:CanCast(ArcaneTorrentSpell) then
                    self:Cast(ArcaneTorrentSpell);
                    return;
                end
            end
            -- Any Unit
            if module.IsOptionEnabled("Interrupt Any Unit") then
                IHT.CustomFunction = function (ThisUnit) return not ThisUnit:IsDeadOrGhost() and ThisUnit:IsInCombat() and ThisUnit:IsInterruptible() and Unit.Player:IsWithinCastRange(ThisUnit, SpellToCast) and Unit.Player:CanAttack(ThisUnit) and (not IHT.CustomInterruptListEnabled or TableContains(InterruptTargets, "name", select(1, ThisUnit:IsCasting()))) and ThisUnit:CastedPercent() >= IHT.Percentage and (not DarkSimSupport or not (ThisUnit:DebuffAny(Spell(77606)) and module.DarkSimList[ThisUnit:CreatureID()] and module.DarkSimList[ThisUnit:CreatureID()][select(1, ThisUnit:IsCasting())])); end;
                IHT.InterruptibleUnit = Unit.FirstWhere(IHT.CustomFunction, "Enemy");
                if IHT.InterruptibleUnit then
                    if IHT.InterruptibleUnit:CanCast(SpellToCast) or (PetInterrupt and IHT.InterruptibleUnit:PetCanCast(SpellToCast)) then
                        IHT.InterruptibleUnit:Cast(SpellToCast);
                    elseif IHT.ArcaneTorrentEnabled and self:CanCast(ArcaneTorrentSpell) then
                        self:Cast(ArcaneTorrentSpell);
                    end
                end
            end
        end
    end

    --- Change the target of the player.
    function Player:TargetUnit (GUID)
        TargetUnit(GUID);
    end

    --- Find a new target if possible.
    -- @param SpellToCheck : The Spell with wich we check the range.
    -- @param SupportMode : Enable to stop ReTarget if targeting a dead ally.
    local RTHT = {
        NewTarget = nil,
        PreviousTarget = nil,
        TargetSwapTimer = 0,
        MainSpeed = 10,
        OffSpeed = 10
    };
    function Player:ReTarget (SpellToCheck, SupportMode)
        if module.GetOptionValue("Target | Attack") ~= "Disabled" and (not Target:Exists() or (Target:IsDeadOrGhost() and (not SupportMode or not Player:CanSupport(Target))) or (module.IsOptionEnabled("Auto Re-Target") and Target:Exists() and Player:CanAttack(Target) and (Player:DistanceTo(Target) > module.GetSecondOptionValue("Auto Re-Target") or not Player:IsFacing(Target) or (module.GetOptionValue("Target | Attack") == "Untanked" and Player:IsTanking(Target))))) then
            RTHT.NewTarget = Unit.AutoTarget(SpellToCheck, module.GetOptionValue("Target | Attack"));
            if RTHT.NewTarget then
                if not Target:Exists() or Target:IsDeadOrGhost() or (module.IsOptionEnabled("Auto Re-Target") and module.GetOptionValue("Auto Re-Target") == "Switch") then
                    RTHT.NewTarget:Attack();
                else
                    if module.GetSecondOptionValue("Target | Attack") == "Enabled" and module.GetTime() > RTHT.TargetSwapTimer then
                        RTHT.PreviousTarget = Target:GUID();
                        Player:TargetUnit(RTHT.NewTarget:GUID());
                        RunMacroText("/startattack target");
                        Player:TargetUnit(RTHT.PreviousTarget);
                        RTHT.MainSpeed, RTHT.OffSpeed = Player:AttackSpeed();
                        RTHT.TargetSwapTimer = module.GetTime() + math.min(RTHT.MainSpeed, RTHT.OffSpeed or 10);
                    end
                    return RTHT.NewTarget;
                end
                return nil;
            end
        end
    end

    --- Marked for Death Handler (Rogue)
    -- @param MarkedForDeath : The Spell.
    -- @param CPDiff : MaxComboPoint - Player:ComboPoints(). (From Rotation)
    -- @param Enemies : The Enemies Table corresponding of Spell Range (30y in our case)
    local MfDHT = {
        Enemies = {},
        Samples = 10,
        Coeff = 3,
        TTD = 0,
        BestUnit = nil,
        BestUnitTTD = 60
    };
    function Player:UseMarkedForDeath (MarkedForDeath, CPDiff)
        if module.IsOptionEnabled("Marked For Death") and module.GetOptionValue("Marked For Death") == "Adds" and (module.CooldownsAllowed() or module.GetSecondOptionValue("Marked For Death") == "Always") and MarkedForDeath:Exists() and not MarkedForDeath:IsOnCooldown() and CPDiff > 0 then
            MfDHT.Enemies = Player:EnemiesWithinDistance(30, false);
            -- Get Handler Settings.
            if CPDiff > 5 then CPDiff = 5; end
            MfDHT.Coeff = Player:Power() < 50 and 3 or 2;
            MfDHT.TTD = CPDiff*MfDHT.Coeff;
            -- TTD Units Handler.
            MfDHT.BestUnit, MfDHT.BestUnitTTD = nil, 60;
            local ThisUnit, ThisUnitTTD;
            for i = 1, #MfDHT.Enemies do
                ThisUnit = MfDHT.Enemies[i];
                ThisUnitTTD = ThisUnit:TimeToDie(MfDHT.Samples);
                if ThisUnitTTD < MfDHT.TTD and ThisUnitTTD < MfDHT.BestUnitTTD and not ThisUnit:IsMfdBlacklisted() and ThisUnit:CanCast(MarkedForDeath) then
                    MfDHT.BestUnit, MfDHT.BestUnitTTD = ThisUnit, ThisUnitTTD;
                end
            end
            -- Cast MfD if we got an unit.
            if MfDHT.BestUnit then
                MfDHT.BestUnit:Cast(MarkedForDeath);
                return true;
            end
        end
    end

    --- PickPocket Handler Init (Rogue)
    function Player:PickPocketInit ()
        module.PickPocketed = {};
        -- Force AutoLoot
        if GetCVar("autoLootDefault") ~= "1" then
            SetCVar("autoLootDefault", "1")
        end
        -- Loot Message (Depending on Locale)
        local LootMessage;
        local Locale = GetLocale();
        -- German
        if Locale == "deDE" then
            --LOOT_ITEM_SELF = "Ihr erhaltet Beute: %s.";
            LootMessage = string.sub(LOOT_ITEM_SELF, 1, 18);
        -- Spanish
        elseif Locale == "esES" or Locale == "esMX" then
            --LOOT_ITEM_SELF = "Recibes botn: %s.";
            LootMessage = string.sub(LOOT_ITEM_SELF, 1, 13);
        -- French
        elseif Locale == "frFR" then
            --LOOT_ITEM_SELF = "Vous recevez le butin : %s.";
            LootMessage = string.sub(LOOT_ITEM_SELF, 1, 21);
        -- Italian
        elseif Locale == "itIT" then
            --LOOT_ITEM_SELF = "Hai ricevuto: %s.";
            LootMessage = string.sub(LOOT_ITEM_SELF, 1, 12);
        -- Korean
        elseif Locale == "koKR" then
            --LOOT_ITEM_SELF = " : %s";
            LootMessage = string.sub(LOOT_ITEM_SELF, 1, 11);
        -- Portuguese (Brazil)
        elseif Locale == "ptBR" then
            --LOOT_ITEM_SELF = "Voc recebe o saque: %s.";
            LootMessage = string.sub(LOOT_ITEM_SELF, 1, 19);
        -- Russian
        elseif Locale == "ruRU" then
            --LOOT_ITEM_SELF = " : %s.";
            LootMessage = string.sub(LOOT_ITEM_SELF, 1, 11);
        -- Chinese
        elseif Locale == "zhCN" or Locale == "zhTW" then
            --LOOT_ITEM_SELF = "%s";
            LootMessage = string.sub(LOOT_ITEM_SELF, 1, 6);
        -- English and Others not recognized.
        else
            --LOOT_ITEM_SELF = "You receive loot: %s.";
            LootMessage = string.sub(LOOT_ITEM_SELF, 1, 16);
        end
        -- Event Handler
        module:RegisterForEvent(
            function (Message)
                -- Variables Reset
                if PickPocketAttempt and module.GetTime()-PickPocketAttempt >= 1.5 then
                    PickPocketAttempt, PickPocketTarget = nil, nil;
                end
                -- Table Update
                -- Legion Alpha Message : SPELL_FAILED_TARGET_NO_POCKETS = 50 ; ERR_ALREADY_PICKPOCKETED = 625 ; ERR_ITEM_MAX_COUNT = ? ; LootMessage = LootMessage
                if PickPocketAttempt and ((Message == SPELL_FAILED_TARGET_NO_POCKETS or Message == 50) or (Message == ERR_ALREADY_PICKPOCKETED or Message == 625) or Message == ERR_ITEM_MAX_COUNT or string.find(Message, LootMessage)) then
                    for Key, Value in ipairs(PickPocketed) do
                        if not FetchedUnitsInfos[Key] then
                            PickPocketed[Key] = nil;
                        end
                    end
                    PickPocketed[PickPocketTarget] = true;
                    PickPocketAttempt = nil;
                end
            end
            , "UI_ERROR_MESSAGE"
            , "CHAT_MSG_LOOT"
        );
        module.PickPocketInitialized = true;
    end


    --------------------------------------------------------------------------------
    -------------------------------- CHARACTER GEAR --------------------------------
    --------------------------------------------------------------------------------

    --- Get whether the player has its Class Trinket equipped (from Archimonde - WoD).
    -- @return Whether the player has its Class Trinket equipped.
    function Player:HasClassTrinket ()
        local T18Trinkets = {
            124513, -- Death Knight : Reaper's Harvest
            124514, -- Druid : Seed of Creation
            124515, -- Hunter : Talisman of the Master Tracker
            124516, -- Mage : Tome of Shifting Words
            124517, -- Monk : Sacred Draenic Incense
            124518, -- Paladin : Libram of Vindication
            124519, -- Priest : Repudiation of War
            124520, -- Rogue : Bleeding Hollow Toxin Vessel
            124521, -- Shaman : Core of the Primal Elements
            124522, -- Warlock : Fragment of the Dark Star
            124523 -- Warrior : Worldbreaker's Resolve
        };
        local Item;
        for i = 13, 14 do
            Item = select(1, GetInventoryItemID("player", i));
            if Item ~= nil then
                for j = 1, 11 do
                    if Item == T18Trinkets[j] then
                        return true;
                    end
                end
            end
        end
        return false;
    end

    --- Get the number of Bonuses from a given Set the player has. (T17 - T18 Supported)
    -- @return The number of Bonuses from a given Set the player has.
    function Player:HasTier (Tier)
        -- Set Bonuses are disabled in Challenge Mode (Diff = 8) and in Proving Grounds (Map = 1148) .
        local DifficultyID, _, _, _, _, MapID = select(3, GetInstanceInfo());
        if DifficultyID == 8 or MapID == 1148 then return 0; end
        -- Sanity Checks for Tier argument
        local Tier = string.upper(Tier);
        if Tier == nil then Tier = "T18"; end
        -- Define Sets
        local Slots = {
            1, -- INVSLOT_HEAD
            3, -- INVSLOT_SHOULDER
            5, -- INVSLOT_CHEST
            7, -- INVSLOT_LEGS
            10, -- INVSLOT_HAND
            15 -- INVSLOT_BACK
        };
        local Sets = {
            ["T18"] = {
                -- Warrior
                [1]     =   {124319, 124329, 124334, 124340, 124346, 999999},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Paladin
                [2]     =   {124318, 124328, 124333, 124339, 124345, 999999},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Hunter
                [3]     =   {124284, 124292, 124296, 124301, 124307, 999999},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Rogue
                [4]     =   {124248, 124257, 124263, 124269, 124274, 999999},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Priest
                [5]     =   {124172, 124155, 124161, 124166, 124178, 999999},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- DeathKnight
                [6]     =   {124317, 124327, 124332, 124338, 124344, 999999},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Shaman
                [7]     =   {124303, 124293, 124297, 124302, 124308, 999999},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Mage
                [8]     =   {124171, 124154, 124160, 124165, 124177, 999999},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Warlock
                [9]     =   {124173, 124156, 124162, 124167, 124179, 999999},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Monk
                [10]    =   {124247, 124256, 124262, 124268, 124273, 999999},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Druid
                [11]    =   {124246, 124255, 124261, 124267, 124272, 999999},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Demon Hunter
                [12]    =   {999999, 999999, 999999, 999999, 999999, 999999}    -- Chest, Hands, Head, Legs, Shoulder, Back
            },
            ["T19"] = {
                -- Warrior
                [1]     =   {138351, 138354, 138357, 138360, 138363, 138374},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Paladin
                [2]     =   {138350, 138353, 138356, 138359, 138362, 138369},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Hunter
                [3]     =   {138339, 138340, 138342, 138344, 138347, 138368},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Rogue
                [4]     =   {138326, 138329, 138332, 138335, 138338, 138371},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Priest
                [5]     =   {138319, 138310, 138313, 138316, 138322, 138370},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- DeathKnight
                [6]     =   {138349, 138352, 138355, 138358, 138361, 138364},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Shaman
                [7]     =   {138346, 138341, 138343, 138345, 138348, 138372},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Mage
                [8]     =   {138318, 138309, 138312, 138315, 138321, 138365},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Warlock
                [9]     =   {138320, 138311, 138314, 138317, 138323, 138373},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Monk
                [10]    =   {138325, 138328, 138331, 138334, 138337, 138367},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Druid
                [11]    =   {138324, 138327, 138330, 138333, 138336, 138366},   -- Chest, Hands, Head, Legs, Shoulder, Back
                -- Demon Hunter
                [12]    =   {138376, 138377, 138378, 138379, 138380, 138375}    -- Chest, Hands, Head, Legs, Shoulder, Back
            }
        };
        -- Scan every items
        local EquippedItems = 0;
        local Item;
        for i = 1, #Slots do
            Item = select(1, GetInventoryItemID("player", Slots[i]));
            -- If there is an item in that slot
            if Item ~= nil then
                -- Compare it to items in our items list
                for j = 1, #Slots do
                    if Item == Sets[Tier][C.CLASSINDEX][j] then
                        EquippedItems = EquippedItems + 1;
                    end
                end
            end
        end
        return EquippedItems > 1, EquippedItems > 3;
    end


    -- Bad Debuffs Manager
    -- Tanks - {{"Tanks", "Spell Name"[, stacks]}, spellID} - {{"Tanks", "Fel Fury", 5}, 181282} -- needs more healing on tanks affected by this debuff
    -- Expiration - {{"Expiration", "Spell Name"}, spellID} - {{"Expiration", "Artillery"}, 182108} -- for Shields before buff ends
    -- Shield - {{"Shield", "Spell Name"}, spellID} - {{"Shield", "Artillery"}, 182108} -- for Shields
    -- Speed - {{"Speed", "Spell Name"}, spellID} - {{"Speed", "Hunger for Life"}, 180146} -- for Body and Soul/Feather
    -- Top - {{"Top", "Spell Name"}, spellID} - {{"Top", "Chomp"}, 145263} -- for bad debuffs that we need to heal to 100%
    -- Debuff - {{"Debuff", "Spell Name"[, stacks]}, spellID} - {{"Debuff", "Foul Crush"}, 181307} - {{"Debuff", "Blitz", 2}, 179886} -- for hots and shields
    -- Dispel - {{"Debuff", "Spell Name", stacks, distance}, spellID} - {{"Dispel", "Aqua Bomb", 0, 0}, 145206} - For Dispels with specific parameters

    -- If we are fighting the boss with the specific ID, we will cycle all its childs.
    -- module.EncounterID contains the encounter ID
    module.BadDebuffs =  {
        -- Immersus
        [1602] = {
            {{"Top", "Testing"}, 143436}
        },
        -- Imperator (Highmaul tester)
        [1705] = {
            -- {{"Debuff", "Mark of Chaos"}, 158605},
            {{"Debuff", "Fixate"}, 157763},
            -- {{"Top", "Branded"}, 156225},
            -- {{"Top", "Branded: Fortification"}, 164005},
            -- {{"Top", "Branded: Replication"}, 164006},
            -- {{"Tanks", "Fetter"}, 158619},
        },
        -- Proving Grounds
        [0] = {
            {{"Top", "Chomp"}, 145263},
            {{"Debuff", "Chomp"}, 145263},
            {{"Debuff", "Lava Burns", 2}, 145403},
            --{{"Tanks", "Aqua Bomb"}, 145206}
            {{"Dispel", "Aqua Bomb",0, 0}, 145206},
        },
        -- Iron Reaver
        [1785] = {
            {{"Expiration", "Artillery"}, 182108},
            {{"Debuff", "Blitz"}, 179886},
            {{"Debuff", "Unstable Orb", 1}, 182001},
            {{"Debuff", "Immolation", 1}, 182074},
            {{"Speed", "Fuel Streak"}, 182003}
        },
        -- Assault
        [1778] = {
            {{"Debuff", "Corruption Siphon"}, 187448},
            {{"Tanks", "Slam"}, 184243},
            {{"Expiration", "Unstable Orb"}, 184379}
        },
        -- Council
        [1798] = {
            {{"Debuff", "Mark of the Necromander"}, 185074}
        },
        -- Kormrok
        [1787] = {
            {{"Expiration", "Explosive Burst"}, 181306},
            {{"Debuff", "Crush"}, 187819},
            {{"Tanks", "Foul Crush"}, 181307}
        },
        -- Gorefiend
        [1783] = {
            {{"Expiration", "Touch of Doom"}, 189434},
            {{"Debuff", "Shared Fate"}, 179909},
            {{"Tanks", "Fel Fury", 5}, 181282},
            {{"Speed", "Hunger for Life"}, 180146}
        },
        -- Shadow-Lord Iskar
        [1788] = {
            {{"Debuff", "Fel Chakram"}, 182173},
            {{"Debuff", "Fel Fire"}, 182600},
            {{"Speed", "Phantasmal Winds"}, 181956},
            {{"Speed", "Fel Beam Fixate"}, 181956}
        },
        -- Fel Lord Zakuun
        [1777] = {
            {{"Speed", "Seed of Destruction"}, 181508},
            {{"Debuff", "Rumbling Fissure"}, 179428},
            {{"Shield", "Befouled"}, 179711},
        },
        -- Socrethar the Eternal
        [1794] = {
            {{"Debuff", "Gift of the Man'ari"}, 184124},
            {{"Tanks", "Shattered Defenses", 3}, 182038},
            {{"Speed", "Felblaze Residue"}, 182218},
            {{"Speed", "Voltatile Fel Orb"}, 189627}
        },
        -- Xhul'horac
        [1800] = {
            {{"Debuff", "Fel Surge"}, 186407},
            {{"Debuff", "Void Surge"}, 186333},
            {{"Debuff", "Wasting Void", 1}, 186063},
            {{"Debuff", "Felsinged", 1}, 186073},
            {{"Debuff", "Ablaze", 1}, 188208}
        },
        -- Tyrant Velhari
        [1784] = {
            {{"Shield", "Touch of Harm"}, 180166},
            {{"Debuff", "Font of Corruption"}, 180526},
            {{"Expiration", "Annihiliating Strike"}, 180260}
        },
        -- Mannoroth
        [1795] = {
            {{"Debuff", "Shadowforce"}, 182112},
            {{"Expiration", "Mannoroth's Gaze"}, 181617},
            {{"Tank", "Doom Spike"}, 181119},
            {{"Debuff", "Mark of the Legion"}, 188514},
            {{"Debuff", "Mark of Doom"}, 181099},
            {{"Debuff", "Empowered Shadowforce"}, 182084},
            {{"Debuff", "Empowered Mannoroth's Gaze"}, 182006},
        },
        -- Kilrogg
        [1786] = {
            {{"Shield", "Rending Howl"}, 183917},
            {{"Debuff", "Heart Seeker"}, 180389},
            {{"Tanks", " Shredded Armor"}, 180200}
        },
        -- Archimonde
        [1799] = {
            {{"Expiration", "Wrough Chaos"}, 184265},
            {{"Expiration", "Focused Chaos"}, 185014},
            {{"Debuff", "Devour Life"}, 187047},
            {{"Debuff", "Doomfire", 1}, 189897},
            {{"Debuff", "Shackled Torment"}, 184931},
            {{"Speed", "Nether Banish"}, 186961}
        },
        -------------------
        -- The Nighthold --
        -------------------
        -- Skorpyron
        [1849] = {},
        -- Chromatic Anomaly
        [1865] = {
            {{"Top", "Time Release"}, 219966}
        },
        --Trilliax
        [1867] = {
            {{"Debuff", "Toxic Slice"}, 206789}
        },
        -- Spellblade Aluriel
        [1871] = {},
        -- Tichondrius
        [1862] = {
            {{"Debuff", "Carrion Plague"}, 212997}
        },
        -- Star Augur Etraeus
        [1863] = {},
        -- Krosus
        [1842] = {},
        -- High Botanist Tel'arm
        [1886] = {
            {{"Dispel", "Parasitic Fetter", 0, 8}, 218424}
        },
        -- Grand Magistrix Elisande
        [1872] = {},
        -- Gul'dan
        [1866] = {},
        -----------------------
        -- Emerald Nightmare --
        -----------------------
        -- Nythendra
        [1853] = {},
        -- Il'gynoth, Heart of Corruption
        [1873] = {},
        -- Elerethe Renferal
        [1876] = {},
        -- Ursoc
        [1841] = {},
        -- Dragons of Nightmare
        [1854] = {},
        -- Cenarius
        [1877] = {},
        -- Xavius
        [1864] = {}
    }

    -- Retutns a table of units wich can be cycled to apply hots, shields and to actively heal
    --@ Accepts: TheseUnits - An array of valid units to parse, usually obtained via Player:GroupUnitsAvailableForHealing(100, true, 40, true)
    --@ Returns: An array of arrays of units classified by categories
    function Player:GetRaidDebuffs (TheseUnits)
        -- local bossID = select(6,strsplit("-", Unit.Boss1:GUID() or ""))
        local bossID = module.EncounterID-- tonumber(bossID)
        local debuffedUnits = {["Tanks"]={},["Expiration"]={},["Shield"]={},["Speed"]={},["Top"]={},["Debuff"]={},["Dispel"]={}};
        if select(8,GetInstanceInfo()) == 1148 or (Unit.Boss1 and Unit.Boss1:Exists() and module.BadDebuffs[bossID] ~= nil) then
            local thisBossTable = (select(8,GetInstanceInfo()) == 1148 and module.BadDebuffs[0]) or module.BadDebuffs[bossID];
            local activeHealingValue = module.GetOptionValue("Active Healing");
            for i = 1, #thisBossTable do
                local thisBossDebuff = module.Spell(thisBossTable[i][2]);
                local thisCategory = thisBossTable[i][1][1];
                if thisCategory == "Tanks" then
                    for j = 1, #TheseUnits do
                        local thisUnit = TheseUnits[j];
                        local name, _, _, count, _, duration, expires = UnitDebuff(thisUnit.UnitID,thisBossDebuff:Name());
                        if name ~= nil and (thisBossTable[i][1][3] == nil or count >= thisBossTable[i][1][3]) and ((MainTank and thisUnit:Equals(MainTank)) or (OffTank and thisUnit:Equals(OffTank))) then
                            tinsert(debuffedUnits.Tanks,thisUnit);
                        end
                    end
                elseif thisCategory == "Expiration" then
                    for j = 1, #TheseUnits do
                        local thisUnit = TheseUnits[j];
                        local name, _, _, count, _, duration, expires = UnitDebuff(thisUnit.UnitID,thisBossDebuff:Name());
                        if name ~= nil and expires - module.GetTime() < 10 then
                            tinsert(debuffedUnits.Expiration,thisUnit);
                        end
                    end
                elseif thisCategory == "Shield" then
                    for j = 1, #TheseUnits do
                        local thisUnit = TheseUnits[j];
                        local name, _, _, count, _, duration, expires = UnitDebuff(thisUnit.UnitID,thisBossDebuff:Name());
                        if name ~= nil then
                            tinsert(debuffedUnits.Shield,thisUnit);
                        end
                    end
                elseif thisCategory == "Speed" then
                    for j = 1, #TheseUnits do
                        local thisUnit = TheseUnits[j];
                        local name, _, _, count, _, duration, expires = UnitDebuff(thisUnit.UnitID,thisBossDebuff:Name());
                        if name ~= nil then
                            tinsert(debuffedUnits.Speed,thisUnit);
                        end
                    end
                elseif thisCategory == "Top" then
                    for j = 1, #TheseUnits do
                        local thisUnit = TheseUnits[j];
                        local name, _, _, count, _, duration, expires = UnitDebuff(thisUnit.UnitID,thisBossDebuff:Name());
                        if name ~= nil then
                            tinsert(debuffedUnits.Top,thisUnit);
                        end
                    end
                elseif thisCategory == "Debuff" then
                    for j = 1, #TheseUnits do
                        local thisUnit = TheseUnits[j];
                        local name, _, _, count, _, duration, expires = UnitDebuff(thisUnit.UnitID,thisBossDebuff:Name());
                        if name ~= nil and (thisBossTable[i][1][3] == nil or count >= thisBossTable[i][1][3]) then
                            tinsert(debuffedUnits.Debuff,thisUnit);
                        end
                    end
                elseif thisCategory == "Dispel" then
                    -- If we found a unit to dispel in the first category then we dont look further.
                    if #debuffedUnits.Dispel == 0 then
                        for j = 1, #TheseUnits do
                            local thisUnit = TheseUnits[j];
                            local name, _, _, count, _, duration, expires = UnitDebuff(thisUnit.UnitID,thisBossDebuff:Name());
                            if name ~= nil and (thisBossTable[i][1][3] == 0 or count >= thisBossTable[i][1][3]) and (thisBossTable[i][1][4] == 0 or #thisUnit:HealUnitsAround(100, thisBossTable[i][1][4]) <= 1) then
                                tinsert(debuffedUnits.Dispel,thisUnit);
                            end
                        end
                    end
                end
            end
            return debuffedUnits;
        else
            return debuffedUnits;
        end
    end

    local DispelWait, BestUnit, BestUnitHealth, BestUnitRole, ThisUnit, ThisUnitHealth, ThisUnitRole, Option1, Option2 = 0, nil, 100, "", nil, 100, "", nil, nil;
    function Player:DispelHandler (DispelSpell, DispelOption, DispelUnit, ActiveDispelTable, Priority)
        -- We must always keep the Waiting Time counting even if set to normal.
        Option1, Option2 = module.GetOptionValue(DispelOption), module.GetSecondOptionValue(DispelOption);
        if DispelSpell:Exists() and module.IsOptionEnabled(DispelOption) then
            -- Important Raid Dispels
            if #ActiveDispelTable > 0 and (Option1 == "Normal" or Option1 == "High" or Priority == "Normal") then
                BestUnit, BestUnitHealth, BestUnitRole = nil, 100, "";
                for i = 1, #ActiveDispelTable do
                    ThisUnit, ThisUnitHealth, ThisUnitRole = ActiveDispelTable[i], ActiveDispelTable[i]:SpecialHealthPercentage(), UnitGroupRolesAssigned(ActiveDispelTable[i].UnitID);
                    if (BestUnit == nil or ThisUnitRole == "TANK" or (ThisUnitRole == "HEALER" and not BestUnitRole == "TANK") or ThisUnitHealth < BestUnitHealth) and ThisUnit:CanCast(DispelSpell) then
                        BestUnit, BestUnitHealth, BestUnitRole = ThisUnit, ThisUnitHealth, ThisUnitRole;
                    end
                end
                if BestUnit then
                    DispelWait = 0;
                    module.Bug("Active Dispel - Raid known Debuffs.");
                    BestUnit:Cast(DispelSpell);
                    return;
                end
            end
            -- Normal Dispels
            if DispelUnit then
                if Option2 == 0 and DispelUnit:CanCast(DispelSpell) then
                    module.Bug(DispelOption.. " on " .. DispelUnit:Name() .. " without delays");
                    DispelUnit:Cast(DispelSpell);
                    return;
                elseif Option2 ~= 0 and DispelWait == 0 then
                    DispelWait = module.GetTime() + Option2;
                    module.Bug(DispelOption .. " in " .. Option2 .. " seconds");
                elseif DispelWait ~= 0 and DispelWait ~= nil then
                    if DispelWait < module.GetTime() then
                        if (Priority == "Normal" or Option1 == "High") then
                            if DispelUnit:CanCast(DispelSpell) then
                                DispelWait = 0;
                                module.Bug(DispelOption .. " on " .. DispelUnit:Name() .. " after " .. module.GetTime() - DispelWait + Option2);
                                DispelUnit:Cast(DispelSpell);
                                return;
                            end
                        end
                    else
                        module.Bug(DispelOption .. " on " .. DispelUnit:Name() .. " in " .. math.floor((DispelWait - module.GetTime())*100)/100 .. " seconds");
                    end
                end
            end
        else
            DispelWait = 0;
        end
    end

    ---------------------------------------------------------------------------------------
    -------------------------------- CHARACTER CONSUMABLES --------------------------------
    ---------------------------------------------------------------------------------------

    --- Flasks Handler - Keep a flask buff up
    -- @param IsEnabled - Option Toggle (Bool)
    -- @param ModeValue - Option Value (String)
    -- Option: module.AddNewOption("General Settings", "Flask", 230, true, { 1, "Oralius", "Strength", "Stamina" }, nil, "Use Flask in combat.");
    -- Use: Player:Flask(module.IsOptionEnabled("Flask"), module.GetOptionValue("Flask"));
    function Player:Flask (IsEnabled, ModeValue)
        if IsEnabled then
            local OraliusWhisperingCrystal, WhispersOfInsanity = module.Item(118922, false, false, true), module.Spell(176151, false, false, true);
            local GreaterDraenicAgility, GreaterDraenicAgilityBuff = module.Item(109153, false, false, true), module.Spell(156064, false, false, true);
            local GreaterDraenicIntellect, GreaterDraenicIntellectBuff = module.Item(109155, false, false, true), module.Spell(156079, false, false, true);
            local GreaterDraenicStamina, GreaterDraenicStaminaBuff = module.Item(109160, false, false, true), module.Spell(156084, false, false, true);
            local GreaterDraenicStrenght, GreaterDraenicStrenghtBuff = module.Item(109156, false, false, true), module.Spell(156080, false, false, true);
            if not Player:Buff(WhispersOfInsanity) and not Player:Buff(GreaterDraenicStrenghtBuff) and not Player:Buff(GreaterDraenicStaminaBuff) and not Player:Buff(GreaterDraenicIntellectBuff) and not Player:Buff(GreaterDraenicAgilityBuff) then
                if ModeValue == "Oralius" and OraliusWhisperingCrystal:InStock() and not OraliusWhisperingCrystal:IsOnCooldown() then
                    OraliusWhisperingCrystal:Use(Player);
                end
                if ModeValue == "Agility" and GreaterDraenicAgility:InStock() and not GreaterDraenicAgility:IsOnCooldown() then
                    GreaterDraenicAgility:Use(Player);
                end
                if ModeValue == "Intellect" and GreaterDraenicIntellect:InStock() and not GreaterDraenicIntellect:IsOnCooldown() then
                    GreaterDraenicIntellect:Use(Player);
                end
                if ModeValue == "Stamina" and GreaterDraenicStamina:InStock() and not GreaterDraenicStamina:IsOnCooldown() then
                    GreaterDraenicStamina:Use(Player);
                end
                if ModeValue == "Strength" and GreaterDraenicStrenght:InStock() and not GreaterDraenicStrenght:IsOnCooldown() then
                    GreaterDraenicStrenght:Use(Player);
                end
            end
        end
    end

    module.PreventPotion = 0
    --- Potions Handler - Use a Potion of the given type
    -- @param IsEnabled - Option Toggle (Bool)
    -- @param ModeValue - Option Value (String)
    function Player:Potion (ModeValue, IsOnCooldown)
        local Potion, PotionBuff, Item, Spell = nil, nil, module.Item, module.Spell;
         -- Define wich potion to use, if we have Commanders Potions available then we should use these
        if ModeValue == "Intellect" then
            Potion = Item(122454):InStock() and Item(122454) or Item(109218);
            PotionBuff = module.Spell(156426, false, false, true);
        elseif ModeValue == "Agility" then
            Potion = Item(122453):InStock() and Item(122453) or Item(109217);
            PotionBuff = Spell(156423);
        elseif ModeValue == "Strength" then
            Potion = Item(122455):InStock() and Item(122455) or Item(109219);
            PotionBuff = module.Spell(156428);
        end
        -- Attempt to use the potion
        if module.PreventPotion < module.GetTime() and not IsOnCooldown and not Player:Buff(PotionBuff) and Potion:InStock() and not Potion:IsOnCooldown() then
            Potion:Use(module.Player);
            module.PreventPotion = module.GetTime() + 60;

            if module.Player:IsInCombat() then
                return true;
            else
                module.Bug("Using |cFF58ACFA" .. ModeValue .. "|r Potion |cFF58ACFA" .. math.floor(BMPullTime()*100)/100 .. "s|r before pull.");
            end
        end
    end

    --- Runes Handler - Keep a rune buff up
    -- @param IsEnabled - Option Toggle (Bool)
    -- @param ModeValue - Option Value (String)
    -- Option: module.AddOption("General Settings", "Augment Rune", false, "Keep Augment Rune buff up. Will use Empowered Augment Rune as priority and otherwise use normal runes.");
    -- Use: Player:Rune(module.IsOptionEnabled("Augment Rune"), "Agility");
    function Player:Rune (IsEnabled, ModeValue)
        if IsEnabled and Player:Level() < 110 then
            local EmpoweredAugmentRune = module.Item(128482, false, false, true); -- Empowered Rune
            local StoutAugmentRune = module.Item(118631, false, false, true); -- Strenght Rune
            local HyperAugmentRune = module.Item(118630, false, false, true); -- Agility Rune
            local FocusAugmentRune = module.Item(118632, false, false, true); -- Intellect Rune
            local RuneItem = (EmpoweredAugmentRune:InStock() and EmpoweredAugmentRune) or (ModeValue == "Agility" and HyperAugmentRune:InStock() and HyperAugmentRune) or (ModeValue == "Strength" and StoutAugmentRune:InStock() and StoutAugmentRune) or (ModeValue == "Intellect" and FocusAugmentRune:InStock() and FocusAugmentRune) or nil
            local RuneBuff = (ModeValue == "Agility" and module.Spell(175456, false, false, true)) or (ModeValue == "Strength" and module.Spell(175439, false, false, true)) or (ModeValue == "Intellect" and module.Spell(175457, false, false, true));
            if RuneItem and not Player:Buff(RuneBuff) then
                if not RuneItem:IsOnCooldown() then
                    RuneItem:Use(Player);
                end
            end
        end
    end

    function Player:HasRing (Name)
        return Name == "Maalus" and IsEquippedItem(124636) or Name == "Nithramus" and IsEquippedItem(124635);
    end

    --- Healing Item Handler
    local HealingItemTable = {-- Sorted from best to worst
        --- % HP
        Item(5512),         -- Healthstone                                  Warlock                 % HP
        Item(137222),       -- Crimson Vial (Legion)                        Rogue Honor Talent      30% HP over 6s
        --- Legion
        Item(136569),       -- Aged Health Potion (Legion)                  ???????                 ??k HP
        Item(127834),       -- Ancient Healing Potion (Legion)              Alchemy                 ??k HP
        --- WoD / 7.0
        Item(115498),       -- Ashran Healing Tonic (WoD)                   Ashran                  255k HP
        Item(118917),       -- Brawler's Bottomless Healing Tonic (WoD)     Brawler's Guild         68k HP
        Item(118916),       -- Brawler's Healing Tonic (WoD)                Brawler's Guild         68k HP
        Item(117415),       -- Smuggled Tonic (WoD)                         NPC (5 Max)             68k HP
        Item(109223),       -- Healing Tonic (WoD)                          First Aid               68k HP
        Item(118006),       -- Shieldtronic Shield (WoD)                    Engineering             68k HP
        Item(129196),       -- Legion Healthstone (7.0)                     DH Area                 48k HP
        --- MoP
        Item(93742),        -- Healing Potion (MoP)                         Scenario                25% HP
        Item(76097),        -- Master Healing Potion (MoP)                  Alchemy                 12k HP
        Item(89640),        -- Life Spirit (MoP)                            Alchemy                 12k HP over 6s
        Item(92954),        -- Brawler's Healing Potion (MoP)               Brawler's Guild         6k HP
        --- Cataclysm
        Item(57191),        -- Mythical Healing Potion (Legion)             Alchemy                 6k HP
        --- Wrath of the Lich King
        Item(43569),        -- Endless Healing Potion (WotLK)               Alchemy                 3k HP
        Item(33447),        -- Runic Healing Potion (WotLK)                 Alchemy                 3k HP
        Item(39671),        -- Resurgent Healing Potion (WotLK)             Alchemy                 3k HP
        --- Burning Crusade
        Item(32947),        -- Auchenai Healing Potion (BC)                 NPC                     3k HP
        Item(33934),        -- Crystal Healing Potion (BC)                  NPC                     3k HP
        Item(22829),        -- Super Healing Potion (BC)                    Alchemy                 3k HP
        Item(28100),        -- Volatile Healing Potion (BC)                 Alchemy                 2k HP
        --- Vanilla
        Item(13446),        -- Major Healing Potion (Classic)               Alchemy                 2k HP
        Item(3928),         -- Superior Healing Potion (Classic)            Alchemy                 700 HP
        Item(1710),         -- Greater Healing Potion (Classic)             Alchemy                 600 HP
        Item(929),          -- Healing Potion (Classic)                     Alchemy                 300 HP
        Item(4596),         -- Discolored Healing Potion (Classic)          Alchemy                 200 HP
        Item(858),          -- Lesser Healing Potion (Classic)              Alchemy                 200 HP
        Item(118)           -- Minor Healing Potion (Classic)               Alchemy                 100 HP
    };
    local SpinalTooltip = CreateFrame("GameTooltip", "SHITooltip", nil, "GameTooltipTemplate");
    SpinalTooltip:SetOwner(WorldFrame, "ANCHOR_NONE");
    SpinalTooltip:AddFontStrings(SpinalTooltip:CreateFontString("$parentTextLeft1", nil, "GameTooltipText"), SpinalTooltip:CreateFontString("$parentTextRight1", nil, "GameTooltipText"));
    function module.SHIEnabled ()
        SpinalTooltip:ClearLines();
        SpinalTooltip:SetInventoryItem("Player", 6, false);
        local Line, LineText;
        for i = 1, SpinalTooltip:NumLines() do
            Line = _G["SHITooltipTextLeft"..tostring(i)];
            if Line then
                LineText = Line:GetText();
                if string.find(LineText, ITEM_SPELL_TRIGGER_ONUSE) and string.find(LineText, string.lower(ITEM_MOD_HEALTH_SHORT)) then
                    SpinalTooltip:ClearLines();
                    return true;
                end
            end
        end
        SpinalTooltip:ClearLines();
        return false;
    end
    function Player:UseHealingItem ()
        if module.IsOptionEnabled("Healing Item") and self:HealthPercentage() <= module.GetOptionValue("Healing Item") then
            -- Spinal Healing Injector Handler
            if module.SHIEnabled() and Item(6):IsUsableInventory() then
                Item(6):UseInventory();
                return;
            end
            -- Regular Healing Item Handler
            for i = 1, #HealingItemTable do
                if HealingItemTable[i]:IsUsable() then
                    HealingItemTable[i]:Use(self);
                    return;
                end
            end
        end
    end

    function Player:UseTrinkets ()
        if module.GetOptionValue("Trinket: 1 | 2") ~= "Disabled" and (module.CooldownsAllowed() or module.GetOptionValue("Trinket: 1 | 2") == "Always") and Item(13):IsUsableInventory() then
            Item(13):UseInventory();
        end
        if module.GetSecondOptionValue("Trinket: 1 | 2") ~= "Disabled" and (module.CooldownsAllowed() or module.GetSecondOptionValue("Trinket: 1 | 2") == "Always") and Item(14):IsUsableInventory() then
            Item(14):UseInventory();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Defines the Spell Class Methods.
    --- Get a spell from its spell ID.
    -- @param ID The spell ID.
    -- @return The spell, or nil if it hasn't been created as a Spell object.
    function Spell.Get (ID)
        return Spells[ID];
        --
    end

    --- Get the spell ID.
    -- @return The spell ID.
    function Spell:ID ()
        return self.Identifier;
        --
    end

    --- Get whether the spell requires facing.
    -- @return Whether the spell requires facing.
    function Spell:IsFacingRequired ()
        return self.FacingRequired;
        --
    end

    --- Get whether the spell is hostile.
    -- @return Whether the spell is hostile.
    function Spell:IsHostile ()
        return self.Hostile;
        --
    end

    --- Get whether the spell is an instant-cast.
    -- @return Whether the spell is an instant-cast.
    function Spell:IsInstant ()
        return self.Instant;
        --
    end

    --- Get whether the spell is a Resurrect Spell.
    -- @return Whether the spell is a Resurrect Spell.
    function Spell:IsResurrect ()
        return self.Resurrect;
        --
    end

    --- Get the spell informations from the spell id.
    -- @param Index Optional, let you choose directly wich argument you want.
    -- @return The informations.
    function Spell:InfoID (Index)
        local SpellID = self:ID();
        if SpellID then
            if not module.SpellsInfos[SpellID] then
                module.SpellsInfos[SpellID] = {GetSpellInfo(SpellID)};
            end
            if Index then
                return module.SpellsInfos[SpellID][Index];
            else
                return unpack(module.SpellsInfos[SpellID]);
            end
        else
            return 0;
        end
    end

    --- Get the spell informations from the spell name.
    -- @param Index Optional, let you choose directly wich argument you want.
    -- @return The informations.
    function Spell:InfoName (Index)
        local SpellName = self:Name();
        if SpellID then
            if not module.SpellsInfos[SpellName] then
                module.SpellsInfos[SpellName] = {GetSpellInfo(SpellName)};
            end
            if Index then
                return module.SpellsInfos[SpellName][Index];
            else
                return unpack(module.SpellsInfos[SpellName]);
            end
        else
            return 0;
        end
    end

    --- Get the spell name.
    -- @return The name.
    function Spell:Name ()
        return self:InfoID(1);
        --
    end

    --- Get the spell ID from the spell name.
    -- @return The current spell ID.
    function Spell:CurrentID ()
        return self:InfoName(7);
        --
    end

    --- Get the spell book index.
    -- @return The spell book index.
    function Spell:BookIndex ()
        local SpellName = self:Name();
        if not SpellName then return false end
        SpellName = string.lower(SpellName);

        -- Pet Book
        local NumPetSpells = HasPetSpells();
        if NumPetSpells then
            for i = 1, NumPetSpells do
                if string.lower(GetSpellBookItemName(i, BOOKTYPE_PET)) == SpellName then
                    return i, BOOKTYPE_PET;
                end
            end
        end

        -- Player Book
        local Offset, NumSpells;
        for i = 1, GetNumSpellTabs() do
            Offset, NumSpells = select(3, GetSpellTabInfo(i));
            for j = 1, (Offset + NumSpells) do
                if string.lower(GetSpellBookItemName(j, BOOKTYPE_SPELL)) == SpellName then
                    return j, BOOKTYPE_SPELL;
                end
            end
        end

        -- Flyout Spells
        local FlyoutID, NumSlots, IsKnown, SpellID, IsKnownSpell, FlyoutSpellName;
        for i = 1, GetNumFlyouts() do
            FlyoutID = GetFlyoutID(i);
            NumSlots, IsKnown = select(3, GetFlyoutInfo(FlyoutID));
            if IsKnown and NumSlots > 0 then
                for j = 1, NumSlots do
                    SpellID, IsKnownSpell = GetFlyoutSlotInfo(FlyoutID, j);
                    FlyoutSpellName = Spell(SpellID):Name();
                    if IsKnownSpell and FlyoutSpellName and string.lower(FlyoutSpellName) == SpellName then
                        return SpellID;
                    end
                end
            end
        end

        return false;
    end

    --- Get if the player can use the spell.
    -- @return Whether the player can use the spell.
    function Spell:IsUsable ()
        return IsUsableSpell(self.Identifier);
        --
    end

    --- Get if the spell is available to the player's current specialization and talents.
    -- @return Whether the player has learned the spell is available to the player's current specialization and talents..
    function Spell:Exists ()
        return IsPlayerSpell(self.Identifier);
        --
    end

    --- Get if the player knows the spell.
    -- @return Whether the player knows the spell.
    function Spell:IsKnown ()
        return IsSpellKnown(self.Identifier);
        --
    end

    --- Get if the player pet knows the spell.
    -- @return Whether the pet knows the spell.
    function Spell:PetKnown ()
        return IsSpellKnown(self.Identifier, true);
        --
    end

    --- Get the spell's minimum range.
    -- @return The minimum range.
    function Spell:MinimumRange ()
        return self:InfoID(5);
        --
    end

    --- Get the spell's maximum range.
    -- @return The maximum range.
    function Spell:MaximumRange ()
        return self:InfoID(6);
        --
    end

    --- Get whether the spell is a melee spell.
    -- @return Whether the spell is melee.
    function Spell:IsMelee ()
        return self:MinimumRange() == 0 and self:MaximumRange() == 0;
        --
    end

    --- Get the spell's cast time.
    -- @return The spell's cast time in seconds.
    function Spell:CastTime ()
        if not self:InfoID(4) then
            return 0;
        else
            return self:InfoID(4)/1000;
        end
    end

    function Spell:CastRegen ()
        if self:InfoID(4)/1000 < 1.4 then
            SpellCast = 1.4;
        else
            SpellCast = self:InfoID(4)/1000;
        end
        return SpellCast*Player:EnergyRegen();
    end

    --- Get spell charges
    -- @return spell charges
    function Spell:Charges ()
        return GetSpellCharges(self.Identifier);
        --
    end

    -- Get spell charges franction (Charges + % of Recharging)
    -- @return fractionnal (%)
    function Spell:FractionalCharges ()
        local currentCharges, maxCharges, Start, Duration = GetSpellCharges(self.Identifier);
        local currentSync = module.GetTime() - Start;
        if SyncTime == nil then
            SyncTime = currentSync;
            LastSync = Start;
        elseif Start ~= LastSync then
            SyncTime = currentSync;
            LastSync = Start;
        end
        local syncedTime = module.GetTime() - SyncTime
        local currentChargesFraction = (syncedTime - Start) / Duration
        local fractionalCharges = math.floor((currentCharges + currentChargesFraction)*100)/100
        if fractionalCharges > maxCharges then
            return maxCharges;
        else
            return fractionalCharges;
        end
    end

    function Spell:Recharge ()
        local charges, maxCharges, Start, Duration = GetSpellCharges(self.Identifier)
        if not Start or Start == 0 then
            return 0;
        end
        return Start + Duration - module.GetTime() - select(4, GetNetStats()) / 1000;
    end

    --- Get the spell's remaining cooldown time.
    -- @return The spell's remaining cooldown time.
    function Spell:Cooldown ()
        -- Get Spell Cooldown Infos
        local CDTime, CDValue = GetSpellCooldown(self.Identifier);
        -- Return 0 if the Spell isn't in CD.
        if CDTime == 0 then
            return 0;
        end
        -- Compute the CD (and apply the Latency compensation if Latency Tolerance is enabled).
        local CD = CDTime + CDValue - module.GetTime() - module.GetLatency();
        -- Return the Spell CD
        if CD > 0 then
            return CD;
        else
            return 0;
        end
    end

    --- Get whether the spell is on cooldown.
    -- @return Whether the spell is on cooldown.
    function Spell:IsOnCooldown ()
        return self:Cooldown() ~= 0;
        --
    end

    --[[ Disabled until spells variables rework.

    --- Get whether the spell can be cast on a unit.
    -- @param Unit The unit to cast on.
    -- @return Whether the spell can be cast on the unit.
    function Spell:CanCast (Unit)
        return Unit:CanCast(self);
    end

    --- Cast the spell.
    -- @param Unit The unit to cast on.
    function Spell:Cast (Unit)
        if Unit then
            Unit:Cast(self);
        else
            CastSpellByName(self:Name());
        end

        --self:UpdateCastTime(Unit);
    end]]

    --- Get whether the spell is in flight.
    -- @return Whether the spell is in flight.
    function Spell:IsInFlight (UnitCheck)
        return self.Identifier == LastID;
        --
    end

    --- Get the time when the last spell was cast.
    -- @return The time when the last spell was cast.
    function Spell.TimeOfLastCast ()
        return CastTime;
        --
    end

    --- Get the time since the last cast.
    -- @return The time since the last cast, in seconds.
    function Spell:TimeSinceLastCast ()
        return CastTime and module.GetTime() - CastTime or math.huge;
        --
    end

    function Spell:NumDots()
        return 1;
        --
    end

    function Spell:TotemDuration ()
        local SpellName = self:Name();
        for index = 1, 4 do
             local _, totemName, startTime, duration = GetTotemInfo(index)
            if totemName == SpellName then
                return floor(startTime + duration - module.GetTime());
            end
        end
        return 0;
    end

    function Spell:TotemActive ()
        local SpellName = self:Name();
        for index = 1, 4 do
            local totemName = select(2,GetTotemInfo(index))
            if totemName == SpellName then
                return true;
            end
        end
        return false;
    end

    --- Get the time since the spell's last cast.
    -- @return The time in seconds since the spell's last cast, or math.huge if the spell hasn't been casted.
    function Spell:TimeSinceCast ()
        return self.LastCastTime > 0 and module.GetTime() - self.LastCastTime or 99 --[[math.huge]];
        --
    end

    function Spell:UpdateCastTime (Unit)
        self.LastCastTime = module.GetTime();
        LastCastID = self.Identifier;
        LastTarget = Unit:GUID();
        CastTime = module.GetTime();
    end

    --local Count = 0;
    --local Critical = false;
    if CombatLog2 == nil then
        Soapbox_CombatLog = CreateFrame('Frame')
        Soapbox_CombatLog:RegisterEvent("COMBAT_LOG_EVENT_UNFILTERED")
        function OnSuccessfulCast(self, event, ...)
            local type, _, sourceGUID, sourceNAME, _, _, destGUID, destNAME = select(2, ...)
            if (event=="COMBAT_LOG_EVENT_UNFILTERED") then
                if sourceGUID == UnitGUID("player") then
                spellID = select(12, ...)
                    if (type=="SPELL_DAMAGE") then
                        if spellID ~= nil then
                            local critical = select(21, ...)
                            if critical then
                                if CriticalSpell == spellID then
                                    Count = Count + 1;
                                else
                                    CriticalSpell = spellID;
                                    Count = 1;
                                end
                            else
                                CriticalSpell = false;
                                Count = 1;
                            end
                        end
                    end
                end
            end
        end
        Soapbox_CombatLog:SetScript('OnEvent', OnSuccessfulCast)

        CombatLog = true
    end

    function Spell:CriticalCount()
        if self.Identifier == CriticalSpell then
            return Count;
        end
        return 0;
    end

    function Spell:Critical()
        return self.Identifier == CriticalSpell;
        --
    end

    --- Get whether the spell was the last cast.
    -- @return Whether the spell was the last cast.
    function Spell:WasLastCast ()
        return self.DoNotCast == true or (CurrentSpellCast ~= nil and CurrentSpellCast.Id == self.Identifier and module.GetTime() < CurrentSpellCast.StartTime + 2) or (PreviousSpellCast ~= nil and PreviousSpellCast.Id == self.Identifier and module.GetTime() < PreviousSpellCast.StartTime + 2);
        --
    end


    --- Get whether a spell was the last one cast, and was cast on a specific unit.
    -- @param Unit The unit.
    -- @return Whether the spell was the last one cast, and was cast on the unit.
    function Spell:WasLastCastOnUnit (Unit)
        return self:WasLastCast() and ((CurrentSpellCast and CurrentSpellCast.UnitGUID == Unit:GUID()) or (PreviousSpellCast and PreviousSpellCast.UnitGUID == Unit:GUID()));
        --
    end

    --- Check if we can Cast Spell without being interrupted
    -- @return true if the spell is instant or we are melee calsses that cannot be interrupted
    function Spell:InterruptFree ()
        if C.CLASSNAME == "WARRIOR" or C.CLASSNAME == "HUNTER" or C.CLASSNAME == "ROGUE" or C.CLASSNAME == "DEATHKNIGHT" or Player:HasImmunity() then
            return true;
        end
        -- Prevent Being interrupted by bosses/dangerous spells
        if module.StopCastingSpells == true and module.GetTime() + Spell:CastTime() > module.StopCastingBefore then
            return false;
        end
        return true;
    end

    if CastLog == nil then
        Soapbox_CastLog = CreateFrame('Frame')
        Soapbox_CastLog:RegisterEvent("COMBAT_LOG_EVENT_UNFILTERED")
        function OnSuccessfulCast(self, event, ...)
            local type, _, sourceGUID, sourceNAME, _, _, destGUID, destNAME = select(2, ...)
            if (event=="COMBAT_LOG_EVENT_UNFILTERED") then
                if sourceGUID == UnitGUID("player") then
                    local spellID = select(12, ...)
                    local spell = Spell.Get(spellID);
                    if (type=="SPELL_CAST_START") then
                        if spell then
                                --self.LastCastTime = module.GetTime();
                                spell:UpdateCastTime(Unit(destGUID));
                                spell.DoNotCast = true;
                        end
                        if (spellID == 56641 or spellID == 77767) and Shots ~= nil then
                            Shots = Shots + 1;
                        else
                            Shots = 0;
                        end
                    end
                    if (type=="SPELL_CAST_FAILED") or (type=="UNIT_SPELLCAST_FAILED_QUIET") or (type=="UNIT_SPELLCAST_INTERRUPTED") or (type=="UNIT_SPELLCAST_STOP") or (type=="UNIT_SPELLCAST_SENT") then
                        local Log = {...}
                        if Log[15]~=SPELL_FAILED_NOT_READY and Log[15]~=SPELL_FAILED_SPELL_IN_PROGRESS then
                            if spellID ==56641 or spellID ==77767 then
                                Shots = Shots - 1;
                            end
                            if spell and spell:WasLastCast() then
                                self.LastCastTime = 0;
                                spell.DoNotCast = false;
                            end
                        end
                    end
                    if (type=="SPELL_CAST_SUCCESS") then
                        if spellID ~=56641 and spellID ~=77767 then
                            Shots = 0;
                        end
                            if spell then
                                LastSpell = spell;
                                LastID = spellID;
                                spell.DoNotCast = false;
                                spell:UpdateCastTime(Unit(destGUID));
                            end
                        end
                    end
                end
            end
        Soapbox_CastLog:SetScript('OnEvent', OnSuccessfulCast)

        CastLog = true
    end


    function Spell:IsFree ()
        local FreeSpells = { 34914, 155361 };
        for i=1, #FreeSpells do
            if self.Identifier == FreeSpells[i] then
                return true;
            end
        end
        return false;
    end

    -- List of know spells travel speed. Non charted spells will be considered travling 40 yards/s
    -- To recover travel speed, open up /eventtrace, calculate difference between SPELL_CAST_SUCCESS and SPELL_DAMAGE events
    local TravelSpeedChart = {
        [116] = 25, -- Frostbolt
        [11366] = 52, -- Pyroblast
        [29722] = 18, -- Incinerate
        [30455] = 39, -- Ice Lance
        [105174] = 33, -- Hand of Gul'dan
        [120644] = 10, -- Halo
        [122121] = 25, -- Divine Star
        [127632] = 19 -- Cascade
    }

    -- Return the time a spell will need to travel to the current target
    function Spell:TravelTime()
        TravelSpeed = TravelSpeedChart[self.Identifier] or 40;
        return Unit.Player:DistanceTo(Unit.Target) / TravelSpeed;
    end

    local StaticTip = CreateFrame("GameTooltip", "SpellScanningTooltip", nil, "GameTooltipTemplate");
    StaticTip:SetOwner( WorldFrame, "ANCHOR_NONE" );
    StaticTip:AddFontStrings(
        StaticTip:CreateFontString("$parentTextLeft1", nil, "GameTooltipText"),
        StaticTip:CreateFontString("$parentTextRight1", nil, "GameTooltipText")
    );

    --- Get the tooltip value of a spell
    -- @returns - The Damage value of the spell - Numeric
    function Spell:DamageValue ()
        StaticTip:ClearLines();
        StaticTip:SetSpellByID(self.Identifier);
        local function FindValue (StringValue)
            local RegexSearch = "%d%d,%d%d%d";
            local RegexSearch2 = "%d,%d%d%d";
            local RegexSearch3 = "%d%d%d";
            local RegexSearch4 = "%d%d";
            return string.find(StringValue, RegexSearch) and string.gsub(string.sub(StringValue, string.find(StringValue, RegexSearch)), ",", "") or string.find(StringValue, RegexSearch2) and string.gsub(string.sub(StringValue, string.find(StringValue, RegexSearch2)), ",", "") or string.find(StringValue, RegexSearch3) and string.sub(StringValue, string.find(StringValue, RegexSearch3)) or string.find(StringValue, RegexSearch4) and string.sub(StringValue, string.find(StringValue, RegexSearch4)) or 0;
        end
        local TipValue = FindValue(_G["SpellScanningTooltipTextLeft4"]:GetText());
        TipValue = TipValue ~= 0 and TipValue or FindValue(_G["SpellScanningTooltipTextLeft5"]:GetText());
        return TipValue;
    end

    --- Artifact Traits Scan Handler
    -- It fill the PowerTable with every traits informations.
    local AUI, PowerTable = C_ArtifactUI, {};
    --- PowerTable[i] :
    --    1      2         3          4         5       6  7      8          9         10         11
    -- SpellID, Cost, CurrentRank, MaxRank, BonusRanks, x, y, PreReqsMet, IsStart, IsGoldMedal, IsFinal
    function module.ArtifactScan ()
        -- Prevent Scan if the Artifact Frame is opened.
        if _G.ArtifactFrame and _G.ArtifactFrame:IsShown() then return; end
        -- Does the scan only if the Artifact is Equipped.
        if HasArtifactEquipped() then
            -- Unregister the events to prevent unwanted call.
            UIParent:UnregisterEvent("ARTIFACT_UPDATE");
            SocketInventoryItem(INVSLOT_MAINHAND);
            local Powers = AUI.GetPowers();
            PowerTable = {};
            for Index, Power in ipairs(Powers) do
                table.insert(PowerTable, {AUI.GetPowerInfo(Power)});
            end
            AUI.Clear();
            -- Register back the event.
            UIParent:RegisterEvent("ARTIFACT_UPDATE");
        end
    end

    --- Get the current rank of an artifact trait
    -- @returns The current rank of the artifact trait
    function Spell:ArtifactRank ()
        if #PowerTable > 0 then
            for Index, Table in ipairs(PowerTable) do
                if self.Identifier == Table[1] and Table[3] > 0 then
                    return Table[3];
                end
            end
        end
        return 0;
    end

    --- Get wether the artifact trait is enabled.
    -- @returns Wether the artifact trait is enabled.
    function Spell:ArtifactEnabled ()
        return self:ArtifactRank() > 0;
        --
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Defines the Item Class Methods.
    --- Get the item's name.
    -- @return The item's name.
    function Item:Name ()
        return ({GetItemInfo(self.Identifier)})[1];
    end

    --- Get the item's remaining cooldown time.
    -- @return The item's remaining cooldown time.
    function Item:Cooldown ()
        -- Get Item Cooldown Infos.
        local CDTime, CDValue = GetItemCooldown(self.Identifier);
        -- Return 0 if the Item isn't in CD.
        if CDTime == 0 then return 0; end
        -- Compute the CD (and apply the Latency compensation if Latency Tolerance is enabled).
        local CD = CDTime + CDValue - module.GetTime() - module.GetLatency();
        -- Return the Item CD.
        if CD > 0 then
            return CD;
        else
            return 0;
        end
    end

    --- Get the item's remaining cooldown time.
    -- @return The item's remaining cooldown time.
    function Item:CooldownInventory ()
        -- Get Item Cooldown Infos.
        local CDTime, CDValue, CDEnabled = GetInventoryItemCooldown(Player.UnitID, self.Identifier);
        -- Return 1 if the Item isn't usable.
        if CDEnabled == 0 then return 1; end
        -- Return 0 if the Item isn't in CD.
        if CDTime == 0 then return 0; end
        -- Compute the CD (and apply the Latency compensation if Latency Tolerance is enabled).
        local CD = CDTime + CDValue - module.GetTime() - module.GetLatency();
        -- Return the Item CD.
        if CD > 0 then
            return CD;
        else
            return 0;
        end
    end

    --- Get whether the item is on cooldown.
    -- @return Whether the item is on cooldown.
    function Item:IsOnCooldown ()
        return self:Cooldown() ~= 0;
    end

    --- Get whether the item is on cooldown.
    -- @return Whether the item is on cooldown.
    function Item:IsOnCooldownInventory ()
        return self:CooldownInventory() ~= 0;
    end

    --- Get whether the item is available.
    -- @return Whether the item is available.
    function Item:InStock ()
        return GetItemCount(self.Identifier) > 0;
    end

    --- Get whether the item is usable.
    -- @return Whether the item is usable.
    function Item:IsUsable ()
        return self:InStock() and not self:IsOnCooldown();
    end

    --- Get whether the item is usable.
    -- @return Whether the item is usable.
    function Item:IsUsableInventory ()
        return not self:IsOnCooldownInventory();
    end

    --- Get whether the item is equipped.
    -- @return Whether the item is equipped.
    function Item:IsEquipped ()
        return IsEquippedItem(self.Identifier);
    end

    --- Use the item on a given unit.
    -- @param ThisUnit The unit to use the item on.
    function Item:Use (ThisUnit)
        if self:TimeSinceUse() >= 1 then
            UseItemByName(self.Identifier, ThisUnit.UnitID);
            self.LastUseTime = module.GetTime();
        end
    end

    --- Use the item through his inventory slot.
    function Item:UseInventory ()
        if self:TimeSinceUse() >= 1 then
            UseInventoryItem(self.Identifier);
            self.LastUseTime = module.GetTime();
        end
    end

    --- Get the time since the item's last use.
    -- @return The time since the item's last use in seconds or 3 if it has not been used.
    function Item:TimeSinceUse ()
        return self.LastUseTime ~= 0 and module.GetTime() - self.LastUseTime or 3;
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --@ TimeToDie
    module.TTD = {}
    local TTD = module.TTD;
    TTD.Settings = {
        Refresh = 0.1, -- Refresh time (seconds) : min=0.1, max=2, default = 0.2, SBR = 0.1
        HistoryTime = 10, -- History time (seconds) : min=5, max=120, default = 20, SBR = 10
        HistoryCount = 100 -- Max history count : min=20, max=500, default = 120, SBR = 100
    };
    TTD.Units = {};
    TTD.Throttle = 0;
    function module.TTDRefresh ()
        local FetchedUnits = module.EnemyUnits;
        local FetchedUnitsInfos = module.UnitsInfos;
        for Key, Value in ipairs(TTD.Units) do
            if not FetchedUnitsInfos[Key] then
                TTD.Units[Key] = nil;
            end
        end
        local ThisUnit, ThisUnitString, ThisUnitHealth, Values, Time;
        for i = 1, #FetchedUnits do
            ThisUnit = FetchedUnits[i];
            if ThisUnit:Exists() then
                ThisUnitString = ThisUnit:GUID();
                ThisUnitHealth = ThisUnit:Health();
                if not TTD.Units[ThisUnitString] or ThisUnitHealth > TTD.Units[ThisUnitString][1][1][2] then
                    TTD.Units[ThisUnitString] = {{}, ThisUnit:MaxHealth(), module.GetTime(), -1};
                end
                Values = TTD.Units[ThisUnitString][1];
                Time = module.GetTime() - TTD.Units[ThisUnitString][3];
                if ThisUnitHealth ~= TTD.Units[ThisUnitString][4] then
                    table.insert(Values, 1, {Time, ThisUnitHealth});
                    while (#Values > TTD.Settings.HistoryCount) or (Time - Values[#Values][1] > TTD.Settings.HistoryTime) do
                        table.remove(Values);
                    end
                    TTD.Units[ThisUnitString][4] = ThisUnitHealth;
                end
            end
        end
    end

    function Unit:TimeToX (Percentage, MinSamples)
        if self:IsDummy() then return 4999; end
        local Seconds = 5555;
        local MaxHealth, StartingTime;
        local UnitTable = TTD.Units[self:GUID()];
        local MinSamples = MinSamples or 1;
        local a, b = 0, 0;
        -- Simple linear regression
        -- ( E(x^2)   E(x) )  ( a )   ( E(xy) )
        -- ( E(x)       n  )  ( b ) = ( E(y)  )
        -- Format of the above: ( 2x2 Matrix ) * ( 2x1 Vector ) = ( 2x1 Vector )
        -- Solve to find a and b, satisfying y = a + bx
        -- Matrix arithmetic has been expanded and solved to make the following operation as fast as possible
        if UnitTable then
            local Values = UnitTable[1];
            local n = #Values;
            if n > MinSamples then
                MaxHealth = UnitTable[2];
                StartingTime = UnitTable[3];
                local x, y = 0, 0;
                local Ex2, Ex, Exy, Ey = 0, 0, 0, 0;

                for _, Value in ipairs(Values) do
                    x, y = unpack(Value);

                    Ex2 = Ex2 + x * x;
                    Ex = Ex + x;
                    Exy = Exy + x * y;
                    Ey = Ey + y;
                end
                -- Invariant to find matrix inverse
                local Invariant = Ex2*n - Ex*Ex;
                -- Solve for a and b
                a = (-Ex * Exy / Invariant) + (Ex2 * Ey / Invariant);
                b = (n * Exy / Invariant) - (Ex * Ey / Invariant);
            end
        end
        if b ~= 0 then
            -- Use best fit line to calculate estimated time to reach target health
            Seconds = (Percentage * 0.01 * MaxHealth - a) / b;
            -- Subtract current time to obtain "time remaining"
            Seconds = math.min(555555, Seconds - (module.GetTime() - StartingTime));
            if Seconds < 0 then Seconds = 55555; end
        end
        return math.floor(Seconds);
    end

    function Unit:TimeToDie (MinSamples)
        if module.IsOptionEnabled("Ignore TTD Boss until %") and self:IsBoss() and self:HealthPercentage() > module.GetOptionValue("Ignore TTD Boss until %") then
            return 5555;
        end
        return self:TimeToX(0, MinSamples);
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --@ Pet Battles
    module.PetBattles = Class();
    PetBattles = module.PetBattles;

    PetBattles = CreateFrame("Frame")
    PetBattles:Show()
    PetBattles.ActivePet = {}
    PetBattles.Pet = {}
    PetBattles.Journal = {}
    PetBattles.Abilities = {}
    PetBattles[1] = {}
    PetBattles[2] = {}
    PetBattles[1].Active = {}
    PetBattles[2].Active = {}

    --[[
    Pet Battles Rotation
    - Optimized for PvE 3v3 outdoor battling.

    Out of Battle Features
    - Options to level your pets and change these according to preferred settings such as Wild/Non-Wild/High Level/Low Level.
    - Out of Battle pets changing will always priorise the pets you set as Favorites in your Pet Journal.
    - Option to Capture Pets according to your desired Quality such as Rare/Uncommon/Common/Poor.
    - Option to define how many of each species you would like to capture.
    - Options to use Revive Pets while Out of Battle.

    In Battle Features
    - Support all Abilities.
    - Swap pets. Pet leveling logic to keep 1 low level pet and 2 high level pets.
    - Option to define Pet Swapping when they are low health.
    - Options to define healing thresholds.
    - Deflection logic for high damage abilities.
    - Kamikaze logic for specific abilities when pets are under 25% health.
    - Buffs on Pet and Team buffs.
    - Debuffs on enemy pet and team debuffs.

    Reporting Invalid Abilities
    In order to help us make Pet Battles Rotation perfect, we will need some inputs for invalid logic on specific abilities.
    When reporting an ability, we will need the following data to be able to address the issues:
    - Pet Specie.
    - Ability Name.
    - Logic you think it should be using.
    ]]

    PetBattles.SurroundingPets = {}
    function PetBattles.FetchPets()
        for Index = 1, module.Unit.Count() do
            local ThisUnit = module.Unit(GetUnitByIndex(Index));
            if ThisUnit:Exists() and UnitIsWildBattlePet(ThisUnit.UnitID) and select(11,C_PetJournal.GetPetInfoBySpeciesID(UnitBattlePetSpeciesID(ThisUnit.UnitID))) == true then
                table.insert(PetBattles.SurroundingPets, ThisUnit);
            end
        end
    end


    PetBattles.Abilities = {
        [97] = { Type = "stun", Name = "Stun Shot" },
        [110] = { Type = "attack", Name = "Bite", Prio = 2 },
        [111] = { Type = "attack", Name = "Punch", Prio = 2 },
        [112] = { Type = "attack", Name = "Peck", Prio = 2 },
        [113] = { Type = "attack", Name = "Burn", Prio = 2 },
        [114] = { Type = "attack", Name = "Beam", Prio = 2 },
        [115] = { Type = "attack", Name = "Breath", Prio = 2 },
        [116] = { Type = "attack", Name = "Zap", Prio = 2 },
        [117] = { Type = "attack", Name = "Infected Claw", Prio = 2 },
        [118] = { Type = "attack", Name = "Water Jet", Prio = 2 },
        [119] = { Type = "attack", Name = "Scratch", Prio = 2 },
        [120] = { Type = "highdmg", Name = "Howling Blast" },
        [121] = { Type = "leech", Name = "Death Coil", },
        [122] = { Type = "attack", Name = "Tail Sweep", Prio = 2 },
        [123] = { Type = "heal", Name = "Healing Wave" },
        [124] = { Type = "3turnhighdmg", Name = "Rampage" },
        [151] = { Type = "debuff", Name = "Poisoned" },
        [152] = { Type = "debuff", Name = "Poison Fang", Debuff = 379 },
        [153] = { Type = "dmgdebuff", Name = "Attack Reduction" },
        [154] = { Type = "speedreduced", Name = "Speed Reduction" },
        [155] = { Type = "speeddebuff", Name = "Hiss" },
        [156] = { Type = "attack", Name = "Vicious Fang", Prio = 1 },
        [157] = { Type = "debuff", Name = "Jacob's" },
        [158] = { Type = "highdmg", Name = "Counterstrike" },
        [159] = { Type = "2turn", Name = "Burrow" },
        [160] = { Type = "leech", Name = "Consume" },
        [161] = { Type = "speedbuff", Name = "Adrenaline" },
        [162] = { Type = "speedbuff", Name = "Adrenaline Rush" },
        [163] = { Type = "3turn", Name = "Stampede" },
        [164] = { Type = "dmgdebuff", Name = "Crouch" },
        [165] = { Type = "shield", Name = "Crouch" },
        [166] = { Type = "teamdebuff", Name = "Nut Barrage", Prio = 3 },
        [167] = { Type = "teamdebuff", Name = "Nut Barrage", Prio = 3 },
        [168] = { Type = "heal", Name = "Healing Flame" },
        [169] = { Type = "attack", Name = "Deep Breath", Prio = 1 },
        [170] = { Type = "highdmg", Name = "Lift-Off" },
        [171] = { Type = "teamdebuff", Name = "Scorched Earth" },
        [172] = { Type = "highdmg", Name = "Scorched Earth" },
        [173] = { Type = "heal", Name = "Cautherize" },
        [174] = { Type = "stun", Name = "Stunned" },
        [175] = { Type = "debuff", Name = "Volcano" },
        [176] = { Type = "debuff", Name = "Volcano" },
        [177] = { Type = "debuff", Name = "Immolate" },
        [178] = { Type = "debuff", Name = "Immolate" },
        [179] = { Type = "debuff", Name = "Conflagrate" },
        [184] = { Type = "quick", Name = "Quills", Prio = 2 },
        [185] = { Type = "dmgdebuff", Name = "Reckless Strike" },
        [186] = { Type = "highdmg", Name = "Reckless Strike" },
        [187] = { Type = "dmgbuff", Name = "Accuracy" },
        [188] = { Type = "dmgbuff", Name = "Accuracy" },
        [189] = { Type = "teamdebuff", Name = "Cyclone" },
        [190] = { Type = "teamdebuff", Name = "Cyclone" },
        [193] = { Type = "attack", Name = "Flank", Prio = 2 },
        [194] = { Type = "speedbuff", Name = "Metabolic Boost" },
        [195] = { Type = "speedbuff", Name = "Metabolic Boost" },
        [196] = { Type = "dmgbuff", Name = "Adrenal Glands" },
        [197] = { Type = "dmgbuff", Name = "Adrenal Glands" },
        [198] = { Type = "3turn", Name = "Zergling Rush" },
        [202] = { Type = "quick", Name = "Trash", Prio = 2 },
        [203] = { Type = "wheater", Name = "Lightning Storm", Desc = "Add lightning damage to all pets attacks" },
        [204] = { Type = "highdmg", Name = "Call Lightning" },
        [205] = { Type = "wheater", Name = "Blizzard", Desc = "All pets are chilled" },
        [206] = { Type = "debuff", Name = "Call Blizzard" },
        [207] = { Type = "dmgbuff", Name = "Supercharged" },
        [208] = { Type = "dmgbuff", Name = "Supercharge" },
        [209] = { Type = "highdmg", Name = "Ion Cannon" },
        [210] = { Type = "attack", Name = "Shadow Slash", Prio = 2 },
        [211] = { Type = "debuff", Name = "Siphon Life" },
        [212] = { Type = "debuff", Name = "Siphon Life" },
        [213] = { Type = "teamdebuff", Name = "Death and Decay" },
        [214] = { Type = "teamdebuff", Name = "Death and Decay" },
        [215] = { Type = "dmgbuff", Name = "Inner Vision" },
        [216] = { Type = "dmgbuff", Name = "Inner Vision" },
        [217] = { Type = "3turnhighdmg", Name = "Curse of Doom" },
        [218] = { Type = "3turnhighdmg", Name = "Curse of Doom" },
        [219] = { Type = "attack", Name = "Jab", Prio = 2 },
        [220] = { Type = "healbuff", Name = "Jacob's" },
        [221] = { Type = "ifbuffed", Name = "Takedown(Stunned)", Debuffs = { 174, 927 } },
        [222] = { Type = "dmgbuff", Name = "Focus Chi" },
        [223] = { Type = "dmgbuff", Name = "Focus Chi" },
        [224] = { Type = "shield", Name = "Staggered Steps" },
        [225] = { Type = "shield", Name = "Staggered Steps" },
        [226] = { Type = "highdmg", Name = "Fury of 1,000 Fists" },
        [227] = { Type = "stun", Name = "Blackout Kick" },
        [228] = { Type = "quick", Name = "Tongue Lash" },
        [229] = { Type = "weather", Name = "Cleansing Rain", Desc = "Reduced damage over time by 1 round" },
        [230] = { Type = "highdmg", Name = "Cleansing Waters" },
        [231] = { Type = "teamdebuff", Name = "Swarm of Flies" },
        [232] = { Type = "teamdebuff", Name = "Swarm of Flies" },
        [233] = { Type = "sleep", Name = "Frog Kiss", Prio = 1 },
        [234] = { Type = "healbuff", Name = "Jacob's 2" },
        [235] = { Type = "hastebuff", Name = "Jacob's 3" },
        [236] = { Type = "passive", Name = "Critter" },
        [237] = { Type = "passive", Name = "Beast" },
        [238] = { Type = "passive", Name = "Humanoid" },
        [239] = { Type = "passive", Name = "Flying" },
        [240] = { Type = "passive", Name = "Aquatic" },
        [241] = { Type = "passive", Name = "Elemental" },
        [242] = { Type = "passive", Name = "Undead" },
        [243] = { Type = "passive", Name = "Magic" },
        [244] = { Type = "passive", Name = "Mechanical" },
        [245] = { Type = "passive", Name = "Dragonkin" },
        [246] = { Type = "delayedheal", Name = "Hibernate" },
        [247] = { Type = "delayedheal", Name = "Hibernate" },
        [248] = { Type = "root", Name = "Rooted" },
        [249] = { Type = "rootattack", Debuff = 248, Name = "Rooted" },
        [250] = { Type = "ifbuffed", Name = "Spiderling Swarm(Webbed)", Debuffs = { 338 } },
        [251] = { Type = "dmgbuff", Name = "Uncanny Luck" },
        [252] = { Type = "dmgbuff", Name = "Uncanny Luck" },
        [253] = { Type = "comeback", Name = "Comeback" },
        [254] = { Type = "hotteam", Name = "Tranquility" },
        [255] = { Type = "hotteam", Name = "Tranquility" },
        [256] = { Type = "highdmg", Name = "Call Darkness" },
        [257] = { Type = "highdmg", Name = "Call Darkness" },
        [258] = { Type = "highdmg", Name = "Starfall" },
        [259] = { Type = "buff", Name = "Invisibility" },
        [260] = { Type = "buff", Name = "Fading" },
        [261] = { Type = "buff", Name = "Invisible" },
        [262] = { Type = "dmgbuff", Name = "Crystal Overload" },
        [263] = { Type = "dmgbuff", Name = "Crystal Overload" },
        [264] = { Type = "debuff", Name = "Grounded" },
        [265] = { Type = "debuff", Name = "Boulder Toss" },
        [267] = { Type = "hotbuff", Name = "Phytosynthesis" },
        [268] = { Type = "hotbuff", Name = "Phytosynthesis" },
        [270] = { Type = "debuff", Debuff = 271, Name = "Glowing Toxin" },
        [271] = { Type = "debuff", Name = "Glowing Toxin" },
        [273] = { Type = "delayedheal", Name = "Wish" },
        [274] = { Type = "delayedheal", Name = "Wish" },
        [275] = { Type = "comeback", Name = "Nerfbat" },
        [276] = { Type = "attack", Name = "Swallow You Whole", Prio = 2 },
        [277] = { Type = "lifeswap", Name = "Life Exchange" },
        [278] = { Type = "delayedheal", Name = "Repair", Min = 40 },
        [279] = { Type = "dmgbuff", Name = "Heartbroken" },
        [280] = { Type = "dmgdebuff", Name = "Overload" },
        [281] = { Type = "dmgbuff", Name = "Hearthbreak" },
        [282] = { Type = "kamikaze", Name = "Explode" },
        [283] = { Type = "cantdie", Name = "Survival" },
        [284] = { Type = "cantdie", Name = "Survival" },
        [289] = { Type = "shield", Name = "Stockpile" },
        [290] = { Type = "shield", Name = "Stockpile" },
        [293] = { Type = "attack", Name = "Launch Rocket", Prio = 1 },
        [294] = { Type = "root", Name = "Charging Rocket" },
        [296] = { Type = "todeflect", Name = "Pumped Up" },
        [297] = { Type = "attack", Name = "Pump", Prio = 1 },
        [298] = { Type = "heal", Name = "Inspiring Song" },
        [299] = { Type = "aoe", Name = "Arcane Explosion" },
        [300] = { Type = "todeflect", Name = "Locked" },
        [301] = { Type = "attack", Name = "Lock-On", Prio = 1 },
        [302] = { Type = "root", Name = "Planted" },
        [303] = { Type = "hotbuff", Name = "Plant" },
        [302] = { Type = "hotbuff", Name = "Planted" },
        [305] = { Type = "dmgdebuff", Name = "Exposed Wounds" },
        [307] = { Type = "quick", Name = "Kick", Prio = 3 },
        [310] = { Type = "shield", Name = "Shell Shield" },
        [311] = { Type = "immunity", Name = "Dodge" },
        [312] = { Type = "deflect", Name = "Dodge" },
        [314] = { Type = "dmgdebuff", Name = "Mangle" },
        [315] = { Type = "shield", Name = "Spiked Skin", Buff = 316 },
        [316] = { Type = "shield", Name = "Spiked Skin" },
        [317] = { Type = "buff", Name = "Thorns" },
        [318] = { Type = "buff", Name = "Thorns" },
        [319] = { Type = "aoe", Name = "Magma Wave" },
        [320] = { Type = "dmgdebuff", Name = "Unholy Ascension" },
        [321] = { Type = "kamikaze", Name = "Unholy Ascension" },
        [322] = { Type = "buff", Name = "Levitated" },
        [323] = { Type = "attack", Name = "Gravity", Prio = 1 },
        [324] = { Type = "debuff", Name = "Gravity" },
        [325] = { Type = "shield", Name = "Beaver Dam" },
        [326] = { Type = "shield", Name = "Beaver Dam" },
        [327] = { Type = "delayedheavy", Name = "Hatchlings" },
        [327] = { Type = "todeflect", Name = "Eggs" },
        [329] = { Type = "delayedheavy", Name = "Hatchlings" },
        [330] = { Type = "highdmg", Name = "Sons of the Flame" },
        [331] = { Type = "immunity", Name = "Submerged", Deflect = true },
        [332] = { Type = "debuff", Name = "Sons of the Flame" },
        [333] = { Type = "shield", Name = "Decoy" },
        [334] = { Type = "shield", Name = "Decoy" },
        [338] = { Type = "root", Name = "Webbed" },
        [339] = { Type = "rootattack", Name = "Sticky Web" },
        [340] = { Type = "immunity", Name = "Burrowed", Deflect = true },
        [341] = { Type = "immunity", Name = "Flying", Deflect = true },
        [345] = { Type = "highdmg", Name = "Maul" },
        [347] = { Type = "dmgbuff", Name = "Roar", Prio = 2 },
        [348] = { Type = "stun", Name = "Bash" },
        [349] = { Type = "attack", Name = "Smash", Prio = 2 },
        [350] = { Type = "stun", Name = "Clobber" },
        [351] = { Type = "teamdebuff", Name = "Banana Barrage" },
        [352] = { Type = "teamdebuff", Name = "Banana Barrage" },
        [353] = { Type = "todeflect", Name = "Barrel Ready" },
        [354] = { Type = "attack", Name = "Barrel Toss", Prio = 1 },
        [355] = { Type = "attack", Name = "Triple Snap", Prio = 2 },
        [356] = { Type = "attack", Name = "Snap", Prio = 2 },
        [357] = { Type = "speeddebuff", Name = "Screech - 25%" },
        [358] = { Type = "sleepdebuff", Name = "" },
        [359] = { Type = "debuff", Name = "Sting" },
        [360] = { Type = "quick", Name = "Flurry", Prio = 2 },
        [362] = { Type = "debuff", Debuff = 542, Name = "Howl" },
        [364] = { Type = "buff", Name = "Leap", Buff = 544 },
        [365] = { Type = "teambuff", Name = "Dazzling Dance" },
        [366] = { Type = "teambuff", Name = "Dazzling Dance" },
        [367] = { Type = "attack", Name = "Chomp", Prio = 2 },
        [368] = { Type = "debuffed", Name = "Acidic Goo" },
        [369] = { Type = "debuff", Name = "Acidic Goo", Debuff = 368 },
        [370] = { Type = "root", Name = "Sticky Goo" },
        [371] = { Type = "rootattack", Name = "Sticky Goo" },
        [375] = { Type = "dmgbuff", Name = "Trumpet Strike" },
        [376] = { Type = "highdmg", Name = "Headbutt" },
        [377] = { Type = "attack", Name = "Trample", Prio = 1 },
        [378] = { Type = "attack", Name = "Strike", Prio = 2 },
        [379] = { Type = "debuff", Name = "Poison Spit" },
        [380] = { Type = "debuff", Name = "Poison Spit" },
        [381] = { Type = "debuff", Name = "Brittle Webbing" },
        [382] = { Type = "debuff", Name = "Brittle Webbing" },
        [383] = { Type = "leech", Name = "Leech Life" },
        [384] = { Type = "attack", Name = "Metal Fist", Prio = 2 },
        [385] = { Type = "todeflect", Name = "XE-321 Boombot" },
        [386] = { Type = "delayedheavy", Name = "XE-321 Boombot" },
        [387] = { Type = "aoe", Name = "Tympanic Tantrum" },
        [389] = { Type = "speedbuff", Name = "Overtune" },
        [390] = { Type = "attack", Name = "Demolish", Prio = 2 },
        [391] = { Type = "shield", Name = "Extra Plating" },
        [392] = { Type = "shield", Name = "Extra Plating" },
        [393] = { Type = "attack", Name = "Shadowflame", Prio = 2 },
        [394] = { Type = "quick", Name = "Lash" },
        [395] = { Type = "teambuff", Name = "Soothing Mists" },
        [396] = { Type = "teambuff", Name = "Soothing Mists" },
        [397] = { Type = "debuff", Name = "Poison Lash" },
        [398] = { Type = "debuff", Name = "Poison Lash" },
        [399] = { Type = "todeflect", Name = "Entangling Roots" },
        [400] = { Type = "delayedheavy", Name = "Entangling Roots" },
        [401] = { Type = "todeflect", Name = "Stun Seed" },
        [402] = { Type = "delayedheavy", Name = "Stun Seed" },
        [403] = { Type = "weather", Name = "Sunny Day" },
        [404] = { Type = "aoe", Name = "Sunlight" },
        [405] = { Type = "comeback", Name = "Early Advantage" },
        [406] = { Type = "attack", Name = "Crush", Prio = 2 },
        [407] = { Type = "2turn", Name = "Meteor Strike" },
        [408] = { Type = "buff", Name = "Immolation" },
        [409] = { Type = "buff", Name = "Immolation" },
        [410] = { Type = "debuff", Name = "Woodchipper" },
        [411] = { Type = "debuff", Name = "Woodchipper", Prio = 1  },
        [412] = { Type = "quick", Name = "Gnaw" },
        [413] = { Type = "attack", Name = "Ice Lance", Prio = 1 },
        [414] = { Type = "highdmg", Name = "Frost Nova" },
        [415] = { Type = "speeddebuff", Name = "Frost Shock - 25%" },
        [416] = { Type = "speeddebuff", Name = "Frost Shock - 25%" },
        [417] = { Type = "todeflect", Name = "Geyser" },
        [418] = { Type = "delayedheavy", Name = "Geyser" },
        [419] = { Type = "aoe", Name = "Tidal Wave" },
        [420] = { Type = "attack", Name = "Slicing Wind", Prio = 2 },
        [421] = { Type = "attack", Name = "Arcane Blast", Prio = 2 },
        [422] = { Type = "attack", Name = "Shadow Shock", Prio = 2 },
        [423] = { Type = "ifbuffed", Name = "Blood in the Water if Bleeding.", Debuffs = { 491 } },
        [424] = { Type = "attack", Name = "Tail Slap", Prio = 2 },
        [425] = { Type = "focus", Name = "Focused", Buff = 426 },
        [426] = { Type = "focus", Name = "Focus" },
        [429] = { Type = "attack", Name = "Claw", Prio = 2 },
        [430] = { Type = "shield", Name = "Jadeskin" },
        [431] = { Type = "shield", Name = "Jadeskin" },
        [432] = { Type = "attack", Name = "Jade Claw", Prio = 2 },
        [433] = { Type = "attack", Name = "Jade Claw", Prio = 2 },
        [434] = { Type = "shield", Name = "Jade Barrier" },
        [435] = { Type = "shield", Name = "Stoneskin" },
        [436] = { Type = "shield", Name = "Stoneskin" },
        [437] = { Type = "attack", Name = "Onyx Bite", Prio = 1 },
        [438] = { Type = "deflect", Name = "Onyx Wall" },
        [439] = { Type = "deflect", Name = "Onyx Wall" },
        [440] = { Type = "deflect", Name = "Evanescence" },
        [441] = { Type = "quick", Name = "Rend" },
        [442] = { Type = "highdmg", Name = "Spectral Strike" },
        [443] = { Type = "deflect", Name = "Prismatic Barrier" },
        [444] = { Type = "buff", Name = "Prismatic Barrier" },
        [445] = { Type = "attack", Name = "Ooze Touch", Prio = 2 },
        [446] = { Type = "debuff", Name = "Corrosion" },
        [447] = { Type = "debuff", Name = "Corrosion" },
        [448] = { Type = "debuff", Debuff = 781, Name = "Creeping Ooze" },
        [449] = { Type = "leech", Name = "Absorb" },
        [450] = { Type = "highdmg", Name = "Expunge" },
        [451] = { Type = "highdmg", Name = "Split" },
        [452] = { Type = "attack", Name = "Broom", Prio = 2 },
        [453] = { Type = "highdmg", Name = "SandStorm", Prio = 1 },
        [454] = { Type = "shield", Name = "SandStorm" },
        [455] = { Type = "quick", Name = "Batter", Prio = 2 },
        [456] = { Type = "highdmg", Name = "Clean-Up" },
        [457] = { Type = "highdmg", Name = "Sweep" },
        [458] = { Type = "dmgbuff", Name = "Wind-Up" },
        [459] = { Type = "attack", Name = "Wind-Up", Prio = 1 },
        [460] = { Type = "highdmg", Name = "Illuminate" },
        [461] = { Type = "ifbuffed", Name = "Light(Blinded)", Debuffs = { 462, 954 } },
        [462] = { Type = "blind", Name = "Blinded" },
        [463] = { Type = "debuff", Name = "Flash" },
        [464] = { Type = "shield", Name = "Illusionary Barrier" },
        [465] = { Type = "shield", Name = "Illusionary Barrier" },
        [466] = { Type = "highdmg", Name = "Nether Gate" },
        [467] = { Type = "attack", Name = "Magical Clone", Prio = 1 },
        [468] = { Type = "debuff", Debuff = 469, Name = "Agony" },
        [469] = { Type = "debuff", Name = "Agony" },
        [470] = { Type = "dmgdebuff", Name = "Weakness" },
        [471] = { Type = "attack", Name = "Weakness", Prio = 1 },
        [472] = { Type = "attack", Name = "Blast of Hatred", Prio = 2 },
        [473] = { Type = "attack", Name = "Focused Beams", Prio = 2 },
        [474] = { Type = "quick", Name = "Interupting Gaze", Prio = 2 },
        [475] = { Type = "speeddebuff", Name = "Eyeblast" },
        [476] = { Type = "attack", Name = "Dark Simulacrum", Prio = 1 },
        [477] = { Type = "attack", Name = "Snowball", Prio = 2 },
        [478] = { Type = "attack", Name = "Magic Hat", Prio = 2 },
        [479] = { Type = "deflect", Name = "Ice Barrier" },
        [480] = { Type = "immunity", Name = "Ice Barrier" },
        [481] = { Type = "highdmg", Name = "Deep Freeze" },
        [482] = { Type = "attack", Name = "Laser", Prio = 2 },
        [483] = { Type = "attack", Name = "Psychic Blast", Prio = 2 },
        [484] = { Type = "attack", Name = "Feedback", Prio = 2 },
        [485] = { Type = "dmgbuff", Name = "Attack Boost", Prio = 2 },
        [486] = { Type = "dmgdebuff", Debuff = 153, Name = "Drain Power" },
        [487] = { Type = "dmgbuff", Name = "Amplify Magic", Prio = 2 },
        [488] = { Type = "dmgbuff", Name = "Amplify Magic" },
        [489] = { Type = "3turnhighdmg", Name = "Mana Surge" },
        [490] = { Type = "deflect", Name = "Deflection" },
        [491] = { Type = "debuff", Name = "Bleeding" },
        [492] = { Type = "attack", Name = "Rake", Prio = 2 },
        [493] = { Type = "highdmg", Name = "Hoof" },
        [494] = { Type = "dmgdebuff", Name = "Attack Reduction" },
        [496] = { Type = "sleep", Name = "Drowsy" },
        [497] = { Type = "debuff", Name = "Soothe" },
        [498] = { Type = "sleepdebuff", Name = "Asleep" },
        [499] = { Type = "attack", Name = "Diseased Bite", Prio = 2 },
        [500] = { Type = "debuff", Name = "Flame Breath" },
        [501] = { Type = "debuff", Name = "Flame Breath", Prio = 3 },
        [502] = { Type = "teamdebuff", Name = "Flamethrower" },
        [503] = { Type = "teamdebuff", Name = "Flamethrower" },
        [504] = { Type = "quick", Name = "Alpha Strike" },
        [505] = { Type = "immunity", Name = "Cocoon Strike" },
        [506] = { Type = "highdmg", Name = "Cocoon Strike" },
        [507] = { Type = "attack", Name = "Moth Balls", Prio = 1 },
        [508] = { Type = "highdmg", Name = "Mosth Dust" },
        [509] = { Type = "attack", Name = "Surge", Prio = 1 },
        [510] = { Type = "hotteam", Name = "Renewing Mists" },
        [511] = { Type = "hotteam", Name = "Renewing Mists", Buff = 510 },
        [512] = { Type = "todeflect", Name = "Whirlpool" },
        [513] = { Type = "delayedheavy", Name = "Whirlpool" },
        [514] = { Type = "attack", Name = "Wild Winds", Prio = 2 },
        [515] = { Type = "debuff", Name = "Flyby" },
        [516] = { Type = "debuff", Name = "Weakened Defenses" },
        [517] = { Type = "highdmg", Name = "Nocturnal Strike" },
        [518] = { Type = "highdmg", Name = "Predatory Strike" },
        [519] = { Type = "apocalypse", Name = "Apocalypse" },
        [520] = { Type = "dmgbuff", Name = "Hawk Eye" },
        [521] = { Type = "dmgbuff", Name = "Hawk Eye" },
        [522] = { Type = "dmgdebuff", Debuff = 738, Name = "Nevermore" },
        [524] = { Type = "debuff", Name = "Squawk" },
        [525] = { Type = "attack", Name = "Emerald Bite", Prio = 2 },
        [526] = { Type = "dmgdebuff", Name = "Stench" },
        [527] = { Type = "dmgdebuff", Name = "Stench" },
        [528] = { Type = "attack", Name = "Frost Spit", Prio = 2 },
        [529] = { Type = "attack", Name = "Belly Slide", Prio = 1 },
        [532] = { Type = "highdmg", Name = "Body Slam" },
        [533] = { Type = "delayedheal", Name = "Rebuild" },
        [535] = { Type = "quick", Name = "Pounce" },
        [536] = { Type = "dmgbuff", Name = "Prowl" },
        [537] = { Type = "dmgdebuff", Name = "Attack Reduction" },
        [538] = { Type = "execute", Name = "Devour" },
        [539] = { Type = "delayedheal", Name = "Bleat" },
        [540] = { Type = "todeflect", Name = "Chew" },
        [541] = { Type = "highdmg", Name = "Chew" },
        [542] = { Type = "dmgdebuff", Name = "Shattered Defenses" },
        [543] = { Type = "dmgbuff", Name = "Prowl" },
        [544] = { Type = "speedbuff", Name = "Speed Boost" },
        [546] = { Type = "root", Name = "Frost Nova" },
        [563] = { Type = "attack", Name = "Quick Attack", Prio = 1 },
        [564] = { Type = "2turn", Name = "Dive" },
        [565] = { Type = "todeflect", Name = "Underground" },
        [566] = { Type = "attack", Name = "Powerball", Prio = 1 },
        [567] = { Type = "buff", Name = "Rush", Buff = 544 },
        [568] = { Type = "cantdie", Name = "Feign Death" },
        [569] = { Type = "stun", Name = "Crystal Prison" },
        [570] = { Type = "attack", Name = "Broom Strike" },
        [571] = { Type = "quick", Name = "Horn Attack" },
        [572] = { Type = "highdmg", Name = "MudSlide" },
        [573] = { Type = "heal", Name = "Nature's Touch" },
        [574] = { Type = "hotbuff", Name = "Nature's Ward" },
        [575] = { Type = "teamdebuff", Name = "Slippery Ice" },
        [576] = { Type = "cantdie", Name = "Perk Up" },
        [577] = { Type = "buff", Name = "Healthy" },
        [578] = { Type = "delayedheal", Name = "Buried Treasure" },
        [579] = { Type = "buff", Name = "Gobble Strike", Buff = 735 },
        [580] = { Type = "sleep", Debuff = 498, Name = "Food Coma" },
        [581] = { Type = "3turn", Name = "Flock" },
        [583] = { Type = "dmgbuff", Name = "Intensity" },
        [584] = { Type = "attack", Name = "Winter Spirit" },
        [585] = { Type = "attack", Name = "Holiday Cheer" },
        [586] = { Type = "highdmg", Name = "Gift of Winter's Veil" },
        [588] = { Type = "highdmg", Name = "Devastate" },
        [589] = { Type = "dmgbuff", Name = "Arcane Storm" },
        [590] = { Type = "weather", Name = "Arcane Winds" },
        [591] = { Type = "dmgdebuff", Name = "Wild Magic" },
        [592] = { Type = "debuff", Name = "Wild Magic" },
        [593] = { Type = "highdmg", Name = "Surge of Power" },
        [594] = { Type = "attack", Name = "Sleeping Gas", Prio = 1 },
        [595] = { Type = "highdmg", Name = "Moonfire" },
        [596] = { Type = "buff", Name = "Moonlight" },
        [597] = { Type = "buff", Name = "Emerald Presence", Buff = 823 },
        [598] = { Type = "delayedheal", Name = "Emerald Dream" },
        [599] = { Type = "delayedheal", Name = "Emerald Dream" },
        [600] = { Type = "stun", Name = "Time Stop" },
        [601] = { Type = "highdmg", Name = "Time Bomb" },
        [602] = { Type = "highdmg", Name = "Time Bomb" },
        [603] = { Type = "teambuff", Name = "Temporal Lapse" },
        [604] = { Type = "teambuff", Name = "Extreme Power" },
        [605] = { Type = "todeflect", Name = "Elementium Bolt" },
        [606] = { Type = "delayedheavy", Name = "Elementium Bolt" },
        [607] = { Type = "highdmg", Name = "Cataclysm" },
        [608] = { Type = "attack", Name = "Nether Blast", Prio = 2 },
        [609] = { Type = "highdmg", Name = "Instability" },
        [610] = { Type = "buff", Name = "Ancient Blessing" },
        [611] = { Type = "heal", Name = "Ancient Blessing" },
        [612] = { Type = "highdmg", Name = "Proto-Strike" },
        [613] = { Type = "dmgbuff", Name = "Competitive Spirit" },
        [614] = { Type = "dmgbuff", Name = "Competitive Spirit" },
        [615] = { Type = "teambuff", Name = "Wrath of Tarecgosa" },
        [616] = { Type = "attack", Name = "Blinkstrike", Prio = 1 },
        [617] = { Type = "quick", Name = "Spark", Prio = 2 },
        [621] = { Type = "highdmg", Name = "Stone Rush" },
        [623] = { Type = "todeflect", Name = "Ice Tomb" },
        [624] = { Type = "delayedheavy", Name = "Ice Tomb" },
        [625] = { Type = "attack", Name = "Ice Spike" },
        [626] = { Type = "attack", Name = "Skitter", Prio = 2 },
        [627] = { Type = "teamdebuff", Name = "Rock Barrage" },
        [628] = { Type = "teamdebuff", Name = "Rock Barrage" },
        [630] = { Type = "debuff", Name = "Poisoned Branch", Prio = 2 },
        [631] = { Type = "debuff", Name = "Super Sticky Goo" },
        [632] = { Type = "debuff", Debuff = 633, Name = "Confusing Sting" },
        [633] = { Type = "debuff", Name = "Confusing Sting" },
        [634] = { Type = "teamdebuff", Name = "Minefield" },
        [635] = { Type = "teamdebuff", Name = "Minefield" },
        [636] = { Type = "delayedheavy", Name = "Sticky Grenade" },
        [637] = { Type = "todeflect", Name = "Sticky Grenade" },
        [639] = { Type = "teamdebuff", Name = "Toxic Smoke" },
        [640] = { Type = "teamdebuff", Name = "Toxic Smoke" },
        [641] = { Type = "teamdebuff", Name = "Egg Barrage" },
        [642] = { Type = "teamdebuff", Name = "Egg Barrage" },
        [644] = { Type = "teamdebuff", Name = "Quake" },
        [645] = { Type = "2turn", Name = "Launch" },
        [646] = { Type = "highdmg", Name = "Shock and Awe" },
        [647] = { Type = "3turn", Name = "Bombing Run" },
        [648] = { Type = "attack", Name = "Bone Bite", Prio = 2 },
        [649] = { Type = "aoe", Name = "BONESTORM" },
        [650] = { Type = "rootattack", Name = "Bone Prison" },
        [652] = { Type = "kamikaze", Name = "Haunt" },
        [653] = { Type = "debuff", Name = "Haunt" },
        [654] = { Type = "stun", Name = "Ghostly Bite" },
        [655] = { Type = "attack", Name = "Creepy Chomp", Prio = 1 },
        [657] = { Type = "debuff", Debuff = 658, Name = "Plagued Blood" },
        [658] = { Type = "debuff", Name = "Plagued Blood" },
        [660] = { Type = "debuff", Name = "Spreading Infection" },
        [661] = { Type = "debuff", Name = "Spreading Infection" },
        [662] = { Type = "debuff", Name = "Spreading Infection" },
        [663] = { Type = "kamikaze", Name = "Corpse Explosion" },
        [664] = { Type = "debuff", Name = "Corpse Explosion" },
        [665] = { Type = "consume", Name = "Consume Corpse" },
        [666] = { Type = "3turn", Name = "Rabid Bite" },
        [667] = { Type = "cleanse", Name = "Aged Yolk" },
        [668] = { Type = "3turn", Name = "Dreadful Breath" },
        [669] = { Type = "highdmg", Name = "Backflip" },
        [670] = { Type = "debuff", Name = "Snap Trap" },
        [671] = { Type = "debuff", Name = "Snap Trap" },
        [677] = { Type = "dmgdebuff", Name = "Wild Winds" },
        [682] = { Type = "15turn", Name = "Apocalypse" },
        [683] = { Type = "15turn", Name = "Apocalypse" },
        [706] = { Type = "3turn", Name = "Swarm" },
        [710] = { Type = "turret", Name = "Build Turret" },
        [711] = { Type = "teambuff", Name = "Turret" },
        [712] = { Type = "attack", Name = "Railgun", Prio = 2 },
        [713] = { Type = "quick", Name = "Blitz", Prio = 2 },
        [717] = { Type = "stunned", Name = "Banished" },
        [718] = { Type = "weather", Name = "Mudslide" },
        [720] = { Type = "teambuff", Name = "Clone" },
        [721] = { Type = "weather", Name = "Slippery Ice" },
        [723] = { Type = "passive", Name = "Mechanical" },
        [724] = { Type = "passive", Name = "Undead" },
        [726] = { Type = "passive", Name = "Humanoid" },
        [734] = { Type = "stunned", Name = "Crystal Prison" },
        [735] = { Type = "speedbuff", Name = "Speed Boost" },
        [737] = { Type = "todeflect", Name = "Meteor" },
        [738] = { Type = "highdmg", Name = "Nevermore" },
        [739] = { Type = "dmgbuff", Name = "Frenzyheart Brew" },
        [740] = { Type = "dmgbuff", Name = "Frenzyheart Brew" },
        [741] = { Type = "aoe", Name = "Whirlwind" },
        [742] = { Type = "teamdebuff", Name = "Creeping Fungus" },
        [743] = { Type = "debuff", Name = "Creeping Fungus" },
        [744] = { Type = "heal", Name = "Leech Seed" },
        [745] = { Type = "heal", Name = "Leech Seed" },
        [746] = { Type = "highdmg", Name = "Spore Shrooms" },
        [747] = { Type = "highdmg", Name = "Spore Shrooms" },
        [748] = { Type = "debuff", Name = "Spore Burst" },
        [750] = { Type = "shield", Name = "Soul Ward" },
        [751] = { Type = "shield", Name = "Soul Ward" },
        [752] = { Type = "highdmg", Name = "Soulrush" },
        [753] = { Type = "highdmg", Name = "Solar Beam" },
        [754] = { Type = "attack", Name = "Screeching Gears", Prio = 1 },
        [755] = { Type = "debuff", Name = "Acid Touch" },
        [756] = { Type = "debuff", Name = "Acid Touch" },
        [757] = { Type = "buff", Name = "Lucky Dance" },
        [758] = { Type = "teambuff", Name = "Mrrrgglllrggghl" },
        [759] = { Type = "immunity", Name = "Block" },
        [760] = { Type = "shield", Name = "Shield Block" },
        [761] = { Type = "highdmg", Name = "Heroic Leap" },
        [762] = { Type = "highdmg", Name = "Haymaker" },
        [763] = { Type = "cleanse", Name = "Sear Magic" },
        [764] = { Type = "deflect", Name = "Phase Shift" },
        [765] = { Type = "attack", Name = "Holy Sword", Prio = 1 },
        [766] = { Type = "stun", Name = "Holy Justice" },
        [767] = { Type = "highdmg", Name = "Holy Charge" },
        [768] = { Type = "aoe", Name = "Omnislash" },
        [769] = { Type = "highdmg", Name = "Surge of Light" },
        [770] = { Type = "heal", Name = "Restoration" },
        [771] = { Type = "attack", Name = "Bow Shot", Prio = 2 },
        [772] = { Type = "stun", Name = "LoveStruck" },
        [773] = { Type = "highdmg", Name = "Shot Through The Heart" },
        [774] = { Type = "aoe", Name = "Rapid Fire" },
        [775] = { Type = "attack", Name = "Perfumed Arrow", Prio = 1 },
        [776] = { Type = "heal", Name = "Love Potion" },
        [777] = { Type = "highdmg", Name = "Missile" },
        [778] = { Type = "attack", Name = "Charge", Prio = 1 },
        [779] = { Type = "highdmg", Name = "Thunderbolt" },
        [780] = { Type = "stun", Name = "Death Grip" },
        [781] = { Type = "debuff", Name = "Creeping Ooze" },
        [782] = { Type = "attack", Name = "Frost Breath", Prio = 2 },
        [784] = { Type = "dmgdebuff", Debuff = 494, Name = "Shriek" },
        [785] = { Type = "teamdebuff", Name = "Blistering Cold" },
        [786] = { Type = "teamdebuff", Name = "Blistering Cold" },
        [787] = { Type = "debuff", Name = "Frostbite" },
        [788] = { Type = "highdmg", Name = "Gauss Rifle" },
        [789] = { Type = "quick", Name = "U-238 Rounds", Prio = 2 },
        [790] = { Type = "dmgbuff", Name = "Stimpack" },
        [791] = { Type = "dmgbuff", Name = "Stimpack" },
        [792] = { Type = "highdmg", Name = "Darkflame" },
        [793] = { Type = "healdebuff", Name = "Healing Reduction" },
        [794] = { Type = "cantdie", Name = "Dark Rebirth" },
        [795] = { Type = "cantdie", Name = "Dark Rebirth" },
        [798] = { Type = "buff", Name = "Dark Simulacrum" },
        [799] = { Type = "teambuff", Name = "Mrrrgglllrggghl" },
        [800] = { Type = "attack", Name = "Impale", Prio = 2 },
        [801] = { Type = "attack", Name = "Stone Shot", Prio = 2 },
        [802] = { Type = "execute", Name = "Ravage" },
        [803] = { Type = "debuff", Name = "Rip" },
        [804] = { Type = "immunity", Name = "Feign Death" },
        [807] = { Type = "dmgdebuff", Name = "Rabies" },
        [809] = { Type = "dmgbuff", Name = "Roll" },
        [810] = { Type = "teamdebuff", Name = "Magma Trap" },
        [811] = { Type = "teamdebuff", Name = "Magma Trap" },
        [812] = { Type = "highdmg", Name = "Sulfuras Smash" },
        [813] = { Type = "highdmg", Name = "Wrath of Tarecgosa" },
        [814] = { Type = "highdmg", Name = "Rupture" },
        [819] = { Type = "todeflect", Name = "Bomb" },
        [820] = { Type = "hotbuff", Name = "Nature's Ward" },
        [822] = { Type = "sleepdebuff", Name = "Frog Kiss" },
        [823] = { Type = "shielded", Name = "Emerald Presence" },
        [826] = { Type = "attack", Name = "Weakening Blow", Prio = 2 },
        [827] = { Type = "immunity", Name = "Sons of the Root" },
        [828] = { Type = "highdmg", Name = "Sons of the Root" },
        [829] = { Type = "immunity", Name = "Submerge", Deflect = true },
        [830] = { Type = "immunity", Name = "Underwater", Deflect = true },
        [831] = { Type = "speedbuff", Name = "Speed Boost" },
        [835] = { Type = "cleanse", Name = "Eggnog" },
        [836] = { Type = "kamikaze", Name = "Baneling Burst" },
        [838] = { Type = "speedbuff", Name = "Centrifugal Hooks" },
        [839] = { Type = "immunity", Name = "Leaping", Deflect = true },
        [841] = { Type = "dmgbuff", Name = "Adrenal Glands" },
        [848] = { Type = "root", Name = "Frost Nova" },
        [849] = { Type = "attack", Name = "Huge, Sharp Teeth!", Prio = 1 },
        [850] = { Type = "speedbuff", Name = "Vicious Streak" },
        [851] = { Type = "buff", Name = "Vicious Streak", Buff = 544 },
        [852] = { Type = "immunity", Name = "Flying(Launch)" },
        [860] = { Type = "teamdebuff", Name = "Flamethrower" },
        [869] = { Type = "dmgdebuff", Debuff = 153, Name = "Darkmoon Curse" },
        [870] = { Type = "3turn", Name = "Murder" },
        [900] = { Type = "debuff", Name = "Fel Immolate" },
        [901] = { Type = "debuff", Name = "Fel Immolate" },
        [904] = { Type = "immunity", Name = "Deflection" },
        [905] = { Type = "buff", Name = "Cute Face" },
        [906] = { Type = "buff", Name = "Lightning Shield" },
        [907] = { Type = "buff", Name = "Lightning Shield" },
        [908] = { Type = "highdmg", Name = "Jolt" },
        [909] = { Type = "debuff", Name = "Paralyzing Shock" },
        [910] = { Type = "attack", Name = "Sand Bolt", Prio = 2 },
        [911] = { Type = "speeddebuff", Name = "QuickSand" },
        [912] = { Type = "highdmg", Name = "QuickSand" },
        [913] = { Type = "highdmg", Name = "Spectral Spine" },
        [914] = { Type = "buff", Name = "Spirit Spikes" },
        [915] = { Type = "buff", Name = "Spirit Spikes" },
        [916] = { Type = "highdmg", Name = "Haywire" },
        [917] = { Type = "3turnhighdmg", Name = "Bloodfang" },
        [918] = { Type = "dmgdebuff", Name = "Black Claw" },
        [919] = { Type = "dmgdebuff", Name = "Black Claw" },
        [920] = { Type = "teamdebuff", Name = "Primal Cry" },
        [921] = { Type = "attack", Name = "Hunting Party", Prio = 1 },
        [922] = { Type = "delayedheal", Name = "Healing Stream" },
        [923] = { Type = "aoe", Name = "Flux" },
        [924] = { Type = "passive", Name = "Critter" },
        [926] = { Type = "sleepdebuff", Name = "Soothe" },
        [927] = { Type = "sleepdebuff", Name = "Stunned" },
        [928] = { Type = "speeddebuff", Name = "Slither" },
        [929] = { Type = "speeddebuff", Name = "Slither" },
        [930] = { Type = "attack", Name = "Huge Fang", Prio = 1 },
        [931] = { Type = "dmgdebuff", Name = "Croak" },
        [932] = { Type = "dmgdebuff", Name = "Croak" },
        [933] = { Type = "immunity", Name = "Bubble" },
        [934] = { Type = "deflect", Name = "Bubble" },
        [935] = { Type = "dmgbuff", Name = "Caw" },
        [936] = { Type = "dmgbuff", Name = "Caw" },
        [937] = { Type = "leech", Name = "Siphon Anima" },
        [938] = { Type = "quick", Name = "Interrupting Jolt" },
        [939] = { Type = "debuff", Name = "Touch of the Animus" },
        [940] = { Type = "debuff", Debuff = 939, Name = "Touch of the Animus" },
        [941] = { Type = "cleanse", Name = "High Fiber" },
        [942] = { Type = "highdmg", Name = "Frying Pan" },
        [943] = { Type = "attack", Name = "Chop", Prio = 1 },
        [944] = { Type = "buff", Name = "Heat Up" },
        [945] = { Type = "buff", Name = "Heat Up" },
        [954] = { Type = "blind", Name = "Blinded" },
        [955] = { Type = "blind", Name = "Blinded" },
        [956] = { Type = "elite", Name = "Elite" },
        [957] = { Type = "buff", Name = "Evolution", Buff = 485 },
        [958] = { Type = "attack", Name = "Trihorn Charge", Prio = 1 },
        [959] = { Type = "shield", Name = "Trihorn Shield" },
        [960] = { Type = "shield", Name = "Trihorn Shield" },
        [961] = { Type = "shield", Name = "Ironbark" },
        [962] = { Type = "shield", Name = "Ironbark" },
        [963] = { Type = "debuff", Name = "Autumn Breeze" },
        [964] = { Type = "debuff", Name = "Autumn Breeze" },
        [983] = { Type = "quick", Name = "SMCKTHAT.EXE" },
        [985] = { Type = "teamdebuff", Name = "Make it Rain", Buff = 986 },
        [986] = { Type = "teamdebuff", Name = "Make it Rain" },
        [989] = { Type = "heal", Name = "Bligntron Gift Package" },
        [996] = { Type = "stunned", Name = "Lullaby" },
        [997] = { Type = "vengeance", Name = "Vengeance" },
        [998] = { Type = "deflect", Name = "Ethereal" },
        [999] = { Type = "immunity", Name = "Ethereal" },
        [1000] = { Type = "highdmg", Name = "Call of Celestials" },
        [1001] = { Type = "highdmg", Name = "Call of Celestials" },
        [1002] = { Type = "3turn", Name = "Inflation" },
        [1003] = { Type = "highdmg", Name = "Gold Rush" },
        [1004] = { Type = "attack", Name = "Gilded Fist", Prio = 1 },
        [1005] = { Type = "shield", Name = "Goldskin" },
        [1006] = { Type = "shield", Name = "Goldskin" },
        [1007] = { Type = "2turn", Name = "Locust Swarm" },
        [1008] = { Type = "highdmg", Name = "Brew Bolt" },
        [1009] = { Type = "dmgdebuff", Name = "Inebriate" },
        [1010] = { Type = "dmgdebuff", Name = "Inebriate" },
        [1011] = { Type = "todeflect", Name = "Locust Swarm" },
        [1012] = { Type = "dmgbuff", Name = "Giant's Blood" },
        [1013] = { Type = "highdmg", Name = "Call of Winter" },
        [1014] = { Type = "blind", Name = "Blinded" },
        [1015] = { Type = "blind", Name = "Blinding Powder" },
        [1016] = { Type = "leech", Name = "Feed" },
        [1019] = { Type = "2turn", Name = "Niuzao's Charge" },
        [1020] = { Type = "blind", Name = "Lens Flare" },
        [1021] = { Type = "attack", Name = "Phaser" },
        [1022] = { Type = "attack", Name = "Plot Twist" },
        [1023] = { Type = "delayedheal", Name = "Rebooting" },
        [1024] = { Type = "delayedheal", Name = "Rebooting" },
        [1025] = { Type = "kamikaze", Name = "Armageddon" },
        [1026] = { Type = "stun", Name = "Amber Prison" },
        [1027] = { Type = "quick", Name = "Fire Quills" },
        [1028] = { Type = "dmgbuff", Name = "Dominance" },
        [1029] = { Type = "dmgbuff", Name = "Dominance" },
        [1030] = { Type = "stunned", Name = "Stunned" },
        [1031] = { Type = "attack", Name = "Jadefire Lightning" },
        [1032] = { Type = "teambuff", Name = "Celestial Blessing" },
        [1033] = { Type = "teambuff", Name = "Sanctified Ground" },
        [1034] = { Type = "dmgreduced", Name = "Celestial Blessing" },
        [1035] = { Type = "aoe", Name = "Spitfire Beam" },
        [1036] = { Type = "forcehigh", Name = "Frill Blast" },
        [1039] = { Type = "teambuff", Name = "Nimbus" },
        [1040] = { Type = "teambuff", Name = "Nimbus" },
        [1041] = { Type = "teamdebuff", Name = "Flame Jet" },
        [1042] = { Type = "teamdebuff", Name = "Flame Jet" },
        [1043] = { Type = "heal", Name = "Drain Blood" },
        [1044] = { Type = "shield", Name = "Barkskin" },
        [1045] = { Type = "shield", Name = "Barkskin" },
        [1046] = { Type = "dmgreduced", Name = "Frolicking" },
        [1047] = { Type = "dmgreduced", Name = "Frolicking" },
        [1048] = { Type = "blind", Name = "Blinding Poison" },
        [1049] = { Type = "blind", Name = "Blinding Poison" },
        [1050] = { Type = "ifbuffed", Name = "Puncture Wound", Debuffs = { 1049, 1050 } },
        [1051] = { Type = "highdmg", Name = "Acid Rain" },
        [1052] = { Type = "highdmg", Name = "Tornado Punch" },
        [1053] = { Type = "dmgbuff", Name = "Bonkers!" },
        [1054] = { Type = "dmgbuff", Name = "Going Bonkers!" },
        [1055] = { Type = "highdmg", Name = "Breath of Sorrow" },
        [1056] = { Type = "attack", Name = "Seethe" },
        [1057] = { Type = "teambuff", Name = "Birth Evil" },
        [1058] = { Type = "teambuff", Name = "Globule" },
        [1059] = { Type = "healdebuff", Name = "Healing Reduction" },
        [1060] = { Type = "attack", Name = "Steam Vent" },
        [1061] = { Type = "dmgbuff", Name = "Rain Dance" },
        [1062] = { Type = "dmgbuff", Name = "Rain Dance" },
        [1063] = { Type = "teamdebuff", Name = "Pheromones" },
        [1064] = { Type = "teamdebuff", Name = "Pheromones" },
        [1065] = { Type = "consume", Name = "Digest Brains" },
        [1066] = { Type = "attack", Name = "Spiritfire Bolt" },
        [1067] = { Type = "dmgdebuff", Name = "Forboding Curse" },
        [1068] = { Type = "dmgdebuff", Name = "Forboding Curse" },
        [1069] = { Type = "root", Name = "Skunky Brew" },
        [1070] = { Type = "root", Name = "Skunky Brew" },
        [1071] = { Type = "todeflect", Name = "Explosive Brew" },
        [1072] = { Type = "delayedheavy", Name = "Explosive Brew" },
        [1073] = { Type = "shield", Name = "Spiny Carapace" },
        [1074] = { Type = "shield", Name = "Spiny Carapace" },
        [1075] = { Type = "shield", Name = "Spiny Carapace" },
        [1076] = { Type = "highdmg", Name = "Greench's Gift" },
        [1077] = { Type = "quick", Name = "Spin Kick" },
        [1078] = { Type = "hotbuff", Name = "Bandage" },
        [1079] = { Type = "attack", Name = "Club" },
        [1080] = { Type = "teamdebuff", Name = "Booby-Trapped Presents" },
        [1081] = { Type = "teamdebuff", Name = "Booby-Trapped Presents" },
        [1082] = { Type = "attack", Name = "Jade Breath" },
        [1083] = { Type = "immunity", Name = "Fade" },
        [1084] = { Type = "deflect", Name = "Fade" },
        [1085] = { Type = "attack", Name = "Magic Sword" },
        [1086] = { Type = "debuff", Name = "Toxic Skin" },
        [1087] = { Type = "debuff", Name = "Toxic Skin" },
        [1088] = { Type = "attack", Name = "Nairn!" },
        [1089] = { Type = "elite", Name = "Boss" },
        [1091] = { Type = "teamdebuff", Name = "Bone Barrage" },
        [1092] = { Type = "teamdebuff", Name = "Bone Barrage" },
        [1093] = { Type = "3turn", Name = "Dead Man's Party" },
        [1094] = { Type = "attack", Name = "Macabre Maraca" },
        [1095] = { Type = "attack", Name = "Horn Gore" },
        [1099] = { Type = "attack", Name = "Punish" },
        [1100] = { Type = "attack", Name = "Blessed Hammer" },
        [1101] = { Type = "teambuff", Name = "Shieldstorm" },
        [1103] = { Type = "highdmg", Name = "Righteous Inspiration" },
        [1104] = { Type = "dmgreduced", Name = "Reflective Shield" },
        [1105] = { Type = "dmgreduced", Name = "Reflective Shield" },
        [1106] = { Type = "dmgreduced", Name = "Reflective Shield" },
        [1107] = { Type = "highdmg", Name = "Falling Murloc" },
        [1108] = { Type = "dmgdebuff", Name = "Bark" },
        [1109] = { Type = "teambuff", Name = "The Good Stuff" },
        [1110] = { Type = "aoe", Name = "Avalanche" },
        [1111] = { Type = "dmgreduced", Name = "Tough n' Cuddly" },
        [1112] = { Type = "dmgreduced", Name = "Tough n' Cuddly" },
        [1116] = { Type = "highdmg", Name = "Call the Pack" },
        [1119] = { Type = "dmgbuff", Name = "Righteous Inspiration" },
        [1120] = { Type = "dmgdebuff", Name = "Attack Reduction" },
        [1121] = { Type = "3turn", Name = "Coin Toss" },
        [1122] = { Type = "debuff", Name = "Greedy" },
        [1123] = { Type = "cleanse", Name = "Disruption" },
        [1124] = { Type = "immunity", Name = "Portal" },
        [1125] = { Type = "deflect", Name = "Portal" },
        [1128] = { Type = "dmgbuff", Name = "Critical Bonus" },
        [1223] = { Type = "attack", Name = "Slice" },
        [1231] = { Type = "cleanse", Name = "Consume Magic" },
        [1232] = { Type = "dmgbuff", Name = "Anzu's Blessing" },
        [1233] = { Type = "attack", Name = "Dark Talon" },
        [1238] = { Type = "attack", Name = "Shadow Talon" },
        [1273] = { Type = "aoe", Name = "Cleave" },
        [1287] = { Type = "aoe", Name = "Carpnado" },
        [1301] = { Type = "leech", Name = "Pig Out" },
        [1302] = { Type = "dmgbuff", Name = "Critical Bonus" },
        [1303] = { Type = "dmgbuff", Name = "Critical Bonus" },
        [1304] = { Type = "dmgbuff", Name = "Critical Bonus" },
        [1305] = { Type = "dmgbuff", Name = "Critical Bonus" },
        [1334] = { Type = "attack", Name = "Plushie Rush" },
        [1335] = { Type = "attack", Name = "Rawr!" },
        [1336] = { Type = "attack", Name = "Who's The Best Elekk In The Whole World?" },
        [1337] = { Type = "heal", Name = "Itchin' for a Stitchin'" },
        [1338] = { Type = "kamikaze", Name = "Cute As A Button" },
        [1343] = { Type = "highdmg", Name = "Fist of the Forest" },
        [1344] = { Type = "immunity", Name = "Refuge" },
        [1345] = { Type = "heal", Name = "Nap Time" },
        [1346] = { Type = "shield", Name = "Cute As A Button" },
        [1347] = { Type = "shield", Name = "Cute As A Button" },
        [1348] = { Type = "sleepdebuff", Name = "Asleep" },
        [1353] = { Type = "quick", Name = "Arcane Slash" },
        [1354] = { Type = "highdmg", Name = "Puppies of the Flame" },
        [1355] = { Type = "immunity", Name = "Puppies of the Flame" },
        [1356] = { Type = "forcehigh", Name = "Inferno Herding" },
        [1357] = { Type = "highdmg", Name = "Superbark" },
        [1358] = { Type = "immunity", Name = "Unattackable" },
        [1359] = { Type = "dmgdebuff", Name = "Bark" },
        [1360] = { Type = "2turn", Name = "Bull Charge" },
        [1369] = { Type = "debuff", Name = "Barbed Stinger" },
        [1370] = { Type = "attack", Name = "Savage Talon" },
        [1371] = { Type = "ifbuffed", Name = "Sneak Attack", Debuffs = { 1049, 1050 } },
        [1372] = { Type = "attack", Name = "Deep Bite" },
        [1377] = { Type = "teambuff", Name = "Hearty Meal" },
        [1378] = { Type = "highdmg", Name = "Righteous Inspiration" },
        [1379] = { Type = "shield", Name = "Shell Armor" },
        [1380] = { Type = "shield", Name = "Shell Armor" },
        [1381] = { Type = "2turn", Name = "Death Bleat" },
        [1382] = { Type = "leech", Name = "Unnatural Appetite" },
        [1387] = { Type = "teambuff", Name = "Birds of a Feather" },
        [1388] = { Type = "teambuff", Name = "Birds of a Feather" },
        [1389] = { Type = "teambuff", Name = "Roboflauge" },
        [1390] = { Type = "shield", Name = "Iron Thread" },
        [1391] = { Type = "dmgbuff", Name = "Enraged" },
        [1392] = { Type = "dmgbuff", Name = "Enraged" },
        [1397] = { Type = "healteam", Name = "Haunting Song" },
        [1398] = { Type = "dmgbuff", Name = "Feathered Frenzy" },
        [1399] = { Type = "dmgbuff", Name = "Feathered Frenzy" },
        [1400] = { Type = "highdmg", Name = "Udder Destruction" },
        [1401] = { Type = "deflect", Name = "Where's the Beef?" },
        [1402] = { Type = "healteam", Name = "Mother's Milk" },
        [1407] = { Type = "attack", Name = "Deep Burn" },
        [1408] = { Type = "delayedheal", Name = "Reforge" },
        [1409] = { Type = "delayedheal", Name = "Reforging" },
        [1410] = { Type = "heal", Name = "Gift of the Naaru" },
        [1411] = { Type = "aoe", Name = "Grave Destruction" },
        [1412] = { Type = "highdmg", Name = "When Elekks Fly" },
        [1417] = { Type = "buff", Name = "Elemental Mark" },
        [1418] = { Type = "buff", Name = "Rot" },
        [1419] = { Type = "buff", Name = "Critter Mark" },
        [1420] = { Type = "buff", Name = "Flying Mark" },
        [1438] = { Type = "highdmg", Name = "Mighty Charge" },
        [1443] = { Type = "smgbuff", Name = "Call the Pack" },
        [1465] = { Type = "attack", Name = "Gargoyle Strike" },
        [1466] = { Type = "delayedheal", Name = "Stone Form" },
        [1483] = { Type = "attack", Name = "Skull Toss" },
        [1516] = { Type = "dmgbuff", Name = "Fel Corruption" },
        [1517] = { Type = "dmgbuff", Name = "Fel Corruption" },
        [1518] = { Type = "attack", Name = "Claw" },
        [1531] = { Type = "aoe", Name = "Psionic Shockwave" },
        [1532] = { Type = "highdmg", Name = "Psionic Storm" },
        [1533] = { Type = "3turn", Name = "Eye Beam" },
        [1534] = { Type = "dmgbuff", Name = "Murkmorphosis" },
        [1535] = { Type = "dmgbuff", Name = "Murkmorphosis" },
        [1536] = { Type = "highdmg", Name = "Arcane Dash" }
    }

    -- to dump all abilities, I am going to use C_PetBattles.GetAbilityInfoById and get every non-null ability in a log that I will dump
    -- for i = 0, 2000 do
    --     if  C_PetBattles.GetAbilityInfoByID(i) ~= nil and not PetBattles.Abilities[i] then
    --         local id, name, icon, nostrongweakhint, tip = C_PetBattles.GetAbilityInfoByID(i)
    --         -- add to array
    --         print(id, name, tip)
    --     end
    --     -- print array
    -- end


    -- List of Pets to chase.
    PetBattles.Pets = {
        "Adder",
        "Alpine Chipmunk",
        "Alpine Foxling",
        "Alpine Foxling Kit",
        "Alpine Hare",
        "Amber Moth",
        "Amethyst Spiderling",
        "Anodized Robo Cub",
        "Arctic Fox Kit",
        "Ash Lizard",
        "Ash Viper",
        "Baby Ape",
        "Bandicoon",
        "Bandicoon Kit",
        "Bat",
        "Beetle",
        "Biletoad",
        "Black Lamb",
        "Black Rat",
        "Blighted Squirrel",
        "Blighthawk",
        "Borean Marmot",
        "Bucktooth Flapper",
        "Cat",
        "Cheetah Cub",
        "Chicken",
        "Clefthoof Runt",
        "Clouded Hedgehog",
        "Cockroach",
        "Cogblade Raptor",
        "Coral Adder",
        "Coral Snake",
        "Crested Owl",
        "Crimson Geode",
        "Crimson Shale Hatchling",
        "Crystal Beetle",
        "Crystal Spider",
        "Dancing Water Skimmer",
        "Darkshore Cub",
        "Death's Head Cockroach",
        "Desert Spider",
        "Dragonbone Hatchling",
        "Dung Beetle",
        "Effervescent Glowfly",
        "Elder Python",
        "Electrified Razortooth",
        "Elfin Rabbit",
        "Emerald Boa",
        "Emerald Proto-Whelp",
        "Emerald Shale Hatchling",
        "Emerald Turtle",
        "Emperor Crab",
        "Eternal Strider",
        "Fawn",
        "Fel Flame",
        "Festering Maggot",
        "Fire Beetle",
        "Fire-Proof Roach",
        "Fledgling Nether Ray",
        "Fjord Rat",
        "Fjord Worg Pup",
        "Forest Moth",
        "Fluxfire Feline",
        "Frog",
        "Fungal Moth",
        "Gazelle Fawn",
        "Gilded Moth",
        "Giraffe Calf",
        "Gold Beetle",
        "Golden Civet",
        "Golden Civet Kitten",
        "Grasslands Cottontail",
        "Grassland Hopper",
        "Grasslands Cottontail",
        "Grey Moth",
        "Grizzly Squirrel",
        "Grove Viper",
        "Hare",
        "Harpy Youngling",
        "Highlands Mouse",
        "Highlands Skunk",
        "Highlands Turkey",
        "Horned Lizard",
        "Horny Toad",
        "Huge Toad",
        "Imperial Eagle Chick",
        "Infected Fawn",
        "Infected Squirrel",
        "Infinite Whelping",
        "Irradiated Roach",
        "Jumping Spider",
        "Jungle Darter",
        "Jungle Grub",
        "King Snake",
        "Kuitan Mongoose",
        "Kun-Lai Runt",
        "Larva",
        "Lava Crab",
        "Leopard Scorpid",
        "Leopard Tree Frog",
        "Little Black Ram",
        "Locust",
        "Lofty Libram",
        "Lost of Lordaeron",
        "Luyu Moth",
        "Mac Frog",
        "Maggot",
        "Malayan Quillrat",
        "Malayan Quillrat Pup",
        "Marsh Fiddler",
        "Masked Tanuki",
        "Masked Tanuki Pup",
        "Mei Li Sparkler",
        "Mirror Strider",
        "Minfernal",
        "Molten Hatchling",
        "Mongoose Pup",
        "Mountain Skunk",
        "Nether Faerie Dragon",
        "Nether Roach",
        "Nexus Whelpling",
        "Nordrassil Wisp",
        "Oasis Moth",
        "Oily Slimeling",
        "Parrot",
        "Plains Monitor",
        "Prairie Dog",
        "Prairie Mouse",
        "Qiraji Guardling",
        "Rabbit",
        "Rabid Nut Varmint 5000",
        "Rapana Whelk",
        "Rat",
        "Rattlesnake",
        "Ravager Hatchling",
        "Red-Tailed Chipmunk",
        "Resilient Roach",
        "Roach",
        "Robo-Chick",
        "Rock Viper",
        "Ruby Sapling",
        "Rusty Snail",
        "Sand Kitten",
        "Sandy Petrel",
        "Savory Beetle",
        "Scarab Hatchling",
        "Scorpid",
        "Scorpling",
        "Scourged Whelpling",
        "Sea Gull",
        "Sidewinder",
        "Shimmershell Snail",
        "Shrine Fly",
        "Shore Crab",
        "Shy Bandicoon",
        "Sifang Otter",
        "Silent Hedgehog",
        "Silithid Hatchling",
        "Silky Moth",
        "Small Frog",
        "Snake",
        "Snow Cub",
        "Snowy Owl",
        "Softshell Snapling",
        "Spawn of Onyxia",
        "Spiky Lizard",
        "Spiny Lizard",
        "Spiny Terrapin",
        "Spirit Crab",
        "Sporeling Sprout",
        "Spotted Bell Frog",
        "Squirrel",
        "Stinkbug",
        "Stormwind Rat",
        "Stripe-Tailed Scorpid",
        "Stunded Shardhorn",
        "Stunted Yeti",
        "Summit Kid",
        "Sumprush Rodent",
        "Swamp Croaker",
        "Tainted Cockroach",
        "Tainted Moth",
        "Tainted Rat",
        "Thundertail Flapper",
        "Tiny Bog Beast",
        "Tiny Harvester",
        "Tiny Twister",
        "Toad",
        "Tolai Hare",
        "Tol'vir Scarab",
        "Topaz Shale Hatchling",
        "Tree Python",
        "Tundra Penguin",
        "Turkey",
        "Turquoise Turtle",
        "Twilight Beetle",
        "Twilight Fiendling",
        "Unborn Val'kyr",
        "Venomspitter Hatchling",
        "Warpstalker Hatchling",
        "Water Snake",
        "Water Waveling",
        "Wild Crimson Hatchling",
        "Wild Golden Hatchling",
        "Wild Jade Hatchling",
        "Yakrat",
        "Yellow-Bellied Marmot",
        "Zooey Snake"
    }

    -- Rukus(85655) and Brutus(85561) 1-2 robots anti-beast 3 Qiraji
    -- Repair only over 40%


    function module.PetBattles.UI ()
        module.AddPage("Pet Battle")
        module.AddSection("Pet Battle", "Out of Battle", "Green");
        module.AddNewOption("Pet Battle", "Pet Battles", 210, false, nil, nil, "Enable Pet Battles (In and Out of Battle)")
        module.AddNewOption("Pet Battle", "Revive Battle Pets", 220, false, {70, 0, 100, 5}, nil, "Use Revive Battle Pets when one of your pets health is under this threshold if the spell is not available, pets under threshold will be changed for ones with more health.")
        module.AddNewOption("Pet Battle", "Change and Level Pets", 220, false, {4, 1, 4, 1}, nil, "Change pets in your journal while out of battle to level these, define leveling pet quality threshold (1-Poor/2-Common/3-Uncommon/4-Rare).")
        module.AddNewOption("Pet Battle", "Level Wild Pets", 210, false, nil, nil, "Enable to level all pets, Disable to level only pets that can be caged.")
        module.AddNewOption("Pet Battle", "Level Highest Pets", 210, false, nil, nil, "Enable this to level highest level pets first, Disable to level lowest level pets first.")
        module.AddNewOption("Pet Battle", "Minimum Level", 120, false, {6, 1, 24, 1}, nil, "Minimum level to bring a pet to slot 1 to level it.")
        module.AddNewOption("Pet Battle", "Maximum Level", 120, false, {24, 1, 24, 1}, nil, "Maximum level to bring a pet to slot 1 to level it.")
        module.AddNewOption("Pet Battle", "Master Team", 220, false, {4, 1, 4, 1}, nil, "Change pets in your journal while out of battle, use Favorite pets first, will use Min and Max from the two options above, set quality threshold (1-Poor/2-Common/3-Uncommon/4-Rare).")
        module.AddSection("Pet Battle", "In Battle", "Green");
        module.AddNewOption("Pet Battle", "Capture Pets", 220, false, {4, 1, 4, 1}, nil, "Capture Pets (1-Poor/2-Common/3-Uncommon/4-Rare).")
        module.AddNewOption("Pet Battle", "Amount to Collect", 220, false, {3, 1, 3, 1}, nil, "Number of pets to keep of each species.")
        module.AddNewOption("Pet Battle", "Swap-Out Health", 220, false, {25, 0, 100, 5}, nil, "Change pet when active pet health falls under threshold, will not swap out for non-wild battles.")
        module.AddNewOption("Pet Battle", "Level Pet 1", 210, false, nil, nil, "Change pet when active pet health falls under threshold.")
        module.AddNewOption("Pet Battle", "Direct Heal", 220, false, {40, 0, 100, 5}, nil, "Cast Heal when active pet health falls under threshold.")
        module.AddNewOption("Pet Battle", "Delayed Heal", 220, false, {70, 0, 100, 5}, nil, "Cast Delayed Heal when active pet health falls under threshold.")
        module.AddNewOption("Pet Battle", "Heal Over Time", 220, false, {85, 0, 100, 5}, nil, "Cast Heal Over Time when active pet health falls under threshold.")
    end
    -- ToDo
    -- "lifeswap" -- swap our life with enemis life - Needs Testing
    -- "deflect" -- next hit will miss - deflect immunity if .Deflect = true - Needs Testing
    -- "cleanse", -- Use on us when we have debuffs on us
    -- "vengeance" -- need to track damage taken, use if we were hit last turn
    -- "dmgreduced" -- if dmgreduced then avoid using highdmg
    -- "forcehigh" -- force the enemy to bring the highest health pet into play
    -- "healdebuff" -- avoid direct heals on us while debuffed
    -- Turrets must not attack shielded units or during storm

    -- during we can know precisely if we are fighting a trainer
    -- C_PetBattles.IsWildBattle    Returns true in wild battle.
    -- C_PetBattles.IsInBattle  Returns true during a pet battle
    -- C_PetBattles.IsInBattle() and C_PetBattles.IsWildBattle()  Return true during a wild pet battle (normal)
    -- C_PetBattles.IsInBattle() and not C_PetBattles.IsWildBattle() return true during trainer pet battle

    function PetBattles.Rotation()
        if module.IsOptionEnabled ~= nil and module.IsOptionEnabled("Pet Battles") then
            if PetBattles.InBattle() == "pve" and TurnReady then
                PetBattles.Consumed = PetBattles.Consumed or 0
                PetBattles.RefreshActivePet(1)
                PetBattles.RefreshPets(1)
                PetBattles.RefreshActivePet(2)
                PetBattles.RefreshPets(2)
                IsWildBattle = C_PetBattles.IsInBattle() and C_PetBattles.IsWildBattle();

                -- Rotation
                PetBattles.CapturePet()
                if IsWildBattle and PetBattles.ShouldCapture then
                    if PetBattles[2].Active.Percent > 35 then
                        -- module.Bug("Should Capture")
                        PetBattles.Pass()
                        PetBattles.Swapper(true)
                        PetBattles.Healing()
                        PetBattles.HealingDelayed()
                        PetBattles.HealTeamOverTime()
                        PetBattles.HealOverTime()
                        PetBattles.Leech()
                        PetBattles.Quick()
                        PetBattles.Attack()
                    end
                else
                    PetBattles.Pass()
                    -- Leveling - Hit once to get XP
                    if IsWildBattle and not PetBattles.IsRooted() and module.IsOptionEnabled("Level Pet 1") and PetBattles[1].Active.Slot == 1 and PetBattles[1].Active.Level <= module.GetOptionValue("Maximum Level") and PetBattles[2].Active.Percent == 100 and PetBattles[1].Pet[2].Percent > 0 and PetBattles[1].Pet[3].Percent > 0 then
                        --module.Bug("Leveling Rotation")
                        PetBattles.Leech()
                        PetBattles.Quick()
                        PetBattles.Attack()
                        PetBattles.Filler()

                    -- Masters Rotation
                    elseif C_PetBattles.IsInBattle() and not C_PetBattles.IsWildBattle() then
                        if PetBattles.CantDie() then
                            PetBattles.Swapper(false)
                            --module.Bug("Cant Die Trainer Rotation")
                            PetBattles.CastBuff("shield")
                            PetBattles.Turrets()
                            PetBattles.Healing()
                            PetBattles.HealingDelayed()
                            PetBattles.HealTeamOverTime()
                            PetBattles.HealOverTime()
                            PetBattles.CastBuff("buff")
                            PetBattles.CastBuff("focus")
                            PetBattles.DamageBuff()
                            PetBattles.Leech()
                            PetBattles.ThreeTurnHeavy()
                            PetBattles.DelayedHeavy()
                            PetBattles.TwoTurns()
                            PetBattles.TeamDebuff()
                            PetBattles.Quick("normal")
                            PetBattles.AoEPunch("normal")
                            PetBattles.Attack()
                            PetBattles.ThreeTurnSoft()
                            PetBattles.Quick("filler")
                            PetBattles.AoEPunch("filler")
                            PetBattles.Filler()
                        end
                        PetBattles.Swapper(false)
                        --module.Bug("Trainer Rotation Rotation")
                        PetBattles.LifeSwap()
                        PetBattles.Kamikaze()
                        PetBattles.Deflect()
                        PetBattles.Apocalypse()
                        PetBattles.CastBuff("shield")
                        PetBattles.Turrets()
                        PetBattles.Consume()
                        PetBattles.Healing()
                        PetBattles.HealingDelayed()
                        PetBattles.HealTeam()
                        PetBattles.HealTeamOverTime()
                        PetBattles.HealOverTime()
                        PetBattles.CastBuff("buff")
                        PetBattles.CastBuff("focus")
                        PetBattles.IfBuffed()
                        PetBattles.DmgDebuff()
                        PetBattles.CastBuff("focus")
                        PetBattles.DamageBuff()
                        PetBattles.Sleep()
                        PetBattles.HeavyAttack()
                        PetBattles.Leech()
                        PetBattles.ThreeTurnHeavy()
                        PetBattles.DelayedHeavy()
                        PetBattles.TwoTurns()
                        PetBattles.TeamDebuff()
                        PetBattles.Debuff()
                        PetBattles.SpeedDebuff()
                        PetBattles.Quick("normal")
                        PetBattles.AoEPunch("normal")
                        PetBattles.Attack()
                        PetBattles.ThreeTurnSoft()
                        PetBattles.Quick("filler")
                        PetBattles.AoEPunch("filler")
                        PetBattles.Roots()
                        PetBattles.Filler()
                    -- normal rotation
                    else
                        if PetBattles.CantDie() then
                            --module.Bug("Cant Die Rotation")
                            PetBattles.Swapper(true)
                            PetBattles.CastBuff("shield")
                            PetBattles.Turrets()
                            PetBattles.Healing()
                            PetBattles.HealingDelayed()
                            PetBattles.HealTeamOverTime()
                            PetBattles.HealOverTime()
                            PetBattles.CastBuff("buff")
                            PetBattles.CastBuff("focus")
                            PetBattles.DamageBuff()
                            PetBattles.Leech()
                            PetBattles.ThreeTurnHeavy()
                            PetBattles.DelayedHeavy()
                            PetBattles.TwoTurns()
                            PetBattles.TeamDebuff()
                            PetBattles.Quick("normal")
                            PetBattles.AoEPunch("normal")
                            PetBattles.Attack()
                            PetBattles.ThreeTurnSoft()
                            PetBattles.Quick("filler")
                            PetBattles.AoEPunch("filler")
                            PetBattles.Filler()
                        end
                        --module.Bug("Normal Rotation")
                        PetBattles.Swapper(true)
                        PetBattles.LifeSwap()
                        PetBattles.Kamikaze()
                        PetBattles.Deflect()
                        PetBattles.Apocalypse()
                        PetBattles.CastBuff("shield")
                        PetBattles.Turrets()
                        PetBattles.Consume()
                        PetBattles.Healing()
                        PetBattles.HealingDelayed()
                        PetBattles.HealTeam()
                        PetBattles.HealTeamOverTime()
                        PetBattles.HealOverTime()
                        PetBattles.CastBuff("buff")
                        PetBattles.CastBuff("focus")
                        PetBattles.IfBuffed()
                        PetBattles.DmgDebuff()
                        PetBattles.CastBuff("focus")
                        PetBattles.DamageBuff()
                        PetBattles.Sleep()
                        PetBattles.HeavyAttack()
                        PetBattles.Leech()
                        PetBattles.ThreeTurnHeavy()
                        PetBattles.DelayedHeavy()
                        PetBattles.TwoTurns()
                        PetBattles.TeamDebuff()
                        PetBattles.Debuff()
                        PetBattles.SpeedDebuff()
                        PetBattles.Quick("normal")
                        PetBattles.AoEPunch("normal")
                        PetBattles.Attack()
                        PetBattles.ThreeTurnSoft()
                        PetBattles.Quick("filler")
                        PetBattles.AoEPunch("filler")
                        PetBattles.Roots()
                        PetBattles.Filler()
                    end
                end
            end
            if PetBattles.InBattle() == "no" then
                PetBattles.Consumed = 0
                if not PetBattles.HealPets() then
                    PetBattles.PetSwapper()
                end
            end
        end
    end
    -- UnitIsWildBattlePet("target")
    -- select(11, C_PetJournal.GetPetInfoBySpeciesID(C_PetBattles.GetPetSpeciesID(2, 1)))
    function PetBattles.CapturePet()
        if select(11, C_PetJournal.GetPetInfoBySpeciesID(C_PetBattles.GetPetSpeciesID(2, PetBattles[2].Active.Slot))) == true and module.IsOptionEnabled("Capture Pets") and C_PetBattles.GetBreedQuality(2, PetBattles[2].Active.Slot) >= module.GetOptionValue("Capture Pets") and C_PetJournal.GetNumCollectedInfo(C_PetBattles.GetPetSpeciesID(2, PetBattles[2].Active.Slot)) < module.GetOptionValue("Amount to Collect") then
            if PetBattles[2].Active.Percent < 35 and C_PetBattles.IsTrapAvailable() then
                C_PetBattles.UseTrap()
                PetBattles.Status("Trapping Pet")
                TurnReady = false
                return
            end
        end
    end

    --  RarityColorsTable[1]
    PetBattles.RarityColorsTable = {
        { Type = "Poor",  Color = "999999" },
        { Type = "Common",   Color = "FFFFFF" },
        { Type = "Uncommon", Color = "33FF33" },
        { Type = "Rare",     Color = "00AAFF" }
    }

    --  TypeWeaknessTable[1].Color
    PetBattles.TypeWeaknessTable = {
        { Num = 1,    Type = "Humanoid",  Weak = 8,   Strong = 2, Resist = 5, Color = "00AAFF" },
        { Num = 2,    Type = "Dragonkin", Weak = 4,   Strong = 6, Resist = 3, Color = "33FF33" },
        { Num = 3,    Type = "Flying",    Weak = 2,   Strong = 9, Resist = 8, Color = "FFFF66" },
        { Num = 4,    Type = "Undead",    Weak = 9,   Strong = 1, Resist = 2, Color = "663366" },
        { Num = 5,    Type = "Critter",   Weak = 1,   Strong = 4, Resist = 7, Color = "AA7744" },
        { Num = 6,    Type = "Magic",     Weak = 10,  Strong = 3, Resist = 9, Color = "CC44DD" },
        { Num = 7,    Type = "Elemental", Weak = 5,   Strong = 10,Resist = 10,Color = "FF9933" },
        { Num = 8,    Type = "Beast",     Weak = 3,   Strong = 5, Resist = 1, Color = "DD2200" },
        { Num = 9,    Type = "Aquatic",   Weak = 6,   Strong = 7, Resist = 4, Color = "33CCFF" },
        { Num = 10,   Type = "Mechanical",Weak = 7,   Strong = 8, Resist = 6, Color = "999999" }
    }

    --------------------------
    -- Battle States & Vars --
    --------------------------
    -- Battle Types
    function PetBattles.InBattle()
        if C_PetBattles.IsInBattle() then
            return "pve"
        elseif C_PetBattles.IsWildBattle() then
            return "wild"
        elseif C_PetBattles.IsInBattle() and C_PetBattles.GetTurnTimeInfo() ~= nil then
            return "pvp"
        else
            return "no"
        end
    end
    -- Return nomber of pet abilities
    function PetBattles.NumberOfAbilities()
        local level = C_PetBattles.GetLevel(1, C_PetBattles.GetActivePet(1))
        if level >= 4 then
            return 3
        elseif level >= 2 then
            return 2
        else
            return 1
        end
    end

    -- Active Pet
    function PetBattles.RefreshActivePet(thisOwner)
        local active = C_PetBattles.GetActivePet(thisOwner)
        PetBattles[thisOwner].Active = {
            Abilities = {
                [0] = PetBattles.NumberOfAbilities(),
                [1] = { ID = C_PetBattles.GetAbilityInfo(thisOwner, active, 1), Name = select(2,C_PetBattles.GetAbilityInfo(thisOwner, active, 1)), Ready = C_PetBattles.GetAbilityState(thisOwner, active, 1) },
                [2] = { ID = C_PetBattles.GetAbilityInfo(thisOwner, active, 2), Name = select(2,C_PetBattles.GetAbilityInfo(thisOwner, active, 2)), Ready = C_PetBattles.GetAbilityState(thisOwner, active, 2) },
                [3] = { ID = C_PetBattles.GetAbilityInfo(thisOwner, active, 3), Name = select(2,C_PetBattles.GetAbilityInfo(thisOwner, active, 3)), Ready = C_PetBattles.GetAbilityState(thisOwner, active, 3) },
            },
            AllAuras = {},
            Auras = C_PetBattles.GetNumAuras(thisOwner, active),
            CanSwap = C_PetBattles.CanActivePetSwapOut(),
            Health = C_PetBattles.GetHealth(thisOwner, active),
            Level = C_PetBattles.GetLevel(thisOwner, active),
            MaxHealth = C_PetBattles.GetMaxHealth(thisOwner, active),
            Percent = math.floor(C_PetBattles.GetHealth(thisOwner, active)/C_PetBattles.GetMaxHealth(thisOwner, active)*100),
            Quality = C_PetBattles.GetBreedQuality(thisOwner, active),
            Slot = active,
            Speed = C_PetBattles.GetSpeed(thisOwner, active),
            Type = C_PetBattles.GetPetType(thisOwner, active)
        }
        for i = 1, PetBattles[thisOwner].Active.Auras do
            PetBattles[thisOwner].Active.AllAuras[i] = C_PetBattles.GetAuraInfo(thisOwner, PetBattles[thisOwner].Active.Slot, i)
        end
        PetBattles[thisOwner].TeamAuras = C_PetBattles.GetNumAuras(thisOwner, 0)
        PetBattles[thisOwner].AllTeamAuras = {}
        for i = 1, PetBattles[thisOwner].TeamAuras do
            PetBattles[thisOwner].AllTeamAuras[i] = C_PetBattles.GetAuraInfo(thisOwner, 0, i)
        end
        for i = 1, PetBattles[thisOwner].Active.Auras do
            PetBattles[thisOwner].Active.AllAuras[i] = C_PetBattles.GetAuraInfo(thisOwner, PetBattles[thisOwner].Active.Slot, i)
        end
        if PetBattles.Abilities[PetBattles[1].Active.Abilities[1].ID] == nil then thisColor = "|cffFF0011" else thisColor = "|cff00AAFF" end
    end

    function PetBattles.RefreshPets(thisOwner)
        local average = 0
        PetBattles[thisOwner].Pet = {}
        for i = 1, 3 do
            PetBattles[thisOwner].Pet[i] = {
                Health = C_PetBattles.GetHealth(thisOwner, i),
                ID = C_PetBattles.GetDisplayID(thisOwner, i),
                Level = C_PetBattles.GetLevel(thisOwner, active),
                MaxHealth = C_PetBattles.GetMaxHealth(thisOwner, i),
                Percent = math.floor(C_PetBattles.GetHealth(thisOwner, i)/C_PetBattles.GetMaxHealth(thisOwner, i)*100),
                Quality = C_PetBattles.GetBreedQuality(thisOwner, i),
                --Owned = C_PetJournal.GetNumCollectedInfo(C_PetBattles.GetPetSpeciesID(4)),
                Quality = C_PetBattles.GetBreedQuality(thisOwner, i),
                Type = C_PetBattles.GetPetType(thisOwner, i)
            }
            average = average + PetBattles[thisOwner].Pet[i].Percent
        end
        PetBattles[thisOwner].AverageHealth = math.floor(average/3)
    end

    function PetBattles.CanTrap()
        return C_PetBattles.IsTrapAvailable()
    end

    function PetBattles.Weather()
        return C_PetBattles.GetAuraInfo(0, 0, 1)
    end

    -- Call to check ability vs enemy pet type.
    function PetBattles.AbilityStrenght(thisAbility)
        if TypeWeaknessTable[select(7,C_PetBattles.GetAbilityInfoByID(thisAbility))].Strong == NmePetType then
            return 3
        end
        if TypeWeaknessTable[select(7,C_PetBattles.GetAbilityInfoByID(thisAbility))].Weak == NmePetType then
            return 1
        end
        return 2
    end


    -- IsImmune(thisOwner) - Bool
    function PetBattles.IsImmune(thisOwner)
        for i = 1, #PetBattles[thisOwner].Active.AllAuras do
            if PetBattles.Abilities[PetBattles[thisOwner].Active.AllAuras[i]] == "immunity" then
                return true
            end
        end
        return false
    end

    function PetBattles.PouplatePetTable(MinLevel, MaxLevel, ThisQuality)
        PetBattles.Journal.PetTable = { }
        for i = 1, select(2,C_PetJournal.GetNumPets()) do
            petID, _, _, _, level, favorite, _, name, _, _, _, _, _, isWild, canBattle, _, _, _ = C_PetJournal.GetPetInfoByIndex(i)
            if petID ~= nil then
                if isWild then WildConvert = 1 else WildConvert = 0 end
                if favorite then FavoriteConvert = 1 else FavoriteConvert = 0 end
                if canBattle and level >= MinLevel and level <= MaxLevel and PetBattles.Journal.HealthGUID(petID) >= 70
                  and select(5, C_PetJournal.GetPetStats(select (1,C_PetJournal.GetPetInfoByIndex(i)))) >= ThisQuality then
                    table.insert(PetBattles.Journal.PetTable,{
                        ID = petID,
                        Level = level,
                        Favorite = FavoriteConvert,
                        Name = name,
                        Wild = WildConvert
                    })
                    -- print("Inserted "..petID.." "..level.." "..FavoriteConvert.." "..WildConvert)
                end
            end
        end
    end

    -- Disable all filters in Pet Journal --
    function PetBattles.PetSwapper()
        if module.IsOptionEnabled("Master Team") and not C_PetBattles.IsInBattle() and (PetBattles.Journal.PetLevel(1) ~= 25 or PetBattles.Journal.PetLevel(2) ~= 25 or PetBattles.Journal.PetLevel(3) ~= 25) then
            -- Populate table
            PetBattles.PouplatePetTable(1, 25, module.GetOptionValue("Master Team"))

            -- Level Sort
            for i = 1, #PetBattles.Journal.PetTable do
                for j = 2, #PetBattles.Journal.PetTable do
                    if i ~= j then
                        if PetBattles.Journal.PetTable[j].Level > PetBattles.Journal.PetTable[j-1].Level then
                            local TempPet = PetBattles.Journal.PetTable[j]
                            PetBattles.Journal.PetTable[j] = PetBattles.Journal.PetTable[j-1]
                            PetBattles.Journal.PetTable[j-1] = TempPet
                        end
                    end
                end
            end

            -- Favorite Sort
            for i = 1, #PetBattles.Journal.PetTable do
                for j = 2, #PetBattles.Journal.PetTable do
                    if PetBattles.Journal.PetTable[j].Favorite > PetBattles.Journal.PetTable[j-1].Favorite then
                        local TempPet = PetBattles.Journal.PetTable[j]
                        PetBattles.Journal.PetTable[j] = PetBattles.Journal.PetTable[j-1]
                        PetBattles.Journal.PetTable[j-1] = TempPet
                    end
                end
            end

            if #PetBattles.Journal.PetTable > 0 and (PetBattles.Journal.Health(1) <= 70 or PetBattles.Journal.PetLevel(1) ~= 25) then
                C_PetJournal.SetPetLoadOutInfo(1, PetBattles.Journal.PetTable[1].ID)
            end
            if #PetBattles.Journal.PetTable > 1 and (PetBattles.Journal.Health(2) <= 70 or PetBattles.Journal.PetLevel(2) ~= 25) then
                C_PetJournal.SetPetLoadOutInfo(2, PetBattles.Journal.PetTable[2].ID)
            end
            if #PetBattles.Journal.PetTable > 2 and (PetBattles.Journal.Health(3) <= 70 or PetBattles.Journal.PetLevel(3) ~= 25) then
                C_PetJournal.SetPetLoadOutInfo(3, PetBattles.Journal.PetTable[3].ID)
            end
        end

        if not module.IsOptionEnabled("Master Team") and module.IsOptionEnabled("Change and Level Pets") and not C_PetBattles.IsInBattle() then
            -- Pet Leveling Slot 1
            if PetBattles.Journal.PetLevel(1) ~= nil and (PetBattles.Journal.PetLevel(1) >= 25 or PetBattles.Journal.Health(1) < module.GetOptionValue("Revive Battle Pets") or PetBattles.Journal.PetLevel(2) ~= 25 or PetBattles.Journal.PetLevel(3) ~= 25 or PetBattles.Journal.Health(2) < 40 or PetBattles.Journal.Health(3) < 40) then
                -- Populate table
                PetBattles.PouplatePetTable(module.GetOptionValue("Minimum Level"), module.GetOptionValue("Maximum Level"), module.GetOptionValue("Change and Level Pets"))

                -- Level Sort
                for i = 1, #PetBattles.Journal.PetTable do
                    for j = 2, #PetBattles.Journal.PetTable do
                        if i ~= j then
                            if (not module.IsOptionEnabled("Level Highest Pets") and PetBattles.Journal.PetTable[j].Level < PetBattles.Journal.PetTable[j-1].Level) or (module.IsOptionEnabled("Level Highest Pets") and PetBattles.Journal.PetTable[j].Level > PetBattles.Journal.PetTable[j-1].Level) then
                                local TempPet = PetBattles.Journal.PetTable[j]
                                PetBattles.Journal.PetTable[j] = PetBattles.Journal.PetTable[j-1]
                                PetBattles.Journal.PetTable[j-1] = TempPet
                            end
                        end
                    end
                end

                -- Wild Sort
                for i = 1, #PetBattles.Journal.PetTable do
                    for j = 2, #PetBattles.Journal.PetTable do
                        if i ~= j then
                            if (not module.IsOptionEnabled("Level Wild Pets") and PetBattles.Journal.PetTable[j].Wild < PetBattles.Journal.PetTable[j-1].Wild) or (module.IsOptionEnabled("Level Wild Pets") and PetBattles.Journal.PetTable[j].Wild > PetBattles.Journal.PetTable[j-1].Wild) then
                                local TempPet = PetBattles.Journal.PetTable[j]
                                PetBattles.Journal.PetTable[j] = PetBattles.Journal.PetTable[j-1]
                                PetBattles.Journal.PetTable[j-1] = TempPet
                            end
                        end
                    end
                end

                -- Favorite Sort
                for i = 1, #PetBattles.Journal.PetTable do
                    for j = 2, #PetBattles.Journal.PetTable do
                        if PetBattles.Journal.PetTable[j].Favorite > PetBattles.Journal.PetTable[j-1].Favorite then
                            local TempPet = PetBattles.Journal.PetTable[j]
                            PetBattles.Journal.PetTable[j] = PetBattles.Journal.PetTable[j-1]
                            PetBattles.Journal.PetTable[j-1] = TempPet
                        end
                    end
                end
                -- for i = 1, #PetBattles.Journal.PetTable do
                --     local ThisPet = PetBattles.Journal.PetTable[i]
                --     print(i .. ") Name:" .. ThisPet.Name .. " Favorite:" .. ThisPet.Favorite .. " Level:" .. ThisPet.Level .. " Wild:" .. ThisPet.Wild)
                -- end

                -- Change pet in slot 1
                if #PetBattles.Journal.PetTable > 0 then
                    C_PetJournal.SetPetLoadOutInfo(1, PetBattles.Journal.PetTable[1].ID)
                end

                -- Other pets check health and change them if under 70% hp or not level 25
                for i = 2, 3 do
                    if (PetBattles.Journal.Health(i) <= 70 or PetBattles.Journal.PetLevel(i) ~= 25) then
                        PetBattles.Journal.RingnersTable = { }
                        for j = 1, select(2,C_PetJournal.GetNumPets()) do
                            petID, _, _, _, level, favorite, _, _, _, _, _, _, _, isWild, canBattle, _, _, _ = C_PetJournal.GetPetInfoByIndex(j)
                            if petID ~= nil then
                                if isWild then WildConvert = 1 else WildConvert = 0 end
                                if favorite then FavoriteConvert = 1 else FavoriteConvert = 0 end
                                if canBattle
                                  and PetBattles.Journal.HealthGUID(petID) > 70
                                  and level >= 25
                                  and petID ~= C_PetJournal.GetPetLoadOutInfo(1)
                                  and petID ~= C_PetJournal.GetPetLoadOutInfo(2)
                                  and petID ~= C_PetJournal.GetPetLoadOutInfo(3)
                                  and select(5, C_PetJournal.GetPetStats(select (1,C_PetJournal.GetPetInfoByIndex(j)))) >= module.GetOptionValue("Change and Level Pets") then
                                    table.insert( PetBattles.Journal.RingnersTable,{
                                        ID = petID,
                                        Level = level,
                                        Favorite = FavoriteConvert,
                                        Wild = WildConvert,
                                    })
                                    -- print("Inserted Ringner "..petID.." "..level.." "..FavoriteConvert.." "..WildConvert)
                                end
                            end
                        end

                        -- Level Sort
                        for i = 1, #PetBattles.Journal.RingnersTable do
                            for j = 2, #PetBattles.Journal.PetTable do
                                if i ~= j then
                                    if PetBattles.Journal.PetTable[j].Level > PetBattles.Journal.PetTable[j-1].Level then
                                        local TempPet = PetBattles.Journal.PetTable[j]
                                        PetBattles.Journal.PetTable[j] = PetBattles.Journal.PetTable[j-1]
                                        PetBattles.Journal.PetTable[j-1] = TempPet
                                    end
                                end
                            end
                        end

                        -- Favorite Sort
                        for i = 1, #PetBattles.Journal.RingnersTable do
                            for j = 2, #PetBattles.Journal.PetTable do
                                if PetBattles.Journal.PetTable[j].Favorite > PetBattles.Journal.PetTable[j-1].Favorite then
                                    local TempPet = PetBattles.Journal.PetTable[j]
                                    PetBattles.Journal.PetTable[j] = PetBattles.Journal.PetTable[j-1]
                                    PetBattles.Journal.PetTable[j-1] = TempPet
                                end
                            end
                        end

                        -- Switch Pet
                        if #PetBattles.Journal.RingnersTable > 0 then
                            C_PetJournal.SetPetLoadOutInfo(i, PetBattles.Journal.RingnersTable[1].ID)
                        end
                    end
                end
            end
        end
    end

    ---------------------------------------------------------------------------------------------------
    ---------------------------------------------------------------------------------------------------
    --[[                                         General                                             ]]
    ---------------------------------------------------------------------------------------------------
    ---------------------------------------------------------------------------------------------------

    -- Engage battles
    function PetBattles.Battle()
        for i = 1,#PetBattles.Pets do
            RunMacroText("/target " .. PetBattles.Pets[i])
        end
    end

    -- Cast this Ability List. DmgCheck - 1 = Strong  2 = Normal  3 = Weak  4 = all
    -- we need to use ability with lowest Prio
    function PetBattles.Cast(thisType)
        if TurnReady then
            local BestAbility = 0
            local BestPrio = 4
            for i = 1, 3 do
                if PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID] and PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Type == thisType then
                    local ThisPrio = PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Prio or 4
                    if PetBattles[1].Active.Abilities[i].Ready and (BestPrio == 4 or (ThisPrio < BestPrio)) then
                        BestAbility = i
                        BestPrio = ThisPrio
                    end
                end
            end
            if BestAbility ~= 0 then
                C_PetBattles.UseAbility(BestAbility)
                PetBattles.LastAbility = thisType
                PetBattles.Status("Casting Ability #" .. BestAbility .. " (" .. thisType .. ")")
                TurnReady = false
                return
            end
        end
    end

    -- Cast Buff if not found on target
    function PetBattles.CastBuff(thisType)
        if TurnReady then
            for i = 1, 3 do
                local ThisAbility = PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID]
                if ThisAbility and ThisAbility.Type == thisType then
                    if PetBattles[1].Active.Abilities[i].Ready then
                        local ThisBuff
                        -- if we didnt list debuff id then we are going to look for ID - 1
                        if PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Buff == nil then
                            ThisBuff = PetBattles[1].Active.Abilities[i].ID - 1
                        else
                            ThisBuff = PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Buff
                        end
                        -- if Debuff not found then we aplly it
                        if not PetBattles.IsBuffed(1, ThisBuff) then
                            C_PetBattles.UseAbility(i)
                            PetBattles.Status("Casting Ability #" .. i .. " to apply Buff (" .. thisType .. ")")
                            TurnReady = false
                            return
                        end
                    end
                end
            end
        end
    end

    -- Cast Debuff if not found on target
    function PetBattles.CastDebuff(thisType)
        if TurnReady then
            for i = 1, 3 do
                -- if our ability is this type and is ready
                if PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID] and PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Type == thisType then
                    if PetBattles[1].Active.Abilities[i].Ready then
                        local thisDebuff
                        -- if we didnt list debuff id then we are going to look for ID - 1
                        if PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Debuff == nil then
                            thisDebuff = PetBattles[1].Active.Abilities[i].ID - 1
                        else
                            thisDebuff = PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Debuff
                        end
                        -- if Debuff not found then we aplly it
                        if not PetBattles.IsBuffed(2, thisDebuff) then
                            C_PetBattles.UseAbility(i)
                            PetBattles.Status("Casting Ability #" .. i .. " to apply Debuff (" .. thisType .. ")")
                            TurnReady = false
                            return
                        end
                    end
                end
            end
        end
    end

    -- Use non-listed abilities
    function PetBattles.Filler()
        if TurnReady then
            for i = 1, 3 do
                if PetBattles[1].Active.Abilities[i].Ready then
                    C_PetBattles.UseAbility(i)
                    PetBattles.Status("Using ability #" .. i .. " without conditions as nothing known was found")
                    TurnReady = false
                    return
                end
            end
            if not PetBattles[1].Active.Abilities[1].Ready and not PetBattles[1].Active.Abilities[2].Ready and not PetBattles[1].Active.Abilities[3].Ready then
                C_PetBattles.SkipTurn()
                if PetBattles[2].Active.Percent ~= 0 and PetBattles[2].Active.Percent ~= 100 and PetBattles.LastAbility ~= "3turnhighdmg" then
                    PetBattles.Status("Casted Pass as nothing could be casted")
                end
                TurnReady = false
                return
            end
        end
    end

    -- Heal the pets out of battle with the heal pets spell if the option is enabled and one pet is under threshold
    function PetBattles.HealPets()
        if module.IsOptionEnabled("Revive Battle Pets") and (PetBattles.Journal.Health(1) <= module.GetOptionValue("Revive Battle Pets") or PetBattles.Journal.Health(2) <= module.GetOptionValue("Revive Battle Pets") or PetBattles.Journal.Health(3) <= module.GetOptionValue("Revive Battle Pets")) and PetBattles:SpellCooldown(125439) == 0 then
            CastSpellByName(GetSpellInfo(125439),"player")
            return true
        else
            return false
        end
    end

    -- IsBuffed(ability, thisOwner, specific) - Test if Ability - 1 is in List. Can test additional IDs.
    function PetBattles.IsBuffed(thisOwner, ThisBuff)
        for i = 1, #PetBattles[thisOwner].Active.AllAuras do
            if PetBattles[thisOwner].Active.AllAuras[i] == ThisBuff then
                return true
            end
        end
        return false
    end

    function PetBattles.IsRooted()
        for i = 1, 1536 do
            if PetBattles.Abilities[i] then
                if PetBattles.Abilities[i].Type == "root" and PetBattles.IsBuffed(1, i) then
                    return true
                end
            end
        end
        return false
    end

    function PetBattles.IsTeamBuffed(thisOwner, ThisBuff)
        for i = 1, #PetBattles[thisOwner].AllTeamAuras do
            if PetBattles[thisOwner].AllTeamAuras[i] == ThisBuff then
                return true
            end
        end
        return false
    end

    -- pass turn if we are sleeping
    function PetBattles.Pass()
        if TurnReady then
            for i = 1, #PetBattles[1].Active.AllAuras do
                if PetBattles.Abilities[PetBattles[1].Active.AllAuras[i]] and PetBattles.Abilities[PetBattles[1].Active.AllAuras[i]].Type == "sleepdebuff" then
                    C_PetBattles.SkipTurn()
                    TurnReady = false
                    return
                end
            end
        end
    end

    -- This will bring pet in specified slot on battlefield
    --@ The pet slot we want to swap to front
    function PetBattles.Swap(thisPet, thisMessage)
        if TurnReady then
            C_PetBattles.ChangePet(thisPet)
            PetBattles.Status("Changing pet to pet #" .. thisPet .. " as " .. thisMessage)
            TurnReady = false
            return
        end
    end

    -- This module handles changing pets out of battle
    function PetBattles.Swapper(AllowSwap)
        if not PetBattles.IsRooted() and (AllowSwap or PetBattles[1].Active.Percent == 0) then
            if PetBattles[1].Active.Slot == 1 and PetBattles[1].Active.Level < 25 and module.IsOptionEnabled("Level Pet 1") then
                -- swap only if we hit once
                if PetBattles[2].Active.Percent < 100 then
                    if PetBattles[1].Pet[2].Percent > 0 then
                        PetBattles.Swap(2, "pet 1 is leveling")
                    elseif PetBattles[1].Pet[3].Percent > 0 then
                        PetBattles.Swap(3, "pet 1 is leveling")
                    end
                end
            end
            if PetBattles[1].Active.Percent == 0 or (module.IsOptionEnabled("Swap-Out Health") and PetBattles[1].Active.Percent <= module.GetOptionValue("Swap-Out Health")) then
                if PetBattles[1].Active.Slot == 1 and PetBattles[1].Pet[2].Percent > 0 then
                    PetBattles.Swap(2, "pet 1 is dieing")
                end
            end
            if PetBattles[1].Active.Percent == 0 or (module.IsOptionEnabled("Swap-Out Health") and PetBattles[1].Active.Percent <= module.GetOptionValue("Swap-Out Health")) then
                if PetBattles[1].Active.Slot == 2 then
                    if PetBattles[1].Pet[3].Percent > module.GetOptionValue("Swap-Out Health") then
                        PetBattles.Swap(3, "pet 2 is dieing")
                    elseif PetBattles[1].Pet[2].Percent == 0 and PetBattles[1].Pet[1].Percent > 0 then
                        PetBattles.Swap(1, "pet 2 and pet 3 are dead")
                    end
                end
                if PetBattles[1].Active.Slot == 3 then
                    if PetBattles[1].Pet[2].Percent > module.GetOptionValue("Swap-Out Health") then
                        PetBattles.Swap(2, "pet 3 is dieing")
                    elseif PetBattles[1].Pet[3].Percent == 0 and PetBattles[1].Pet[1].Percent > 0 then
                        PetBattles.Swap(1, "pet 2 and pet 3 are dead")
                    end
                end
            end
        end
    end

    -- Get the heal pets cooldown
    function PetBattles:SpellCooldown(SpellID)
        if GetSpellCooldown(SpellID) == 0 then
            return 0
        else
            local Start ,CD = GetSpellCooldown(SpellID)
            local MyCD = Start + CD - module.GetTime()
            return MyCD
        end
    end

    -- Health from journal
    function PetBattles.Journal.Health(thisPet)
        return C_PetJournal.GetPetLoadOutInfo(thisPet) and 100*(select(1,C_PetJournal.GetPetStats(C_PetJournal.GetPetLoadOutInfo(thisPet)))/select(2,C_PetJournal.GetPetStats(C_PetJournal.GetPetLoadOutInfo(thisPet)))) or 0
    end

    -- Health from journal by GUID
    function PetBattles.Journal.HealthGUID(PetGUID)
        return 100*(select(1,C_PetJournal.GetPetStats(PetGUID))/select(2,C_PetJournal.GetPetStats(PetGUID))) or 0
    end

    -- PetLevel
    function PetBattles.Journal.PetLevel(thisPet)
        return C_PetJournal.GetPetLoadOutInfo(thisPet) and select(3, C_PetJournal.GetPetInfoByPetID(C_PetJournal.GetPetLoadOutInfo(thisPet)))
    end

    function PetBattles.Status(thisStatus)
        if PetBattles.CurrentStatus ~= thisStatus then
            PetBattles.CurrentStatus = thisStatus
            module.Bug(thisStatus)
        end
    end
    ---------------------------------------------------------------------------------------------------
    ---------------------------------------------------------------------------------------------------
    --[[                                         Abilities                                           ]]
    ---------------------------------------------------------------------------------------------------
    ---------------------------------------------------------------------------------------------------





    -- AoE Attacks to be used only while there are 3 Enemies.
    function PetBattles.AoEPunch(isFiller)
        if PetBattles[2].Active.Slot == 1 or isFiller == "filler" then
            PetBattles.Cast("aoe")
        end
    end

    -- Apocalypse - 15turns - use only if 3 pets alive or enemy have lots of hp
    function PetBattles.Apocalypse()
        if PetBattles[2].Active.MaxHealth > 2000 or (PetBattles[2].Pet[1].Health > 50 and PetBattles[2].Pet[2].Health > 80 and PetBattles[2].Pet[2].Health > 80) then
            PetBattles.Cast("apocalypse")
        end
    end

    -- Basic Attacks.
    function PetBattles.Attack()
        PetBattles.Cast("attack")
    end

    function PetBattles.CantDie()
        for i = 1, 1536 do
            if PetBattles.Abilities[i] and PetBattles.Abilities[i].Type == "cantdie" and PetBattles.IsBuffed(2,PetBattles.Abilities[i]) then
                return true
            end
        end
        return false
    end

    -- Abilities that are stronger if the enemy have more health than us.
    function PetBattles.Comeback()
        if PetBattles[1].Active.Percent < PetBattles[2].Active.Percent and not PetBattles.IsImmune(2) then
            PetBattles.Cast("comeback")
        end
    end

    -- Damage Buffs that we want to cast on us.
    function PetBattles.DamageBuff()
        if not PetBattles.IsBuffed(1, 485) then
            PetBattles.Cast("dmgbuff")
        end
    end

    -- Focus Buff that we want to cast on us.
    function PetBattles.FocusBuff()
        if not PetBattles.IsBuffed(1, 425) then
            PetBattles.Cast("focusbuff")
        end
    end

    -- Buff on us
    function PetBattles.Buff()
        PetBattles.CastBuff("buff")
    end

    -- Consume allied dead corpse
    function PetBattles.Consume()
        if module.IsOptionEnabled("Direct Heal") then
            local DeadCorpses = 0
            for i = 1, 3 do
                if PetBattles[1].Pet[i].Percent == 0 then
                    DeadCorpses = DeadCorpses + 1
                end
            end
            if PetBattles.Consumed < DeadCorpses then
                if PetBattles[1].Active.Percent < module.GetOptionValue("Direct Heal") then
                    PetBattles.Consumed = PetBattles.Consumed + 1
                    PetBattles.Cast("consume")
                end
            end
        end
    end

    -- Deflect High damage attack
    function PetBattles.Deflect()
        -- if immunity buff and should deflect or todeflect buff
        for i = 1, 1536 do
            if PetBattles.Abilities[i] ~= nil and ((PetBattles.Abilities[i].Type == "todeflect" and PetBattles.IsBuffed(2, PetBattles.Abilities[i])) or (PetBattles.Abilities[i].Type == "immunity" and PetBattles.IsBuffed(2, PetBattles.Abilities[i]) and PetBattles.Abilities[i].Deflect == true)) then
                PetBattles.Cast("deflect")
            end
        end
    end

    -- Three turn heavy attacks
    function PetBattles.DelayedHeavy()
        PetBattles.Cast("delayedheavy")
    end

    -- Debuffs on the enemy pets
    function PetBattles.Debuff()
        PetBattles.CastDebuff("debuff")
    end
    function PetBattles.DmgDebuff()
        PetBattles.CastDebuff("dmgdebuff")
    end

    -- Direct Healing
    function PetBattles.HealingDelayed()
        if module.IsOptionEnabled("Delayed Heal") then
            if PetBattles[1].Active.Percent < module.GetOptionValue("Delayed Heal") then
                for i = 1, 3 do
                    if PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID] and PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Type == "delayedheal" then
                        if PetBattles[1].Active.Abilities[i].Ready and PetBattles[1].Active.Percent > 40 then
                            C_PetBattles.UseAbility(i)
                            TurnReady = false
                            return
                        end
                    end
                end
            end
        end
    end

    -- Heal Over Time
    function PetBattles.HealOverTime()
        if TurnReady then
            if module.IsOptionEnabled("Heal Over Time") and PetBattles[1].Active.Percent < module.GetOptionValue("Heal Over Time") then
                for i = 1, 3 do
                    if PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID] and PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Type == "hotbuff" then
                        if PetBattles[1].Active.Abilities[i].Ready and not PetBattles.IsBuffed(1, PetBattles[1].Active.Abilities[i].ID) and not (PetBattles[1].Active.Abilities[i].Buff and PetBattles.IsBuffed(1, PetBattles[1].Active.Abilities[i].Buff)) then
                            C_PetBattles.UseAbility(i)
                            TurnReady = false
                            return
                        end
                    end
                end
            end
        end
    end

    -- Heal Team over time
    function PetBattles.HealTeamOverTime()
        if TurnReady then
            if module.IsOptionEnabled("Heal Over Time") and PetBattles[1].Active.Percent < module.GetOptionValue("Heal Over Time") then
                for i = 1, 3 do
                    if PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID] and PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Type == "hotteam" then
                        if PetBattles[1].Active.Abilities[i].Ready and not PetBattles.IsTeamBuffed(1, PetBattles[1].Active.Abilities[i].ID) and not (PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Buff and PetBattles.IsTeamBuffed(1, PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Buff)) then
                            C_PetBattles.UseAbility(i)
                            TurnReady = false
                            return
                        end
                    end
                end
            end
        end
    end

    -- Direct Healing
    function PetBattles.Healing()
        if module.IsOptionEnabled("Direct Heal") then
            if PetBattles[1].Active.Percent < module.GetOptionValue("Direct Heal") then
                PetBattles.Cast("heal")
            end
        end
    end

    -- Direct Healing on Team
    function PetBattles.HealTeam()
        if module.IsOptionEnabled("Direct Heal") then
            -- calculate missing health of the team
            local LifeDeficit = 0
            for i = 1, 3 do
                LifeDeficit = LifeDeficit + (100-PetBattles[1].Pet[i].Percent)
            end
            if PetBattles[1].Active.Percent < module.GetOptionValue("Direct Heal") and LifeDeficit > 50 then
                PetBattles.Cast("healteam")
            end
        end
    end

    -- Heavy Attacks
    function PetBattles.HeavyAttack()
        PetBattles.Cast("highdmg")
    end

    -- If Buffed - Do this attack only if we have the enemy have specific buff
    function PetBattles.IfBuffed()
        if TurnReady then
            for i = 1, 3 do
                local ThisAbility = PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID]
                if ThisAbility and ThisAbility.Type == "ifbuffed" and PetBattles[1].Active.Abilities[i].Ready then
                    for j = 1, #ThisAbility.Debuffs do
                        if PetBattles.IsBuffed(2, ThisAbility.Debuffs[j]) then
                            C_PetBattles.UseAbility(i)
                            PetBattles.Status("Casting Ability #" .. i .. " (ifbuffed)")
                            TurnReady = false
                            return
                        end
                    end
                end
            end
        end
    end

    -- Kamikaze
    function PetBattles.Kamikaze()
        if PetBattles[1].Active.Percent < 35 then
            PetBattles.Cast("kamikaze")
        end
    end

    -- Leech
    function PetBattles.Leech()
        PetBattles.Cast("leech")
    end

    -- Life Swap
    function PetBattles.LifeSwap()
        if TurnReady then
            for i = 1, 3 do
                local ThisAbility = PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID]
                if ThisAbility and ThisAbility.Type == "lifeswap" and PetBattles[1].Active.Abilities[i].Ready then
                    if PetBattles[1].Active.Percent < PetBattles[2].Active.Percent-50 then
                        C_PetBattles.UseAbility(i)
                        PetBattles.Status("Casting Ability #" .. i .. " (lifeswap)")
                        TurnReady = false
                        return
                    end
                end
            end
        end
    end

    -- Roots
    function PetBattles.Roots()
        PetBattles.Cast("rootattack")
    end

    -- Sleep
    function PetBattles.Sleep()
        if not PetBattles.IsBuffed(2, 236) then
            local Sleeping = false
            for i = 1, 1536 do
                local ThisAbility = PetBattles.Abilities[i]
                if ThisAbility and ThisAbility.Type == "sleepdebuff" and PetBattles.IsBuffed(2,ThisAbility) then
                    Sleeping = true
                    break
                end
            end
            if not Sleeping then
                PetBattles.Cast("sleep")
            end
        end
    end

    -- Speed Buff
    function PetBattles.SpeedBuff()
        if PetBattles[2].Active.Percent >= 45 and PetBattles[1].Active.Speed < PetBattles[2].Active.Speed and PetBattles[1].Active.Speed > (3*PetBattles[2].Active.Speed/4) then
            PetBattles.CastBuff("speedbuff")
        end
    end

    -- Speed Debuff
    function PetBattles.SpeedDebuff()
        if PetBattles[2].Active.Percent >= 45 and PetBattles[1].Active.Speed < PetBattles[2].Active.Speed and PetBattles[1].Active.Speed > (3*PetBattles[2].Active.Speed/4) then
            PetBattles.CastDebuff("speeddebuff")
        end
    end

    function PetBattles.TeamDebuff()
        if TurnReady then
            for i = 1, 3 do
                if PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID] and PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Type == "teamdebuff" then
                    if PetBattles[1].Active.Abilities[i].Ready and not PetBattles.IsTeamBuffed(2, PetBattles[1].Active.Abilities[i].ID) and not (PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Buff and PetBattles.IsTeamBuffed(2, PetBattles.Abilities[PetBattles[1].Active.Abilities[i].ID].Buff)) then
                        C_PetBattles.UseAbility(i)
                        TurnReady = false
                        return
                    end
                end
            end
        end
    end

    -- Robot Turrets
    function PetBattles.Turrets()
        if PetBattles.Weather() ~= 454 and not (PetBattles[2].Active.Slot == 3 and PetBattles[2].Active.Percent <= 55) then
            PetBattles.Cast("turret")
        end
    end


    -- Three turn soft attacks
    function PetBattles.ThreeTurnSoft()
        PetBattles.Cast("3turn")
    end

    -- Three turn heavy attacks
    function PetBattles.ThreeTurnHeavy()
        PetBattles.Cast("3turnhighdmg")
    end

    function PetBattles.TwoTurns()
        PetBattles.Cast("2turn")
    end

    -- Attack that are stronger if we are quicker.
    function PetBattles.Quick(isFiller)
        if (PetBattles[1].Active.Speed > PetBattles[2].Active.Speed or isFiller == "filler") and not PetBattles.IsImmune(2) then
            PetBattles.Cast("quick")
        end
    end



    -- Debuff to cast on ennemy.
    function PetBattles.DeBuff()
        if PetBattles[2].Active.Percent >= 45 and not PetBattles.IsImmune() then
            local abilityList = PetBattles.Abilities.DeBuffList
            for i = 1, #abilityList do
                if not PetBattles.IsBuffed(abilityList[i], 2) then
                    PetBattles.Cast(abilityList[i])
                end
            end
            local abilityList = PetBattles.Abilities.SpecialDebuffsList
            for i = 1, #abilityList do
                if not PetBattles.IsBuffed(nil, 2, abilityList[i].Debuff) then
                    PetBattles.Cast(abilityList[i].Ability)
                end
            end
        end
    end

    -- HighDamageIfBuffed to cast on ennemy.
    function PetBattles.HighDamageIfBuffed()
        if not PetBattles.IsImmune() then
            local abilityList = PetBattles.Abilities.HighDamageIfBuffedList
            for i = 1, #abilityList do
                if PetBattles.IsBuffed(nil, 2, abilityList[i]) then
                    PetBattles.Cast(abilityList[i])
                end
            end
        end
    end

    -- Wait after everything was loaded before we can start pulsing
    local Frame = CreateFrame("FRAME")
    Frame:RegisterEvent("PET_BATTLE_PET_ROUND_PLAYBACK_COMPLETE")
    Frame:RegisterEvent("PET_BATTLE_OPENING_START")
    local function AddonsLoaded(timeStamp, event, addonName)
        if event == "PET_BATTLE_PET_ROUND_PLAYBACK_COMPLETE" or event == "PET_BATTLE_OPENING_START" then
            TurnReady = true
        end
    end
    Frame:SetScript("OnEvent", AddonsLoaded)
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --@ Define Morpher
    module.Morpher = module.GetSetting("Morpher");

    local function ModifyEquipment (Add, Slot, SlotName)
        local Slot = Slot;
        if Add then
            local Value = 1;
            local Difficulty = module.GetOptionValue("Tier Level");

            if Difficulty == "Heroic" then Value = 2 end;
            if Difficulty == "Mythic" then Value = 3 end;
            Value ="";

            local ValidateMorph = module.GetOptionValue(SlotName) ~= nil and module.GetOptionValue(SlotName).." "..Value or 0;
            if ValidateMorph ~= 0 then
                UnitSetItemDisplayID("player", Slot, ValidateMorph);
            end
            return;
        end

        local ValidateMorph = GetInventoryItemID("player", Slot) and select(1, GetInventoryItemID("player", Slot)) or 0;
        UnitSetItemDisplayID("player", Slot, ValidateMorph);
    end

    local function ModifyMount (Add)
        if Add then
            if module.GetOptionValue("Mount") ~= nil then
                UnitSetMountDisplayID("player", module.GetOptionValue("Mount"));
            end
            return;
        end
    end

    local function ModifyEnchant (Add)
        local Slot = Slot;
        if Add then
            if module.GetOptionValue("Main Hand Enchant") ~= nil then

            end

            if module.GetOptionValue("Off Hand Enchant") ~= nil then

            end
        return;
        end
    end

    local function ModifyRace (Add)
        local SelectedRace = module.GetOptionValue("Race");
        local PlayerRace = select(2, UnitRace("player"));
        local Race = 1;

        if Add and SelectedRace ~= "" then
            if SelectedRace == "Orc" then Race = 2;
            elseif SelectedRace == "Dwarf" then Race = 3;
            elseif SelectedRace == "Night Elf" then Race = 4;
            elseif SelectedRace == "Undead" then Race = 5;
            elseif SelectedRace == "Tauren" then Race = 6;
            elseif SelectedRace == "Gnome" then Race = 7;
            elseif SelectedRace == "Troll" then Race = 8;
            elseif SelectedRace == "Goblin" then Race = 9;
            elseif SelectedRace == "Blood Elf" then Race = 10;
            elseif SelectedRace == "Draenei" then Race = 11;
            elseif SelectedRace == "Worgen" then Race = 22;
            elseif SelectedRace == "Pandaren" then Race = 24;
            end
            return;
        end

        if PlayerRace == "Orc" then Race = 2;
        elseif PlayerRace == "Dwarf" then Race = 3;
        elseif PlayerRace == "Night Elf" then Race = 4;
        elseif PlayerRace == "Undead" then Race = 5;
        elseif PlayerRace == "Tauren" then Race = 6;
        elseif PlayerRace == "Gnome" then Race = 7;
        elseif PlayerRace == "Troll" then Race = 8;
        elseif PlayerRace == "Goblin" then Race = 9;
        elseif PlayerRace == "Blood Elf" then Race = 10;
        elseif PlayerRace == "Draenei" then Race = 11;
        elseif PlayerRace == "Worgen" then Race = 22;
        elseif PlayerRace == "Pandaren" then Race = 24;
        end
    end

    local GenderSwapped = false;
    local function ModifyGender (Add)

    end

    function AddMorph ()
        ModifyEquipment(true, 0, "Head");
        ModifyEquipment(true, 2, "Shoulders");
        ModifyEquipment(true, 14, "Back");
        ModifyEquipment(true, 4, "Chest");
        ModifyEquipment(true, 3, "Shirt");
        ModifyEquipment(true, 18, "Tabard");
        ModifyEquipment(true, 8, "Wrist");
        ModifyEquipment(true, 9, "Hands");
        ModifyEquipment(true, 5, "Waist");
        ModifyEquipment(true, 6, "Legs");
        ModifyEquipment(true, 7, "Feet");
        ModifyEquipment(true, 15, "Main Hand");
        ModifyEquipment(true, 16, "Off Hand");
        ModifyMount(true);
        UpdateUnitModel("player");
    end

    function RemoveMorph ()
        UnitReset("player");
        UpdateUnitModel("player");
    end

    local Morphed = nil;
    function module.UseMorpher ()
        if module.Morpher and not Morphed then
            AddMorph();
            Morphed = true;
        elseif not module.Morpher and Morphed == true then
            RemoveMorph();
            Morphed = false;
        end
        return module.Morpher;
    end

    function module.SetMorpher (Morpher)
        module.Morpher = Morpher;
        module.SetSetting("Morpher", Morpher);
    end

    function module.MorpherCmd ()
        local Morpher = not module.UseMorpher();
        module.SetMorpher(Morpher);
        module.StatusUpdate(Morpher and "Morpher has been |cFF40FF00enabled." or "Morpher has been |cFFFF0000disabled.");
        XRNOverlay(Morpher and "Morpher |cFF40FF00Enabled" or "Morpher |cFFFF0000Disabled");
    end

    function LoadMorpherSettings()
        module.Morpher = module.GetSetting("Morpher");
        local Morpher = module.AddPage("Morpher Settings");
        module.AddNewOption("Morpher Settings", "Model Morphing", 140, true, "", "Input a model ID");
        module.AddSection("Morpher Settings", "");
        module.AddSection("Morpher Settings", "|cFF01DF01Character Customization");

        module.AddNewOption("Morpher Settings", "Race", 130, true, {1, "", "Human", "Orc", "Dwarf", "Night Elf", "Undead", "Tauren", "Gnome", "Troll", "Goblin", "Blood Elf", "Draenei", "Worgen", "Pandaren"}, nil);
        module.AddNewOption("Morpher Settings", "Swap Gender", 130, true, {1, "false", "true"}, nil);
        module.AddNewOption("Morpher Settings", "Tier Level", 130, true, {3, "Normal", "Heroic", "Mythic"}, nil);
        module.AddSection("Morpher Settings", "");
        module.AddNewOption("Morpher Settings", "Head", 140, true, "", "Input an item ID");
        module.AddNewOption("Morpher Settings", "Shoulders", 140, true, "", "Input an item ID");
        module.AddNewOption("Morpher Settings", "Back", 140, true, "", "Input an item ID");
        module.AddNewOption("Morpher Settings", "Chest", 140, true, "", "Input an item ID");
        module.AddNewOption("Morpher Settings", "Shirt", 140, true, "", "Input an item ID");
        module.AddNewOption("Morpher Settings", "Tabard", 140, true, "", "Input an item ID");
        module.AddNewOption("Morpher Settings", "Wrist", 140, true, "", "Input an item ID");
        module.AddNewOption("Morpher Settings", "Hands", 140, true, "", "Input an item ID");
        module.AddNewOption("Morpher Settings", "Waist", 140, true, "", "Input an item ID");
        module.AddNewOption("Morpher Settings", "Legs", 140, true, "", "Input an item ID");
        module.AddNewOption("Morpher Settings", "Feet", 140, true, "", "Input an item ID");
        module.AddNewOption("Morpher Settings", "Main Hand", 140, true, "", "Input an item ID");
        module.AddNewOption("Morpher Settings", "Off Hand", 140, true, "", "Input an item ID");
        module.AddNewOption("Morpher Settings", "Main Hand Enchant", 140, true, "", "Input a display ID");
        module.AddNewOption("Morpher Settings", "Off Hand Enchant", 140, true, "", "Input a display ID");
        module.AddSection("Morpher Settings", "");
        module.AddNewOption("Morpher Settings", "Mount", 140, true, "", "Input a display ID");

        if select(2,UnitClass("player")) == "DRUID" then
            module.AddPage("Druid Morpher Settings");
            module.AddSection("Druid Morpher Settings", "|cFF01DF01Druid Forms");
            module.AddNewOption("Druid Morpher Settings", "Cat Form", 140, true, "", "Input a Display ID");
            module.AddNewOption("Druid Morpher Settings", "Bear Form", 140, true, "", "Input a Display ID");
            module.AddNewOption("Druid Morpher Settings", "Aquatic Form", 140, true, "", "Input a Display ID");
            module.AddNewOption("Druid Morpher Settings", "Flight Form", 140, true, "", "Input a Display ID");
            module.AddNewOption("Druid Morpher Settings", "Moonkin Form", 140, true, "", "Input a Display ID");
            module.AddNewOption("Druid Morpher Settings", "Travel Form", 140, true, "", "Input a Display ID");
            module.AddNewOption("Druid Morpher Settings", "Tree of Life Form", 140, true, "", "Input a Display ID");
        end
    end
    local Class = "";
    local events = CreateFrame("Frame")
    events:SetScript("OnEvent", function(self, event, ...) return self[event](self, ...) end)

    function events:UPDATE_SHAPESHIFT_FORM()
        if not module.Morpher then return; end

        local form = GetShapeshiftForm();

        if Class == "DEATHKNIGHT" then
        elseif Class == "DRUID" then
            form = GetShapeshiftFormID();
            if form == 1 and module.GetOptionValue("Cat Form") ~= "" then --Cat Form
              UnitSetDisplayID("player", module.GetOptionValue("Cat Form"));
            elseif form == 5 and module.GetOptionValue("Bear Form") ~= "" then --Bear Form
              UnitSetDisplayID("player", module.GetOptionValue("Bear Form"));
            elseif form == 4 and module.GetOptionValue("Aquatic Form") ~= "" then --Aquatic Form
              UnitSetDisplayID("player", module.GetOptionValue("Aquatic Form"));
            elseif (form == 29 or form == 27) and module.GetOptionValue("Flight Form") ~= "" then --Flight Form
              UnitSetDisplayID("player", module.GetOptionValue("Flight Form"));
            elseif form == 31 and module.GetOptionValue("Moonkin Form") ~= "" then --Moonkin Form
              UnitSetDisplayID("player", module.GetOptionValue("Moonkin Form"));
            elseif form == 3 and module.GetOptionValue("Travel Form") ~= "" then --Travel Form
              UnitSetDisplayID("player", module.GetOptionValue("Travel Form"));
            elseif form == 2 and module.GetOptionValue("Tree of Life Form") ~= "" then --Tree of Life Form
              UnitSetDisplayID("player", module.GetOptionValue("Tree of Life Form"));
            end
        elseif Class == "PRIEST" then
        elseif Class == "ROGUE" then
        elseif Class == "SHAMAN" then
        elseif Class == "WARRIOR" then
        end
    end

    if select(2,UnitClass("player")) == "DRUID" or select(2,UnitClass("player")) == "WARRIOR" then
        Class = select(2,UnitClass("player"));
        --events:RegisterEvent("UPDATE_SHAPESHIFT_FORM");
    end

    UnitInfo = {};

    local function GetUnitInfo (GUID)
        local Info = UnitInfo[GUID];
        if not Info then
            Info = { Items = {}, OriginalItems = {} };
            UnitInfo[GUID] = Info;
        end

        return Info;
    end

    local UnitSetDisplayID_Original = UnitSetDisplayID;
    function UnitSetDisplayID (Unit, DisplayID)
        local Info = GetUnitInfo(UnitGUID(Unit));
        if Info then
            if not Info.OriginalDisplayID then
                Info.OriginalDisplayID = UnitDisplayID(Unit);
            end

            if not Info.OriginalNativeDisplayID then
                Info.OriginalNativeDisplayID = UnitNativeDisplayID(Unit);
            end

            Info.DisplayID = DisplayID;
            Info.NativeDisplayID = DisplayID;
            UnitSetDisplayID_Original(Unit, DisplayID);
        end
    end

    local UnitSetMountDisplayID_Original = UnitSetMountDisplayID;
    function UnitSetMountDisplayID (Unit, DisplayID)
        local Info = GetUnitInfo(UnitGUID(Unit));
        if Info then
            Info.MountDisplayID = DisplayID;

            if UnitMountDisplayID(Unit) ~= 0 then
                UnitSetMountDisplayID_Original(Unit, DisplayID);
            end
        end
    end

    local UnitSetItemDisplayID_Original = UnitSetItemDisplayID;
    function UnitSetItemDisplayID (Unit, Item, DisplayID)
        local Info = GetUnitInfo(UnitGUID(Unit));
        if Info then
            if not Info.OriginalItems[Item] then
                Info.OriginalItems[Item] = UnitItemDisplayID(Unit, Item);
            end

            Info.Items[Item] = DisplayID;
            UnitSetItemDisplayID_Original(Unit, Item, DisplayID);
        end
    end

    function UnitReset (Unit)
        local GUID = UnitGUID(Unit);
        local Info = GetUnitInfo(GUID);
        if Info then
            if Info.OriginalDisplayID and UnitDisplayID(GUID) ~= Info.OriginalDisplayID then
                UnitSetDisplayID_Original(GUID, Info.OriginalDisplayID);
            end

            if Info.OriginalNativeDisplayID and UnitNativeDisplayID(GUID) ~= Info.OriginalNativeDisplayID then
                UnitSetNativeDisplayID(GUID, Info.OriginalNativeDisplayID);
            end

            for Item, DisplayID in pairs(Info.OriginalItems) do
                if UnitSetItemDisplayID_Original(GUID, Item) ~= DisplayID then
                    UnitSetItemDisplayID(GUID, Item, DisplayID);
                end
            end
        end

        UnitInfo[GUID] = nil;
    end

    --[[ Commented as not used currently.
    CreateFrame("Frame"):SetScript("OnUpdate",
        function ()
            for GUID, Info in pairs(UnitInfo) do
                if UnitExists(GUID) then
                    if Info.DisplayID and UnitDisplayID(GUID) ~= Info.DisplayID then
                        UnitSetDisplayID_Original(GUID, Info.DisplayID);
                    end

                    if Info.NativeDisplayID and UnitNativeDisplayID(GUID) ~= Info.NativeDisplayID then
                        UnitSetNativeDisplayID(GUID, Info.NativeDisplayID);
                    end

                    local Mount = UnitMountDisplayID(GUID);
                    if Info.MountDisplayID and Mount ~= 0 and Mount ~= Info.MountDisplayID then
                        UnitSetMountDisplayID_Original(GUID, Info.MountDisplayID);
                    end

                    for Item, DisplayID in pairs(Info.Items) do
                        if UnitItemDisplayID(GUID, Item) ~= DisplayID then
                            UnitSetItemDisplayID(GUID, Item, DisplayID);
                        end
                    end
                else
                    UnitInfo[GUID] = nil;
                end
            end
        end
    );]]
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Defines the events reader.
    -- TODO : Add this efficiently based on current map in Combat Log
        -- Archimonde Phase 3
        --if module.EncounterDifficulty == 16 and (SpellID == 190118 or SpellID == 190310) then module.EncounterPhase = 3; end
    -- TODO : Add Register/Unregister based on Spec dynamically and not on Class OnLoad

    ---- TOREDO PROPERLY ----
    -- Boss Interrupt Spells List
    local ShouldStopCasting = {
        -- [145405] = "Large Illusionary Flamecaller - Invoke Lava - Tester",
        -- [147600] = "Large Illusionary Flamecaller - Pyroblast - Tester",
        [143343] = "Thok the Bloodthirsty - Deafening Screech", -- Siege Of Ogrimmar
        [158102] = "Pol - Interrupting Shout", -- Highmaul
        [160838] = "Franzok - Disrupting Roar", -- Blackrock Foundry
        [161087] = "Borka the Brute - Slam", -- Grimrail Depot
        [209748] = "Kra'liss - Deafening Roar" -- Restoration Shaman - Artifact Quest
    };
    -- Boss Interrupt Frame
    local BossInterruptFrame = CreateFrame("Frame");
    local function BossInterruptFunction (self)
        if module.StopCastingBefore ~= nil and module.GetTime() > module.StopCastingBefore then
            module.Bug("|cffFFDD11Stop Casting|r completed.");
            module.StopCastingBefore, module.StopCastingUnit, module.StopCastingSpells = nil, nil, nil;
        end
        if module.StopCastingBefore ~= nil and UnitCastingInfo("Player") ~= nil then
            if select(6, UnitCastingInfo("player"))/1000 > module.StopCastingBefore - 0.1 then
                module.Bug("|cffFFDD11Stop Casting|r cast Interrupted.");
                SpellStopCasting();
                module.StopCastingSpells = true;
            end
        end
    end
    BossInterruptFrame:SetScript("OnUpdate", BossInterruptFunction);
    ---- End TOREDO PROPERLY ----

    -- Return Synchronized GetTime based on Events Time
    local SyncTime;
    local function GetSyncTime (EventTime)
        SyncTime = SyncTime or EventTime - GetTime();
        return EventTime - SyncTime;
    end

    --- Combat Log Arguments


        ------- Base -------
            --     1        2        3            4           5           6               7           8         9         10           11
            -- TimeStamp, Event, HideCaster, SourceGUID, SourceName, SourceFlags, SourceRaidFlags, DestGUID, DestName, DestFlags, DestRaidFlags


        ------- Prefixes -------

            --- SWING
            -- N/A

            --- SPELL & SPELL_PERIODIC
            --    12        13         14
            -- SpellID, SpellName, SpellSchool


        ------- Suffixes -------

            --- _CAST_START & _CAST_SUCCESS & _SUMMON & _RESURRECT
            -- N/A

            --- _CAST_FAILED
            --     15
            -- FailedType

            --- _AURA_APPLIED & _AURA_REMOVED & _AURA_REFRESH
            --    15
            -- AuraType

            --- _AURA_APPLIED_DOSE
            --    15        16
            -- AuraType, Charges

            --- _INTERRUPT
            --      15            16              17
            -- ExtraSpellID, ExtraSpellName, ExtraSchool

            --- _HEAL
            --   15        16          17        18
            -- Amount, Overhealing, Absorbed, Critical

            --- _DAMAGE
            --   15       16       17       18       19        20        21        22        23
            -- Amount, Overkill, School, Resisted, Blocked, Absorbed, Critical, Glancing, Crushing

            --- _MISSED
            --    15        16           17
            -- MissType, IsOffHand, AmountMissed


        ------- Special -------

            --- UNIT_DIED, UNIT_DESTROYED
            -- N/A

    --- End Combat Log Arguments



    -- Arguments Variables
    local Event, SourceGUID, DestGUID, DestName, SpellID, Charges;
    local CurrentTime;
    -- WasLastCast locals
    local SavedTargetGUID2, PreviousSpellCast, CurrentSpellCast;
    -- ActionLog Icon Variables
    local SpellInfoName, SpellInfoIcon;
    -- Resurrection Informations
    module.ResurrectedUnits = {};
    module.CenteredSpellList = {};
    -- Shaman
    module.SearingTotem = { LastSummon = 0 };

    --- Common Combat Events
    -- SPELL_CAST_START
    module:RegisterForCombatEvent(
        function (...)
            SourceGUID, _, _, _, _, _, _, _, SpellID = select(4, ...);
            CurrentTime = GetSyncTime(...);

            -- Boss Interrupt
            if ShouldStopCasting[SpellID] ~= nil and module.UnitsInfos[SourceGUID] and module.UnitsInfos[SourceGUID].CanAttack == true then
                module.Bug("|cffFFDD11Stop Casting|r for " .. ShouldStopCasting[SpellID]);
                module.StopCastingSpells = true;
                module.StopCastingBefore = CurrentTime + (select(4,GetSpellInfo(SpellID))/1000);
                module.StopCastingUnit = SourceGUID;
            end
        end
        ,"SPELL_CAST_START"
    );
    module:RegisterForSelfCombatEvent(
        function (...)
            DestGUID, _, _, _, SpellID = select(8, ...);
            CurrentTime = GetSyncTime(...);

            module.CastingOnUnit = DestGUID;

            -- WasLastCast Handling
            -- keep the currently beign casted spell id and target to reuse it with WasLastCast
            if SavedTargetGUID2 then
                -- make sure we do not reuse the values, take and trash
                local CurrentTargetGUID = SavedTargetGUID2;
                SavedTargetGUID2 = nil;
                CurrentSpellCast = {
                    ["Id"] = SpellID,
                    ["StartTime"] = CurrentTime,
                    ["UnitGUID"] = CurrentTargetGUID
                };
                --module.Bug("|cffFFDD11Started " .. CurrentSpellCast.Id .. " on " .. CurrentSpellCast.UnitGUID .. " at " .. CurrentTime)
            end

            -- Improved Spell Casting Logic
            if module.ISCL and module.ISCL[SpellID] then
                StartedSpell = SpellID;
                SpellStartCastingTime = CurrentTime;
                if not module.PauseRotation then
                    module.Bug("Spell Cast Started: |cFFFFFF00Rotation Paused");
                end
                module.PauseRotation = true;
            end

            -- Action Log
            if module.UseDebug() then
                SpellInfoName, _, SpellInfoIcon = GetSpellInfo(SpellID)
                module.actionLog.insert('Spell Cast Start', SpellInfoName, SpellInfoIcon)
            end
        end
        ,"SPELL_CAST_START"
    );
    -- SPELL_CAST_FAILED
    module:RegisterForCombatEvent(
        function (...)
            CurrentTime = GetSyncTime(...);

            -- Resurrection Informations
            if module.LastResurrectionTime and CurrentTime - 15 < module.LastResurrectionTime then
                module.ResurrectedUnits[module.LastResurrectionTarget] = CurrentTime + 65;
            end

            -- Ground Cast Fail
            if module.CenteredSpellList[select(12, ...)] then
                module.CenteredSpellFailed = CurrentTime + 2;
            end

            -- Failed
            if select(4, ...) == module.StopCastingUnit then
                module.Bug("|cffFFDD11Stop Casting|r cancelled (Failed)");
                module.StopCastingBefore, module.StopCastingUnit, module.StopCastingSpells = nil, nil, nil;
            end
        end
        ,"SPELL_CAST_FAILED"
    );
    module:RegisterForSelfCombatEvent(
        function (...)
            -- Improved Spell Casting Logic
            if module.ISCL and module.ISCL[select(12, ...)] then
                if module.PauseRotation then
                    module.Bug("Spell Cast Failed: |cFFFF0000Rotation Resumed");
                end
                module.PauseRotation = false;
            end
        end
        ,"SPELL_CAST_FAILED"
    );
    -- SPELL_CAST_SUCCESS
    module:RegisterForSelfCombatEvent(
        function (...)
            DestGUID, _, _, _, SpellID = select(8, ...);

            module.LastCastedUnit = DestGUID;

            -- WasLastCast Handling
            if CurrentSpellCast then
                PreviousSpellCast = CurrentSpellCast;
                CurrentSpellCast = nil;
                --module.Bug("Finished " .. PreviousSpellCast.Id .. " on " .. PreviousSpellCast.UnitGUID .. " at " .. CurrentTime)
            end

            -- Improved Spell Casting Logic
            if module.ISCL and module.ISCL[SpellID] then
                if module.PauseRotation then
                    module.Bug("Spell Casted Successfully: |cFF00FF00Rotation Resumed");
                end
                module.PauseRotation = false;
            end

            -- Action Log
            SpellInfoName, _, SpellInfoIcon = GetSpellInfo(SpellID)
            module.actionLog.insert('Spell Cast Success', SpellInfoName, SpellInfoIcon)
        end
        ,"SPELL_CAST_SUCCESS"
    );
    -- SPELL_INTERRUPT
    module:RegisterForCombatEvent(
        function (...)
            DestGUID = select(8, ...);
            -- Interrupted
            if DestGUID == module.StopCastingUnit then
                module.Bug("|cffFFDD11Stop Casting|r cancelled (Interrupted)");
                module.StopCastingBefore, module.StopCastingUnit, module.StopCastingSpells = nil, nil, nil;
            end
        end
        ,"SPELL_INTERRUPT"
    );
    -- SPELL_RESURRECT
    module:RegisterForCombatEvent(
        function (...)
            DestName = select(9, ...);
            CurrentTime = GetSyncTime(...);
            -- Resurrection Informations
            module.ResurrectedUnits[DestName] = CurrentTime + math.random(15, 35);
        end
        ,"SPELL_RESURRECT"
    );
    -- UNIT_DIED & UNIT_DESTROYED
    module:RegisterForCombatEvent(
        function (...)
            DestGUID = select(8, ...);
            -- Died
            if DestGUID == module.StopCastingUnit then
                module.Bug("|cffFFDD11Stop Casting|r cancelled (Unit Died)");
                module.StopCastingBefore, module.StopCastingUnit, module.StopCastingSpells = nil, nil, nil;
            end
        end
        ,"UNIT_DIED"
        ,"UNIT_DESTROYED"
    );


    -- 1 - Warrior
    if C.CLASSINDEX == 1 then
        -- All
        -- Arms
        -- Fury
        -- Protection
    end
    -- 2 - Paladin
    if C.CLASSINDEX == 2 then
        -- All
        -- Holy
        -- Protection
        -- Retribution
    end
    -- 3 - Hunter
    if C.CLASSINDEX == 3 then
        -- All
        module.PetDismissed = 0;
        module:RegisterForSelfCombatEvent(
            function (...)
                -- When we Dismiss Pet, define 5 seconds to wait before recasting
                if select(12, ...) == 2641 then
                    module.PetDismissed = CurrentTime + 5;
                end
            end
            ,"SPELL_CAST_SUCCESS"
        );
        -- Beastmaster
        module:RegisterForCombatEvent(
            function (...)
                -- Prevent reusing Kill Command when it fails
                if select(15, ...) == SPELL_FAILED_NOPATH then
                    module.KillFailTime = CurrentTime + 3;
                end
            end
            ,"SPELL_CAST_FAILED"
        );
        -- Marksmanship
        module.ShotCount = 0;
        module:RegisterForSelfCombatEvent(
            function (...)
                SpellID = select(12, ...);

                -- Steady Focus Handling
                if SpellID == 185358 or SpellID == 2643 then
                    module.ShotCount = module.ShotCount + 1;
                else
                    module.ShotCount = 0;
                end
            end
            ,"SPELL_CAST_SUCCESS"
        );
        -- Survival
    end
    -- 4 - Rogue
    if C.CLASSINDEX == 4 then
        -- All
        -- Assassination
        --- Exsanguinated Handler
        module.BleedTable = {
            Garrote = {};
            Rupture = {};
        }
        local BleedDuration, BleedExpires, BleedGUID;

        function module.Exsanguinated (Unit, SpellName)
            BleedGUID = Unit:GUID();
            if BleedGUID then
                if SpellName == "Garrote" then
                    if module.BleedTable.Garrote[GUID] then
                        return module.BleedTable.Garrote[GUID][3];
                    end
                elseif SpellName == "Rupture" then
                    if module.BleedTable.Rupture[GUID] then
                        return module.BleedTable.Rupture[GUID][3];
                    end
                end
            end
            return false;
        end
        -- Exsanguinate Cast
        module:RegisterForSelfCombatEvent(
            function (...)
                if Rupture then
                    DestGUID, _, _, _, SpellID = select(8, ...);

                    -- Exsanguinate
                    if SpellID == 200806 then
                        for Key, _ in pairs(module.BleedTable) do
                            for Key2, _ in pairs(module.BleedTable[Key]) do
                                if Key2 == DestGUID then
                                    -- Change the Exsanguinate info to true
                                    module.BleedTable[Key][Key2][3] = true;
                                end
                            end
                        end
                    end
                end
            end
            , "SPELL_CAST_SUCCESS"
        );
        -- Bleed Record
        local function GetBleedInfos (GUID, Spell)
            -- Debuff API is not used since we don't want cached informations.
            return select(6, UnitAura(GUID, ({GetSpellInfo(Spell)})[1], nil, "HARMFUL|PLAYER"));
        end
        module:RegisterForSelfCombatEvent(
            function (...)
                if Rupture then
                    DestGUID, _, _, _, SpellID = select(8, ...);

                    --- Record the Bleed Target and its Infos
                    -- Garrote
                    if SpellID == 703 then
                        BleedDuration, BleedExpires = GetBleedInfos(DestGUID, SpellID);
                        module.BleedTable.Garrote[DestGUID] = {BleedDuration, BleedExpires, false};
                    -- Rupture
                    elseif SpellID == 1943 then
                        BleedDuration, BleedExpires = GetBleedInfos(DestGUID, SpellID);
                        module.BleedTable.Rupture[DestGUID] = {BleedDuration, BleedExpires, false};
                    end
                end
            end
            , "SPELL_AURA_APPLIED"
            , "SPELL_AURA_REFRESH"
        );
        -- Bleed Remove
        module:RegisterForSelfCombatEvent(
            function (...)
                if Rupture then
                    DestGUID, _, _, _, SpellID = select(8, ...);

                    -- Removes the Unit from Garrote Table
                    if SpellID == 703 then
                        if module.BleedTable.Garrote[DestGUID] then
                            module.BleedTable.Garrote[DestGUID] = nil;
                        end
                    -- Removes the Unit from Rupture Table
                    elseif SpellID == 1943 then
                        if module.BleedTable.Rupture[DestGUID] then
                            module.BleedTable.Rupture[DestGUID] = nil;
                        end
                    end
                end
            end
            , "SPELL_AURA_REMOVED"
        );
        module:RegisterForCombatEvent(
            function (...)
                if Rupture then
                    DestGUID = select(8, ...);

                    -- Removes the Unit from Garrote Table
                    if module.BleedTable.Garrote[DestGUID] then
                        module.BleedTable.Garrote[DestGUID] = nil;
                    end
                    -- Removes the Unit from Rupture Table
                    if module.BleedTable.Rupture[DestGUID] then
                        module.BleedTable.Rupture[DestGUID] = nil;
                    end
                end
            end
            , "UNIT_DIED"
            , "UNIT_DESTROYED"
        );
        -- Outlaw
        -- Subtlety
    end
    -- 5 - Priest
    if C.CLASSINDEX == 5 then
        -- All
        -- Discipline
        -- Holy
        -- Shadow
    end
    -- 6 - Deathknight
    if C.CLASSINDEX == 6 then
        -- All
        -- Blood
        module:RegisterForCombatEvent( -- Events need to be confirmed --
            function (...)
                -- Dancing Rune Weapon Diseases (Blood Plague)
                if module.DancingRuneWeapon ~= nil and select(4, ...) == module.DancingWeapon and select(12, ...) == 55078 then
                    module.DancingWeaponBlood = true;
                end
            end
            , "SPELL_CAST_SUCCESS"
            , "SPELL_AURA_APPLIED"
            , "SPELL_AURA_REFRESH"
        );
        module:RegisterForCombatEvent(
            function (...)
                -- Dancing Rune Weapon Buff Faded
                if select(8, ...) == C.PLAYERGUID and select(12, ...) == 81256 then
                    module.Bug("Dancing Rune Weapon - Finished.")
                    module.DancingRuneWeapon = nil;
                    module.DancingWeaponBlood = nil;
                end
            end
            , "SPELL_AURA_REMOVED"
        );
        module:RegisterForSelfCombatEvent(
            function (...)
                -- Dancing Rune Weapon Summon
                if select(12, ...) == 49028 then
                    module.DancingRuneWeapon = DestGUID;
                end
            end
            , "SPELL_SUMMON"
        );
        module:RegisterForSelfCombatEvent(
            function (...)
                -- Dark Arbiter Summon
                if select(12, ...) == 207349 then
                    module.Arbiter = GetSyncTime(...) + 15;
                end
            end
            , "SPELL_SUMMON"
        );
        -- Frost
        -- Unholy
    end
    -- 7 - Shaman
    if C.CLASSINDEX == 7 then
        -- All
        -- Elemental
        -- Enhancement
        -- Restoration
    end
    -- 8 - Mage
    if C.CLASSINDEX == 8 then
        -- All
        -- Arcane
        -- Fire
        module:RegisterForSelfCombatEvent(
            function (...)
                SpellID = select(12, ...);

                -- Combustion triggered (T18)
                if SpellID == 11129 then
                    module.ShouldCombustion = nil;
                    module.ShouldCombustionTime = nil;
                end
                -- Meteor in flight
                if SpellID == 153561 then
                    module.MeteorLands = CurrentTime + 2.75;
                end
            end
            , "SPELL_CAST_SUCCESS"
        );
        -- Frost
        module.FrostboltCasted = 1;
        module:RegisterForSelfCombatEvent(
            function (...)
                SpellID = select(12, ...);

                --- Shatterlance management (T18 Class Trinket)
                -- Frost Bolt
                if SpellID == 116 then
                    module.FrostboltCasted = CurrentTime + module.Spell(116):CastTime();
                end
                -- Ice Lance
                if SpellID == 30455 then
                    module.FrostboltCasted = 0;
                end
            end
            , "SPELL_CAST_START"
        );
        module:RegisterForSelfCombatEvent(
            function (...)
                --- Shatterlance management (T18 Class Trinket)
                -- Frost Bolt cancelled
                if select(12, ...) == 116 then
                    module.FrostboltCasted = 0;
                end
            end
            , "SPELL_CAST_FAILED"
        );
        module.PetDismissed = 0;
        module:RegisterForEvent(
            function (...)
                module.PetDismissed = CurrentTime + 5;
            end
            ,"PET_DISMISS_START"
        );
        -- Water Jet
        module.WaterJetChanneling = 0;
        module:RegisterForCombatEvent(
            function (...)

                if select(12, ...) == 135029 and select(4, ...) == PlayerPet:GUID() then
                    module.Bug("Water Jet Started")
                    module.WaterJetChanneling = CurrentTime + 3.5;
                end
            end
            ,"SPELL_AURA_APPLIED"
        );
        module:RegisterForCombatEvent(
            function (...)

                if select(12, ...) == 135029 and select(4, ...) == PlayerPet:GUID() then
                    module.Bug("Water Jet Ended")
                    module.WaterJetChanneling = 0;
                end
            end
            ,"SPELL_AURA_REMOVED"
        );

    end
    -- 9 - Warlock
    if C.CLASSINDEX == 9 then
        -- All
        -- Affliction
        -- Demonology
        -- Demonology Warlock Pets Table
        local DreadstalkersCount, DreadstalkersIdentifier, DreadstalkersTime = 0, nil, 0;
        local TotalImps, ImpsCount, ImpsTable, ImpsTime, ImplosionReady = 0, 0, {}, 0, nil;
        module.TotalDreadStalkers, module.TotalImps = 0, 0;
        -- Demonology Dreadstalkers / Imps Tracker via Totems
        module:RegisterForEvent(
            function (totemIdentifier)
                -- Dreadstalkers
                if module.GetTime() - DreadstalkersTime < 1 then
                    DreadstalkersIdentifier = totemIdentifier;
                    module.TotalDreadStalkers = DreadstalkersCount;
                elseif totemIdentifier == DreadstalkersIdentifier then
                    DreadstalkersCount, DreadstalkersIdentifier = 0, 0;
                    module.TotalDreadStalkers = 0;
                end
                -- Imps
                if module.GetTime() - ImpsTime < 1 then
                    ImpsTable[totemIdentifier] = ImpsCount;
                    ImpsCount = 0;
                    local ImpsRecount = 0;
                    for key, value in pairs(ImpsTable) do
                        ImpsRecount = ImpsRecount + value;
                    end
                    module.TotalImps = ImpsRecount;
                    ImplosionReady = ImpsTime + 6
                elseif ImpsTable[totemIdentifier] ~= nil then
                    module.TotalImps = module.TotalImps - ImpsTable[totemIdentifier] >= 0 and module.TotalImps - ImpsTable[totemIdentifier] or 0;
                    ImpsTable[totemIdentifier] = nil;
                end
                if module.TotalImps == 0 then ImplosionReady = nil; end
                module.SetOutput("Dreadstalkers / Imps:", module.TotalDreadStalkers .. " / " .. module.TotalImps);
            end
            , "PLAYER_TOTEM_UPDATE"
        );
        module:RegisterForSelfCombatEvent(
            function (...)
                SpellID = select(12, ...);

                -- Felhunter Appear
                if SpellID == 196274 or SpellID == 196273 or SpellID == 193332 or SpellID == 193331 then
                    DreadstalkersCount = DreadstalkersCount + 1;
                    DreadstalkersTime = CurrentTime;
                end
                -- Imp Appear
                if SpellID == 104317 then
                    ImpsCount = ImpsCount + 1;
                    ImpsTime = CurrentTime;
                end
            end
            , "SPELL_SUMMON"
        );
        -- Destruction
    end
    -- 10 - Monk
    if C.CLASSINDEX == 10 then
        -- All
        -- Brewmaster
        module.BlackOxStatue = {};
        module:RegisterForSelfCombatEvent(
            function (...)
                DestGUID, DestName, _, _, SpellID = select(8, ...);
                CurrentTime = GetSyncTime(...);

                -- BlackOxStatue Handler
                if SpellID == 163177 then
                    module.BlackOxStatue.LastSummon = CurrentTime;
                    module.BlackOxStatue.UnitID = DestGUID;
                end
            end
            ,"SPELL_SUMMON"
        );
        -- Mistweaver
        module.JadeSerpentStatue = {};
        module:RegisterForSelfCombatEvent(
            function (...)
                DestGUID, DestName, _, _, SpellID = select(8, ...);
                CurrentTime = GetSyncTime(...);

                -- JadeSerpentStatue Handler
                if SpellID == 115313 then
                    module.JadeSerpentStatue.LastSummon = CurrentTime;
                    module.JadeSerpentStatue.UnitID = DestGUID;
                end
            end
            ,"SPELL_SUMMON"
        );
        -- Artifact Sheilun's Gift
        module.SheilunsCharges = 0;
        module:RegisterForSelfCombatEvent(
            function (...)
                Event, _, _, _, _, _, DestGUID, DestName, _, _, SpellID, _, _, _, Charges = select(2, ...);
                CurrentTime = GetSyncTime(...);

                -- JadeSerpentStatue Handler
                if SpellID == 214502 then
                    if Event == "SPELL_AURA_APPLIED" then
                        module.SheilunsCharges = 1;
                    elseif Event == "SPELL_AURA_APPLIED_DOSE" then
                        module.SheilunsCharges = Charges;
                    else
                        module.SheilunsCharges = 0;
                    end
                end
            end
            ,"SPELL_AURA_APPLIED"
            ,"SPELL_AURA_APPLIED_DOSE"
            ,"SPELL_AURA_REMOVED"
        );
        -- Windwalker
    end
    -- 11 - Druid
    if C.CLASSINDEX == 11 then
        -- All
        -- Balance
        -- Feral

        -- Feral Bleed Damage Calculator
        module.BleedTable = {
            Rake = {};
            Rip = {};
            Thrash = {};
            LastRakeDmg = 1;
            LastRakeTime = 0;
            LastRipDmg = 1;
            LastRipTime = 0;
            LastThrashDmg = 1;
            LastThrashTime = 0;
        }
        local DamageMultiplier, RakeMultiplier;
        function module.BleedDamage (SpellName)
            if S and S.BloodtalonsBuff then
                DamageMultiplier = 1;
                -- Tiger's Fury : 15% dmg
                if Player:Buff(S.TigersFury) then DamageMultiplier = DamageMultiplier * 1.15; end
                -- Savage Roar : 25% dmg
                if Player:Buff(S.SavageRoar) then DamageMultiplier = DamageMultiplier * 1.25; end
                -- Bloodtalons : 50% dmg
                if Player:Buff(S.BloodtalonsBuff) then DamageMultiplier = DamageMultiplier * 1.5; end
                -- Stealth : 100% dmg on Rake
                if Player:IsStealthed(true) then RakeMultiplier = 2; else RakeMultiplier = 1; end

                if SpellName == "Rake" then
                    return RakeMultiplier * DamageMultiplier;
                elseif SpellName == "Rip" then
                    return Player:ComboPoints() * DamageMultiplier;
                elseif SpellName == "Thrash" then
                    return DamageMultiplier;
                end
            else
                return 1;
            end
        end
        module:RegisterForSelfCombatEvent(
            function (...)
                SpellID = select(12, ...);

                --- Snapshot the Bleed Damage on Spell Cast
                -- Rake
                if SpellID == 1822 then
                    module.BleedTable.LastRakeDmg = module.BleedDamage("Rake");
                    module.BleedTable.LastRakeTime = module.GetTime() + 0.3;
                -- Rip
                elseif SpellID == 1079 then
                    module.BleedTable.LastRipDmg = module.BleedDamage("Rip");
                    module.BleedTable.LastRipTime = module.GetTime() + 0.3;
                -- Thrash
                elseif SpellID == 106830 then
                    module.BleedTable.LastThrashDmg = module.BleedDamage("Thrash");
                    module.BleedTable.LastThrashTime = module.GetTime() + 0.3;
                end
            end
            , "SPELL_CAST_SUCCESS"
        );
        module:RegisterForSelfCombatEvent(
            function (...)
                DestGUID, _, _, _, SpellID = select(8, ...);

                -- Record the Bleed Damage Snapshot if it is successfully applied on an unit
                if SpellID == 155722 then
                    module.BleedTable.Rake[DestGUID] = module.GetTime() < module.BleedTable.LastRakeTime and module.BleedTable.LastRakeDmg or module.BleedDamage("Rake");
                elseif SpellID == 1079 then
                    module.BleedTable.Rip[DestGUID] = module.GetTime() < module.BleedTable.LastRipTime and module.BleedTable.LastRipDmg or module.BleedDamage("Rip");
                elseif SpellID == 106830 then
                    module.BleedTable.Thrash[DestGUID] = module.GetTime() < module.BleedTable.LastThrashTime and module.BleedTable.LastThrashDmg or module.BleedDamage("Thrash");
                end
            end
            , "SPELL_AURA_APPLIED"
            , "SPELL_AURA_REFRESH"
        );
        module:RegisterForCombatEvent(
            function (...)
                DestGUID = select(8, ...);

                -- Removes the Unit from Rake Table
                if module.BleedTable.Rake[DestGUID] then
                    module.BleedTable.Rake[DestGUID] = nil;
                end
                -- Removes the Unit from Rip Table
                if module.BleedTable.Rip[DestGUID] then
                    module.BleedTable.Rip[DestGUID] = nil;
                end
                -- Removes the Unit from Thrash Table
                if module.BleedTable.Thrash[DestGUID] then
                    module.BleedTable.Thrash[DestGUID] = nil;
                end
            end
            , "UNIT_DIED"
            , "UNIT_DESTROYED"
        );
        -- Guardian
        -- Restoration
    end
    -- 12 - Demon Hunter
    if C.CLASSINDEX == 12 then
        -- All
        -- Havoc
        -- Vengeance
    end

    -- Tanks
    if C.CLASSINDEX == 1 or C.CLASSINDEX == 2 or C.CLASSINDEX == 6 or C.CLASSINDEX == 10 or C.CLASSINDEX == 11 or C.CLASSINDEX == 12 then
        -- /dump Engine.DamageTakenTable
        module.DamageTakenTable = {};
        local TotalAmount, LastCleanup, ThisKey = 0, module.GetTime() + 10, 1;
        local function CleanupDamageTakenTable ()
            if LastCleanup < module.GetTime() then
                local CleanedUpDamageTakenTable = {};
                for Key, Value in pairs(module.DamageTakenTable) do
                    if module.GetTime() - module.DamageTakenTable[Key][1] < 15 then
                        --module.Bug("Damage Taken - Keep - " .. module.DamageTakenTable[Key][2]);
                        CleanedUpDamageTakenTable[#CleanedUpDamageTakenTable + 1] = module.DamageTakenTable[Key];
                    else
                        --module.Bug("Damage Taken - Remove - " .. module.DamageTakenTable[Key][2]);
                    end
                end
                module.DamageTakenTable = CleanedUpDamageTakenTable;
                LastCleanup = module.GetTime() + 10;
            end
        end
        -- Tanks
        module:RegisterForCombatEvent(
            function (...)
                if select(8, ...) == C.PLAYERGUID then
                    CleanupDamageTakenTable();
                    -- If Swing Attack, dmg start at arg 12.
                    Amount, _, _, Resisted, Blocked, Absorbed = select(12, ...);
                    CurrentTime = GetSyncTime(...);
                    Resisted, Blocked, Absorbed = Resisted or 0, Blocked or 0, Absorbed or 0;
                    TotalAmount = Amount - Resisted - Blocked - Absorbed;
                    --module.Bug("Damage Taken - Swing - " .. TotalAmount);
                    module.DamageTakenTable[#module.DamageTakenTable + 1] = {CurrentTime, TotalAmount};
                end
            end
            , "SWING_DAMAGE"
        );
        module:RegisterForCombatEvent(
            function (...)
                if select(8, ...) == C.PLAYERGUID then
                    CleanupDamageTakenTable();
                    -- If Spells or Ranged Attack, dmg start at arg 15.
                    Amount, _, _, Resisted, Blocked, Absorbed = select(15, ...);
                    CurrentTime = GetSyncTime(...);
                    Resisted, Blocked, Absorbed = Resisted or 0, Blocked or 0, Absorbed or 0;
                    TotalAmount = Amount - Resisted - Blocked - Absorbed;
                    --module.Bug("Damage Taken - Spell - " .. TotalAmount);
                    module.DamageTakenTable[#module.DamageTakenTable + 1] = {CurrentTime, TotalAmount};
                end
            end
            , "SPELL_DAMAGE"
            , "SPELL_PERIODIC_DAMAGE"
            , "SPELL_BUILDING_DAMAGE"
            , "RANGE_DAMAGE"
        );
    end

    -- OnSpecGearTalentUpdate
    module:RegisterForEvent(
        function ()
            -- WoD
            module.HasT18_2Pc, module.HasT18_4Pc = Player:HasTier("T18");
            module.HasT18_ClassTrinket = Player:HasClassTrinket();
            -- Legion
            module.ArtifactScan();
            module.HasT19_2Pc, module.HasT19_4Pc = Player:HasTier("T19");
        end
        , "ZONE_CHANGED_NEW_AREA"
        , "PLAYER_TALENT_UPDATE"
        , "PLAYER_EQUIPMENT_CHANGED"
    );
end)();
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Unholy Deathknight
    local Rotation = {};
    module.SetRotation(252, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local Enemies_40y, TargetEnemies_8y, EpidemicUnitsCount, OutbreakCount, NumEnemies = {}, {}, 0, 0, 0;
    local IsDarkTransformationEnabled, ShouldArbiter;
    local MainTankResDelay, OffTankResDelay = nil, nil;
    local RuneCount, NextRune, RunicPower = 0, 0, 0;
    module.Arbiter = 0;

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        -- Items
        DraenicStrength = Item(109217, false, false, true);
        DraenicStrengthBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Racials
        ArcaneTorrent = Spell(50613, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59545, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Spells
        Apocalypse = Spell(220143, false, true, true);
        AntiMagicShell = Spell(48707, false, false, true);
        ArmyOfTheDead =Spell(42650, false, false, true);
        BlightedRuneWeapon = Spell(194918, false, false, true);
        ClawingShadows = Spell(207311, true, true, true);
        ControlUndead = Spell(111673, true, true, true);
        CorpseShield = Spell(207319, false, false, true);
        DarkArbiter = Spell(207349, true, true, true);
        DarkCommand = Spell(56222, true, true, true);
        DarkSuccor = Spell(178819);
        DarkSuccorBuff = Spell(101568);
        DarkTransformation = Spell(63560, false, false, true);
        DeathAndDecay = Spell(43265, false, true, true);
        DeathAndDecayBuff = Spell(188290);
        DeathCoil = Spell(47541, true, true, true);
        DeathStrike = Spell(49998, true, true, true);
        Defile = Spell(152280, false, true, true);
        Epidemic = Spell(207317, false, false, true);
        FesteringStrike = Spell(85948, true, true, true);
        FesteringWound = Spell(194310);
        IceboundFortitude = Spell(48792, false, false, true);
        InfectedClaws = Spell(207272);
        MindFreeze = Spell(47528, true, true, true);
        Necrosis = Spell(207346);
        NecrosisBuff = Spell(216974);
        Outbreak = Spell(77575, false, true, true);
        RaiseAlly = Spell(61999, false, false, true, true);
        RaiseDead = Spell(46584, false, false, true);
        ScourgeStrike = Spell(55090, true, true, true);
        ShadowInfusion = Spell(198943);
        SludgeBelcher = Spell(207313);
        SoulReaper = Spell(130736, true, true, true);
        SoulReaperBuff = Spell(215711);
        SuddenDoom = Spell(81340, true, true, true);
        SummonGargoyle = Spell(49206, false, true, true);
        UnholyStrength = Spell(53365);
        VirulentPlague = Spell(191587);
        WraithWalk = Spell(212552, false, false, true);

        -- Ghoul Spells
        Claw = Spell(47468, true, true, true);
        Huddle = Spell(47484, false, false, true)
        Gnaw = Spell(47481, true, true, true);
        -- Abomination Spell
        Cleaver = Spell(212333, true, true, true);
        ProtectiveBile = Spell(212384, false, false, true);
        Smash = Spell(212336, true, true, true)


        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range.\n\n|cffFF0044Mode (Left Box)|r\n|cFF0088FFKeep:|r Cast on the new unit but keep your target the same.\n|cFF0088FFSwitch:|r Cast on the new unit and change your target to this unit.\n\n|cffFF0044Range (Right Box)|r\nSet the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Mind Freeze to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddNewOption("General Settings", "Raise Ally", 210, true, nil, nil, "Use Raise Ally on dead target.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Wraith Walk", 210, false, nil, nil, "Automatically use Wraith Walk while moving and Out of Combat.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Apocalypse", 232, true, {1, "Always", "Cooldown Only"}, {6, 1, 8, 1}, "Use Apocalypse."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("We will always ramp up Festering Wound stacks to 8 prior to using Apocalypse."));
        module.AddNewOption("Offensive Settings", "Blighted Rune Weapon", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Blighted Rune Weapon."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("We will always ramp up Festering Wound stacks to 8 prior to using Apocalypse."));
        module.AddNewOption("Offensive Settings", "Dark Arbiter", 232, true, {2, "Always", "Cooldown Only"}, {80, 1, 100, 1}, "Use Dark Arbiter."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."How much Runic Power should we pool before using Dark Arbiter?");
        module.AddNewOption("Offensive Settings", "Gargoyle", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Gargoyle."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Only usable if Dark Arbiter is not talented."));
        module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Disabled", "Enabled"}, {2, "Disabled", "Enabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Death And Decay", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {2, 1, 10, 1}, "Use Death and Decay." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use."..C.TOOLTIP_HINT("Also used for Defile."));
        module.AddNewOption("Offensive Settings", "Epidemic", 222, true, {5, 1, 10, 1}, {3, 1, 10, 1}, "Use Epidemic."..C.TOOLTIP_VALUE_1.."Amount of enemies that must have Virulent Plague to use."..C.TOOLTIP_VALUE_2.."Amount of enemies that must have Virulent Plague to use as low priority.");
        module.AddNewOption("Offensive Settings", "Pet Damage Handling", 233, true, {1, "Handle Assist", "Do Not Handle Assist"}, {1, "Handle Spells", "Do Not Handle Spells"}, "Manage Pet Casts to use power as high priority only during Dark Transformation."..C.TOOLTIP_VALUE_1.."Enable this to automatically change between assist and passive mode depending if you have a target or not."..C.TOOLTIP_VALUE_2.."Enable this to automatically disable spells the profile should be handling so that they are handled by the rotation."..C.TOOLTIP_HINT("Spells handling applies to Ghoul Claw and Gnaw or Abomination Cleaver and Smash."));

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Death Strike", 222, true, {20, 1, 100, 1}, {70, 1, 100, 1}, "Use Death Strike."..C.TOOLTIP_VALUE_1.."Health threshold to use."..C.TOOLTIP_VALUE_2.."Health threshold to use with Dark Succor buff.");
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, true, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru on self."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Anti-Magic Shell", 220, false, {50, 1, 100, 1}, nil, "Use Anti-Magic Shell."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Corpse Shield", 232, false, {2, "Do Not Use Pet Shield", "Use Pet Shield"}, {25, 1, 100, 1}, "Use Corpse Shield."..C.TOOLTIP_VALUE_1.."Set to Use Pet Shield to allow using the Pet Shield ability (Ghoul Huddle or Abomination Protective Bile)."..C.TOOLTIP_VALUE_2.."Health threshold."..C.TOOLTIP_HINT("If first option is set to Use Pet Shield, the Pet will Shield itself whenever you use Corpse Shield. Even if used manually or if the option to use Corpse Shield is disabled. To prevent Pet from Shielding itself, you need to define it to Do Not Use Pet Shield."));
        module.AddNewOption("Defensive Settings", "Icebound Fortitude", 220, true, {20, 1, 100, 1}, nil, "Use Icebound Fortitude."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we wait to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        -- Anti-Magic Shell - Absorb 33% total health in magic damage - Generate runic power
        if AntiMagicShell:Exists() and module.IsOptionEnabled("Anti-Magic Shell") and Player:HealthPercentage() <= module.GetOptionValue("Anti-Magic Shell") and Player:CanCast(AntiMagicShell) then
            Player:Cast(AntiMagicShell);
        end
        -- Icebound Fortitude
        if IceboundFortitude:Exists() and module.IsOptionEnabled("Icebound Fortitude") and Player:HealthPercentage() <= module.GetOptionValue("Icebound Fortitude") and Player:CanCast(IceboundFortitude) then
            Player:Cast(IceboundFortitude);
        end
        -- Corpse Shield
        if CorpseShield:Exists() and module.IsOptionEnabled("Corpse Shield") and Player:HealthPercentage() <= module.GetSecondOptionValue("Corpse Shield") and Player:CanCast(CorpseShield) then
            Player:Cast(CorpseShield);
        end
        if CorpseShield:Exists() and module.GetOptionValue("Corpse Shield") == "Use Pet Shield" and PlayerPet:Power() > 10 and Player:Buff(CorpseShield) then
            if SludgeBelcher:Exists() and Player:PetCanCast(ProtectiveBile) and ProtectiveBile:TimeSinceCast() > 45 then
                Player:Cast(ProtectiveBile);
                ProtectiveBile.LastCastTime = module.GetTime();
            elseif Player:PetCanCast(Huddle) and Huddle:TimeSinceCast() > 45 then
                Player:Cast(Huddle);
                Huddle.LastCastTime = module.GetTime();
            end
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
        end
    end

    function Rotation:Interrupts ()
        -- Interrupts
        -- Mind Freeze
        Player:UseInterrupt(MindFreeze, ArcaneTorrent);
    end

    -- Handling of Pet Actionbar Abilities
    local PetActionName, IsPetActionActive, PetActionID, PetAssisting;
    local function PlayerPetHandling ()
        -- Player Pet Handling
        if module.IsOptionEnabled("Pet Damage Handling") then
            if PlayerPet:Exists() then
                if module.GetSecondOptionValue("Pet Damage Handling") == "Handle Spells" then
                    -- Disable Spells
                    for i = 1, 10 do
                        PetActionName, _, _, _, _, _, IsPetActionActive, PetActionID = GetPetActionInfo(i);
                        if PetActionID == 212333 or PetActionID == 212336 or PetActionID == 47468 or PetActionID == 47481 then
                            if IsPetActionActive then
                                module.Bug("Disabling "..PetActionName);
                                DisableSpellAutocast(PetActionName);
                            end
                        end
                    end
                end
                -- Assist/Passive Mode
                if module.GetOptionValue("Pet Damage Handling") == "Handle Assist" then
                    if Target:Exists() and not PetAssisting then
                        PetAssistMode();
                        PetAssisting = true;
                    elseif not Target:Exists() and PetAssisting then
                        PetPassiveMode();
                        PetAssisting = false;
                    end
                end
                IsDarkTransformationEnabled = DarkTransformation:Exists() and module.IsOptionEnabled("Dark Transformation") and (module.CooldownsAllowed() or module.GetOptionValue("Dark Transformation") == "Always") or false;
                if SludgeBelcher:Exists() then
                    -- Cleaver
                    if PlayerPet:Buff(DarkTransformation) and Target:PetCanCast(Cleaver) then
                        Target:Cast(Cleaver);
                    elseif (not IsDarkTransformationEnabled or DarkTransformation:Cooldown() > 10 or PlayerPet:Power() >= 80) and Target:PetCanCast(Cleaver) then
                        Target:Cast(Cleaver);
                    end
                    -- Smash
                    if PlayerPet:Buff(DarkTransformation) and Target:PetCanCast(Smash) then
                        Target:Cast(Smash);
                    elseif (not IsDarkTransformationEnabled or DarkTransformation:Cooldown() > 25) and Target:PetCanCast(Smash) then
                        Target:Cast(Smash);
                    end
                else
                    -- Claw
                    if PlayerPet:Buff(DarkTransformation) and Target:PetCanCast(Claw) then
                        Target:Cast(Claw);
                    elseif (not IsDarkTransformationEnabled or DarkTransformation:Cooldown() > 10 or PlayerPet:Power() >= 80) and Target:PetCanCast(Claw) then
                        Target:Cast(Claw);
                    end
                    -- Gnaw
                    if PlayerPet:Buff(DarkTransformation) and Target:PetCanCast(Gnaw) then
                        Target:Cast(Gnaw);
                    elseif (not IsDarkTransformationEnabled or DarkTransformation:Cooldown() > 25) and Target:PetCanCast(Gnaw) then
                        Target:Cast(Gnaw);
                    end
                end
            end
        else
            if PlayerPet:Exists() then
                if module.GetSecondOptionValue("Pet Damage Handling") == "Handle Spells" then
                    -- Enable Spells
                    for i = 1, 10 do
                        PetActionName, _, _, _, _, _, IsPetActionActive, PetActionID = GetPetActionInfo(i);
                        if PetActionID == 212333 or PetActionID == 212336 or PetActionID == 47468 or PetActionID == 47481 then
                            if not IsPetActionActive then
                                module.Bug("Enabling "..PetActionName);
                                EnableSpellAutocast(PetActionName);
                            end
                        end
                    end
                end
            end
        end
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        PlayerPetHandling();
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura "..HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(FesteringStrike, false) or Unit.Target;
    end

    local function PetHandler ()
        if (UnitExists("PlayerPet") == false or UnitIsDeadOrGhost("PlayerPet")) and Player:CanCast(RaiseDead) then
            Player:Cast(RaiseDead);
            return;
        end
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        -- Raise Ally
        if RaiseAlly:Exists() and module.IsOptionEnabled("Raise Ally") and Target:Exists() and Target:IsDeadOrGhost() and Target:IsPlayer() and Target:CanCast(RaiseAlly) then
            Target:Cast(RaiseAlly);
            return;
        end
        PetHandler();
        -- Common values for SimC Calculations
        RuneCount, NextRune = Player:Runes();
        RunicPower = Player:RunicPower();
        if Target:Exists() and Player:CanAttack(Target) then
            -- Enemies Check
            if module.UseAOE() then
                if RefreshEnemies < module.GetTime() then
                    Enemies_40y = Player:EnemiesWithinDistance(40, false);
                    EpidemicUnitsCount = Epidemic:Exists() and #Player:FilterEnemiesByDebuff(Enemies_40y, VirulentPlague) or 0;
                    TargetEnemies_8y = Target:EnemiesWithinDistance(8, true);
                    OutbreakCount = #Target:FilterEnemiesByDebuff(TargetEnemies_8y, VirulentPlague) or 0;
                    NumEnemies = #TargetEnemies_8y;
                    RefreshEnemies = module.GetTime() + 0.2;
                end
            else
                Enemies_40y, TargetEnemies_8y, EpidemicUnitsCount, OutbreakCount, NumEnemies = {}, {}, 0, 0, 1;
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, FesteringStrike) then
                --- Cooldowns ---
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and RunicPower < 70 and Player:CanCast(ArcaneTorrent) then
                        Player:Cast(ArcaneTorrent);
                        return;
                    end
                end
            end

            -- actions+=/outbreak,target_if=!dot.virulent_plague.ticking
            if Outbreak:Exists() and not Target:Debuff(VirulentPlague) and Target:CanCast(Outbreak) then
                Target:Cast(Outbreak);
                return;
            end
            -- actions+=/dark_transformation
            if DarkTransformation:Exists() and Player:CanCast(DarkTransformation) then
                Player:Cast(DarkTransformation);
                return;
            end
            -- actions+=/blighted_rune_weapon
            if BlightedRuneWeapon:Exists() and module.IsOptionEnabled("Blighted Rune Weapon") and (module.CooldownsAllowed() or module.GetOptionValue("Blighted Rune Weapon") == "Always") and Player:CanCast(BlightedRuneWeapon) then
                Player:Cast(BlightedRuneWeapon);
                return;
            end

            -- actions+=/run_action_list,name=valkyr,if=talent.dark_arbiter.enabled&pet.valkyr_battlemaiden.active
            if DarkArbiter:Exists() and module.GetTime() < module.Arbiter then
                -- actions.valkyr=death_coil
                if DeathCoil:Exists() and RunicPower >= 35 and Target:CanCast(DeathCoil) then
                    Target:Cast(DeathCoil);
                    return;
                end
                -- actions.valkyr+=/call_action_list,name=aoe,if=active_enemies>=2
                if NumEnemies >= 2 then
                    -- actions.aoe=death_and_decay,if=spell_targets.death_and_decay>=2
                    if not Defile:Exists() and DeathAndDecay:Exists() and module.IsOptionEnabled("Death And Decay") and Target:CanCast(DeathAndDecay) then
                        if Target:CastGroundSpell(DeathAndDecay, "Death And Decay", 10) then return; end
                    end
                    -- actions.aoe+=/epidemic,if=spell_targets.epidemic>4
                    if Epidemic:Exists() and module.IsOptionEnabled("Epidemic") and EpidemicUnitsCount >= module.GetOptionValue("Epidemic") and Player:CanCast(Epidemic) then
                        Player:Cast(Epidemic);
                        return;
                    end
                    -- actions.aoe+=/scourge_strike,if=spell_targets.scourge_strike>=2&(dot.death_and_decay.ticking|dot.defile.ticking)
                    if ScourgeStrike:Exists() and Player:Buff(DeathAndDecay) and Target:CanCast(ScourgeStrike) then
                        Target:Cast(ScourgeStrike);
                        return;
                    end
                    -- actions.aoe+=/clawing_shadows,if=spell_targets.clawing_shadows>=2&(dot.death_and_decay.ticking|dot.defile.ticking)
                    if ClawingShadows:Exists() and Player:Buff(DeathAndDecay) and Target:CanCast(ClawingShadows) then
                        Target:Cast(ClawingShadows);
                        return;
                    end
                    -- actions.aoe+=/epidemic,if=spell_targets.epidemic>2
                    if Epidemic:Exists() and module.IsOptionEnabled("Epidemic") and EpidemicUnitsCount >= module.GetSecondOptionValue("Epidemic") and Player:CanCast(Epidemic) then
                        Player:Cast(Epidemic);
                        return;
                    end
                end
                -- actions.valkyr+=/festering_strike,if=debuff.festering_wound.stack<=6
                if FesteringStrike:Exists() and Target:DebuffCount(FesteringWound) <= 6 and Target:CanCast(FesteringStrike) then
                    Target:Cast(FesteringStrike);
                    return;
                end
                -- actions.valkyr+=/scourge_strike,if=debuff.festering_wound.up
                if ScourgeStrike:Exists() and Target:Debuff(FesteringWound) and Target:CanCast(ScourgeStrike) then
                    Target:Cast(ScourgeStrike);
                    return;
                end
                -- actions.valkyr+=/clawing_shadows,if=debuff.festering_wound.up
                if ClawingShadows:Exists() and Target:Debuff(FesteringWound) and Target:CanCast(ClawingShadows) then
                    Target:Cast(ClawingShadows);
                    return;
                end
                return;
            end

            -- actions+=/call_action_list,name=generic
            -- actions.generic=dark_arbiter,if=runic_power>80
            if DarkArbiter:Exists() and module.IsOptionEnabled("Dark Arbiter") and (module.CooldownsAllowed() or module.GetOptionValue("Dark Arbiter") == "Always") and RunicPower >= module.GetSecondOptionValue("Dark Arbiter") and Target:CanCast(DarkArbiter) then
                Target:Cast(DarkArbiter);
                return;
            end
            -- actions.generic+=/summon_gargoyle
            if not DarkArbiter:Exists() and SummonGargoyle:Exists() and module.IsOptionEnabled("Summon Gargoyle") and (module.CooldownsAllowed() or module.GetOptionValue("Summon Gargoyle") == "Always") and Target:CanCast(SummonGargoyle) then
                Target:Cast(SummonGargoyle);
                return;
            end
            -- actions.generic+=/death_coil,if=runic_power>80
            if DeathCoil:Exists() and RunicPower > 80 and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil);
                return;
            end
            -- actions.generic+=/death_coil,if=runic_power>80&cooldown.dark_arbiter.remains>5
            if DeathCoil:Exists() and RunicPower > 80 and DarkArbiter:Cooldown() > 5 and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil);
                return;
            end
            -- actions.generic+=/death_coil,if=talent.dark_arbiter.enabled&buff.sudden_doom.react&cooldown.dark_arbiter.remains>5
            if DeathCoil:Exists() and DarkArbiter:Exists() and Player:Buff(SuddenDoom) and DarkArbiter:Cooldown() > 5 and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil);
                return;
            end
            -- actions.generic+=/death_coil,if=!talent.dark_arbiter.enabled&buff.sudden_doom.react
            if DeathCoil:Exists() and not DarkArbiter:Exists() and Player:Buff(SuddenDoom) and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil);
                return;
            end
            -- actions.generic+=/soul_reaper,if=debuff.festering_wound.stack>=3
            if SoulReaper:Exists() and Target:DebuffCount(FesteringWound) >= 3 and Target:CanCast(SoulReaper) then
                Target:Cast(SoulReaper);
                return;
            end
            -- actions.generic+=/festering_strike,if=debuff.soul_reaper.up&!debuff.festering_wound.up
            if FesteringStrike:Exists() and Target:Debuff(SoulReaper) and not Target:Debuff(FesteringWound) and Target:CanCast(FesteringStrike) then
                Target:Cast(FesteringStrike);
                return;
            end
            -- actions.generic+=/scourge_strike,if=debuff.soul_reaper.up&debuff.festering_wound.stack>=1
            if ScourgeStrike:Exists() and Target:Debuff(SoulReaper) and Target:Debuff(FesteringWound) and Target:CanCast(ScourgeStrike) then
                Target:Cast(ScourgeStrike);
                return;
            end
            -- actions.generic+=/clawing_shadows,if=debuff.soul_reaper.up&debuff.festering_wound.stack>=1
            if ClawingShadows:Exists() and Target:Debuff(SoulReaper) and Target:Debuff(FesteringWound) and Target:CanCast(ClawingShadows) then
                Target:Cast(ClawingShadows);
                return;
            end
            -- actions.generic+=/defile
            if Defile:Exists() and module.IsOptionEnabled("Death And Decay") and Target:CanCast(Defile) then
                if Target:CastGroundSpell(Defile, "Death And Decay", 10) then return; end
            end
            -- actions.generic+=/call_action_list,name=aoe,if=active_enemies>=2
            if NumEnemies >= 2 then
                -- actions.aoe=death_and_decay,if=spell_targets.death_and_decay>=2
                if not Defile:Exists() and DeathAndDecay:Exists() and module.IsOptionEnabled("Death And Decay") and Target:CanCast(DeathAndDecay) then
                    if Target:CastGroundSpell(DeathAndDecay, "Death And Decay", 10) then return; end
                end
                -- actions.aoe+=/epidemic,if=spell_targets.epidemic>4
                if Epidemic:Exists() and module.IsOptionEnabled("Epidemic") and EpidemicUnitsCount >= module.GetOptionValue("Epidemic") and Player:CanCast(Epidemic) then
                    Player:Cast(Epidemic);
                    return;
                end
                -- actions.aoe+=/scourge_strike,if=spell_targets.scourge_strike>=2&(dot.death_and_decay.ticking|dot.defile.ticking)
                if ScourgeStrike:Exists() and Player:Buff(DeathAndDecay) and Target:CanCast(ScourgeStrike) then
                    Target:Cast(ScourgeStrike);
                    return;
                end
                -- actions.aoe+=/clawing_shadows,if=spell_targets.clawing_shadows>=2&(dot.death_and_decay.ticking|dot.defile.ticking)
                if ClawingShadows:Exists() and Player:Buff(DeathAndDecay) and Target:CanCast(ClawingShadows) then
                    Target:Cast(ClawingShadows);
                    return;
                end
                -- actions.aoe+=/epidemic,if=spell_targets.epidemic>2
                if Epidemic:Exists() and module.IsOptionEnabled("Epidemic") and EpidemicUnitsCount >= module.GetSecondOptionValue("Epidemic") and Player:CanCast(Epidemic) then
                    Player:Cast(Epidemic);
                    return;
                end
            end
            -- actions.generic+=/festering_strike,if=debuff.festering_wound.stack<=4
            if FesteringStrike:Exists() and Target:DebuffCount(FesteringWound) <= 4 and Target:CanCast(FesteringStrike) then
                Target:Cast(FesteringStrike);
                return;
            end
            -- actions.generic+=/scourge_strike,if=buff.necrosis.react
            if ScourgeStrike:Exists() and Player:Buff(NecrosisBuff) and Target:CanCast(ScourgeStrike) then
                Target:Cast(ScourgeStrike);
                return;
            end
            -- actions.generic+=/clawing_shadows,if=buff.necrosis.react
            if ClawingShadows:Exists() and Player:Buff(NecrosisBuff) and Target:CanCast(ClawingShadows) then
                Target:Cast(ClawingShadows);
                return;
            end
            -- actions.generic+=/scourge_strike,if=buff.unholy_strength.react
            if ScourgeStrike:Exists() and Player:Buff(UnholyStrength) and Target:CanCast(ScourgeStrike) then
                Target:Cast(ScourgeStrike);
                return;
            end
            -- actions.generic+=/clawing_shadows,if=buff.unholy_strength.react
            if ClawingShadows:Exists() and Player:Buff(UnholyStrength) and Target:CanCast(ClawingShadows) then
                Target:Cast(ClawingShadows);
                return;
            end
            -- actions.generic+=/scourge_strike,if=rune>=3
            if ScourgeStrike:Exists() and RuneCount >= 3 and Target:CanCast(ScourgeStrike) then
                Target:Cast(ScourgeStrike);
                return;
            end
            -- actions.generic+=/clawing_shadows,if=rune>=3
            if ClawingShadows:Exists() and RuneCount >= 3 and Target:CanCast(ClawingShadows) then
                Target:Cast(ClawingShadows);
                return;
            end
            -- actions.generic+=/death_coil,if=talent.shadow_infusion.enabled&talent.dark_arbiter.enabled&!buff.dark_transformation.up&cooldown.dark_arbiter.remains>15
            if DeathCoil:Exists() and ShadowInfusion:Exists() and DarkArbiter:Exists() and not PlayerPet:Buff(DarkTransformation) and DarkArbiter:Cooldown() > 15 and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil);
                return;
            end
            -- actions.generic+=/death_coil,if=talent.shadow_infusion.enabled&!talent.dark_arbiter.enabled&!buff.dark_transformation.up
            if DeathCoil:Exists() and ShadowInfusion:Exists() and not DarkArbiter:Exists() and not PlayerPet:Buff(DarkTransformation) and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil);
                return;
            end
            -- actions.generic+=/death_coil,if=talent.dark_arbiter.enabled&cooldown.dark_arbiter.remains>15
            if DeathCoil:Exists() and not ShadowInfusion:Exists() and DarkArbiter:Exists() and DarkArbiter:Cooldown() > 15 and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil);
                return;
            end
            -- actions.generic+=/death_coil,if=!talent.shadow_infusion.enabled&!talent.dark_arbiter.enabled
            if DeathCoil:Exists() and not ShadowInfusion:Exists() and not DarkArbiter:Exists() and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil);
                return;
            end
        end
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(ScourgeStrike, module.GetOptionValue("Target | Attack"));
            if AutoAttack then
                AutoAttack:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        PetHandler();
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicStrengthBuff) and DraenicStrength:InStock() and not DraenicStrength:IsOnCooldown() then
            if Player:Potion("Strength", Potion) then Potion = true; end
        end
        -- Wraith Walk when we run more than choosen time
        if WraithWalk:Exists() and module.IsOptionEnabled("Wraith Walk") and Player:IsMoving() and Player:CanCast(WraithWalk) then
            Player:Cast(WraithWalk);
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() -- Frost Deathknight
    local Rotation = {};
    module.SetRotation(251, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local Enemies_8y, FrostscytheUnits, GlacialAdvanceEnemies, SindragosasFuryEnemies, TargetEnemies_8y = {}, 0, 0, 0, {};
    local ShouldObliteration, RunesDump, ShouldBreath = false, false, false;
    local MainTankResDelay, OffTankResDelay = nil, nil;

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        -- Items
        DraenicStrength = Item(109217, false, false, true);
        DraenicStrengthBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Racials
        ArcaneTorrent = Spell(50613, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59545, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Spells
        AntiMagicShell = Spell(48707, false, false, true);
        BreathOfSindragosa = Spell(152279, false, false, true);
        ControlUndead = Spell(111673, true, true, true);
        DarkCommand = Spell(56222, true, true, true);
        DarkSuccor = Spell(178819);
        DarkSuccorBuff = Spell(101568);
        DeathStrike = Spell(49998, true, true, true);
        EmpowerRuneWeapon = Spell(47568, false, false, true);
        FrostFever = Spell(55095);
        Frostscythe =Spell(207230, false, false, true);
        FrostStrike = Spell(49143, true, true, true);
        FrozenPulse = Spell(194909);
        GlacialAdvance = Spell(194913, false, false, true);
        KillingMachine = Spell(51124);
        HornOfWinter = Spell(57330, false, false, true);
        HowlingBlast = Spell(49184, true, true, true);
        HungeringWeapon = Spell(207127, false, false, true);
        IceboundFortitude = Spell(48792, false, false, true);
        IcyTalons = Spell(194878);
        IcyTalonsBuff = Spell(194879);
        MindFreeze = Spell(47528, true, true, true);
        Obliterate = Spell(49020, true, true, true);
        Obliteration = Spell(207256);
        PillarOfFrost = Spell(51271, false, false, true);
        RaiseAlly = Spell(61999, false, false, true, true);
        RemorselessWinter = Spell(196770, false, false, true);
        Rime = Spell(59052);
        SindragosasFury = Spell(190778, false, false, true);
        WraithWalk = Spell(212552, false, false, true);

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range.\n\n|cffFF0044Mode (Left Box)|r\n|cFF0088FFKeep:|r Cast on the new unit but keep your target the same.\n|cFF0088FFSwitch:|r Cast on the new unit and change your target to this unit.\n\n|cffFF0044Range (Right Box)|r\nSet the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Mind Freeze to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddNewOption("General Settings", "Raise Ally", 210, true, nil, nil, "Use Raise Ally on dead target.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Wraith Walk", 210, false, nil, nil, "Automatically use Wraith Walk while moving and Out of Combat.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Breath Of Sindragosa", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Breath Of Sindragosa."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Empower Rune Weapon", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Empower Rune Weapon."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Include Hungering Rune Weapon talent."));
        module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Obliteration", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Obliteration."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Pillar Of Frost", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Pillar Of Frost."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Disabled", "Enabled"}, {2, "Disabled", "Enabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Frostscythe", 220, true, {2, 1, 10, 1}, nil, "Use Frostscythe."..C.TOOLTIP_VALUE.."Amount of enemies that must be in 5y in front of player to use."..C.TOOLTIP_HINT("Frostscythe will be used with as few as 1 unit when we have the Killing Machine buff."));
        module.AddNewOption("Offensive Settings", "Glacial Advance", 222, true, {2, 1, 10, 1}, {1, 1, 10, 1}, "Use Glacial Advance."..C.TOOLTIP_VALUE_1.."Amount of enemies that must be in the 20y corridor in front of player to use as high priority."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the 20y corridor in front of player to use as low priority.");
        module.AddNewOption("Offensive Settings", "Howling Blast", 220, true, {7, 1, 20, 1}, nil, "Use Howling Blast filler rather than Obliterate."..C.TOOLTIP_VALUE.."Amount of enemies that must be in 8 yards around our target to use Howling Blast instead of Obliterate when no procs and we have at least 3 Runes."..C.TOOLTIP_HINT("Lower it if you use the Freezing Fog talent."));
        module.AddNewOption("Offensive Settings", "Remorseless Winter", 222, true, {3, 1, 10, 1}, {2, 1, 10, 1}, "Use Remorseless Winter."..C.TOOLTIP_VALUE_1.."Amount of enemies that must be in 8y around player to use as high priority."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in 8y around player to use as low priority.");
        module.AddNewOption("Offensive Settings", "Sindragosa's Fury", 222, true, {2, 1, 10, 1}, {1, 1, 10, 1}, "Use Sindragosa's Fury."..C.TOOLTIP_VALUE_1.."Amount of enemies that must be in the 40y corridor in front of player to use as high priority."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the 40y corridor in front of player to use as low priority.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Death Strike", 222, true, {20, 1, 100, 1}, {70, 1, 100, 1}, "Use Death Strike."..C.TOOLTIP_VALUE_1.."Health threshold to use."..C.TOOLTIP_VALUE_2.."Health threshold to use with Dark Succor buff.");
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, true, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru on self."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Icebound Fortitude", 220, true, {30, 1, 100, 1}, nil, "Use Icebound Fortitude."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Anti-Magic Shell", 220, false, {50, 1, 100, 1}, nil, "Use Anti-Magic Shell."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we wait to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        -- Anti-Magic Shell - Absorb 33% total health in magic damage - Generate runic power
        if AntiMagicShell:Exists() and module.IsOptionEnabled("Anti-Magic Shell") and Player:HealthPercentage() <= module.GetOptionValue("Anti-Magic Shell") and Player:CanCast(AntiMagicShell) then
            Player:Cast(AntiMagicShell);
        end
        -- Icebound Fortitude
        if IceboundFortitude:Exists() and module.IsOptionEnabled("Icebound Fortitude") and Player:HealthPercentage() <= module.GetOptionValue("Icebound Fortitude") and Player:CanCast(IceboundFortitude) then
            Player:Cast(IceboundFortitude);
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
        end
    end

    function Rotation:Interrupts ()
        -- Interrupts
        -- Mind Freeze
        Player:UseInterrupt(MindFreeze, ArcaneTorrent);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura "..HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(Obliterate, false) or Unit.Target;
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        -- Raise Ally
        if RaiseAlly:Exists() and module.IsOptionEnabled("Raise Ally") and Target:Exists() and Target:IsDeadOrGhost() and Target:IsPlayer() and Target:CanCast(RaiseAlly) then
            Target:Cast(RaiseAlly);
            return;
        end
        local RuneCount, NextRune = Player:Runes();
        if Target:Exists() and Player:CanAttack(Target) then
            -- Enemies Check
            if module.UseAOE() and RefreshEnemies < module.GetTime() then
                Enemies_8y = Player:EnemiesWithinDistance(8, true); -- Remorseless Winter
                FrostscytheUnits = #Player:UnitsInFrontCone(5, 180); -- Frostscythe Cone.
                GlacialAdvanceEnemies = #Player:UnitsInFrontRectangle(20, 5); -- Glacial Advance
                SindragosasFuryEnemies = #Player:UnitsInFrontRectangle(40, 5); -- Sindragosa's Fury
                TargetEnemies_8y = Target:EnemiesWithinDistance(10); -- Howling Blast
                RefreshEnemies = module.GetTime() + 0.2;
            else
                Enemies_8y, FrostscytheUnits, GlacialAdvanceEnemies, SindragosasFuryEnemies, TargetEnemies_8y = {}, 0, 0, 0, {};
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, Obliterate) then
                --- Cooldowns ---
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Obliteration
                if Obliteration:Exists() and module.IsOptionEnabled("Obliteration") and (module.CooldownsAllowed() or module.GetOptionValue("Obliteration") == "Always") and Obliteration:Cooldown() < 6 then
                    if Player:RunicPower() >= 80 and Player:CanCast(Obliteration) then
                        Player:Cast(Obliteration);
                        ShouldObliteration = false;
                        return;
                    else
                        ShouldObliteration = true;
                    end
                else
                    ShouldObliteration = false;
                end
                -- Pillar of Frost
                if PillarOfFrost:Exists() and module.IsOptionEnabled("Pillar Of Frost") and (module.CooldownsAllowed() or module.GetOptionValue("Pillar Of Frost") == "Always") and Player:CanCast(PillarOfFrost) then
                    Player:Cast(PillarOfFrost);
                    return;
                end
                -- Empower/Hungering Rune Weapon
                if module.IsOptionEnabled("Empower Rune Weapon") and (module.CooldownsAllowed() or module.GetOptionValue("Empower Rune Weapon") == "Always") then
                    if not HungeringWeapon:Exists() and EmpowerRuneWeapon:Exists() and Player:CanCast(EmpowerRuneWeapon) then
                        if RuneCount < 1 then
                            Player:Cast(EmpowerRuneWeapon);
                            return;
                        else
                            RunesDump = true
                        end
                    end
                    if HungeringWeapon:Exists() and Player:CanCast(HungeringWeapon) then
                        if RuneCount < 3 then
                            Player:Cast(HungeringWeapon);
                            return;
                        else
                            RunesDump = true
                        end
                    end
                else
                    RunesDump = false
                end
                -- Breath Of Sindragosa
                if BreathOfSindragosa:Exists() then
                    if module.IsOptionEnabled("Breath Of Sindragosa") and (module.CooldownsAllowed() or module.GetOptionValue("Breath Of Sindragosa") == "Always") and BreathOfSindragosa:Cooldown() < 8 then
                        if Player:CanCast(BreathOfSindragosa) and Player:RunicPower() >= 80 then
                            ShouldBreath = false;
                            Player:Cast(BreathOfSindragosa);
                            return;
                        end
                        ShouldBreath = true;
                    else
                        ShouldBreath = false;
                    end
                    if Player:Buff(BreathOfSindragosa) then
                        ShouldBreath = true;
                        RunesDump = true;
                    end
                else
                    ShouldBreath = false;
                end
            end

            -- Death Strike - Healing + Dark Succor
            if DeathStrike:Exists() and (Player:HealthPercentage() <= module.GetOptionValue("Death Strike") or (Player:Buff(DarkSuccorBuff) and Player:HealthPercentage() <= module.GetSecondOptionValue("Death Strike"))) and Target:CanCast(DeathStrike) then
                Target:Cast(DeathStrike);
                return;
            end
            -- Frost Strike - Obliteration
            if FrostStrike:Exists() and Player:Buff(Obliteration) and not Player:Buff(KillingMachine) and Target:CanCast(FrostStrike) then
                Target:Cast(FrostStrike);
                return;
            end
            -- Obliterate/Frostscythe - Obliteration
            if Player:Buff(Obliteration) and RuneCount >= 2 and Player:Buff(KillingMachine) then
                if Frostscythe:Exists() and module.IsOptionEnabled("Frostscythe") and FrostscytheUnits >= 1 and Player:CanCast(Frostscythe) then
                    Player:Cast(Frostscythe);
                    return;
                end
                if Obliterate:Exists() and Target:CanCast(Obliterate) then
                    Target:Cast(Obliterate);
                    return;
                end
            end
            -- Frost Strike - Dump (80)
            if FrostStrike:Exists() and not Player:Buff(BreathOfSindragosa) and Player:RunicPower() >= 80 and Target:CanCast(FrostStrike) then
                Target:Cast(FrostStrike);
                return;
            end
            -- Frost Strike - Icy Talons
            if not ShouldBreath and not ShouldObliteration and IcyTalons:Exists() and FrostStrike:Exists() and Player:Buff(IcyTalonsBuff) and Player:BuffRemains(IcyTalonsBuff) < 2.5 and Player:RunicPower() >= 25 and Target:CanCast(FrostStrike) then
                Target:Cast(FrostStrike);
                return;
            end
            -- Howling Blast - Frost Fever
            if HowlingBlast:Exists() and not Target:Debuff(FrostFever) and Target:CanCast(HowlingBlast) then
                Target:Cast(HowlingBlast);
                return;
            end
            -- Obliterate/Frostscythe - Killing Machine
            if Player:Buff(KillingMachine) then
                if Frostscythe:Exists() and module.IsOptionEnabled("Frostscythe")and FrostscytheUnits >= 1 and Player:CanCast(Frostscythe) then
                    Player:Cast(Frostscythe);
                    return;
                end
                if Obliterate:Exists() and RuneCount >= 2 and Target:CanCast(Obliterate) then
                    Target:Cast(Obliterate);
                    return;
                end
            end
            -- Glacial Advance - High Prio
            if GlacialAdvance:Exists() and module.IsOptionEnabled("Glacial Advance") and GlacialAdvanceEnemies >= module.GetOptionValue("Glacial Advance") and Player:CanCast(GlacialAdvance) then
                Player:Cast(GlacialAdvance);
                return;
            end
            -- Sindragosa's Fury - High Prio
            if SindragosasFury:Exists() and module.IsOptionEnabled("Sindragosa's Fury") and SindragosasFuryEnemies >= module.GetOptionValue("Sindragosa's Fury") and Player:CanCast(SindragosasFury) then
                Player:Cast(SindragosasFury);
                return;
            end
            -- Remorseless Winter - High Prio
            if RemorselessWinter:Exists() and module.IsOptionEnabled("Remorseless Winter") and #Enemies_8y >= module.GetOptionValue("Remorseless Winter") and Player:CanCast(RemorselessWinter) then
                Player:Cast(RemorselessWinter);
                return;
            end
            -- Howling Blast - Rime
            if HowlingBlast:Exists() and Player:Buff(Rime) and Target:CanCast(HowlingBlast) then
                Target:Cast(HowlingBlast);
                return;
            end
            -- Glacial Advance - Low Prio
            if GlacialAdvance:Exists() and module.IsOptionEnabled("Glacial Advance") and GlacialAdvanceEnemies >= module.GetSecondOptionValue("Glacial Advance") and Player:CanCast(GlacialAdvance) then
                Player:Cast(GlacialAdvance);
                return;
            end
            -- Sindragosa's Fury - Low Prio
            if SindragosasFury:Exists() and module.IsOptionEnabled("Sindragosa's Fury") and SindragosasFuryEnemies >= module.GetSecondOptionValue("Sindragosa's Fury") and Player:CanCast(SindragosasFury) then
                Player:Cast(SindragosasFury);
                return;
            end
            -- Remorseless Winter - Low Prio
            if RemorselessWinter:Exists() and module.IsOptionEnabled("Remorseless Winter") and #Enemies_8y >= module.GetSecondOptionValue("Remorseless Winter") and Player:CanCast(RemorselessWinter) then
                Player:Cast(RemorselessWinter);
                return;
            end
            -- Frost Strike - Dump (60)
            if not ShouldBreath and not ShouldObliteration and not IcyTalons:Exists() and FrostStrike:Exists() and Player:RunicPower() >= 60 and Target:CanCast(FrostStrike) then
                Target:Cast(FrostStrike);
                return;
            end
            -- Obliterate/Howling Blast - 3+ Runes or Frozen Pulse
            if RuneCount >= 3 or (RuneCount >= 2 and NextRune < 3) or FrozenPulse:Exists() or RunesDump then
                -- Howling Blast
                if HowlingBlast:Exists() and module.IsOptionEnabled("Howling Blast") and #TargetEnemies_8y >= module.GetOptionValue("Howling Blast") and Target:CanCast(HowlingBlast) then
                    Target:Cast(HowlingBlast);
                    return;
                end
                -- Obliterate/Frostscythe
                if Frostscythe:Exists() and module.IsOptionEnabled("Frostscythe") and FrostscytheUnits >= module.GetOptionValue("Frostscythe") and Player:CanCast(Frostscythe) then
                    Player:Cast(Frostscythe);
                    return;
                end
                if Obliterate:Exists() and RuneCount >= 2 and Target:CanCast(Obliterate) then
                    Target:Cast(Obliterate);
                    return;
                end
                -- Howling Bast
                if FrozenPulse:Exists() and HowlingBlast:Exists() and not Player:Buff(KillingMachine) and ((RuneCount >= 1 and RuneCount < 2 and NextRune >= 3) or RunesDump) and Target:CanCast(HowlingBlast) then
                    module.Bug("Howling Blast - Clear Runes for Frozen Pulse");
                    Target:Cast(HowlingBlast);
                    return;
                end
            end
            -- Hown of Winter
            if HornOfWinter:Exists() and Player:CanCast(HornOfWinter) then
                Player:Cast(HornOfWinter);
                return;
            end
            -- Frost Strike - Filler
            if not ShouldBreath and not ShouldObliteration and not IcyTalons:Exists() and FrostStrike:Exists() and Player:RunicPower() >= 25 and Target:CanCast(FrostStrike) then
                Target:Cast(FrostStrike);
                return;
            end
        end
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Obliterate, module.GetOptionValue("Target | Attack"));
            if AutoAttack then
                AutoAttack:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicStrengthBuff) and DraenicStrength:InStock() and not DraenicStrength:IsOnCooldown() then
            if Player:Potion("Strength", Potion) then Potion = true; end
        end
        -- Wraith Walk when we run more than choosen time
        if WraithWalk:Exists() and module.IsOptionEnabled("Wraith Walk") and Player:IsMoving() and Player:CanCast(WraithWalk) then
            Player:Cast(WraithWalk);
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() -- Blood Deathknight
    local Rotation = {};
    module.SetRotation(250, Rotation);

    --- Localization
    -- Core
    local Enemies_30y, Enemies_10y, RefreshEnemies = {}, {}, 0;
    local SpamPrevention, TPSTime = 0, 0.1; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local MainTankResDelay, OffTankResDelay = nil, nil;

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        -- Items
        DraenicArmor = Item(109220, false, false, true);
        DraenicArmorBuff = Spell(156430, false, false, true);
        DraenicStrength = Item(109217, false, false, true);
        DraenicStrengthBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Racials
        ArcaneTorrent = Spell(50613, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59545, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Spells
        AntiMagicShell = Spell(48707, false, false, true);
        Asphyxiate = Spell(221562, true, true, true);
        BloodBoil = Spell(50842, false, false, true);
        BloodDrinker = Spell(206931, true, true, true);
        BloodMirror = Spell(206977, true, true, true);
        BloodPlague = Spell(55078, false, false, true);
        BloodTap = Spell(221699, false, false, true);
        BoneShield = Spell(195181, false, false, true);
        Bonestorm = Spell(194844, false, false, true);
        Consumption = Spell(205223, true, true, true);
        ControlUndead = Spell(111673, true, true, true);
        DancingRuneWeapon = Spell(49028, false, true, true);
        DancingRuneWeaponBuff = Spell(81256, false, false, true);
        DarkCommand = Spell(56222, true, true, true);
        DeathAndDecay = Spell(43265, false, true, true);
        DeathAndDecayBuff = Spell(188290, false, false, true);
        DeathStrike = Spell(49998, true, true, true);
        DeathsCaress = Spell(195292, true, true, true);
        Exsanguinate = Spell(206931, true, true, true);
        HearthStrike = Spell(206930, true, true, true);
        MarkOfBlood = Spell(206940, true, true, true);
        MarrowRend = Spell(195182, true, true, true);
        MindFreeze = Spell(47528, true, true, true);
        RaiseAlly = Spell(61999, false, false, true, true);
        RuneTap = Spell(194679, false, false, true);
        Soulgorge = Spell(212744, false, false, true);
        Tombstone = Spell(219809, false, false, true);
        VampiricBlood = Spell(55233, false, false, true);
        WraithWalk = Spell(212552, false, false, true);

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {6, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest", "Untanked"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_SUBVALUE("Untanked").."Integrate tanking logic that will priorise the untaked units."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range.\n\n|cffFF0044Mode (Left Box)|r\n|cFF0088FFKeep:|r Cast on the new unit but keep your target the same.\n|cFF0088FFSwitch:|r Cast on the new unit and change your target to this unit.\n\n|cffFF0044Range (Right Box)|r\nSet the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.TauntManagerOptions("Dark Command");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Mind Freeze to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddNewOption("General Settings", "Raise Ally", 210, true, nil, nil, "Use Raise Ally on dead target.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Wraith Walk", 210, false, nil, nil, "Automatically use Wraith Walk while moving and Out of Combat.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Only Arcane Torrent is supported."));
        module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Disabled", "Enabled"}, {2, "Disabled", "Enabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Bonestorm", 222, true, {2, 1, 10, 1}, {90, 10, 100, 5}, "Use Bonestorm." .. C.TOOLTIP_VALUE .. "Amount of enemies that must be in melee range to use." .. C.TOOLTIP_VALUE_2 .. "Required Runic Power to use.");
        module.AddNewOption("Offensive Settings", "Death And Decay", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {1, 1, 10, 1}, "Use Death and Decay." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Death's Caress", 122, true, {3, 1, 10, 1}, {3, 0, 25, 0.1}, "Death's Caress Cycle for Soulgorge." .. C.TOOLTIP_VALUE_1 .. "Number of dots to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum enemy health (in million) to apply." .. C.TOOLTIP_HINT("Only used when the Soulgorge talent is selected."));
        module.AddNewOption("Offensive Settings", "Soulgorge", 220, true, {2, 0, 20, 0.1}, nil, "Use Soulgorge." .. C.TOOLTIP_VALUE .. "Remaining seconds on the Blood Plague that will expire next to use Soulgorge." .. C.TOOLTIP_HINT("Lesser is usually better."))

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Death Strike", 222, true, {20, 1, 100, 1}, {80, 1, 100, 1}, "Use Death Strike." .. C.TOOLTIP_VALUE_1 .. "Health threshold to use as high priority." .. C.TOOLTIP_VALUE_2 .. "Health threshold to use as low priority.");
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, true, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddNewOption("Defensive Settings", "Mark Of Blood", 222, true, {100, 1, 100, 1}, {5, 0, 25, 0.1}, "Use Mark of Blood." .. C.TOOLTIP_VALUE_1 .. "Health threshold." .. C.TOOLTIP_VALUE_2 .. "Minimum enemy health (in million) to apply.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru on self." .. C.TOOLTIP_VALUE .. "Health threshold.");
        end
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Anti-Magic Shell", 220, false, {50, 1, 100, 1}, nil, "Use Anti-Magic Shell."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Blood Drinker", 220, true, {85, 1, 100, 1}, nil, "Use Blood Drinker." .. C.TOOLTIP_VALUE_1 .. "Health threshold.");
        module.AddNewOption("Defensive Settings", "Blood Mirror", 222, true, {20, 1, 100, 1}, {3, 0, 25, 0.1}, "Use Blood Mirror." .. C.TOOLTIP_VALUE_1 .. "Health threshold." .. C.TOOLTIP_VALUE_2 .. "Minimum enemy health (in million) to apply.");
        module.AddNewOption("Defensive Settings", "Dancing Rune Weapon", 220, true, {40, 1, 100, 1}, nil, "Use Dancing Rune Weapon." .. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddNewOption("Defensive Settings", "Rune Tap", 222, true, {20, 1, 100, 1}, {80, 1, 100, 1}, "Use Rune Tap." .. C.TOOLTIP_VALUE_1 .. "Health threshold to use when we have 1 charge." .. C.TOOLTIP_VALUE_2 .. "Health threshold to use when we have 2 charges.");
        module.AddNewOption("Defensive Settings", "Tombstone", 222, true, {5, 1, 10, 1}, {40, 1, 100, 1}, "Use Tombstone." .. C.TOOLTIP_VALUE_1 .. "Minimum Bone Shield stacks to use." .. C.TOOLTIP_VALUE_2 .. "Health threshold.");
        module.AddNewOption("Defensive Settings", "Vampiric Blood", 220, true, {20, 1, 100, 1}, nil, "Use Vampiric Blood." .. C.TOOLTIP_VALUE .. "Health threshold.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we wait to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        if module.CooldownsAllowed() and not Player:Buff(Tombstone) and not Player:Buff(RuneTap) and not Player:Buff(DancingRuneWeapon) and not Player:Buff(VampiricBlood) then
            local Shielded = false;
            -- Tombstone - Consume Bone Shield stacks and shield up to 3% per stack for 8 seconds
            if Tombstone:Exists() and module.IsOptionEnabled("Tombstone") and Player:BuffCount(BoneShield) >= module.GetOptionValue("Tombstone") and Player:HealthPercentage() <= module.GetSecondOptionValue("Tombstone") and Player:CanCast(Tombstone) then
                Player:Cast(Tombstone);
                Shielded = true;
            end
            -- Rune Tap - Reduce damage taken by 25% for 3 seconds
            if not Shielded and RuneTap:Exists() and module.IsOptionEnabled("Rune Tap") and ((Player:HealthPercentage() <= module.GetOptionValue("Rune Tap")) or (RuneTap:Charges() >= 2 and Player:HealthPercentage() <= module.GetSecondOptionValue("Rune Tap"))) and Player:CanCast(RuneTap) then
                Player:Cast(RuneTap);
                Shielded = true;
            end
            -- Dancing Rune Weapon - 40% parry chance
            if not Shielded and DancingRuneWeapon:Exists() and module.IsOptionEnabled("Dancing Rune Weapon") and Player:HealthPercentage() <= module.GetOptionValue("Dancing Rune Weapon") and Target:CanCast(DancingRuneWeapon) then
                Target:Cast(DancingRuneWeapon);
                Shielded = true;
            end
            -- Vampiric Blood - Increase Max Health / Increased Healing Received
            if not Shielded and VampiricBlood:Exists() and module.IsOptionEnabled("Vampiric Blood") and Player:HealthPercentage() <= module.GetOptionValue("Vampiric Blood") and Player:CanCast(VampiricBlood) then
                Player:Cast(VampiricBlood);
            end
        end
        -- Anti-Magic Shell - Absorb 33% total health in magic damage - Generate runic power
        if AntiMagicShell:Exists() and module.IsOptionEnabled("Anti-Magic Shell") and Player:HealthPercentage() <= module.GetOptionValue("Anti-Magic Shell") and Player:CanCast(AntiMagicShell) then
            Player:Cast(AntiMagicShell);
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
        end
    end

    function Rotation:Interrupts ()
        -- Interrupts
        -- Mind Freeze
        Player:UseInterrupt(MindFreeze, ArcaneTorrent);
        -- Asphyxiate
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(HearthStrike, false) or Unit.Target;
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        -- Raise Ally
        if RaiseAlly:Exists() and module.IsOptionEnabled("Raise Ally") and Target:Exists() and Target:IsDeadOrGhost() and Target:IsPlayer() and Target:CanCast(RaiseAlly) then
            Target:Cast(RaiseAlly);
            return;
        end

        -- Runes
        local RuneCount, NextRune = Player:Runes();

        if Target:Exists() and Player:CanAttack(Target) and not Target:IsDeadOrGhost() then

            -- Enemies Check
            if module.UseAOE() and RefreshEnemies < module.GetTime() then
                Enemies_30y = Player:EnemiesWithinDistance(30, false);
                Enemies_10y = Player:FilterEnemiesByDistance(Enemies_30y, 10, true);
                Enemies_5y = module.IsOptionEnabled("Bonestorm") and Player:FilterEnemiesByDistance(Enemies_10y, 6.5, true) or {};
                RefreshEnemies = module.GetTime() + 0.2;
            else
                Enemies_30y, Enemies_10y, Enemies_5y = {}, {}, {};
            end

            -- Dark Command
            if Player:TauntManager(DarkCommand, "Dark Command", Target, Enemies_30y) then
                return;
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, HearthStrike) then
                --- Cooldowns ---
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
            end
            -- Rotation
            if Consumption:Exists() and Target:CanCast(Consumption) then
                Target:Cast(Consumption);
                return;
            end
            -- MarrowRend - 2 Runes - Apply 3 BoneShield charges - Active Mitigation
            if MarrowRend:Exists() and Target:CanCast(MarrowRend) and (Player:BuffCount(BoneShield) < 2 or Player:BuffRemains(BoneShield) < 3) then
                Target:Cast(MarrowRend);
                return;
            end
            -- Death Strike - High Priority Heal
            if DeathStrike:Exists() and module.IsOptionEnabled("Death Strike") and Player:HealthPercentage() <= module.GetOptionValue("Death Strike") and Target:CanCast(DeathStrike) then
                Target:Cast(DeathStrike);
                return;
            end
            -- Blood Mirror
            if BloodMirror:Exists() and module.IsOptionEnabled("Blood Mirror") and Player:HealthPercentage() <= module.GetOptionValue("Blood Mirror") and Target:Health() >= module.GetSecondOptionValue("Blood Mirror")*1000000 and Target:CanCast(BloodMirror) then
                Target:Cast(BloodMirror);
                return;
            end
            -- Bonestorm - Dump Runic Power
            if Bonestorm:Exists() and module.IsOptionEnabled("Bonestorm") and #Enemies_5y >= module.GetOptionValue("Bonestorm") and Player:RunicPower() >= module.GetSecondOptionValue("Bonestorm") and Player:CanCast(Bonestorm) then
                Player:Cast(Bonestorm);
                return;
            end
            -- Death Strike - Dump Runic Power
            if DeathStrike:Exists() and module.IsOptionEnabled("Death Strike") and (not module.IsOptionEnabled("Bonestorm") or not Bonestorm:Exists() or Bonestorm:Cooldown() > 2 or #Enemies_5y < module.GetOptionValue("Bonestorm")) and Player:RunicPower() >= 75 and Target:CanCast(DeathStrike) then
                Target:Cast(DeathStrike);
                return;
            end
            -- If Soulgorge then we should apply blood plague via DeathsCaress (multi-dot)
            -- then when all units have dots and the first applied dot is about to fall off we Soulgorge
            if DeathsCaress:Exists() and Soulgorge:Exists() then
                local LowestUnitDuration, BestUnitToCastOn, PlaguedUnits, DeathsCaressThreshold = 24, nil, 0, module.GetSecondOptionValue("Death's Caress")*1000000;
                for i = 1, #Enemies_30y do
                    local ThisUnit = Enemies_30y[i];
                    local ThisUnitDebuffDuration = ThisUnit:DebuffRemains(BloodPlague);
                    LowestUnitDuration = ThisUnitDebuffDuration > 0 and ThisUnitDebuffDuration < LowestUnitDuration and ThisUnitDebuffDuration or LowestUnitDuration
                    if ThisUnitDebuffDuration == 0 then
                        BestUnitToCastOn = (ThisUnit:IsDummy() or ThisUnit:Health() >= DeathsCaressThreshold) and ThisUnit:CanCast(DeathsCaress) and ThisUnit:Level() < Player:Level() + 5 and not (Player:Level() < 110 and ThisUnit:Level() == -1) and ThisUnit or BestUnitToCastOn;
                    end
                end
                if LowestUnitDuration < module.GetOptionValue("Soulgorge") and Player:CanCast(Soulgorge) then
                    Player:Cast(Soulgorge);
                    return;
                end
                if PlaguedUnits < module.GetOptionValue("Death's Caress") and BestUnitToCastOn then
                    BestUnitToCastOn:Cast(DeathsCaress);
                    return;
                end
            end
            -- Blood Boil Cycle - Apply Blood Plague / DeathsCaress if > 10 yard
            if BloodBoil:Exists() and not Soulgorge:Exists() and Player:CanCast(BloodBoil) then
                for i = 1, #Enemies_10y do
                    local ThisUnit = Enemies_10y[i];
                    if ThisUnit:DebuffRemains(BloodPlague) < 3 then
                        Player:Cast(BloodBoil);
                        return;
                    end
                end
            end
            -- Blood Tap - Generate 1 rune - Cooldown reduced when Bone Shield charges are used
            if BloodTap:Exists() and RuneCount < 3 and Player:CanCast(BloodTap) then
                Player:Cast(BloodTap);
                return;
            end
            -- Death and Decay - Increase Targets hit by Hearth Strike to 3 when we are in it
            if DeathAndDecay:Exists() and module.IsOptionEnabled("Death And Decay") and Target:CanCast(DeathAndDecay) then
                if Player:CastGroundSpell(DeathAndDecay, "Death And Decay", 10) then return; end
            end
            -- Mark of Blood
            if MarkOfBlood:Exists() and module.IsOptionEnabled("Mark Of Blood") and not Target:Debuff(MarkOfBlood) and Player:HealthPercentage() <= module.GetOptionValue("Mark Of Blood") and Target:Health() >= module.GetSecondOptionValue("Mark Of Blood")*1000000 and Target:CanCast(MarkOfBlood) then
                Target:Cast(MarkOfBlood);
                return;
            end
            -- Death Strike - Low Priority Heal
            if DeathStrike:Exists() and module.IsOptionEnabled("Death Strike") and Player:HealthPercentage() <= module.GetSecondOptionValue("Death Strike") and Target:CanCast(DeathStrike) then
                Target:Cast(DeathStrike);
                return;
            end
            -- Blood Drinker
            if BloodDrinker:Exists() and module.IsOptionEnabled("Blood Drinker") and Player:HealthPercentage() <= module.GetOptionValue("Blood Drinker") and Target:CanCast(BloodDrinker) then
                Target:Cast(BloodDrinker);
                return;
            end
            if RuneCount >= 2.5 then
                if Player:DistanceTo(Target) > 10 then
                    -- Death's Caress - Out of Range
                    if DeathsCaress:Exists() and Target:CanCast(DeathsCaress) and not Target:Debuff(BloodPlague) then
                        Target:Cast(DeathsCaress);
                        return;
                    end
                else
                    -- MarrowRend - Stack up to 10 stacks
                    if MarrowRend:Exists() and Target:CanCast(MarrowRend) and Player:BuffCount(BoneShield) <= 7 then
                        Target:Cast(MarrowRend);
                        return;
                    end
                    -- Hearth Strike - 1 Rune - Generate 5 Runic Power
                    if HearthStrike:Exists() and Target:CanCast(HearthStrike) then
                        Target:Cast(HearthStrike);
                        return;
                    end
                end
            end
            -- Blood Boil - Filler
            if BloodBoil:Exists() and Player:IsWithinCastRange(Target, HearthStrike) and Player:CanCast(BloodBoil) then
                Player:Cast(BloodBoil);
                return;
            end
        end
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(HearthStrike, module.GetOptionValue("Target | Attack"));
            if AutoAttack then
                AutoAttack:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicArmorBuff) and DraenicArmor:InStock() and not DraenicArmor:IsOnCooldown() then
            if Player:Potion("Armor", Potion) then Potion = true; end
        end
        -- Deaths Advance when we run more than choosen time
        if WraithWalk:Exists() and module.IsOptionEnabled("Wraith Walk") and Player:IsMoving() and Player:CanCast(WraithWalk) then
            Player:Cast(WraithWalk);
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Havoc Demon Hunter Rotation
    local Rotation = {};
    module.SetRotation(577, Rotation);

    --- Localization
    -- Core
    local Enemies_8y, EyeBeamNumEnemies, NumEnemies = {}, 1, 1; -- Enemies
    local SpamPrevention, TPSTime = 0, 0.1; -- Combat Module Throttle
    local UpdateInterruptPercentage, InterruptPercentage = 0, 1; -- Interrupt Module
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local MetamorphosisTimer, MetamorphosisCasted, MetamorphosisReset = 0, nil, nil; -- Metamorphosis Handler
    local NoPathFromEvent, NoPathFromEventPositionX, NoPathFromEventPositionY, NoPathFromEventPositionZ = nil, nil, nil, nil; -- No Path Available Handler
    local EyeBeamStanding, EyeBeamPooling = 0.7, nil; -- Time to Stand before casting Eye Beam (because movements cancel it) and EyeBeam Pooling Variable.
    local VR_FR_FB_Sync, FelBladeTarget = -1, nil; -- Variable to do Vengeful Retreat / Fel Rush / Felblade trick.

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        --- Spells
        -- (ID, RequiresFacing, Hostile, Instant)
        -- Racials
        ArcaneTorrent = Spell(202719, false, false, true);
        Shadowmeld = Spell(58984, false, false, true);
        -- Items
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Abilities
        Annihilation = Spell(201427, true, true, true);
        BladeDance = Spell(188499, false, false, true);
        ChaosNova = Spell(179057, false, false, true);
        ChaosStrike = Spell(162794, true, true, true);
        ConsumeMagic = Spell(183752, true, true, true);
        DeathSweep = Spell(210152, false, false, true);
        Demonic = Spell(213410, false, false, true);
        DemonsBite = Spell(162243, true, true, true);
        EyeBeam = Spell(198013, false, false, true);
        FelBarrage = Spell(211053, true, true, true);
        FelBlade = Spell(213241, true, true, true);
        FelEruption = Spell(211881, true, true, true);
        FelRush = Spell(195072, false, false, true);
        FirstBlood = Spell(206416, false, false, true);
        Momentum = Spell(206476, false, false, true);
        Nemesis = Spell(206491, true, true, true);
        Prepared = Spell(203551, false, false, true);
        ThrowGlaive = Spell(185123, true, true, true);
        VengefulRetreat = Spell(198793, false, false, true);
        -- Offensive Cooldowns
        ChaosBlades = Spell(211048, false, false, true);
        FuryoftheIllidari = Spell(201467, false, false, true);
        Metamorphosis = Spell(191427, false, false, true);
        MetamorphosisBuff = Spell(162264, false, false, true);
        -- Defensive Cooldowns
        Blur = Spell(198589, false, false, true);
        BlurBuff = Spell(212800, false, false, true);
        Netherwalk = Spell(196555, false, false, true);

        --- GUI Frame
        -- Pages
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Consume Magic to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "VR | FR Trick", 210, false, nil, nil, "Enable for the automatic usage of Vengeful Retreat -> Fel Rush trick to proc Momentum.\n\nYou need Prepared and Momentum talents.\n\nYou will need to get back in melee range yourself.");
        module.AddNewOption("General Settings", "VR | FR | FB Trick", 210, true, nil, nil, "Enable for the automatic usage of Vengeful Retreat -> Fel Rush -> Felblade trick to proc Momentum while staying in melee range.\n\nYou need Prepared, Felblade and Momentum talents.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Chaos Blades | Fel Barrage", 223, true, {4, 1, 5, 1}, {2, "Always", "Cooldown Only"}, "Enable for the automatic usage of Chaos Blades | Fel Barrage."..C.TOOLTIP_VALUE_1.."If you have Fel Barrage as talent, select how many charges you want to have in order to cast it."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Fury of the Illidari", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Fury of the Illidari."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Nemesis", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Nemesis."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Metamorphosis", 210, true, nil, nil, "Enable for the automatic usage of Metamorphosis.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Only Arcane Torrent is supported."));
        end
        module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Disabled", "Enabled"}, {2, "Disabled", "Enabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Eye Beam", 220, true, {1, 1, 5, 1}, {1, "Always", "Cooldown Only"}, "Enable for the automatic usage of Eye Beam."..C.TOOLTIP_VALUE_1.."Set the number of enemies required in front of you."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Chaos Nova", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Chaos Nova."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Fel Eruption", 210, true, nil, nil, "Enable for the automatic usage of Fel Eruption.");
        module.AddNewOption("Offensive Settings", "Felblade", 210, true, nil, nil, "Enable for the automatic usage of Felblade.");
        module.AddNewOption("Offensive Settings", "Throw Glaive", 210, true, nil, nil, "Enable for the automatic usage of Throw Glaive.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Health Percentage to use Healing Belt / Healing Pot / Healthstone.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, false, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Blur | Netherwalk", 220, true, {25, 1, 100, 1}, nil, "Health Percentage to use Blur or Netherwalk.");

        --- Misc
        -- Status Frame
        Player:AddCommonMeleeStatus();
        module.AddOutput("Next VR | FR Trick :");
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
        -- No Path Available Handler Event Register
        local PathFrame = CreateFrame("FRAME", "PathFrameFrame");
        PathFrame:RegisterEvent("UI_ERROR_MESSAGE");
        local function PathCheck(Self, Event, Message)
            -- Legion Alpha Message : SPELL_FAILED_NOPATH = 50;
            if Message == SPELL_FAILED_NOPATH or Message == 50 then
                NoPathFromEvent = true;
                NoPathFromEventPositionX, NoPathFromEventPositionY, NoPathFromEventPositionZ = Player:Position():Expand();
            end
        end
        PathFrame:SetScript("OnEvent", PathCheck);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Blur | Netherwalk") and Player:HealthPercentage() <= module.GetOptionValue("Blur | Netherwalk") then
            if not Netherwalk:Exists() then
                if not Player:Buff(BlurBuff)  and Player:CanCast(Blur) then
                    Player:Cast(Blur);
                end
            else
                if not Player:Buff(Netherwalk) and Player:CanCast(Netherwalk) then
                    Player:Cast(Netherwalk);
                end
            end
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(ConsumeMagic, ArcaneTorrent);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(DemonsBite, false) or Unit.Target;
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Enemies Check
            if module.UseAOE() then
                Enemies_8y = Player:EnemiesWithinDistance(8, true, false);
                NumEnemies = #Enemies_8y;
            else
                NumEnemies = 1;
            end
            -- Eye Beam Handler
            if module.IsOptionEnabled("Eye Beam") then
                EyeBeamNumEnemies = #Player:UnitsInFrontRectangle(16, 3); -- Measured on 04/18/2016 : 7.0.3.21491 (Normal Range + Pythagore for Width)
            end
            EyeBeamPooling = false; -- Reset EyeBeam Pooling
            -- No Path Available Handler (Check if we moved or not since last error)
            if NoPathFromEvent then
                local X, Y, Z = Player:Position():Expand();
                if NoPathFromEventPositionX ~= X or NoPathFromEventPositionY ~= Y or NoPathFromEventPositionZ ~= Z then
                    NoPathFromEvent = false;
                    NoPathFromEventPositionX, NoPathFromEventPositionY, NoPathFromEventPositionZ = nil, nil, nil;
                end
            end
            -- Status Update
            if Momentum:Exists() and Prepared:Exists() then
                if FelBlade:Exists() then
                    if module.IsOptionEnabled("VR | FR | FB Trick") then
                        module.SetOutput("Next VR | FR Trick :", tostring(math.floor(math.max(VengefulRetreat:Cooldown(), FelRush:Cooldown(), FelBlade:Cooldown()))).."s");
                    else
                        module.SetOutput("Next VR | FR Trick :", "Disabled");
                    end
                else
                    if module.IsOptionEnabled("VR | FR Trick") then
                        module.SetOutput("Next VR | FR Trick :", tostring(math.floor(math.max(VengefulRetreat:Cooldown(), FelRush:Cooldown()))).."s");
                    else
                        module.SetOutput("Next VR | FR Trick :", "Disabled");
                    end
                end
            else
                module.SetOutput("Next VR | FR Trick :", "Disabled");
            end
            -- Cooldowns
            if not MetamorphosisReset and module.GetTime()-MetamorphosisTimer > 2 then MetamorphosisCasted, MetamorphosisReset = false, true; module.Bug("Metamorphosis Buffer Reset"); end
            if Player:IsWithinCastRange(Target, DemonsBite) then
                if module.CooldownsAllowed() then
                    -- Metamorphosis
                    if module.IsOptionEnabled("Metamorphosis") and Metamorphosis:Exists() and (not module.IsOptionEnabled("Eye Beam") or EyeBeam:IsOnCooldown()) and not NoPathFromEvent and not Player:Buff(MetamorphosisBuff) and Player:CanCast(Metamorphosis) then
                        Player:CastGround(Metamorphosis);
                        MetamorphosisTimer, MetamorphosisCasted, MetamorphosisReset = module.GetTime(), true, false;
                        return;
                    end
                    -- Trinkets
                    if Trinket1:IsUsableInventory() and module.GetOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket1:UseInventory();
                    end
                    if Trinket2:IsUsableInventory() and module.GetSecondOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket2:UseInventory();
                    end
                end
                -- Arcane Torrent
                if ArcaneTorrent:Exists() and module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:Power() < Player:PowerMax()-30 and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent);
                    return;
                end
                -- Chaos Blades | Fel Barrage
                if module.IsOptionEnabled("Chaos Blades | Fel Barrage") and (module.CooldownsAllowed() or module.GetSecondOptionValue("Chaos Blades | Fel Barrage") == "Always") then
                    if ChaosBlades:Exists() and Player:CanCast(ChaosBlades) then
                        Player:Cast(ChaosBlades);
                        return;
                    end
                    if FelBarrage:Exists() and FelBarrage:Charges() >= module.GetOptionValue("Chaos Blades | Fel Barrage") and Target:CanCast(FelBarrage) then
                        Target:Cast(FelBarrage);
                        return;
                    end
                end
                -- Nemesis
                if module.IsOptionEnabled("Nemesis") and Nemesis:Exists() and (module.CooldownsAllowed() or module.GetOptionValue("Nemesis") == "Always") and Target:CanCast(Nemesis) then
                    Target:Cast(Nemesis);
                end
                -- Fury of the Illidari
                if module.IsOptionEnabled("Fury of the Illidari") and FuryoftheIllidari:Exists() and (module.CooldownsAllowed() or module.GetOptionValue("Fury of the Illidari") == "Always") and Player:CanCast(FuryoftheIllidari) then
                    Player:Cast(FuryoftheIllidari);
                    return;
                end
            end
            if Momentum:Exists() and Prepared:Exists() then
                --Vengeful Retreat / Fel Rush / Felblade trick
                if module.IsOptionEnabled("VR | FR | FB Trick") and FelBlade:Exists() then
                    if (Target:CanCast(FelBlade) or (module.GetTime()-VR_FR_FB_Sync < 1 and module.GetTime()-VR_FR_FB_Sync > 0)) and not NoPathFromEvent then
                        if Player:CanCast(VengefulRetreat) and Player:CanCast(FelRush) then
                            Player:Cast(VengefulRetreat);
                            Player:Cast(FelRush);
                            FelBladeTarget = Target;
                            VR_FR_FB_Sync = module.GetTime();
                            return;
                        end
                        if module.GetTime()-VR_FR_FB_Sync > 0.4 and FelBladeTarget and FelBladeTarget:CanCast(FelBlade) then
                            FelBladeTarget:Cast(FelBlade);
                            VR_FR_FB_Sync = -1;
                            return;
                        end
                    end
                -- Vengeful Retreat / Fel Rush trick
                elseif module.IsOptionEnabled("VR | FR Trick") then
                    if Player:CanCast(VengefulRetreat) and Player:CanCast(FelRush) then
                        Player:Cast(VengefulRetreat);
                        Player:Cast(FelRush);
                        return;
                    end
                end
            end
            -- Eye Beam
            if module.IsOptionEnabled("Eye Beam") and EyeBeam:Exists() and (module.CooldownsAllowed() or module.GetSecondOptionValue("Eye Beam") == "Always") and (module.GetOptionValue("Eye Beam") == 1 or (module.GetOptionValue("Eye Beam") > 1 and module.UseAOE())) and EyeBeamNumEnemies >= module.GetOptionValue("Eye Beam") and Player:Standing() >= EyeBeamStanding then
                EyeBeamPooling = true; -- In case we want to pool for EyeBeam
                if Player:CanCast(EyeBeam) then
                    Player:Cast(EyeBeam);
                    return;
                end
            end
            if (EyeBeam:IsOnCooldown() or not EyeBeamPooling) then
                -- AoE Rotation
                if NumEnemies >= 2 then
                    -- Chaos Nova AoE
                    if module.IsOptionEnabled("Chaos Nova") and ChaosNova:Exists() and (module.CooldownsAllowed() or module.GetOptionValue("Chaos Nova") == "Always") and Player:CanCast(ChaosNova) then
                        Player:Cast(ChaosNova);
                        return;
                    end
                    -- Spender AoE
                    if Player:Buff(MetamorphosisBuff) then
                        if Player:CanCast(DeathSweep) then
                            Player:Cast(DeathSweep);
                            return;
                        end
                    else
                        if BladeDance:Exists() and Player:CanCast(BladeDance) then
                            Player:Cast(BladeDance);
                            return;
                        end
                    end
                end
                -- Single Target Rotation
                if module.IsOptionEnabled("Fel Eruption") and FelEruption:Exists() and Target:CanCast(FelEruption) then
                    Target:Cast(FelEruption);
                    return;
                end
                -- Use Blade Dance in Single Target if we have First Blood talent.
                if FirstBlood:Exists() then
                    if Player:Buff(MetamorphosisBuff) then
                        if Player:CanCast(DeathSweep) then
                            Player:Cast(DeathSweep);
                            return;
                        end
                    else
                        if Player:CanCast(BladeDance) then
                            Player:Cast(BladeDance);
                            return;
                        end
                    end
                end
            end
            -- Throw Glaive AoE
            if module.UseAOE() and module.IsOptionEnabled("Throw Glaive") and ThrowGlaive:Exists() then
                if Player:Chain(ThrowGlaive, 3, 10, 30, true) then
                    return;
                else
                    if Player:Chain(ThrowGlaive, 2, 10, 30, true) then
                        return;
                    end
                end
            end
            -- Spender Single
            if (EyeBeam:IsOnCooldown() or not EyeBeamPooling) and (Player:Power() >= Player:PowerMax()*0.6 or Player:Buff(MetamorphosisBuff)) then
                if Player:Buff(MetamorphosisBuff) or MetamorphosisCasted then
                    if Target:CanCast(Annihilation) then
                        Target:Cast(Annihilation);
                        return;
                    end
                else
                    if Target:CanCast(ChaosStrike) then
                        Target:Cast(ChaosStrike);
                        return;
                    end
                end
            end
            -- Fel Blade
            if module.IsOptionEnabled("Felblade") and FelBlade:Exists() and not NoPathFromEvent and (not Momentum:Exists() or (not module.IsOptionEnabled("VR | FR | FB Trick") or VengefulRetreat:Cooldown() > 5)) and Target:CanCast(FelBlade) then
                Target:Cast(FelBlade);
                return;
            end
            -- Demon's Bite
            if Target:CanCast(DemonsBite) then
                Target:Cast(DemonsBite);
                return;
            end
            -- Throw Glaive Out of Range
            if module.IsOptionEnabled("Throw Glaive") and ThrowGlaive:Exists() and Target:CanCast(ThrowGlaive) then
                Target:Cast(ThrowGlaive);
                return;
            end
            return;
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Status Update
        if Momentum:Exists() and Prepared:Exists() then
            if FelBlade:Exists() then
                if module.IsOptionEnabled("VR | FR | FB Trick") then
                    module.SetOutput("Next VR | FR Trick :", tostring(math.floor(math.max(VengefulRetreat:Cooldown(), FelRush:Cooldown(), FelBlade:Cooldown()))).."s");
                else
                    module.SetOutput("Next VR | FR Trick :", "Disabled");
                end
            else
                if module.IsOptionEnabled("VR | FR Trick") then
                    module.SetOutput("Next VR | FR Trick :", tostring(math.floor(math.max(VengefulRetreat:Cooldown(), FelRush:Cooldown()))).."s");
                else
                    module.SetOutput("Next VR | FR Trick :", "Disabled");
                end
            end
        else
            module.SetOutput("Next VR | FR Trick :", "Disabled");
        end
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        -- Engage Target
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            if Player:Buff(MetamorphosisBuff) or MetamorphosisCasted then
                if Target:CanCast(Annihilation) then
                    Target:Cast(Annihilation);
                    return;
                end
            else
                if Target:CanCast(ChaosStrike) then
                    Target:Cast(ChaosStrike);
                    return;
                end
            end
            if module.IsOptionEnabled("Felblade") and FelBlade:Exists() and not NoPathFromEvent and Target:CanCast(FelBlade) then
                Target:Cast(FelBlade);
                return;
            end
            if Target:CanCast(DemonsBite) then
                Target:Cast(DemonsBite);
                return;
            end
            if module.IsOptionEnabled("Throw Glaive") and ThrowGlaive:Exists() and Target:CanCast(ThrowGlaive) then
                Target:Cast(ThrowGlaive);
                return;
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Vengeance Demon Hunter Rotation
    local Rotation = {};
    module.SetRotation(581, Rotation);

    --- Localization
    -- Core
    local TargetEnemies_8y, Enemies_30y, Enemies_5y1, FelDevastationNumEnemies, NumEnemies, NumEnemies_5_1 = {}, {}, {}, 1, 1, 1; -- Enemies
    local SpamPrevention, TPSTime = 0, 0.1; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local NoPathFromEvent, NoPathFromEventPositionX, NoPathFromEventPositionY, NoPathFromEventPositionZ = nil, nil, nil, nil; -- No Path Available Handler
    local FelDevastationStanding = 0.7; -- Time to Stand before casting Fel Devastation (because movements cancel it).

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        --- Spells
        -- (ID, RequiresFacing, Hostile, Instant)
        -- Racials
        ArcaneTorrent = Spell(202719, false, false, true);
        Shadowmeld = Spell(58984, false, false, true);
        -- Items
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Abilities
        ConsumeMagic = Spell(183752, true, true, true);
        DemonSpikes = Spell(203720, false, false, true);
        DemonSpikesBuff = Spell(203819, false, false, true);
        FelBlade = Spell(213241, true, true, true);
        FelDevastation = Spell(212084, false, false, true);
        FelEruption = Spell(211881, true, true, true);
        FieryBrand = Spell(204021, true, true, true);
        Fracture = Spell(209795, true, true, true);
        ImmolationAura = Spell(178740, false, false, true);
        RazorSpikes = Spell(209400, false, false, true);
        Shear = Spell(203782, true, true, true);
        SigilofFlame = Spell(204596, false, true, true);
        SpiritBomb = Spell(218679, false, true, true);
        SpiritBombDebuff = Spell(218677, false, false, true);
        SoulCleave = Spell(203798, true, true, true);
        SoulFragments = Spell(203981, false, true, true);
        ThrowGlaive = Spell(204157, true, true, true);
        Torment = Spell(185245, false, true, true);
        -- Offensive Cooldowns
        Metamorphosis = Spell(187827, false, false, true);
        SoulCarver = Spell(207407, true, true, true);
        -- Defensive Cooldowns
        EmpowerWards = Spell(218256, false, false, true);

        --- GUI Frame
        -- Pages
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {6, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest", "Untanked"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_SUBVALUE("Untanked").."Integrate tanking logic that will priorise the untaked units."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.TauntManagerOptions("Torment");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Consume Magic to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Fiery Brand", 223, true, {100, 1, 100, 1}, {2, "Always", "Cooldown Only"}, "Enable for the automatic usage of Fiery Brand."..C.TOOLTIP_VALUE_1.."Minimum Health Percentage required to use it."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Soul Carver", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Soul Carver."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Metamorphosis", 210, true, nil, nil, "Enable for the automatic usage of Metamorphosis.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Only Arcane Torrent is supported."));
        end
        module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Disabled", "Enabled"}, {2, "Disabled", "Enabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Fel Devastation", 222, true, {1, 1, 5, 1}, {100, 1, 100, 1}, "Enable for the automatic usage of Fel Devastation."..C.TOOLTIP_VALUE_1.."Number of enemies required in front of you."..C.TOOLTIP_VALUE_2.."Minimum Health Percentage required to use it.");
        module.AddNewOption("Offensive Settings", "Sigil of Flame", 210, true, nil, nil, "Enable for the automatic usage of Sigil of Flame.");
        module.AddNewOption("Offensive Settings", "Fel Eruption", 210, true, nil, nil, "Enable for the automatic usage of Fel Eruption.");
        module.AddNewOption("Offensive Settings", "Immolation Aura", 210, true, nil, nil, "Enable for the automatic usage of Immolation Aura.");
        module.AddNewOption("Offensive Settings", "Felblade", 210, true, nil, nil, "Enable for the automatic usage of Felblade.");
        module.AddNewOption("Offensive Settings", "Throw Glaive", 210, true, nil, nil, "Enable for the automatic usage of Throw Glaive.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Health Percentage to use Healing Belt / Healing Pot / Healthstone.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Demon Spikes", 220, true, {80, 1, 100, 1}, nil, "Health Percentage to use Demon Spikes.");
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, false, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Empower Wards", 220, true, {60, 1, 100, 1}, nil, "Health Percentage to use Empower Wards.");

        --- Misc
        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
        -- No Path Available Handler Event Register
        local PathFrame = CreateFrame("FRAME", "PathFrameFrame");
        PathFrame:RegisterEvent("UI_ERROR_MESSAGE");
        local function PathCheck(Self, Event, Message)
            -- Legion Alpha Message : SPELL_FAILED_NOPATH = 50;
            if Message == SPELL_FAILED_NOPATH or Message == 50 then
                NoPathFromEvent = true;
                NoPathFromEventPositionX, NoPathFromEventPositionY, NoPathFromEventPositionZ = Player:Position():Expand();
            end
        end
        PathFrame:SetScript("OnEvent", PathCheck);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Empower Wards") and Player:HealthPercentage() <= module.GetOptionValue("Empower Wards") and (EmpowerWards:Exists() and Player:Level() >= 100) and not Player:Buff(EmpowerWards) and Player:CanCast(EmpowerWards) then
            Player:Cast(EmpowerWards);
        end
        if module.IsOptionEnabled("Demon Spikes") and Player:HealthPercentage() <= module.GetOptionValue("Demon Spikes") and not Player:Buff(DemonSpikesBuff) and Player:CanCast(DemonSpikes) then
            Player:Cast(DemonSpikes);
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(ConsumeMagic, ArcaneTorrent);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(Shear, false) or Unit.Target;
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            --- Enemies Check
            if module.UseAOE() then
                TargetEnemies_8y = Target:EnemiesWithinDistance(8, false, false, false);
                Enemies_30y = Player:EnemiesWithinDistance(30, false); -- Used for Torment
                Enemies_5y1 = Player:FilterEnemiesByDistance(Enemies_30y, 5.1, false, false, true); -- Take Enemies in 5.1y range and 180 cone.
                NumEnemies = #TargetEnemies_8y;
                NumEnemies_5_1 = #Enemies_5y1;
            else
                NumEnemies = 1;
                NumEnemies_5_1 = 1;
            end

            -- Torment
            if Player:TauntManager(Torment, "Torment", Target, Enemies_30y) then
                return;
            end

            -- Fel Devastation Handler
            if module.IsOptionEnabled("Fel Devastation") and FelDevastation:Exists() then
                FelDevastationNumEnemies = #Player:UnitsInFrontRectangle(16, 3); -- Same as Eye Beam : Measured on 04/18/2016 : 7.0.3.21491 (Normal Range + Pythagore for Width)
            end
            -- No Path Available Handler (Check if we moved or not since last error)
            if NoPathFromEvent then
                local X, Y, Z = Player:Position():Expand();
                if NoPathFromEventPositionX ~= X or NoPathFromEventPositionY ~= Y or NoPathFromEventPositionZ ~= Z then
                    NoPathFromEvent = false;
                    NoPathFromEventPositionX, NoPathFromEventPositionY, NoPathFromEventPositionZ = nil, nil, nil;
                end
            end

            if Player:IsWithinCastRange(Target, Shear) then
                --- Cooldowns
                if module.CooldownsAllowed() then
                    -- Metamorphosis
                    if module.IsOptionEnabled("Metamorphosis") and (Player:Level() >= 110 or (Metamorphosis:Exists() and IsQuestFlaggedCompleted(40051))) and not Player:Buff(Metamorphosis) and Player:CanCast(Metamorphosis) then
                        Player:Cast(Metamorphosis);
                    end
                    -- Trinkets
                    if Trinket1:IsUsableInventory() and module.GetOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket1:UseInventory();
                    end
                    if Trinket2:IsUsableInventory() and module.GetSecondOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket2:UseInventory();
                    end
                end
                -- Arcane Torrent
                if ArcaneTorrent:Exists() and module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:Power() < 80 and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent);
                    return;
                end
                -- Fiery Brand
                if module.IsOptionEnabled("Fiery Brand") and (Player:Level() >= 110 or (FieryBrand:Exists() and (IsQuestFlaggedCompleted(40253) or IsQuestFlaggedCompleted(38723)))) and (module.CooldownsAllowed() or module.GetSecondOptionValue("Fiery Brand") == "Always") and Player:HealthPercentage() <= module.GetOptionValue("Fiery Brand") and Target:CanCast(FieryBrand) then
                    Target:Cast(FieryBrand);
                end
                -- Soul Carver
                if module.IsOptionEnabled("Soul Carver") and SoulCarver:Exists() and (module.CooldownsAllowed() or module.GetOptionValue("Soul Carver") == "Always") and Target:CanCast(SoulCarver) then
                    Target:Cast(SoulCarver);
                    return;
                end
            end
            -- Spirit Bomb Talent (Keep Debuff on Target)
            if SpiritBomb:Exists() and Target:DebuffRemains(SpiritBombDebuff) < 1 and Player:Buff(SoulFragments) and Target:CanCast(SpiritBomb) then
                Target:Cast(SpiritBomb);
                return;
            end
            -- Fel Devastation
            if module.IsOptionEnabled("Fel Devastation") and FelDevastation:Exists() and Player:HealthPercentage() <= module.GetSecondOptionValue("Fel Devastation") and (module.GetOptionValue("Fel Devastation") == 1 or (module.GetOptionValue("Fel Devastation") > 1 and module.UseAOE())) and FelDevastationNumEnemies >= module.GetOptionValue("Fel Devastation") and Player:Standing() >= FelDevastationStanding and Player:CanCast(FelDevastation) then
                Player:Cast(FelDevastation);
                return;
            end
            -- Immolation Aura
            if module.IsOptionEnabled("Immolation Aura") and (Player:Level() >= 110 or (ImmolationAura:Exists() and (IsQuestFlaggedCompleted(40254) or IsQuestFlaggedCompleted(39683)))) and Player:IsWithinCastRange(Target, Shear) and Player:CanCast(ImmolationAura) then
                Player:Cast(ImmolationAura);
                return;
            end
            -- Sigil of Flame
            if module.IsOptionEnabled("Sigil of Flame") and SigilofFlame:Exists() and NumEnemies >= 2 and Target:CanCast(SigilofFlame) and Player:CastGround(SigilofFlame, 2, 8, 30, true) then
                return;
            end
            -- Fel Eruption
            if module.IsOptionEnabled("Fel Eruption") and FelEruption:Exists() and Target:CanCast(FelEruption) then
                Target:Cast(FelEruption);
                return;
            end
            -- Spenders
            if Player:Power() >= 60 then
                -- Soul Cleave AoE
                if NumEnemies_5_1 >= 2 and Target:CanCast(SoulCleave) then
                    Target:Cast(SoulCleave);
                    return;
                end
                -- Fracture
                if Fracture:Exists() then
                    if Target:CanCast(Fracture) then
                        Target:Cast(Fracture);
                        return;
                    end
                -- Soul Cleave Single Target
                elseif Target:CanCast(SoulCleave) then
                    Target:Cast(SoulCleave);
                    return;
                end
            end
            -- Fel Blade
            if module.IsOptionEnabled("Felblade") and FelBlade:Exists() and not NoPathFromEvent and Target:CanCast(FelBlade) then
                Target:Cast(FelBlade);
                return;
            end
            -- Shear
            if Target:CanCast(Shear) then
                Target:Cast(Shear);
                return;
            end
            -- Throw Glaive Out of Range
            if module.IsOptionEnabled("Throw Glaive") and Target:CanCast(ThrowGlaive) then
                Target:Cast(ThrowGlaive);
                return;
            end
            return;
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        -- Engage Target
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Fel Blade
            if module.IsOptionEnabled("Felblade") and FelBlade:Exists() and not NoPathFromEvent and Target:CanCast(FelBlade) then
                Target:Cast(FelBlade);
                return;
            end
            -- Shear
            if Target:CanCast(Shear) then
                Target:Cast(Shear);
                return;
            end
            -- Throw Glaive Out of Range
            if module.IsOptionEnabled("Throw Glaive") and Target:CanCast(ThrowGlaive) then
                Target:Cast(ThrowGlaive);
                return;
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Balance Druid
    local Rotation = {};
    module.SetRotation(102, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local UpdateInterruptPercentage, InterruptPercentage = 0, 0; -- Interrupt Handler
    local MainTankResDelay, OffTankResDelay = nil, nil; -- Main Tank Resurrection
    local Enemies, TyphoonUnits, PlayerEnemies_10y, Enemies_20y, Enemies_5y, MoonfireUnit, SunfireUnit, NumEnemies = {}, {}, {}, {}, {}, nil, nil, 0; -- Units
    local StellarFlareUnit = nil;
    -- Healers Specific
    local MainTank, MainTankTarget, OffTank, OffTankTarget, Lowest, HealUnits = nil, nil, nil, nil, nil, {};
    local StarfallAstralPower = 60;

    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        IntellectPotion = Item(109218, false, false, true);
        IntellectPotionBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        AstralCommunion = Spell(202359, false, false, true); -- lvl 90 grants 75 Astral Power
        Barkskin = Spell(22812, false, false, true);-- As Usual
        BearForm = Spell(5487, false, false, true);
        CatForm = Spell(768, false, false, true);
        CelestialAlignment = Spell(194223, false, false, true);
        DisplacerBeast = Spell(137452, false, false , true);
        ForceOfNature = Spell(205636, false, true, true); -- lvl 15 talent - Like Meteor but good for ST
        FullMoon = Spell(202771, false, true, false);
        FuryOfElune = Spell(202770, true, true, true);
        HalfMoon = Spell(202768, false, true, false);
        HealingTouch = Spell(5185, false, false, false); -- As usual
        Incarnation = Spell(102560, false, false, true);
        LunarEmpowerment = Spell(164547);
        Moonfire = Spell(8921, true, true, true);
        MoonfireDebuff = Spell(164812);
        MoonkinForm = Spell(24858, false, false, true);
        NewMoon = Spell(202767, false, true, false);
        Rebirth = Spell(20484, false, false, false, true);
        Renewal = Spell(108238, false, false, true);
        SolarBeam = Spell(78675, true, true, true);
        SolarEmpowerment = Spell(164545);
        SoulOfTheForest = Spell(114107);
        Starfall = Spell(191034, false, true, true);
        StarfallBuff = Spell(184989);
        LunarStrike = Spell(194153, true, true, false);
        Starsurge = Spell(78674, true, true, true);
        StellarFlare = Spell(202347, true, true, false);
        Sunfire = Spell(93402, true, true, true);
        SunfireDebuff = Spell(164815);
        TravelForm = Spell(783, false, false, true);
        SolarWrath = Spell(190984, true, true, false);
        WarriorOfElune = Spell(202425, false, false, true);

        FeralAffinity = Spell(202157);
        FerociousBite = Spell(22568 , true, true, true);
        Rip = Spell(1079 , true, true, true);
        Shred = Spell(5221 , true, true, true);
        Swipe = Spell(106785 , false, false, true);

        GuardianAffinity = Spell(197491);
        FrenziedRegeneration = Spell(22842, false, false, true);
        Ironfur = Spell(192081, false, false, true);
        Mangle = Spell(33917, true, true, true);
        Thrash = Spell(77758, false, false, true);
        ThrashDebuff = Spell(192090);

        RestorationAffinity = Spell(197492);
        Regrowth = Spell(8936, false, false, false);
        Rejuvenation = Spell(774, false, false, true);
        Swiftmend = Spell(18562, false, false, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Moonkin Form", 210, true, nil, nil, "Use Moonkin Form.");
        module.AddNewOption("General Settings", "Rebirth", 210, true, nil, nil, "Enable to automatically resurrect targeted dead player targets in combat.");
        module.AddNewOption("General Settings", "Instant Rebirth Tank", 220, true, {2, 0, 3, 0.1}, nil, "Enable to use Rebirth to resurrect a dead Tank."..C.TOOLTIP_VALUE.."Set the delay before using it.");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Solar Beam to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our LunarStrike to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Astral Communion", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Astral Communion."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Celestial Alignment", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Celestial Alignment."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Force Of Nature", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Force Of Nature."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Incarnation", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Incarnation."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Warrior Of Elune", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Warrior Of Elune."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Full Moon", 120, true, {2, 1, 10, 1}, nil, "Full Moon with artifact."..C.TOOLTIP_VALUE.."Amount of units needed within 5 yards of target to use Full Moon.");
        module.AddNewOption("Offensive Settings", "Fury Of Elune", 120, true, {2, 1, 10, 1}, nil, "Use Fury Of Elune."..C.TOOLTIP_HINT("If you have the artifact Weapon, Fury Of Elune will be used when Full Moon is Ready to be used."));
        module.AddNewOption("Offensive Settings", "Multi-Dot Moonfire", 222, false, { 5, 1, 10, 1 }, { 3, 0, 25, 0.1 }, "Multi-Dot Moonfire Cycle."..C.TOOLTIP_VALUE_1.."Number of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Stellar Flare", 222, false, { 10, 1, 10, 1 }, { 3, 0, 25, 0.1 }, "Multi-Dot Stellar Flare Cycle."..C.TOOLTIP_VALUE_1.."Number of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Sunfire", 222, false, { 10, 1, 10, 1 }, { 3, 0, 25, 0.1 }, "Multi-Dot Sunfire Cycle."..C.TOOLTIP_VALUE_1.."Number of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Moonfire While Moving", 220, true, { 0.7, 0, 4, 0.1 }, nil, "Time to wait in seconds before using Moonfire/Sunfire filler while moving.");
        module.AddNewOption("Offensive Settings", "Starsurge", 210, true, nil, nil, "Use Starsurge.");
        module.AddNewOption("Offensive Settings", "Starfall", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {2, 1, 25, 1}, "Use Starfall."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Target").."Always use on the current target."..C.TOOLTIP_SUBVALUE("Target Standing").."Always use on the current target. Target must be standing still."..C.TOOLTIP_SUBVALUE("Centered").."Use centered on a cluster of enemies."..C.TOOLTIP_SUBVALUE("Centered Standing").."Use centered on a cluster of enemies. Enemies must be standing still."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the spell effect to use.");
        module.AddSection("Offensive Settings", "Feral Affinity", "Green");
        module.AddNewOption("Offensive Settings", "Feral Affinity", 210, false, nil, nil, "Enable Feral Affinity DPS.");
        module.AddNewOption("Offensive Settings", "Rip", 210, true, nil, nil, "Use Rip.");
        module.AddNewOption("Offensive Settings", "Swipe", 220, true, {3, 1, 10, 1}, nil, "Use Swipe."..C.TOOLTIP_VALUE.."Amount of units needed within 10 yards of player to use Swipe.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Barkskin", 220, true, {40, 1, 100, 1}, nil, "Use Barkskin."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Rejuvenation Self", 220, true, {30, 1, 100, 1}, nil, "Use Rejuvenation on ourself."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Healing Touch Self", 222, true, {30, 1, 100, 1}, {80, 1, 100, 1}, "Use Healing Touch on ourself."..C.TOOLTIP_VALUE_1.."Health threshold while In Combat."..C.TOOLTIP_VALUE_2.."Health threshold while Out of Combat.");
        module.AddNewOption("Defensive Settings", "Renewal", 220, true, {30, 1, 100, 1}, nil, "Use Renewal on ourself."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Restoration Affinity", "Green");
        module.AddNewOption("Defensive Settings", "Restoration Affinity", 210, false, nil, nil, "Enable Restoration Affinity Healing.");
        module.AddNewOption("Defensive Settings", "Healing Touch", 222, true, {95, 0, 100, 1}, {90, 0, 100, 1}, "Use Healing Touch."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Defensive Settings", "Regrowth", 222, true, {35, 0, 100, 1}, {25, 0, 100, 1}, "Use Regrowth."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Defensive Settings", "Rejuvenation", 222, true, {85, 0, 100, 1}, {80, 0, 100, 1}, "Use Rejuvenation."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Defensive Settings", "Swiftmend", 222, true, {40, 0, 100, 1}, {25, 0, 100, 1}, "Use Swiftmend."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddSection("Defensive Settings", "Guardian Affinity", "Green");
        module.AddNewOption("Defensive Settings", "Guardian Affinity", 210, false, nil, nil, "Enable Guardian Affinity Tanking.");
        module.AddNewOption("Defensive Settings", "Frenzied Regeneration", 220, true, {35, 1, 100, 1}, nil, "Use Frenzied Regeneration."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Ironfur", 220, true, {90, 1, 100, 1}, nil, "Use Ironfur."..C.TOOLTIP_VALUE.."Health threshold.");


        module.AddOutput("|cFF9A2EFEMain Tank:");
        module.AddOutput("|cFF9A2EFEOff Tank:");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [HalfMoon:ID()] = "Half Moon",
            [HealingTouch:ID()] = "Healing Touch",
            [LunarStrike:ID()] = "Lunar Strike",
            [NewMoon:ID()] = "New Moon",
            [Regrowth:ID()] = "Regrowth",
            [SolarWrath:ID()] = "Solar Wrath",
            [StellarFlare:ID()] = "Stellar Flare"
        };
    end

    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end
        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        local OpenerSpell = NewMoon:Exists() and NewMoon or LunarStrike;
        -- 1) Incarnation
        if BMPullTime() < OpenerSpell:CastTime() + Player:GCD() + module.GetSecondOptionValue("Pre-Pull BossMod") and Target:CanCast(OpenerSpell) and Incarnation:Exists() and module.IsOptionEnabled("Incarnation") and (module.CooldownsAllowed() or module.GetOptionValue("Incarnation") == "Always") and Player:CanCast(Incarnation) then
            Player:Cast(Incarnation);
            return;
        end
        -- 2) Potion
        if module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) and Player:IsWithinCastRange(Target, OpenerSpell) then
            if Player:Potion("Intellect", Potion) then module.Bug("Pre-Pull - Intellect Potion"); Potion = true; end
        end
        -- 3) New Moon / Lunar Strike
        if BMPullTime() < OpenerSpell:CastTime() + module.GetSecondOptionValue("Pre-Pull BossMod") and Target:CanCast(OpenerSpell) then
            Target:Cast(OpenerSpell);
            return;
        end
    end

    function Rotation:Interrupts ()
        Player:UseInterrupt(SolarBeam);
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- barkskin
        if module.IsOptionEnabled("Barkskin") and Player:HealthPercentage() <= module.GetOptionValue("Barkskin") and Player:CanCast(Barkskin) then
            Player:Cast(Barkskin);
        end
    end

    function Rotation:OffGCDAbilities ()
        -- Guardian Affinity
        if GuardianAffinity:Exists() and module.IsOptionEnabled("Guardian Affinity") and Player:Buff(BearForm) then
            -- Ironfur
            if module.IsOptionEnabled("Ironfur") and Player:CanCast(Ironfur) then
                if Player:Rage() >= 85 or (Player:HealthPercentage() <= module.GetOptionValue("Ironfur") and Player:Rage() >= 40 and not Player:Buff(Ironfur)) then
                    Player:Cast(Ironfur);
                    return;
                end
            end
            -- Frenzied Regeneration
            if module.IsOptionEnabled("Frenzied Regeneration") and Player:CanCast(FrenziedRegeneration) and not Player:Buff(FrenziedRegeneration) then
                if Player:HealthPercentage() <= module.GetOptionValue("Frenzied Regeneration") and Player:Rage() >= 10 then
                    Player:Cast(FrenziedRegeneration);
                    return;
                end
            end
        end
        -- Astral Communion
        if AstralCommunion:Exists() and module.IsOptionEnabled("Astral Communion") and (module.CooldownsAllowed() or module.GetOptionValue("Astral Communion") == "Always") and Player:AstralPower() < 15 and (not FuryOfElune:Exists() or FuryOfElune:TimeSinceCast() < 15) and Player:CanCast(AstralCommunion) then
            Player:Cast(AstralCommunion);
            return;
        end
    end

    local function AstralDump (Energy, Delay)
        -- Starfall
        if Starfall:Exists() and module.IsOptionEnabled("Starfall") and Player:AstralPower() >= Energy and Target:CanCast(Starfall) then
            if Target:CastGroundSpell(Starfall, "Starfall", 20) then return; end
        end
        -- Starsurge
        if Starsurge:Exists() and module.IsOptionEnabled("Starsurge") and (Player:AstralPower() >= 90 or (not Delay and Player:AstralPower() >= Energy)) and Target:CanCast(Starsurge) then
            Target:Cast(Starsurge);
            return;
        end
    end

    local function HealCycle (Spell, SpellOption, SpellBuff)
        if Spell:Exists() and module.IsOptionEnabled(SpellOption) then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue(SpellOption) and (not SpellBuff or MainTank:BuffRemains(SpellBuff) < 3) and MainTank:CanHeal(Spell) then
                MainTank:Cast(Spell);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue(SpellOption) and (not SpellBuff or OffTank:BuffRemains(SpellBuff) < 3) and OffTank:CanHeal(Spell) then
                OffTank:Cast(Spell);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue(SpellOption) and (not SpellBuff or Lowest:BuffRemains(SpellBuff) < 3) and Lowest:CanCast(Spell) then
                Lowest:Cast(Spell);
                return;
            end
            if SpellBuff then
                -- Cycle
                for i = 1, #HealUnits do
                    local ThisUnit = HealUnits[i];
                    if ThisUnit:CanHeal(Spell) and ThisUnit:BuffRemains(Spell) < 3 and ThisUnit:SpecialHealthPercentage() <= module.GetSecondOptionValue(SpellOption) then
                        ThisUnit:Cast(Spell);
                        return;
                    end
                end
            end
        end
    end

    function Rotation:Combat ()
        -- Rejuvenation
        if module.IsOptionEnabled("Rejuvenation Self") and Player:HealthPercentage() <= module.GetOptionValue("Rejuvenation Self") and Player:CanCast(Rejuvenation) and not Player:Buff(Rejuvenation) then
            Player:Cast(Rejuvenation);
            return;
        end
        -- Healing Touch
        if HealingTouch:Exists() and module.IsOptionEnabled("Healing Touch Self") and Player:HealthPercentage() <= module.GetOptionValue("Healing Touch Self") and Player:CanCast(HealingTouch) then
            Player:Cast(HealingTouch);
            return;
        end
        -- Renewal
        if Renewal:Exists() and module.IsOptionEnabled("Renewal") and Player:HealthPercentage() <= module.GetOptionValue("Renewal") and Player:CanCast(Renewal) then
            Player:Cast(Renewal);
            return;
        end
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();
        -- Combat Res Tanks
        if MainTank and MainTank:Exists() and not MainTank:IsDeadOrGhost() then MainTankResDelay = nil; end
        if OffTank and OffTank:Exists() and not OffTank:IsDeadOrGhost() then OffTankResDelay = nil; end
        if module.IsOptionEnabled("Instant Rebirth Tank") then
            if MainTank and MainTank:Exists() and MainTank:IsDeadOrGhost() and MainTank:IsPlayer() and MainTank:CanCast(Rebirth) then
                if not MainTankResDelay then MainTankResDelay = module.GetTime(); end
                if module.GetTime()-MainTankResDelay >= module.GetOptionValue("Instant Rebirth Tank") then
                    MainTankResDelay = nil;
                    MainTank:Cast(Rebirth);
                    return;
                end
            elseif OffTank and OffTank:Exists() and OffTank:IsDeadOrGhost() and OffTank:IsPlayer() and OffTank:CanCast(Rebirth) then
                if not OffTankResDelay then OffTankResDelay = module.GetTime(); end
                if module.GetTime()-OffTankResDelay >= module.GetOptionValue("Instant Rebirth Tank") then
                    OffTankResDelay = nil;
                    OffTank:Cast(Rebirth);
                    return;
                end
            end
        end
        -- Combat Res Target
        if Rebirth:Exists() and module.IsOptionEnabled("Rebirth") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and Target:IsPlayer() and Target:CanCast(Rebirth) then
            Target:Cast(Rebirth);
            return;
        end
        -- Restoration Affinity
        if RestorationAffinity:Exists() and module.IsOptionEnabled("Restoration Affinity") then
            HealUnits = Player:HealUnitsAround(100, 40) or {};
            Lowest = Unit.Lowest(MainTank, OffTank);
            -- Swiftmend
            if Swiftmend:Exists() and module.IsOptionEnabled("Swiftmend") and not Swiftmend:IsOnCooldown() then
                if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Swiftmend") and (MainTank:Buff(Rejuvenation) or MainTank:Buff(Regrowth)) and MainTank:CanHeal(Swiftmend) then
                    MainTank:Cast(Swiftmend);
                    return;
                end
                if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Swiftmend") and (OffTank:Buff(Rejuvenation) or OffTank:Buff(Regrowth)) and OffTank:CanHeal(Swiftmend) then
                    OffTank:Cast(Swiftmend);
                    return;
                end
                if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Swiftmend") and (Lowest:Buff(Rejuvenation) or Lowest:Buff(Regrowth)) and Lowest:CanHeal(Swiftmend) then
                    Lowest:Cast(Swiftmend);
                    return;
                end
            end
            -- Regrowth Cycle
            HealCycle(Regrowth, "Regrowth", Regrowth);
            -- Rejuvenation Cycle
            HealCycle(Rejuvenation, "Rejuvenation", Rejuvenation);
            -- Healing Touch
            HealCycle(HealingTouch, "Healing Touch", nil);
        end
        -- Determine if we have enough time to use Celestial Alignment
        if Target:Exists() and Player:CanAttack(Target)  then
            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                Enemies = Player:EnemiesWithinDistance(40); -- 40 yards for Dots Cycles.
                MoonfireUnit = Unit.DotCycle(Enemies, Moonfire, MoonfireDebuff, 22, "Multi-Dot Moonfire"); -- Moonfire DoT Cycle
                SunfireUnit = Unit.DotCycle(Enemies, Sunfire, SunfireDebuff, 18, "Multi-Dot Sunfire"); -- Sunfire DoT Cycle
                StellarFlareUnit = Unit.DotCycle(Enemies, StellarFlare, StellarFlare, 24, "Multi-Dot Stellar Flare"); -- Stellar Flare DoT Cycle
                StarfallAstralPower = SoulOfTheForest:Exists() and 50 or 60;
                Enemies_20y = Target:EnemiesWithinDistance(20, true); -- 20 yards for Starfall.
                Enemies_5y = Target:FilterEnemiesByDistance(Enemies_20y, 5, true); -- 5 yards for Lunar Strike.
                PlayerEnemies_10y = FeralAffinity:Exists() and module.IsOptionEnabled("Feral Affinity") and module.IsOptionEnabled("Swipe") and Player:EnemiesWithinDistance(10, true) or {};
                NumEnemies = #Enemies_5y;
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- Guardian Affinity
            if GuardianAffinity:Exists() and module.IsOptionEnabled("Guardian Affinity") then
                -- Apply Bear Form
                if not Player:Buff(BearForm) and Player:CanCast(BearForm) then
                    Player:Cast(BearForm);
                    return;
                end
                -- Bear DPS
                if Player:IsWithinCastRange(Target, Mangle) then
                    if not Target:Debuff(ThrashDebuff) and Player:CanCast(Thrash) then
                        Player:Cast(Thrash);
                        return;
                    end
                    if Target:CanCast(Mangle) then
                        Target:Cast(Mangle);
                        return;
                    end
                    if Player:CanCast(Thrash) then
                        Player:Cast(Thrash);
                        return;
                    end
                end
                -- Full Moon
                if NewMoon:Exists() and NewMoon:CurrentID() == FullMoon.Identifier and Target:CanCast(NewMoon) and (NumEnemies >= module.GetOptionValue("Full Moon") or NewMoon:Charges() >= 3 or (NewMoon:Charges() >= 2 and NewMoon:Recharge() < 5)) then
                    Target:Cast(NewMoon);
                    return;
                end
                -- Dump Moon
                if NewMoon:Exists() and Target:CanCast(NewMoon) and (NewMoon:Charges() >= 3 or (NewMoon:Charges() >= 2 and NewMoon:Recharge() < 5)) then
                    Target:Cast(NewMoon);
                    return;
                end
                -- Apply Moonfire
                if Moonfire:Exists() then
                    if Target:DebuffRemains(MoonfireDebuff) < 6 and Target:CanCast(Moonfire) then
                        Target:Cast(Moonfire);
                        return;
                    end
                    if module.IsOptionEnabled("Multi-Dot Moonfire") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                        MoonfireUnit:Cast(Moonfire);
                        return;
                    end
                end
                -- New Moon
                if NewMoon:Exists() and NewMoon:CurrentID() == NewMoon.Identifier and Target:CanCast(NewMoon) then
                    Target:Cast(NewMoon);
                    return;
                end
                -- Half Moon
                if NewMoon:Exists() and NewMoon:CurrentID() == HalfMoon.Identifier and Target:CanCast(NewMoon) then
                    Target:Cast(NewMoon);
                    return;
                end
                return;
            end

            -- Feral Affinity
            if FeralAffinity:Exists() and module.IsOptionEnabled("Feral Affinity") then
                -- Apply Cat Form
                if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
                    Player:Cast(CatForm);
                    return;
                end
                -- Use Combos
                -- Rip with 5 Combo Points
                if Rip:Exists() and module.IsOptionEnabled("Rip") and Player:ComboPoints() >= 5 and Target:DebuffRemains(Rip) < 6 then
                    Target:Cast(Rip);
                    return;
                end
                -- Ferocious Bite with 5 Combo Points or less than 5 second till death
                if FerociousBite:Exists() and (Player:ComboPoints() >= 5 or Target:TimeToDie() < 5) then
                    Target:Cast(FerociousBite);
                    return;
                end

                -- Use Energy
                -- Swipe
                if module.IsOptionEnabled("Swipe") and #PlayerEnemies_10y >= module.GetOptionValue("Swipe") then
                    if Player:CanCast(Swipe) then
                        Player:Cast(Swipe);
                        return;
                    end
                else
                    -- Shred
                    if Target:CanCast(Shred) then
                        Target:Cast(Shred);
                        return;
                    end
                end

                -- Dump Moon
                if NewMoon:Exists() and Target:CanCast(NewMoon) and (NewMoon:Charges() >= 3 or (NewMoon:Charges() >= 2 and NewMoon:Recharge() < 5)) then
                    Target:Cast(NewMoon);
                    return;
                end
                -- New Moon
                if NewMoon:Exists() and NewMoon:CurrentID() == NewMoon.Identifier and Target:CanCast(NewMoon) then
                    Target:Cast(NewMoon);
                    return;
                end
                -- Half Moon
                if NewMoon:Exists() and NewMoon:CurrentID() == HalfMoon.Identifier and Target:CanCast(NewMoon) then
                    Target:Cast(NewMoon);
                    return;
                end
                return;
            end

            -- Moonkin Form
            if MoonkinForm:Exists() and module.IsOptionEnabled("Moonkin Form") and not Player:Buff(MoonkinForm) and Player:CanCast(MoonkinForm) and (not Player:Buff(CatForm) or Player:Buff(DisplacerBeast)) and not Player:Buff(BearForm) and not Player:Buff(TravelForm) then
                Player:Cast(MoonkinForm);
                return;
            end
            -- Cooldowns
            if Player:IsWithinCastRange(Target, SolarWrath) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Celestial Alignment
                if not Incarnation:Exists() and CelestialAlignment:Exists() and module.IsOptionEnabled("Celestial Alignment") and (module.CooldownsAllowed() or module.GetOptionValue("Celestial Alignment") == "Always") and Player:CanCast(CelestialAlignment) then
                    Player:Cast(CelestialAlignment);
                    return;
                end
                -- Force Of Nature
                if ForceOfNature:Exists() and module.IsOptionEnabled("Force Of Nature") and (module.CooldownsAllowed() or module.GetOptionValue("Force Of Nature") == "Always") and Target:CanCast(ForceOfNature) then
                    Target:Cast(ForceOfNature);
                    return;
                end
                -- Timing Warrior Of Elune with Celestial Alignment
                local CelestialAlignmentReady = not Incarnation:Exists() and CelestialAlignment:Exists() and module.IsOptionEnabled("Celestial Alignment") and (module.CooldownsAllowed() or module.GetOptionValue("Celestial Alignment") == "Always") and CelestialAlignment:Cooldown() or Incarnation:Exists() and module.IsOptionEnabled("Incarnation") and (module.CooldownsAllowed() or module.GetOptionValue("Incarnation") == "Always") and CelestialAlignment:Cooldown() or 100;
                -- Warrior Of Elune
                if WarriorOfElune:Exists() and module.IsOptionEnabled("Warrior Of Elune") and (module.CooldownsAllowed() or module.GetOptionValue("Warrior Of Elune") == "Always") and CelestialAlignmentReady > 40 and Player:CanCast(WarriorOfElune) then
                    Player:Cast(WarriorOfElune);
                    return;
                end
                -- Incarnation
                if Incarnation:Exists() and module.IsOptionEnabled("Incarnation") and (module.CooldownsAllowed() or module.GetOptionValue("Incarnation") == "Always") and Player:CanCast(Incarnation) then
                    Player:Cast(Incarnation);
                    return;
                end
            end

            -- Rotation
            -- Full Moon
            if NewMoon:Exists() and NewMoon:CurrentID() == FullMoon.Identifier and Target:CanCast(NewMoon) and (NumEnemies >= module.GetOptionValue("Full Moon") or NewMoon:Charges() >= 3 or (NewMoon:Charges() >= 2 and NewMoon:Recharge() < 5)) then
                if FuryOfElune:Exists() and module.IsOptionEnabled("Fury Of Elune") then
                    if not Target:IsMoving() and ((#Enemies_20y > module.GetSecondOptionValue("Starfall") and Player:AstralPower() >= StarfallAstralPower) or Player:AstralPower() >= 90) and (not AstralCommunion:Exists() or AstralCommunion:Cooldown() < 5) and Target:CanCast(FuryOfElune) then
                        Target:Cast(FuryOfElune);
                        FuryOfElune.LastCastTime = module.GetTime();
                        return;
                    end
                    if FuryOfElune:TimeSinceCast() < 10 and Player:AstralPower() < 70 then
                        module.Bug("Full Moon");
                        Target:Cast(NewMoon);
                        return;
                    end
                else
                    -- Starsurge/Starfall with 60 Astral Power
                    AstralDump(60);
                    module.Bug("Full Moon");
                    Target:Cast(NewMoon);
                    return;
                end
            end
            -- Starsurge/Starfall with 90 Astral Power
            AstralDump(90);
            -- Sunfire
            if Sunfire:Exists() then
                if Target:DebuffRemains(SunfireDebuff) < 5 and Target:CanCast(Sunfire) then
                    Target:Cast(Sunfire);
                    return;
                end
                if module.IsOptionEnabled("Multi-Dot Sunfire") and SunfireUnit and SunfireUnit:CanCast(Sunfire) then
                    SunfireUnit:Cast(Sunfire);
                    return;
                end
            end
            -- Apply Moonfire
            if Moonfire:Exists() then
                if Target:DebuffRemains(MoonfireDebuff) < 6 and Target:CanCast(Moonfire) then
                    Target:Cast(Moonfire);
                    return;
                end
                if module.IsOptionEnabled("Multi-Dot Moonfire") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                    MoonfireUnit:Cast(Moonfire);
                    return;
                end
            end
            -- Stellar Flare
            if StellarFlare:Exists() then
                if Target:DebuffRemains(StellarFlare) < 5 and Target:CanCast(StellarFlare) then
                    Target:Cast(StellarFlare);
                    return;
                end
                if module.IsOptionEnabled("Multi-Dot Stellar Flare") and StellarFlareUnit and StellarFlareUnit:CanCast(StellarFlare) then
                    StellarFlareUnit:Cast(StellarFlare);
                    return;
                end
            end
            -- Lunar Strike with 3 Lunar Empowerments or Warrior Of Elune
            if LunarStrike:Exists() and (((Player:BuffCount(LunarEmpowerment) == 3 or Player:BuffCount(WarriorOfElune) == 1) and not Player:Casting(LunarStrike)) or Player:BuffCount(WarriorOfElune) == 2) and Target:CanCast(LunarStrike) then
                Target:Cast(LunarStrike);
                return;
            end
            -- Starsurge/Starfall with 60 Astral Power
            AstralDump(StarfallAstralPower, true);
            -- New Moon
            if NewMoon:Exists() and NewMoon:CurrentID() == NewMoon.Identifier and Target:CanCast(NewMoon) then
                module.Bug("New Moon");
                Target:Cast(NewMoon);
                return;
            end
            -- Half Moon
            if NewMoon:Exists() and NewMoon:CurrentID() == HalfMoon.Identifier and Target:CanCast(NewMoon) then
                module.Bug("Half Moon");
                Target:Cast(NewMoon);
                return;
            end
            -- Solar Wrath single Target
            if SolarWrath:Exists() and NumEnemies < 2 and Target:CanCast(SolarWrath) then
                Target:Cast(SolarWrath);
                return;
            end
            -- Lunar Strike with at least 2 enemies in range of the target
            if LunarStrike:Exists() and Target:CanCast(LunarStrike) then
                Target:Cast(LunarStrike);
                return;
            end
            -- Moonfire / Sunfire fillers
            if module.IsOptionEnabled("Moonfire While Moving") and Player:Moving() > module.GetOptionValue("Moonfire While Moving") then
                if NumEnemies > 1 and Target:CanCast(Sunfire) then
                    Target:Cast(Sunfire);
                    return;
                end
                if Target:CanCast(Moonfire) then
                    Target:Cast(Moonfire);
                    return;
                end
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(SolarWrath, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    function Rotation:OutOfCombat ()
        -- Rejuvenation
        if module.IsOptionEnabled("Rejuvenation Self") and Player:HealthPercentage() <= module.GetOptionValue("Rejuvenation Self") and Player:CanCast(Rejuvenation) and not Player:Buff(Rejuvenation) then
            Player:Cast(Rejuvenation);
            return;
        end
        -- Healing Touch
        if Player:Standing() > 1.5 and module.IsOptionEnabled("Healing Touch Self") and Player:HealthPercentage() <= module.GetSecondOptionValue("Healing Touch Self") and Player:CanCast(HealingTouch) then
            Player:Cast(HealingTouch);
        end
        if not Player:Buff(CatForm) and not Player:Buff(BearForm) and not Player:Buff(TravelForm) then
            -- Guardian Affinity
            if GuardianAffinity:Exists() and module.IsOptionEnabled("Guardian Affinity") then
                if not Player:Buff(BearForm) and Player:CanCast(BearForm) then
                    Player:Cast(BearForm);
                    return;
                end
            -- Feral Affinity
            elseif FeralAffinity:Exists() and module.IsOptionEnabled("Feral Affinity") then
                if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
                    Player:Cast(CatForm);
                    return;
                end
            -- Moonkin Form
            elseif module.IsOptionEnabled("Moonkin Form") then
                if not Player:Buff(MoonkinForm) and Player:CanCast(MoonkinForm) then
                    Player:Cast(MoonkinForm);
                    return;
                end
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Feral Druid Rotation
    local Rotation = {};
    module.SetRotation(103, Rotation);

    --- Localization
    -- Core
    local Enemies_45y, Enemies_8y, Enemies_5y, NumEnemies = {}, {}, {}, 1; -- Enemies
    local SpamPrevention, TPSTime = 0, 0.1; -- Combat Module Throttle
    -- Rotation Specific
    local UnitNeedRes = nil; -- OoC Res Handler
    local Lowest = nil; -- Lowest Unit
    local MainTank, OffTank, MainTankResDelay, OffTankResDelay = nil, nil, nil, nil; -- Battle Resurection timers
    local ShadowmeldStanding = 0.7; -- Time to Stand before casting S.Shadowmeld (because movements cancel it)
    local FBValue = 50; -- Energy required for a full Ferocious Bite
    local RipTargetTTD, RipCycleTTD, RakeTargetTTD, RakeCycleTTD = 0, 0, 0, 0; -- Minimum TTD Value to use Rip and Rake
    local RakeTickTime, MoonfireTickTime = 3, 2; -- Tick Times
    local RakePandemic, RipPandemic, ThrashPandemic, ThrashSmartDuration = 4.5, 7.2, 4.5, 10;

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        --- Spells
        S = {
            -- (ID, RequiresFacing, Hostile, Instant, Resurrect)
            -- Racials
            Berserking = Spell(26297, false, false, true),
            Shadowmeld = Spell(58984, false, false, true),
            -- Items
            DraenicAgility = Item(109217, false, false, true),
            DraenicAgilityBuff = Spell(156423, false, false, true),
            -- Offensive Abilities
            Bloodtalons = Spell(155672, false, false, false),
            BloodtalonsBuff = Spell(145152, false, false, false),
            BrutalSlash = Spell(202028, false, false, true),
            Clearcasting = Spell(135700, false, false, false),
            FerociousBite = Spell(22568, true, true, true),
            JaggedWounds = Spell(202032, false, false, false),
            LunarInspiration = Spell(155580, false, false, false),
            MomentofClarity = Spell(155577, false, false, false),
            Moonfire = Spell(8921, false, true, true),
            MoonfireDebuff = Spell(164812, false, false, false),
            PredatorySwiftness = Spell(69369, false, false, false),
            Prowl = Spell(5215, false, false, true),
            Rake = Spell(1822, true, true, true),
            RakeDebuff = Spell(155722, false, false, false),
            Rip = Spell(1079, true, true, true),
            Sabertooth = Spell(202031, false, false, false),
            SavageRoar = Spell(52610, false, false, true),
            Shred = Spell(5221, true, true, true),
            Swipe = Spell(106785, false, false, true),
            Thrash = Spell(106830, false, false, true),
            ThrashDebuff = Spell(106830, false, false, false),
            -- Offensive Cooldowns
            AshamanesFrenzy = Spell(210722, true, true, true),
            Berserk = Spell(106951, false, false, true),
            ElunesGuidance = Spell(202060, false, false, true),
            Incarnation = Spell(102543, false, false, true),
            TigersFury = Spell(5217, false, false, true),
            -- Defensive Abilities
            HealingTouch = Spell(5185, false, false, false),
            Rebirth = Spell(20484, false, false, false, true),
            Revive = Spell(50769, false, false, false, true),
            -- Defensive Cooldowns
            Renewal = Spell(108238, false, false, true),
            SurvivalInstincts = Spell(61336, false, false, true),
            -- Utility
            Dash = Spell(1850, false, false, true),
            SkullBash = Spell(106839, true, true, true),
            -- Shapeshift
            BearForm = Spell(5487, false, false, true),
            CatForm = Spell(768, false, false, true),
            MoonkinForm = Spell(197625, false, false, true),
            -- Balance Affinity
            BalanceAffinity = Spell(197488, false, false, false),
            LunarEmpowerment = Spell(164547, false, false, false),
            LunarStrike = Spell(197628, true, true, false),
            SolarEmpowerment = Spell(164545, false, false, false),
            SolarWrath = Spell(197629, true, true, false),
            Starsurge = Spell(197626, true, true, false),
            Sunfire = Spell(197630, true, true, false),
            SunfireDebuff = Spell(164815, false, false, false),
            -- Guardian Affinity
            GuardianAffinity = Spell(217615, false, false, false),
            Mangle = Spell(33917, true, true, true),
            Ironfur = Spell(192081, false, false, true),
            FrenziedRegeneration = Spell(22842, false, false, true),
            -- Restoration AFfinity
            Regrowth = Spell(8936, false, false, false),
            Rejuvenation = Spell(774, false, false, true),
            RestorationAffinity = Spell(197492, false, false, false),
            Swiftmend = Spell(18562, false, false, false)
        };

        --- GUI Frame
        -- Pages
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        module.AddCommonOptions();
        module.AddPresetOption("TargetAttack");
        module.AddPresetOption("ReTarget");
        module.AddPresetOption("BossCD");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddPresetOption("Interrupt");
        module.AddSection("General Settings", "Shapeshifting", "Green");
        module.AddNewOption("General Settings", "Auto Cat Form and Prowl", 220, true, {15, 1, 40, 1}, nil, "Enable to auto put in Cat Form or use Prowl."..C.TOOLTIP_VALUE.."Distance away from the target."..C.TOOLTIP_HINT("The distance is checked only while out of combat."));
        module.AddNewOption("General Settings", "Auto Cancel Cat Form", 220, false, {20, 1, 40, 1}, nil, "Enable to auto cancel Cat Form."..C.TOOLTIP_VALUE.."Distance away from the target."..C.TOOLTIP_HINT("Does cancel only when out of combat."));
        module.AddNewOption("General Settings", "Proc Bloodtalons", 220, true, {20, 1, 25, 1}, nil, "Enable to auto proc Bloodtalons."..C.TOOLTIP_VALUE.."Set the duration to refresh it."..C.TOOLTIP_HINT("Does proc only when out of combat and not in cat form or stealth."));
        module.AddSection("General Settings", "Rebirth", "Green");
        module.AddNewOption("General Settings", "Rebirth", 210, true, nil, nil, "Enable to automatically resurrect targeted dead player targets in combat.");
        module.AddNewOption("General Settings", "Instant Rebirth Tank", 220, false, {0, 0, 3, 0.1}, nil, "Enable to use the Predatory Swiftness buff on rebirth to resuscitate a dead tank"..C.TOOLTIP_VALUE.."Set the delay before using it.");
        module.AddSection("General Settings", "Out of Combat", "Green");
        module.AddNewOption("General Settings", "Mark of The Wild", 210, true, nil, nil, "Enable for automatic buff application.");
        module.AddPresetOption("AutoResuscitate");
        module.AddPresetOption("AutoHeal");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddPresetOption("PrePot");
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Tiger's Fury", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Tiger's Fury."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Elune's Guidance", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Elune's Guidance."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Ashamane's Frenzy", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Ashamane's Frenzy."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Berserk", 210, true, nil, nil, "Enable for the automatic usage of Berserk (or Incarnation if talented into).");
        if S.Berserking:Exists() or S.Shadowmeld:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Berserking and Shadowmeld are supported."));
        end
        module.AddPresetOption("Trinket");
        --module.AddPresetOption("Potion");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Rip: Target | Adds", 222, true, {12, 0, 25, 1}, {16, 0, 25, 1}, "Enable to use Rip and set the TimeToDie threshold in order to apply it."..C.TOOLTIP_VALUE_1.."Set TTD for target."..C.TOOLTIP_VALUE_2.."Set TTD for Adds (Multi-DoT).");
        module.AddNewOption("Offensive Settings", "Rake: Target | Adds", 122, true, {6, 0, 25, 1}, {9, 0, 25, 1}, "Set the TimeToDie threshold in order to apply Rake (and Moonfire if talented into Lunar Inspiration)."..C.TOOLTIP_VALUE_1.."Set TTD for target."..C.TOOLTIP_VALUE_2.."Set TTD for Adds (Multi-DoT).");
        module.AddNewOption("Offensive Settings", "Swipe", 220, true, {4, 2, 5, 1}, nil, "Enable for the automatic usage of Swipe (or Brutal Slash) during AoE."..C.TOOLTIP_VALUE.."Set the minimum number of units in order to use Swipe (or Brutal Slash)");
        module.AddNewOption("Offensive Settings", "Thrash", 222, true, {2, 1, 7, 1}, {2, 1, 7, 1}, "Enable to use Thrash for AoE."..C.TOOLTIP_VALUE_1.."Set the total number of enemies around you in order to use Trash."..C.TOOLTIP_VALUE_2.."Set the min. number of enemies to refresh Trash if it has been applied recently (during AoE).");
        module.AddNewOption("Offensive Settings", "Moonfire", 230, true, {2, "Always", "Lunar Inspiration"}, nil, "Enable for the automatic usage of Moonfire while in Human Form or with Lunar Inspiration talent."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability both while in Human Form and with Lunar Inspiration talent."..C.TOOLTIP_SUBVALUE("Lunar Inspiration").."Will only use the ability with Lunar Inspiration talent.");
        module.AddNewOption("Offensive Settings", "Incarnation Prowl", 210, false, nil, nil, "Enable for the automatic usage of Prowl if available while Incarnation is up. (Check it until Blizzard fixes this bug)");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddPresetOption("HealingItem");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Healing Touch High Priority", 220, false, {90, 1, 100, 1}, nil, "Health Percentage to use Survival Instincts.");
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Survival Instincts", 220, true, {45, 1, 100, 1}, nil, "Health Percentage to use Survival Instincts.");

        --- Misc
        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Improved Spell Casting Logic
        module.ISCL = {
            [S.LunarStrike:ID()] = "Lunar Strike",
            [S.SolarWrath:ID()] = "Solar Wrath",
            [S.HealingTouch:ID()] = "Healing Touch",
            [S.Regrowth:ID()] = "Regrowth",
            [S.Revive:ID()] = "Revive"
        };
    end

    --- Combat's Local Functions
    local function ProwlHotfix ()
        if S.Incarnation:Exists() and Player:Buff(S.Berserk) and Player:CanCast(S.Prowl) then
            Player:Cast(S.Prowl);
        end
    end
    local function Generator ()
        -- ashamanes_frenzy,if=combo_points<=2&buff.elunes_guidance.down&(!talent.bloodtalons.enabled|buff.bloodtalons.up)
        if module.IsOptionEnabled("Ashamane's Frenzy") and (module.CooldownsAllowed() or module.GetOptionValue("Ashamane's Frenzy") == "Always") and S.AshamanesFrenzy:Exists() and Player:ComboPoints() <= 2 and not Player:Buff(S.ElunesGuidance) and (not S.Bloodtalons:Exists() or Player:Buff(S.BloodtalonsBuff)) and Target:CanCast(S.AshamanesFrenzy) then
            Target:Cast(S.AshamanesFrenzy);
            return;
        end
        -- pool_resource,for_next=1
        -- brutal_slash,if=spell_targets.brutal_slash>desired_targets
        -- pool_resource,for_next=1
        -- brutal_slash,if=active_enemies>=2&raid_event.adds.exists&raid_event.adds.in>(1+max_charges-charges_fractional)*15
        -- pool_resource,for_next=1
        -- brutal_slash,if=active_enemies>=2&!raid_event.adds.exists&(charges_fractional>2.66&time>10)
        -- swipe_cat,if=spell_targets.swipe_cat>=4
        if module.UseAOE() and module.IsOptionEnabled("Swipe") and NumEnemies >= module.GetOptionValue("Swipe") then
            if S.BrutalSlash:Exists() then
                if Player:CanCast(S.BrutalSlash) then
                    Player:Cast(S.BrutalSlash);
                    return;
                end
            elseif Player:CanCast(S.Swipe) then
                Player:Cast(S.Swipe);
                return;
            end
        end
        -- shred,if=spell_targets.swipe_cat<=3|talent.brutal_slash.enabled
        if (NumEnemies < module.GetOptionValue("Swipe") or S.BrutalSlash:Exists()) and Target:CanCast(S.Shred) then
            Target:Cast(S.Shred);
            return;
        end
    end
    local function Finisher ()
        -- rip,cycle_targets=1,if=remains<=duration*0.3&(target.health.pct>25|!dot.rip.ticking)
        if Target:DebuffRemains(S.Rip) <= RipPandemic and (Target:HealthPercentage() > 25 or not Target:Debuff(S.Rip)) and Target:TimeToDie() > RipTargetTTD and Target:CanCast(S.Rip) then
            Target:Cast(S.Rip);
            return;
        end
        if module.UseAOE() then
            local ThisUnit;
            for i = 1, #Enemies_5y do
                ThisUnit = Enemies_5y[i];
                if ThisUnit:DebuffRemains(S.Rip) <= RipPandemic and (ThisUnit:HealthPercentage() > 25 or not ThisUnit:Debuff(S.Rip)) and Target:TimeToDie() > RipCycleTTD and ThisUnit:CanCast(S.Rip) then
                    ThisUnit:Cast(S.Rip);
                    return;
                end
            end
        end
        -- savage_roar,if=buff.savage_roar.remains<=7.2&(target.health.pct<25|energy.time_to_max<1|buff.berserk.up|buff.incarnation.up|dot.rake.remains<1.5|buff.elunes_guidance.up|cooldown.tigers_fury.remains<3|(talent.moment_of_clarity.enabled&buff.clearcasting.react))
        if S.SavageRoar:Exists() and Player:BuffRemains(S.SavageRoar) <= 7.2 and (Target:HealthPercentage() < 25 or Player:EnergyTimeToMax() < 1 or Player:Buff(S.Berserk) or Target:DebuffRemains(S.RakeDebuff) < 1.5 or Player:Buff(S.ElunesGuidance) or S.TigersFury:Cooldown() < 3 or (S.MomentofClarity:Exists() and Player:Buff(S.Clearcasting))) and Player:CanCast(S.SavageRoar) then
            Player:Cast(S.SavageRoar);
            return;
        end
        -- ferocious_bite,max_energy=1,cycle_targets=1,if=(target.health.pct<25|talent.sabertooth.enabled)&(cooldown.tigers_fury.remains<3|energy.time_to_max<1|buff.berserk.up|buff.incarnation.up|dot.rake.remains<1.5|buff.elunes_guidance.up|(talent.moment_of_clarity.enabled&buff.clearcasting.react))
        if (Target:HealthPercentage() < 25 or S.Sabertooth:Exists()) and (S.TigersFury:Cooldown() < 3 or Player:EnergyTimeToMax() < 1 or Player:Buff(S.Berserk) or Target:DebuffRemains(S.RakeDebuff) < 1.5 or Player:Buff(S.ElunesGuidance) or (S.MomentofClarity:Exists() and Player:Buff(S.Clearcasting))) and Target:CanCast(S.FerociousBite, nil, true) then
            if Player:Energy() >= FBValue then
                Target:Cast(S.FerociousBite);
                return;
            else
                return "Pooling";
            end
        end
        if module.UseAOE() then
            local ThisUnit;
            local SabertoothExists = S.Sabertooth:Exists();
            local StaticCondition = S.TigersFury:Cooldown() < 3 or Player:EnergyTimeToMax() < 1 or Player:Buff(S.Berserk) or Player:Buff(S.ElunesGuidance) or (S.MomentofClarity:Exists() and Player:Buff(S.Clearcasting));
            for i = 1, #Enemies_5y do
                ThisUnit = Enemies_5y[i];
                if (SabertoothExists or ThisUnit:HealthPercentage() > 25) and (StaticCondition or ThisUnit:DebuffRemains(S.RakeDebuff) < 1.5) and ThisUnit:CanCast(S.FerociousBite, nil, true) then
                    if Player:Energy() >= FBValue then
                        ThisUnit:Cast(S.FerociousBite);
                        return;
                    else
                        return "Pooling";
                    end
                end
            end
        end
        -- ferocious_bite,max_energy=1,if=buff.berserk.up|buff.incarnation.up|cooldown.tigers_fury.remains<3|buff.elunes_guidance.up
        if Player:Buff(S.Berserk) or S.TigersFury:Cooldown() < 3 or Player:Buff(S.ElunesGuidance) and Target:CanCast(S.FerociousBite, nil, true) then
            if Player:Energy() >= FBValue then
                Target:Cast(S.FerociousBite);
                return;
            else
                return "Pooling";
            end
        end
        -- ferocious_bite,max_energy=1,if=energy.time_to_max<1
        if Player:EnergyTimeToMax() < 1 and Target:CanCast(S.FerociousBite, nil, true) then
            if Player:Energy() >= FBValue then
                Target:Cast(S.FerociousBite);
                return;
            else
                return "Pooling";
            end
        end
    end
    local function Maintain ()
        -- shadowmeld,if=energy>=35&dot.rake.pmultiplier<2.1&buff.tigers_fury.up&(buff.bloodtalons.up|!talent.bloodtalons.enabled)&(!talent.incarnation.enabled|cooldown.incarnation.remains>18)&!buff.incarnation.up
        if S.Shadowmeld:Exists() and module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:Standing() >= ShadowmeldStanding and Player:Energy() >= 35 and Target:RakeDamage() < 2.1 and Player:Buff(S.TigersFury) and (Player:Buff(S.BloodtalonsBuff) or not S.Bloodtalons:Exists()) and (not S.Incarnation:Exists() or S.Incarnation:Cooldown() > 18) and not Player:Buff(S.Incarnation) and Player:CanCast(S.Shadowmeld) then
            Player:Cast(S.Shadowmeld);
            return;
        end
        -- rake,cycle_targets=1,if=remains<=tick_time&((target.time_to_die-remains>3&spell_targets.swipe_cat<3)|target.time_to_die-remains>6)
        RakeTickTime = S.JaggedWounds:Exists() and 3*(1-0.33) or 3; -- 0.33 is the % from Jagged Wounds, currently 33%.
        if Target:DebuffRemains(S.RakeDebuff) <= RakeTickTime and ((Target:TimeToDie()-Target:DebuffRemains(S.RakeDebuff) > 3 and NumEnemies < 3) or Target:TimeToDie()-Target:DebuffRemains(S.RakeDebuff) > 6) and Target:TimeToDie() > RakeTargetTTD and Target:CanCast(S.Rake) then
            ProwlHotfix();
            Target:Cast(S.Rake);
            return;
        end
        if module.UseAOE() then
            local ThisUnit;
            for i = 1, #Enemies_5y do
                ThisUnit = Enemies_5y[i];
                if ThisUnit:DebuffRemains(S.RakeDebuff) <= RakeTickTime and ((ThisUnit:TimeToDie()-ThisUnit:DebuffRemains(S.RakeDebuff) > 3 and NumEnemies < 3) or ThisUnit:TimeToDie()-ThisUnit:DebuffRemains(S.RakeDebuff) > 6) and ThisUnit:TimeToDie() > RakeCycleTTD and ThisUnit:CanCast(S.Rake) then
                    ProwlHotfix();
                    ThisUnit:Cast(S.Rake);
                    return;
                end
            end
        end
        -- rake,cycle_targets=1,if=remains<=duration*0.3&(persistent_multiplier>=dot.rake.pmultiplier|(talent.bloodtalons.enabled&(buff.bloodtalons.up|!buff.predatory_swiftness.up)))&((target.time_to_die-remains>3&spell_targets.swipe_cat<3)|target.time_to_die-remains>6)
        if Target:DebuffRemains(S.RakeDebuff) <= RakePandemic and (module.BleedDamage("Rake") >= Target:RakeDamage() or (S.Bloodtalons:Exists() and (Player:Buff(S.BloodtalonsBuff) or not Player:Buff(S.PredatorySwiftness)))) and ((Target:TimeToDie()-Target:DebuffRemains(S.RakeDebuff) > 3 and NumEnemies < 3) or Target:TimeToDie()-Target:DebuffRemains(S.RakeDebuff) > 6) and Target:TimeToDie() > RakeTargetTTD and Target:CanCast(S.Rake) then
            ProwlHotfix();
            Target:Cast(S.Rake);
            return;
        end
        if module.UseAOE() then
            local ThisUnit;
            local StaticCondition = S.Bloodtalons:Exists() and (Player:Buff(S.BloodtalonsBuff) or not Player:Buff(S.PredatorySwiftness));
            for i = 1, #Enemies_5y do
                ThisUnit = Enemies_5y[i];
                if ThisUnit:DebuffRemains(S.RakeDebuff) <= RakePandemic and (module.BleedDamage("Rake") >= ThisUnit:RakeDamage() or StaticCondition) and ((ThisUnit:TimeToDie()-ThisUnit:DebuffRemains(S.RakeDebuff) > 3 and NumEnemies < 3) or ThisUnit:TimeToDie()-ThisUnit:DebuffRemains(S.RakeDebuff) > 6) and ThisUnit:TimeToDie() > RakeCycleTTD and ThisUnit:CanCast(S.Rake) then
                    ProwlHotfix();
                    ThisUnit:Cast(S.Rake);
                    return;
                end
            end
        end
        -- moonfire_cat,cycle_targets=1,if=remains<=4.2&spell_targets.swipe_cat<=5&target.time_to_die-remains>tick_time*5
        if module.IsOptionEnabled("Moonfire") and S.LunarInspiration:Exists() and NumEnemies <= 5 then
            MoonfireTickTime = (20.0/(1+UnitSpellHaste("player")/100)/10)*5;
            if Target:DebuffRemains(S.MoonfireDebuff) <= 4.2 and Target:TimeToDie() > RakeTargetTTD and Target:TimeToDie()-Target:DebuffRemains(S.MoonfireDebuff) > MoonfireTickTime and Target:CanCast(S.Moonfire) then
                Target:Cast(S.Moonfire);
                return;
            end
            if module.UseAOE() then
                local ThisUnit;
                for i = 1, #Enemies_45y do
                    ThisUnit = Enemies_45y[i];
                    if ThisUnit:DebuffRemains(S.MoonfireDebuff) <= 4.2 and ThisUnit:TimeToDie() > RakeCycleTTD and ThisUnit:TimeToDie()-ThisUnit:DebuffRemains(S.MoonfireDebuff) > MoonfireTickTime and ThisUnit:CanCast(S.Moonfire) then
                        ThisUnit:Cast(S.Moonfire);
                        return;
                    end
                end
            end
        end
    end
    local function AoEList ()
        -- thrash_cat,cycle_targets=1,if=remains<=duration*0.3&spell_targets.thrash_cat>=2
        if module.UseAOE() and module.IsOptionEnabled("Thrash") and NumEnemies >= module.GetOptionValue("Thrash") then
            local Count = 0;
            local ThisUnit;
            for i = 1, #Enemies_8y do
                ThisUnit = Enemies_8y[i];
                if ThisUnit:DebuffRemains(S.Thrash) > ThrashSmartDuration then
                    Count = Count + 1;
                end
            end
            if NumEnemies-Count >= module.GetSecondOptionValue("Thrash") then
                for i = 1, #Enemies_8y do
                    ThisUnit = Enemies_8y[i];
                    if ThisUnit:DebuffRemains(S.Thrash) < ThrashPandemic then
                        if Player:CanCast(S.Thrash) then
                            Player:Cast(S.Thrash);
                            return;
                        elseif (Player:Energy() < 50 or (Player:Buff(S.Berserk) and Player:Energy() < 25)) then
                            return;
                        end
                    end
                end
            end
        end
        -- call_action_list,name=finisher,if=combo_points=5
        if Player:ComboPoints() == 5 then
            if Finisher() == "Pooling" then
                return;
            end
        end
        -- swipe_cat
        if module.UseAOE() and module.IsOptionEnabled("Swipe") and NumEnemies >= module.GetOptionValue("Swipe") then
            if Player:CanCast(S.Swipe) then
                Player:Cast(S.Swipe);
                return;
            end
        end
    end
    local function TigersFurySync ()
        -- Trinkets
        Player:UseTrinkets();
        -- Berserking
        if S.Berserking:Exists() and module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:CanCast(S.Berserking) then
            CastSpellByID(26297, "player")
        end
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we wait to keep updated
        Player:SetCommonMeleeStatus();
        -- Multiple Spell IDs Handler
        S.HealingTouch = Player:Buff(S.PredatorySwiftness) and Spell(5185, false, false, true) or Spell(5185, false, false, false); -- w/ or w/o Predatory Swiftness Buff (HT Instant)
        if S.Incarnation:Exists() then -- w/ or w/ Incarnation Talent
            S.Berserk = Spell(102543, false, false, true); --102453
            S.Prowl = Player:Buff(S.Incarnation) and Spell(102547, false, false, true) or Spell(5215, false, false, true); -- w/ or w/o Incarnation Buff
        else
            S.Berserk = Spell(106951, false, false, true);
            S.Prowl = Spell(5215, false, false, true);
        end
        if S.LunarInspiration:Exists() and Player:Buff(S.CatForm) then -- w/ or w/o LunarInspiration Talent
            S.Moonfire = Spell(155625, false, true, true);
            S.MoonfireDebuff = Spell(155625, false, false, false);
        else
            S.Moonfire = Spell(8921, false, true, true);
            S.MoonfireDebuff = Spell(164812, false, false, false);
        end
        if Player:Buff(S.CatForm) then -- Swipe & Thrash while in Cat Form
            S.Swipe = Spell(106785, false, false, true);
            S.Thrash = Spell(106830, false, false, true);
            S.ThrashDebuff = Spell(106830, false, false, false);
        elseif Player:Buff(S.BearForm) then -- Swipe & Thrash while in Bear Form
            S.Swipe = Spell(213771, false, false, true);
            S.Thrash = Spell(77758, false, false, true);
            S.ThrashDebuff = Spell(192090, false, false, false);
        else -- Swipe & Thrash while in Normal/Travel/Moonkin Form
            S.Swipe = Spell(213764, false, false, true);
            S.Thrash = Spell(106832, false, false, true);
            S.ThrashDebuff = Spell(106832, false, false, false);
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Survival Instincts") and Player:HealthPercentage() <= module.GetOptionValue("Survival Instincts") and not Player:Buff(S.SurvivalInstincts) and S.SurvivalInstincts:TimeSinceCast() > 0.5 and Player:CanCast(S.SurvivalInstincts) then
            Player:Cast(S.SurvivalInstincts);
            S.SurvivalInstincts.LastCastTime = module.GetTime();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(S.SkullBash);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(S.Shred, true) or Unit.Target;
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        -- Combat Res Tanks
        if module.IsOptionEnabled("Instant Rebirth Tank") then
            MainTank, OffTank = Unit.MainTank(), Unit.OffTank();
            if MainTank and MainTank:Exists() and MainTank:IsPlayer() then
                if not MainTank:IsDeadOrGhost() then
                    MainTankResDelay = nil;
                else
                    if not MainTankResDelay then MainTankResDelay = module.GetTime() + module.GetOptionValue("Instant Rebirth Tank"); end
                    if module.GetTime() >= MainTankResDelay and Player:Buff(S.PredatorySwiftness) and MainTank:CanCast(S.Rebirth) then
                        MainTankResDelay = nil;
                        MainTank:Cast(S.Rebirth);
                        return;
                    end
                end
            end
            if OffTank and OffTank:Exists() and OffTank:IsPlayer() then
                if not OffTank:IsDeadOrGhost() then
                    OffTankResDelay = nil;
                else
                    if not OffTankResDelay then OffTankResDelay = module.GetTime() + module.GetOptionValue("Instant Rebirth Tank"); end
                    if module.GetTime() >= OffTankResDelay and Player:Buff(S.PredatorySwiftness) and OffTank:CanCast(S.Rebirth) then
                        OffTankResDelay = nil;
                        OffTank:Cast(S.Rebirth);
                        return;
                    end
                end
            end
        end
        -- Combat Res Target
        if module.IsOptionEnabled("Rebirth") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and Target:IsPlayer() and Target:CanCast(S.Rebirth) then
            Target:Cast(S.Rebirth);
            return;
        end

        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Enemies Check:
            if module.UseAOE() then
                Enemies_45y = Player:EnemiesWithinDistance(45, false);-- This Table is the used for Moonfire Cycling (+ others use it as the master).
                if S.BalanceAffinity:Exists() then -- Add +5y range
                    Enemies_8y = Player:FilterEnemiesByDistance(Enemies_45y, 13, true); -- Using 13y (real range w/ Balance Affinity) for Thrash & Swipe and true as they are PlayerCenteredAoE Spells.
                    Enemies_5y = Player:FilterEnemiesByDistance(Enemies_8y, 10, false); -- This table is used for Melee Range Cycling Abilities (like Rip, Rake, etc...).
                else
                    Enemies_8y = Player:FilterEnemiesByDistance(Enemies_45y, 8, true); -- Using 8y (real range) for Thrash & Swipe and true as they are PlayerCenteredAoE Spells.
                    Enemies_5y = Player:FilterEnemiesByDistance(Enemies_8y, 5, false); -- This table is used for Melee Range Cycling Abilities (like Rip, Rake, etc...).
                end
                NumEnemies = #Enemies_8y;
            else
                NumEnemies = 1;
            end
            -- Energy cost to have a full Ferocious Bite
            if Player:Buff(S.Berserk) and Player:Buff(S.Clearcasting) then
                FBValue = 12.5;
            elseif Player:Buff(S.Berserk) or Player:Buff(S.Clearcasting) then
                FBValue = 25;
            else
                FBValue = 50;
            end
            -- TTD Values
            RipTargetTTD = module.GetOptionValue("Rip: Target | Adds");
            RipCycleTTD = module.GetSecondOptionValue("Rip: Target | Adds");
            RakeTargetTTD = module.GetOptionValue("Rake: Target | Adds");
            RakeCycleTTD = module.GetSecondOptionValue("Rake: Target | Adds");
            -- Jagged Wounds Handler
            if S.JaggedWounds:Exists() then
                RakePandemic = 3.015;
                RipPandemic = 4.824;
                ThrashPandemic = 3.015;
                ThrashSmartDuration = 6.7;
            else
                RakePandemic = 4.5;
                RipPandemic = 7.2;
                ThrashPandemic = 4.5;
                ThrashSmartDuration = 10;
            end

            Lowest = Unit.Lowest();

            -- Balance Affinity
            if Player:Buff(S.MoonkinForm) then
                -- Starsurge
                if Target:CanCast(S.Starsurge) then
                    Target:Cast(S.Starsurge);
                    return;
                end
                -- DoT Target
                if Target:TimeToDie() > RakeTargetTTD then
                    -- Sunfire
                    if Target:DebuffRemains(S.SunfireDebuff) <= 4 and Target:CanCast(S.Sunfire) then
                        Target:Cast(S.Sunfire);
                        return;
                    end
                    -- Moonfire
                    if Target:DebuffRemains(S.MoonfireDebuff) <= 4 and Target:CanCast(S.Moonfire) then
                        Target:Cast(S.Moonfire);
                        return;
                    end
                end
                -- DoT AoE
                if module.UseAOE() then
                    local ThisUnit;
                    for i = 1, #Enemies_45y do
                        ThisUnit = Enemies_45y[i];
                        if ThisUnit:TimeToDie() > RakeCycleTTD then
                            -- Sunfire
                            if ThisUnit:DebuffRemains(S.SunfireDebuff) <= 4 and ThisUnit:CanCast(S.Sunfire) then
                                ThisUnit:Cast(S.Sunfire);
                                return;
                            end
                            -- Moonfire
                            if ThisUnit:DebuffRemains(S.MoonfireDebuff) <= 4 and ThisUnit:CanCast(S.Moonfire) then
                                ThisUnit:Cast(S.Moonfire);
                                return;
                            end
                        end
                    end
                end
                -- Solar Wrath
                if Player:Buff(S.SolarEmpowerment) and Target:CanCast(S.SolarWrath) then
                    Target:Cast(S.SolarWrath);
                    return;
                end
                -- Lunar Strike
                if Target:CanCast(S.LunarStrike) then
                    Target:Cast(S.LunarStrike);
                    return;
                end
                return;
            end
            -- Bear Rotation
            if Player:Buff(S.BearForm) then
                -- Guardian Affinity Active Mitigation
                if S.GuardianAffinity:Exists() then
                    -- Frenzied Regeneration
                    if Player:HealthPercentage() <= 60 and Player:Rage() >= 10 and Player:CanCast(S.FrenziedRegeneration) then
                        Player:Cast(S.FrenziedRegeneration);
                    end
                    -- Ironfur
                    if Player:Rage() >= 45 and Player:CanCast(S.Ironfur) then
                        Player:Cast(S.Ironfur);
                        return;
                    end
                end
                -- Thrash
                if Player:DistanceTo(Target, false, true) <= 8+(S.BalanceAffinity:Exists() and 5 or 0) and Player:CanCast(S.Thrash) then
                    Player:Cast(S.Thrash);
                    return;
                end
                -- Guardian Affinity Mangle
                if S.GuardianAffinity:Exists() and Target:CanCast(S.Mangle) then
                    Target:Cast(S.Mangle);
                    return;
                end
                -- Moonfire
                if Target:TimeToDie() > RakeTargetTTD and Target:DebuffRemains(S.MoonfireDebuff) <= 4 and Target:CanCast(S.Moonfire) then
                    Target:Cast(S.Moonfire);
                    return;
                end
                -- Swipe
                if not S.BrutalSlash:Exists() and Player:DistanceTo(Target, false, true) <= 8+(S.BalanceAffinity:Exists() and 5 or 0) and Player:CanCast(S.Swipe) then
                    Player:Cast(S.Swipe);
                    return;
                end
                -- Moonfire
                if module.UseAOE() then
                    local ThisUnit;
                    for i = 1, #Enemies_45y do
                        ThisUnit = Enemies_45y[i];
                        if ThisUnit:TimeToDie() > RakeCycleTTD and ThisUnit:DebuffRemains(S.MoonfireDebuff) <= 4 and ThisUnit:CanCast(S.Moonfire) then
                            ThisUnit:Cast(S.Moonfire);
                            return;
                        end
                    end
                end
                -- Moonfire Out of Range
                if Target:CanCast(S.Moonfire) then
                    Target:Cast(S.Moonfire);
                    return;
                end
                return;
            end
            -- Restoration Affinity
            if S.RestorationAffinity:Exists() and not Player:Buff(S.CatForm) then
                -- Swiftmend
                if Lowest:CanCast(S.Swiftmend) then
                    Lowest:Cast(S.Swiftmend);
                    return;
                end
                -- Rejuvenation
                if Lowest:BuffRemains(S.Rejuvenation) <= 4.5 and Lowest:CanCast(S.Rejuvenation) then
                    Lowest:Cast(S.Rejuvenation);
                    return;
                end
                -- Regrowth
                if Player:Standing() >= 0.7 and Lowest:BuffRemains(S.Regrowth) <= 3 and Lowest:CanCast(S.Regrowth) then
                    Lowest:Cast(S.Regrowth);
                    return;
                end
                -- Healing Touch
                if Player:Standing() >= 0.7 and Lowest:CanCast(S.HealingTouch) then
                    Lowest:Cast(S.HealingTouch);
                    return;
                end
            end

            -- Cat Form
            if module.IsOptionEnabled("Auto Cat Form and Prowl") and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Cat Form and Prowl") and not Player:Buff(S.CatForm) and Player:CanCast(S.CatForm) then
                Player:Cast(S.CatForm);
                return;
            end
            -- Cat Rotation
            if Player:Buff(S.CatForm) then
                -- Stealth Rake
                if S.Rake:TimeSinceCast() > 0.5 and Player:IsStealthed(true, true) and Target:CanCast(S.Rake) then
                    ProwlHotfix();
                    Target:Cast(S.Rake);
                    S.Rake.LastCastTime = module.GetTime();
                    return;
                end
                -- Stealth Pool
                if Player:IsStealthed(true, true) then
                    return;
                end
                -- Healing Touch High priority
                if module.IsOptionEnabled("Healing Touch High Priority") and Lowest and Player:Buff(S.PredatorySwiftness) and not Player:IsStealthed(true, true) and Lowest:HealthPercentage() <= module.GetOptionValue("Healing Touch High Priority") and Lowest:CanCast(S.HealingTouch) then
                    Lowest:Cast(S.HealingTouch);
                    return;
                end
                -- Cooldowns
                if Player:IsWithinCastRange(Target, S.Shred) then
                    -- elunes_guidance,if=combo_points=0&(!artifact.ashamanes_bite.enabled|!dot.ashamanes_rip.ticking)
                    -- TODO : Add Ashamanes Bite Support
                    if module.IsOptionEnabled("Elune's Guidance") and (module.CooldownsAllowed() or module.GetOptionValue("Elune's Guidance") == "Always") and S.ElunesGuidance:Exists() and Player:ComboPoints() == 0 and Player:CanCast(S.ElunesGuidance) then
                        Player:Cast(S.ElunesGuidance);
                        return;
                    end
                    -- berserk,if=buff.tigers_fury.up
                    -- incarnation,if=cooldown.tigers_fury.remains<gcd
                    -- use_item,slot=trinket1,if=(prev.tigers_fury&(target.time_to_die>trinket.stat.any.cooldown|target.time_to_die<45))|prev.berserk|(buff.incarnation.up&time<10)
                    if module.IsOptionEnabled("Berserk") and module.CooldownsAllowed() and not Player:Buff(S.Berserk) and ((not S.Incarnation:Exists() and Player:Buff(S.TigersFury)) or (S.Incarnation:Exists() and S.TigersFury:Cooldown() < Player:GCD())) and Player:CanCast(S.Berserk) then
                        Player:UseTrinkets();
                        Player:Cast(S.Berserk);
                        return;
                    end
                    -- potion,name=draenic_agility,if=((buff.berserk.remains>10|buff.incarnation.remains>20)&(target.time_to_die<180|(trinket.proc.all.react&target.health.pct<25)))|target.time_to_die<=40
                        -- TOREADD
                    -- tigers_fury,if=(!buff.clearcasting.react&energy.deficit>=60)|energy.deficit>=80|(t18_class_trinket&buff.berserk.up&buff.tigers_fury.down)
                    -- tigers_fury,if=talent.sabertooth.enabled&time<10&combo_points=5
                    if module.IsOptionEnabled("Tiger's Fury") and (module.CooldownsAllowed() or module.GetOptionValue("Tiger's Fury") == "Always") and ((not Player:Buff(S.Clearcasting) and Player:EnergyDeficit() >= 60) or Player:EnergyDeficit() >= 80 or (module.HasT18_ClassTrinket and Player:Buff(S.Berserk) and not Player:Buff(S.TigersFury)) or (S.Sabertooth:Exists() and CombatTime() < 10 and Player:ComboPoints() == 5)) and Player:CanCast(S.TigersFury) then
                        TigersFurySync();
                        Player:Cast(S.TigersFury);
                        return;
                    end
                    -- incarnation,if=energy.time_to_max>1
                    if module.IsOptionEnabled("Berserk") and module.CooldownsAllowed() and S.Incarnation:Exists() and not Player:Buff(S.Berserk) and Player:EnergyTimeToMax() > 1 and Player:CanCast(S.Berserk) then
                        Player:UseTrinkets();
                        Player:Cast(S.Berserk);
                        return;
                    end
                end
                -- ferocious_bite,cycle_targets=1,if=dot.rip.ticking&dot.rip.remains<3&target.health.pct<25
                if Target:Debuff(S.Rip) and Target:DebuffRemains(S.Rip) < 3 and Target:HealthPercentage() < 25 and Target:CanCast(S.FerociousBite, nil, true) then
                    Target:Cast(S.FerociousBite);
                    return;
                end
                if module.UseAOE() then
                    local ThisUnit;
                    for i = 1, #Enemies_5y do
                        ThisUnit = Enemies_5y[i];
                        if ThisUnit:Debuff(S.Rip) and ThisUnit:DebuffRemains(S.Rip) < 3 and ThisUnit:HealthPercentage() < 25 and ThisUnit:CanCast(S.FerociousBite, nil, true) then
                            ThisUnit:Cast(S.FerociousBite);
                            return;
                        end
                    end
                end
                -- healing_touch,if=talent.bloodtalons.enabled&buff.predatory_swiftness.up&((combo_points>=4&!set_bonus.tier18_4pc)|combo_points=5|buff.predatory_swiftness.remains<1.5)
                -- healing_touch,if=talent.bloodtalons.enabled&buff.predatory_swiftness.up&combo_points=2&buff.bloodtalons.down&cooldown.ashamanes_frenzy.ready
                if S.Bloodtalons:Exists() and Player:Buff(S.PredatorySwiftness) then
                    if ((Player:ComboPoints() >= 4 and not module.HasT18_4Pc) or Player:ComboPoints() == 5 or Player:BuffRemains(S.PredatorySwiftness) <= 1.5) or (Player:ComboPoints() == 2 and not Player:Buff(S.BloodtalonsBuff) and S.AshamanesFrenzy:Exists() and not S.AshamanesFrenzy:IsOnCooldown()) then
                        if Focus:Exists() and Focus:CanCast(S.HealingTouch) then
                            Focus:Cast(S.HealingTouch);
                            return;
                        end
                        if Lowest and Lowest:CanCast(S.HealingTouch) then
                            Lowest:Cast(S.HealingTouch);
                            return;
                        end
                        if Player:CanCast(S.HealingTouch) then
                            Player:Cast(S.HealingTouch)
                            return;
                        end
                    end
                end
                -- savage_roar,if=buff.savage_roar.down
                if S.SavageRoar:Exists() and not Player:Buff(S.SavageRoar) and Player:CanCast(S.SavageRoar) then
                    Player:Cast(S.SavageRoar);
                    return;
                end
                -- call_action_list,name=aoe,if=spell_targets.swipe_cat>=3
                AoEList();
                -- call_action_list,name=finisher,if=combo_points=5
                if Player:ComboPoints() == 5 then
                    if Finisher() == "Pooling" then
                        return;
                    end
                end
                -- savage_roar,if=buff.savage_roar.remains<gcd
                if S.SavageRoar:Exists() and Player:BuffRemains(S.SavageRoar) < Player:GCD() and Player:CanCast(S.SavageRoar) then
                    Player:Cast(S.SavageRoar);
                    return;
                end
                -- ashamanes_frenzy,if=time<10&dot.rake.ticking&!talent.elunes_guidance.enabled
                if module.IsOptionEnabled("Ashamane's Frenzy") and (module.CooldownsAllowed() or module.GetOptionValue("Ashamane's Frenzy") == "Always") and S.AshamanesFrenzy:Exists() and CombatTime() < 10 and Target:Debuff(S.RakeDebuff) and not S.ElunesGuidance:Exists() and Target:CanCast(S.AshamanesFrenzy) then
                    Target:Cast(S.AshamanesFrenzy);
                    return;
                end
                -- call_action_list,name=maintain,if=combo_points<5
                if Player:ComboPoints() < 5 then
                    Maintain();
                end
                -- pool_resource,for_next=1
                -- thrash_cat,cycle_targets=1,if=remains<=duration*0.3&(spell_targets.thrash_cat>=2&set_bonus.tier17_2pc|spell_targets.thrash_cat>=4)
                if module.UseAOE() and module.IsOptionEnabled("Thrash") and NumEnemies >= module.GetOptionValue("Thrash") then
                    local Count = 0;
                    local ThisUnit;
                    for i = 1, #Enemies_8y do
                        ThisUnit = Enemies_8y[i];
                        if ThisUnit:DebuffRemains(S.Thrash) > ThrashSmartDuration then
                            Count = Count + 1;
                        end
                    end
                    if NumEnemies-Count >= module.GetSecondOptionValue("Thrash") then
                        for i = 1, #Enemies_8y do
                            ThisUnit = Enemies_8y[i];
                            if ThisUnit:DebuffRemains(S.Thrash) < ThrashPandemic then
                                if Player:CanCast(S.Thrash) then
                                    Player:Cast(S.Thrash);
                                    return;
                                elseif (Player:Energy() < 50 or (Player:Buff(S.Berserk) and Player:Energy() < 25)) then
                                    return;
                                end
                            end
                        end
                    end
                end
                -- call_action_list,name=generator,if=combo_points<5
                if Player:ComboPoints() < 5 then
                    Generator();
                end
                -- Healing Filler
                if Lowest and not S.Bloodtalons:Exists() and Player:Buff(S.PredatorySwiftness) and Lowest:CanCast(S.HealingTouch) then
                    Lowest:Cast(S.HealingTouch);
                    return;
                end
            elseif module.IsOptionEnabled("Moonfire") and module.GetSecondOptionValue("Moonfire") == "Always" then
                -- Moonfire AoE
                if module.UseAOE() then
                    local ThisUnit;
                    for i = 1, #Enemies_45y do
                        ThisUnit = Enemies_45y[i];
                        if ThisUnit:DebuffRemains(S.MoonfireDebuff) <= 4.2 and ThisUnit:TimeToDie() > RakeCycleTTD and ThisUnit:CanCast(S.Moonfire) then
                            ThisUnit:Cast(S.Moonfire);
                            return;
                        end
                    end
                end
                -- Moonfire Out of Range
                if Target:CanCast(S.Moonfire) then
                    Target:Cast(S.Moonfire);
                    return;
                end
            end
            return;
        end
        return;
        -- cat_form
        -- wild_charge
        -- displacer_beast,if=movement.distance>10
        -- dash,if=movement.distance&buff.displacer_beast.down&buff.wild_charge_movement.down
        -- rake,if=buff.prowl.up|buff.shadowmeld.up
        -- auto_attack
        -- skull_bash
        -- pool_resource,wait=0.1,for_next=1,extra_amount=50
        -- elunes_guidance,if=combo_points=0&(!artifact.ashamanes_bite.enabled|!dot.ashamanes_rip.ticking)
        -- berserk,if=buff.tigers_fury.up
        -- incarnation,if=cooldown.tigers_fury.remains<gcd
        -- use_item,slot=trinket1,if=(prev.tigers_fury&(target.time_to_die>trinket.stat.any.cooldown|target.time_to_die<45))|prev.berserk|(buff.incarnation.up&time<10)
        -- potion,name=draenic_agility,if=((buff.berserk.remains>10|buff.incarnation.remains>20)&(target.time_to_die<180|(trinket.proc.all.react&target.health.pct<25)))|target.time_to_die<=40
        -- blood_fury,sync=tigers_fury
        -- berserking,sync=tigers_fury
        -- arcane_torrent,sync=tigers_fury
        -- tigers_fury,if=(!buff.clearcasting.react&energy.deficit>=60)|energy.deficit>=80|(t18_class_trinket&buff.berserk.up&buff.tigers_fury.down)
        -- tigers_fury,if=talent.sabertooth.enabled&time<10&combo_points=5
        -- incarnation,if=energy.time_to_max>1
        -- ferocious_bite,cycle_targets=1,if=dot.rip.ticking&dot.rip.remains<3&target.health.pct<25
        -- healing_touch,if=talent.bloodtalons.enabled&buff.predatory_swiftness.up&((combo_points>=4&!set_bonus.tier18_4pc)|combo_points=5|buff.predatory_swiftness.remains<1.5)
        -- healing_touch,if=talent.bloodtalons.enabled&buff.predatory_swiftness.up&combo_points=2&buff.bloodtalons.down&cooldown.ashamanes_frenzy.ready
        -- savage_roar,if=buff.savage_roar.down
        -- pool_resource,for_next=1
        -- thrash_cat,cycle_targets=1,if=remains<=duration*0.3&(spell_targets.thrash_cat>=2&set_bonus.tier17_2pc|spell_targets.thrash_cat>=4)
        -- call_action_list,name=aoe,if=spell_targets.swipe_cat>=3
        -- call_action_list,name=finisher,if=combo_points=5
        -- savage_roar,if=buff.savage_roar.remains<gcd
        -- ashamanes_frenzy,if=time<10&dot.rake.ticking&!talent.elunes_guidance.enabled
        -- call_action_list,name=maintain,if=combo_points<5
        -- pool_resource,for_next=1
        -- thrash_cat,cycle_targets=1,if=remains<=duration*0.3&spell_targets.thrash_cat>=2
        -- call_action_list,name=generator,if=combo_points<5

        -- ashamanes_frenzy,if=combo_points<=2&buff.elunes_guidance.down&(!talent.bloodtalons.enabled|buff.bloodtalons.up)
        -- pool_resource,for_next=1
        -- brutal_slash,if=spell_targets.brutal_slash>desired_targets
        -- pool_resource,for_next=1
        -- brutal_slash,if=active_enemies>=2&raid_event.adds.exists&raid_event.adds.in>(1+max_charges-charges_fractional)*15
        -- pool_resource,for_next=1
        -- brutal_slash,if=active_enemies>=2&!raid_event.adds.exists&(charges_fractional>2.66&time>10)
        -- swipe_cat,if=spell_targets.swipe_cat>=4
        -- shred,if=spell_targets.swipe_cat<=3|talent.brutal_slash.enabled

        -- rip,cycle_targets=1,if=remains<=duration*0.3&(target.health.pct>25|!dot.rip.ticking)
        -- savage_roar,if=buff.savage_roar.remains<=7.2&(target.health.pct<25|energy.time_to_max<1|buff.berserk.up|buff.incarnation.up|dot.rake.remains<1.5|buff.elunes_guidance.up|cooldown.tigers_fury.remains<3|(talent.moment_of_clarity.enabled&buff.clearcasting.react))
        -- ferocious_bite,max_energy=1,cycle_targets=1,if=(target.health.pct<25|talent.sabertooth.enabled)&(cooldown.tigers_fury.remains<3|energy.time_to_max<1|buff.berserk.up|buff.incarnation.up|dot.rake.remains<1.5|buff.elunes_guidance.up|(talent.moment_of_clarity.enabled&buff.clearcasting.react))
        -- ferocious_bite,max_energy=1,if=buff.berserk.up|buff.incarnation.up|cooldown.tigers_fury.remains<3|buff.elunes_guidance.up
        -- ferocious_bite,max_energy=1,if=energy.time_to_max<1

        -- shadowmeld,if=energy>=35&dot.rake.pmultiplier<2.1&buff.tigers_fury.up&(buff.bloodtalons.up|!talent.bloodtalons.enabled)&(!talent.incarnation.enabled|cooldown.incarnation.remains>18)&!buff.incarnation.up
        -- rake,cycle_targets=1,if=remains<=tick_time&((target.time_to_die-remains>3&spell_targets.swipe_cat<3)|target.time_to_die-remains>6)
        -- rake,cycle_targets=1,if=remains<=duration*0.3&(persistent_multiplier>=dot.rake.pmultiplier|(talent.bloodtalons.enabled&(buff.bloodtalons.up|!buff.predatory_swiftness.up)))&((target.time_to_die-remains>3&spell_targets.swipe_cat<3)|target.time_to_die-remains>6)
        -- moonfire_cat,cycle_targets=1,if=remains<=4.2&spell_targets.swipe_cat<=5&target.time_to_die-remains>tick_time*5

        -- thrash_cat,cycle_targets=1,if=remains<=duration*0.3&spell_targets.thrash_cat>=2
        -- call_action_list,name=finisher,if=combo_points=5
        -- swipe_cat


        --- DoT TickTime = Full_Duraction/(1+HastePct/100)/NB_Tick
        --- Bleed TickTime = Full_Duraction/NB_Tick
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Auto Cancel Form
        if module.IsOptionEnabled("Auto Cancel Cat Form") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and Player:DistanceTo(Target) > module.GetOptionValue("Auto Cancel Cat Form") and Player:Buff(S.CatForm) then
            CancelShapeshiftForm();
            return;
        end
        -- Healing Part
        if not Player:Buff(S.CatForm) then
            -- Auto-Resuscitate Friends
            if module.IsOptionEnabled("Auto-Resuscitate Friends") and Player:Standing() >= 0.7 then
                UnitNeedRes = Unit.Resurrect(S.Revive);
                if UnitNeedRes and UnitNeedRes:CanCast(S.Revive) then
                    UnitNeedRes:Cast(S.Revive);
                    return;
                end
                if not UnitNeedRes then Unit:ResurrectCheck(true); end
            end
            -- Auto-Heal OutOfCombat
            if module.IsOptionEnabled("Auto-Heal OutOfCombat") and Player:Mana()/Player:ManaMax()*100 >= module.GetSecondOptionValue("Auto-Heal OutOfCombat") and Player:HealthPercentage() <= module.GetOptionValue("Auto-Heal OutOfCombat") then
                if S.RestorationAffinity:Exists() then
                    if Player:CanCast(S.Swiftmend) then
                        Player:Cast(S.Swiftmend);
                        return;
                    end
                    if Player:BuffRemains(S.Rejuvenation) <= 4.5 and Player:CanCast(S.Rejuvenation) then
                        Player:Cast(S.Rejuvenation);
                        return;
                    end
                    if Player:Standing() >= 0.7 and Player:BuffRemains(S.Regrowth) <= 3 and Player:CanCast(S.Regrowth) then
                        Player:Cast(S.Regrowth);
                        return;
                    end
                end
                if Player:Standing() >= 0.7 and Player:CanCast(S.HealingTouch) then
                    Player:Cast(S.HealingTouch);
                    return;
                end
            end
            -- PreCasting S.HealingTouch to proc Bloodtalons Buff
            if module.IsOptionEnabled("Proc Bloodtalons") and S.Bloodtalons:Exists() and Player:BuffRemains(S.BloodtalonsBuff) <= module.GetOptionValue("Proc Bloodtalons") and not Player:Buff(S.CatForm) and Player:Standing() >= 0.7 and Player:CanCast(S.HealingTouch) then
                Player:Cast(S.HealingTouch);
                return;
            end
        end
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(S.DraenicAgilityBuff) and S.DraenicAgility:InStock() and not S.DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            if module.IsOptionEnabled("Auto Cat Form and Prowl") and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Cat Form and Prowl") then
                -- Auto Stealth
                if not Player:IsStealthed(true, true) and Player:CanCast(S.Prowl) then
                    Player:Cast(S.Prowl);
                    return;
                end
                -- Auto Cat Form
                if not Player:Buff(S.CatForm) and Player:CanCast(S.CatForm) then
                    Player:Cast(S.CatForm);
                    return;
                end
            end
            -- Open with rake when in range and stealthed
            if Player:IsStealthed(true, true) and Target:CanCast(S.Rake) then
                Target:Cast(S.Rake);
                return;
            end
        end
        return;
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Guardian Druid
    local Rotation = {};
    module.SetRotation(104, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local Enemies_40y, Enemies_30y , MoonfireUnit, SunfireUnit, PlayerEnemies_10y, SurroundingEnemies, NumEnemies = {}, {}, nil, nil, {}, {}, 0; -- Units
    local RandomOffGCD;
    -- Healers Specific
    local MainTank, MainTankTarget, OffTank, OffTankTarget, Lowest, HealUnits = nil, nil, nil, nil, nil, {};

    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        IntellectPotion = Item(109218, false, false, true);
        IntellectPotionBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        Barkskin = Spell(22812, false, false, true);
        BearForm = Spell(5487, false, false, true);
        BristlingFur = Spell(155835, false, false, true);
        CatForm = Spell(768, false, false, true);
        DisplacerBeast = Spell(137452, false, false , true);
        FrenziedRegeneration = Spell(22842, false, false, true);
        GalacticGuardian = Spell(203964);
        GalacticGuardianBuff = Spell(213708);
        Growl = Spell(6795, false, true, true);
        HealingTouch = Spell(5185, false, false, true);
        Incarnation = Spell(102558, false, false, true);
        Ironfur = Spell(192081, false, false, true);
        LunarBeam = Spell(204066, false, false, true);
        Maul = Spell(6807, true, true, true);
        Mangle = Spell(33917, true, true, true);
        MarkOfUrsol = Spell(192083, false, false, true);
        Pulverize = Spell(80313, true, true, true);
        PulverizeBuff = Spell(158792, false, false, true);
        RageOfTheSleeper = Spell(200851, false, false, true);
        Rebirth = Spell(20484, false, false, false, true);
        SoulOfTheForest = Spell(158447);
        SkullBash = Spell(106839, true, true, true);
        SurvivalInstincts = Spell(61336, false, false, true);
        Swipe = Spell(213764 , false, false, true);
        Thrash = Spell(106832, false, false, true);
        ThrashDebuff = Spell(192090);
        TravelForm = Spell(783, false, false, true);

        -- Feral Affinity
        FeralAffinity = Spell(202155);
        FeralThrash = Spell(77758, false, false, true);
        FerociousBite = Spell(22568 , true, true, true);
        Rip = Spell(1079 , true, true, true);
        Shred = Spell(5221 , true, true, true);

        -- Balance Affinity
        BalanceAffinity = Spell(197488);
        LunarEmpowerment = Spell(164547);
        LunarStrike = Spell(197628, true, true, false);
        MoonkinForm = Spell(197625, false, false, true);
        Moonfire = Spell(8921, true, true, true);
        MoonfireDebuff= Spell(164812);
        Sunfire = Spell(197630, true, true, true);
        SunfireDebuff= Spell(164815);
        SolarEmpowerment = Spell(164545);
        SolarWrath = Spell(197629, true, true, false);
        Starsurge = Spell(197626, true, true, true);

        -- Restoration Affinity
        RestorationAffinity = Spell(197492);
        Regrowth = Spell(8936, false, false, false);
        Rejuvenation = Spell(774, false, false, true);
        Swiftmend = Spell(18562, false, false, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {6, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest", "Untanked"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_SUBVALUE("Untanked").."Integrate tanking logic that will priorise the untaked units."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range.\n\n|cffFF0044Mode (Left Box)|r\n|cFF0088FFKeep:|r Cast on the new unit but keep your target the same.\n|cFF0088FFSwitch:|r Cast on the new unit and change your target to this unit.\n\n|cffFF0044Range (Right Box)|r\nSet the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.TauntManagerOptions("Growl");
        module.AddNewOption("General Settings", "Bear Form", 210, true, nil, nil, "Automatically handle Bear Form.");
        module.AddNewOption("General Settings", "Rebirth", 210, true, nil, nil, "Enable to automatically resurrect targeted dead player targets in combat.");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Skull Bash to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our LunarStrike to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Bristling Fur", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Bristling Fur."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Incarnation", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Incarnation."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Lunar Beam", 223, true, {1, 1, 10, 1}, {2, "Always", "Cooldown Only"}, "Use Incarnation."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Maul", 220, true, {80, 1, 85, 1}, nil, "Use Maul to dump rage when we do not need our Active Mitigation."..C.TOOLTIP_VALUE.."Minimum Rage needed to use Maul.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Moonfire", 222, false, { 5, 1, 10, 1 }, { 3, 0, 25, 0.1 }, "Multi-Dot Moonfire Cycle."..C.TOOLTIP_VALUE_1.."Number of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply."..C.TOOLTIP_HINT("Also applies to Balance Affinity."));
        module.AddNewOption("Offensive Settings", "Swipe", 120, true, {3, 1, 10, 1}, nil, "Use Swipe while in Bear Form."..C.TOOLTIP_VALUE.."Amount of units needed in range of player to use Swipe."..C.TOOLTIP_HINT("It will still be used as filler even if less units are detected."));
        module.AddNewOption("Offensive Settings", "Thrash", 120, true, {3, 1, 10, 1}, nil, "Use Thrash."..C.TOOLTIP_VALUE.."Amount of units needed in range of player to use Thrash."..C.TOOLTIP_HINT("It will still be used as filler even if less units are detected."));
        module.AddSection("Offensive Settings", "Balance Affinity", "Green");
        module.AddNewOption("Offensive Settings", "Balance Affinity", 210, false, nil, nil, "Enable Balance Affinity DPS.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Sunfire", 222, false, { 10, 1, 10, 1 }, { 3, 0, 25, 0.1 }, "Multi-Dot Sunfire Cycle."..C.TOOLTIP_VALUE_1.."Number of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddSection("Offensive Settings", "Feral Affinity", "Green");
        module.AddNewOption("Offensive Settings", "Feral Affinity", 210, false, nil, nil, "Enable Feral Affinity DPS.");
        module.AddNewOption("Offensive Settings", "Rip", 210, true, nil, nil, "Use Rip.");
        module.AddNewOption("Offensive Settings", "Feral Swipe", 220, true, {3, 1, 10, 1}, nil, "Use Swipe with Feral Affinity."..C.TOOLTIP_VALUE.."Amount of units needed within 10 yards of player to use Swipe.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Active Mitigation", 232, true, {1, "Ironfur", "Mark Of Ursol"}, {90, 1, 100, 1}, "Use Active Mitigation."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Barkskin", 220, true, {40, 1, 100, 1}, nil, "Use Barkskin."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Frenzied Regeneration", 220, true, {35, 1, 100, 1}, nil, "Use Frenzied Regeneration."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, true, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddNewOption("Defensive Settings", "Healing Touch Self", 220, true, {80, 1, 100, 1}, nil, "Use Healing Touch on ourself."..C.TOOLTIP_VALUE.."Health threshold while Out of Combat.");
        module.AddNewOption("Defensive Settings", "Pulverize", 220, true, {90, 1, 100, 1}, nil, "Use Pulverize."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Rage Of The Sleeper", 220, true, {45, 1, 100, 1}, nil, "Use Rage Of The Sleeper."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Survival Instincts", 220, true, {25, 1, 100, 1}, nil, "Use Survival Instincts."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Restoration Affinity", "Green");
        module.AddNewOption("Defensive Settings", "Healing Touch", 222, true, {95, 0, 100, 1}, {90, 0, 100, 1}, "Use Healing Touch."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Defensive Settings", "Regrowth", 222, true, {35, 0, 100, 1}, {25, 0, 100, 1}, "Use Regrowth."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Defensive Settings", "Rejuvenation", 222, true, {85, 0, 100, 1}, {80, 0, 100, 1}, "Use Rejuvenation."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Defensive Settings", "Rejuvenation Self", 220, true, {30, 1, 100, 1}, nil, "Use Rejuvenation on ourself."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Restoration Affinity", 210, false, nil, nil, "Enable Restoration Affinity Healing.");
        module.AddNewOption("Defensive Settings", "Swiftmend", 222, true, {40, 0, 100, 1}, {25, 0, 100, 1}, "Use Swiftmend."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we wait to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pot BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        -- Potion
        if module.GetOptionValue("Pre-Pot BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pot BossMod") == "Always" or Target:IsBoss()) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pot BossMod") or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) and Player:IsWithinCastRange(Target, Moonfire) then
            if Player:Potion("Agility", Potion) then module.Bug("Pre-Pull - Agility Potion"); Potion = true; end
        end
    end

    function Rotation:Interrupts ()
        Player:UseInterrupt(SkullBash);
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- barkskin
        if module.IsOptionEnabled("Barkskin") and Player:HealthPercentage() <= module.GetOptionValue("Barkskin") and Player:CanCast(Barkskin) then
            Player:Cast(Barkskin);
        end
    end

    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(Mangle, false) or Unit.Target;
        -- Survival Instincts
        if SurvivalInstincts:Exists() and module.IsOptionEnabled("Survival Instincts") and Player:HealthPercentage() <= module.GetOptionValue("Survival Instincts") and Player:CanCast(SurvivalInstincts) then
            Player:Cast(SurvivalInstincts);
            return;
        end
        -- Rage of the Sleeper
        if RageOfTheSleeper:Exists() and module.IsOptionEnabled("Rage Of The Sleeper") and Player:HealthPercentage() <= module.GetOptionValue("Rage Of The Sleeper") and Player:CanCast(RageOfTheSleeper) then
            Player:Cast(RageOfTheSleeper);
            return;
        end
        --- Maul
        RandomOffGCD = RandomOffGCD or math.random(35,115)*0.01;
        if Swipe:Cooldown() < RandomOffGCD then
            if Maul:Exists() and module.IsOptionEnabled("Maul") and Player:Rage() >= module.GetOptionValue("Maul") and Target:CanCast(Maul) then
                Target:Cast(Maul);
                RandomOffGCD = nil;
            end
            -- Active Mitigation
            if module.IsOptionEnabled("Active Mitigation") and (Player:Rage() >= 85 or (Player:HealthPercentage() <= module.GetSecondOptionValue("Active Mitigation") and Player:Rage() >= 45)) then
                if module.GetOptionValue("Active Mitigation") == "Ironfur" and (Player:BuffRemains(Ironfur) < 2 or Player:HealthPercentage() <= module.GetSecondOptionValue("Active Mitigation") or Player:Rage() >= 90) and Player:CanCast(Ironfur) then
                    Player:Cast(Ironfur);
                    RandomOffGCD = nil;
                end
                if module.GetOptionValue("Active Mitigation") == "Mark Of Ursol" and (Player:BuffRemains(MarkOfUrsol) < 2 or Player:HealthPercentage() <= module.GetSecondOptionValue("Active Mitigation") or Player:Rage() >= 90) and Player:CanCast(MarkOfUrsol) then
                    Player:Cast(MarkOfUrsol);
                    RandomOffGCD = nil;
                end
            end
            -- Frenzied Regeneration
            if module.IsOptionEnabled("Frenzied Regeneration") and Player:CanCast(FrenziedRegeneration) and not Player:Buff(FrenziedRegeneration) then
                if Player:HealthPercentage() <= module.GetOptionValue("Frenzied Regeneration") and Player:Rage() >= 10 then
                    Player:Cast(FrenziedRegeneration);
                    return;
                end
            end
        end
    end

    local function HealCycle (Spell, SpellOption, SpellBuff)
        if Spell:Exists() and module.IsOptionEnabled(SpellOption) then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue(SpellOption) and (not SpellBuff or MainTank:BuffRemains(SpellBuff) < 3) and MainTank:CanHeal(Spell) then
                MainTank:Cast(Spell);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue(SpellOption) and (not SpellBuff or OffTank:BuffRemains(SpellBuff) < 3) and OffTank:CanHeal(Spell) then
                OffTank:Cast(Spell);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue(SpellOption) and (not SpellBuff or Lowest:BuffRemains(SpellBuff) < 3) and Lowest:CanCast(Spell) then
                Lowest:Cast(Spell);
                return;
            end
            if SpellBuff then
                -- Cycle
                for i = 1, #HealUnits do
                    local ThisUnit = HealUnits[i];
                    if ThisUnit:CanHeal(Spell) and ThisUnit:BuffRemains(Spell) < 3 and ThisUnit:SpecialHealthPercentage() <= module.GetSecondOptionValue(SpellOption) then
                        ThisUnit:Cast(Spell);
                        return;
                    end
                end
            end
        end
    end

    function Rotation:Combat ()
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();
        -- Combat Res Target
        if Rebirth:Exists() and module.IsOptionEnabled("Rebirth") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and Target:IsPlayer() and Target:CanCast(Rebirth) then
            Target:Cast(Rebirth);
            return;
        end
        -- Restoration Affinity
        if RestorationAffinity:Exists() and module.IsOptionEnabled("Restoration Affinity") then
            if Player:Buff(BearForm) and Player:CanCast(BearForm) then
                Player:Cast(BearForm);
                return;
            end
            HealUnits = Player:HealUnitsAround(100, 40) or {};
            Lowest = Unit.Lowest(MainTank, OffTank);
            -- Swiftmend
            if Swiftmend:Exists() and module.IsOptionEnabled("Swiftmend") and not Swiftmend:IsOnCooldown() then
                if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Swiftmend") and (MainTank:Buff(Rejuvenation) or MainTank:Buff(Regrowth)) and MainTank:CanHeal(Swiftmend) then
                    MainTank:Cast(Swiftmend);
                    return;
                end
                if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Swiftmend") and (OffTank:Buff(Rejuvenation) or OffTank:Buff(Regrowth)) and OffTank:CanHeal(Swiftmend) then
                    OffTank:Cast(Swiftmend);
                    return;
                end
                if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Swiftmend") and (Lowest:Buff(Rejuvenation) or Lowest:Buff(Regrowth)) and Lowest:CanHeal(Swiftmend) then
                    Lowest:Cast(Swiftmend);
                    return;
                end
            end
            -- Regrowth Cycle
            HealCycle(Regrowth, "Regrowth", Regrowth);
            -- Rejuvenation Cycle
            HealCycle(Rejuvenation, "Rejuvenation", Rejuvenation);
            -- Healing Touch
            HealCycle(HealingTouch, "Healing Touch", nil);
        end
        -- Determine if we have enough time to use Celestial Alignment
        if Target:Exists() and Player:CanAttack(Target)  then
            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                local SourroundingRange = BalanceAffinity:Exists() and 13 or 8;
                Enemies_40y = Player:EnemiesWithinDistance(40); -- 40 yards for Dots Cycles.
                Enemies_30y = Player:FilterEnemiesByDistance(Enemies_40y, 30, false);
                MoonfireUnit = Unit.DotCycle(Enemies_40y, Moonfire, MoonfireDebuff, 16, "Multi-Dot Moonfire") or nil; -- Moonfire DoT Cycle
                SunfireUnit = BalanceAffinity:Exists() and module.IsOptionEnabled("Moonkin Affinity") and Unit.DotCycle(Enemies_40y, Sunfire, SunfireDebuff, 18, "Multi-Dot Sunfire") or nil; -- Sunfire DoT Cycle
                PlayerEnemies_10y = FeralAffinity:Exists() and module.IsOptionEnabled("Feral Affinity") and module.IsOptionEnabled("Feral Swipe") and Player:EnemiesWithinDistance(10, true) or {};
                SurroundingEnemies = Player:EnemiesWithinDistance(SourroundingRange);
                NumEnemies = #SurroundingEnemies;
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- Growl
            if Player:TauntManager(Growl, "Growl", Target, Enemies_30y) then
                return;
            end

            -- Balance Affinity
            if BalanceAffinity:Exists() and module.IsOptionEnabled("Balance Affinity") and Target:Exists() then
                -- Moonkin Form
                if MoonkinForm:Exists() and not Player:Buff(MoonkinForm) and Player:CanCast(MoonkinForm) and (not Player:Buff(CatForm) or Player:Buff(DisplacerBeast)) and not Player:Buff(TravelForm) then
                    Player:Cast(MoonkinForm);
                    return;
                end
                if Player:Buff(MoonkinForm) then
                    -- Starsurge
                    if Starsurge:Exists() and Target:CanCast(Starsurge) then
                        Target:Cast(Starsurge);
                        return;
                    end
                    -- Sunfire
                    if Sunfire:Exists() then
                        if Target:DebuffRemains(SunfireDebuff) < 5 and Target:CanCast(Sunfire) then
                            Target:Cast(Sunfire);
                            return;
                        end
                        if module.IsOptionEnabled("Multi-Dot Sunfire") and SunfireUnit and SunfireUnit:CanCast(Sunfire) then
                            SunfireUnit:Cast(Sunfire);
                            return;
                        end
                    end
                    -- Apply Moonfire
                    if Moonfire:Exists() then
                        if Target:DebuffRemains(MoonfireDebuff) < 6 and Target:CanCast(Moonfire) then
                            Target:Cast(Moonfire);
                            return;
                        end
                        if module.IsOptionEnabled("Multi-Dot Moonfire") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                            MoonfireUnit:Cast(Moonfire);
                            return;
                        end
                    end
                    -- Solar Wrath
                    if SolarWrath:Exists() and Player:Buff(SolarEmpowerment) and Target:CanCast(SolarWrath) then
                        Target:Cast(SolarWrath);
                        return;
                    end
                    -- Lunar Strike
                    if LunarStrike:Exists() and Target:CanCast(LunarStrike) then
                        Target:Cast(LunarStrike);
                        return;
                    end
                end
                return;
            end

            -- Feral Affinity
            if FeralAffinity:Exists() and module.IsOptionEnabled("Feral Affinity") then
                -- Apply Cat Form
                if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
                    Player:Cast(CatForm);
                    return;
                end
                -- Use Combos
                -- Rip with 5 Combo Points
                if Rip:Exists() and module.IsOptionEnabled("Rip") and Player:ComboPoints() >= 5 and Target:DebuffRemains(Rip) < 6 then
                    Target:Cast(Rip);
                    return;
                end
                -- Ferocious Bite with 5 Combo Points or less than 5 second till death
                if FerociousBite:Exists() and (Player:ComboPoints() >= 5 or Target:TimeToDie() < 5) then
                    Target:Cast(FerociousBite);
                    return;
                end
                -- Use Energy
                -- Swipe
                if module.IsOptionEnabled("Feral Swipe") and #PlayerEnemies_10y >= module.GetOptionValue("Feral Swipe") then
                    if Player:CanCast(Swipe) then
                        Player:Cast(Swipe);
                        return;
                    end
                else
                    -- Shred
                    if Target:CanCast(Shred) then
                        Target:Cast(Shred);
                        return;
                    end
                end
                return;
            end

            -- Bear Form
            if BearForm:Exists() and module.IsOptionEnabled("Bear Form") and not Player:Buff(BearForm) and Player:CanCast(BearForm) and (not Player:Buff(CatForm) or Player:Buff(DisplacerBeast)) and not Player:Buff(TravelForm) then
                Player:Cast(BearForm);
                return;
            end
            -- Cooldowns
            if Player:IsWithinCastRange(Target, Mangle) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Incarnation
                if Incarnation:Exists() and module.IsOptionEnabled("Incarnation") and (module.CooldownsAllowed() or module.GetOptionValue("Incarnation") == "Always") and Player:CanCast(Incarnation) then
                    Player:Cast(Incarnation);
                    return;
                end
                -- Bristling Fur
                if BristlingFur:Exists() and module.IsOptionEnabled("Bristling Fur") and (module.CooldownsAllowed() or module.GetOptionValue("Bristling Fur") == "Always") and Player:CanCast(BristlingFur) then
                    Player:Cast(BristlingFur);
                    return;
                end
            end

            -- Rotation
            -- Lunar Beam
            if LunarBeam:Exists() and Player:Standing() >= 1.5 and NumEnemies >= module.GetOptionValue("Lunar Beam") and (module.CooldownsAllowed() or module.GetSecondOptionValue("Lunar Beam") == "Always") and Player:IsWithinCastRange(Target, Mangle) and Player:CanCast(LunarBeam) then
                Player:Cast(LunarBeam);
                return;
            end
            -- Pulverize
            if Pulverize:Exists() and module.IsOptionEnabled("Pulverize") and Player:HealthPercentage() <= module.GetOptionValue("Pulverize") and Target:DebuffCount(ThrashDebuff) >= 2 and Player:BuffRemains(PulverizeBuff) < 3 and Target:CanCast(Pulverize) then
                Target:Cast(Pulverize);
                return;
            end
            -- Thrash - Apply or AoE - Weird Spell ID
            if (Thrash:Exists() or FeralThrash:Exists()) and Player:IsWithinCastRange(Target, Mangle) and (not Target:Debuff(ThrashDebuff) or (NumEnemies >= module.GetOptionValue("Thrash"))) and Player:CanCast(Thrash) and Player:CanCast(FeralThrash) then
                Player:Cast(Thrash);
                return;
            end
            -- Mangle
            if Mangle:Exists() and Target:CanCast(Mangle) then
                Target:Cast(Mangle);
                return;
            end
            -- Galactic Guardian
            if GalacticGuardian:Exists() and Player:Buff(GalacticGuardianBuff) and module.IsOptionEnabled("Multi-Dot Moonfire") then
                if MoonfireUnit and MoonfireUnit:Exists() and MoonfireUnit:CanCast(Moonfire) then
                    MoonfireUnit:Cast(Moonfire);
                    return;
                elseif Target:CanCast(Moonfire) then
                    Target:Cast(Moonfire);
                    return;
                end
            end
            -- Thrash - Weird Spell ID
            if (Thrash:Exists() or FeralThrash:Exists()) and Player:IsWithinCastRange(Target, Mangle) and Player:CanCast(Thrash) and Player:CanCast(FeralThrash) then
                Player:Cast(Thrash);
                return;
            end
            -- Swipe - Weird Spell ID
            if Swipe:Exists() and NumEnemies >= module.GetOptionValue("Swipe") and Player:IsWithinCastRange(Target, Mangle) and Player:CanCast(Swipe) then
                Player:Cast(Swipe);
                return;
            end
            -- Moonfire
            if Moonfire:Exists() and Target:DebuffRemains(MoonfireDebuff) < 3 and Target:CanCast(Moonfire) then
                Target:Cast(Moonfire);
                return;
            end
            -- Moonfire - Cycle
            if module.IsOptionEnabled("Multi-Dot Moonfire") and MoonfireUnit and MoonfireUnit:Exists() and MoonfireUnit:CanCast(Moonfire) then
                MoonfireUnit:Cast(Moonfire);
                return;
            end
            -- Swipe - Weird Spell ID
            if Swipe:Exists() and Player:IsWithinCastRange(Target, Mangle) and Player:CanCast(Swipe) then
                Player:Cast(Swipe);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Mangle, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    function Rotation:OutOfCombat ()
        -- Rejuvenation
        if RestorationAffinity:Exists() and Rejuvenation:Exists() and module.IsOptionEnabled("Rejuvenation Self") and Player:HealthPercentage() <= module.GetOptionValue("Rejuvenation Self") and Player:CanCast(Rejuvenation) and not Player:Buff(Rejuvenation) then
            Player:Cast(Rejuvenation);
            return;
        end
        -- Healing Touch
        if HealingTouch:Exists() and Player:Standing() > 1.5 and module.IsOptionEnabled("Healing Touch Self") and Player:HealthPercentage() <= module.GetOptionValue("Healing Touch Self") and Player:CanCast(HealingTouch) then
            Player:Cast(HealingTouch);
            return;
        end
        if not Player:Buff(CatForm) and not Player:Buff(BearForm) and not Player:Buff(TravelForm) then
            -- Feral Affinity
            if FeralAffinity:Exists() and module.IsOptionEnabled("Feral Affinity") then
                if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
                    Player:Cast(CatForm);
                    return;
                end
            -- Moonkin Form
            elseif BalanceAffinity:Exists() and module.IsOptionEnabled("Balance Affinity") then
                if not Player:Buff(MoonkinForm) and Player:CanCast(MoonkinForm) then
                    Player:Cast(MoonkinForm);
                    return;
                end
            -- Bear Form
            elseif not (RestorationAffinity:Exists() and module.IsOptionEnabled("Restoration Affinity")) and BearForm:Exists() and module.IsOptionEnabled("Bear Form") then
                if not Player:Buff(BearForm) and Player:CanCast(BearForm) then
                    Player:Cast(BearForm);
                    return;
                end
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Restoration Druid
    local Rotation = {};
    module.SetRotation(105, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshTables = 0, 0.1, 0; -- Combat Module Throttle
    -- Healers Specific
    local MainTank, MainTankTarget, OffTank, OffTankTarget, HealUnits, Lowest, CurrentBadDebuffs, BestTarget, DispelUnit;
    local Trinket1Units, Trinket2Units, RacialsUnits;
    -- Profile Specific
    local HealingRange, WildGrowthUnit, TranquilityUnits, IncarnationTreeOfLifeUnits, EssenceOfGHanirUnits, EfflorescenceUnits = 40, nil, {}, {}, {}, 0; -- Spells
    local Enemies, MoonfireUnit, SunfireUnit, PlayerEnemies_10y; -- Affinities
    local LifebloomUnits, MaxLifebloomValue, RejuvenationUnits, GerminationUnits = 0, 1, 0, 0;

    --- Initialize the rotation.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        LukewarmYakRoastBroth = Item(120293, false, false, true);
        DraenicChanneledManaPotion = Spell(156432, false, false, false);
        --Racials
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33697, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        AstralInfluence = Spell(197524);
        Barkskin = Spell(22812, false, false, true);
        CenarionWard = Spell(102351, false, false, true);
        Clearcasting = Spell(16870, false, false, true); -- Omen of Clarity proc
        Dash = Spell(1850, false, false, true);
        DisplacerBeast = Spell(137452, false, false , true);
        Efflorescence = Spell(145205, false, false, true);
        EssenceOfGHanir = Spell(208253, false, false, true);
        Germination = Spell(155675); -- Talent - Allow double Rejuv
        GerminationRejuvenation = Spell(155777, false, false, true); -- Buff ID of second Rejuv
        HealingTouch = Spell(5185, false, false, false);
        IncarnationTreeOfLife = Spell(33891, false, false, true);
        Ironbark = Spell(102342, false, false, true);
        Lifebloom = Spell(33763, false, false, true);
        MomentOfClarity = Spell(155577); -- Talent - Omen has 3 stacks when it proc
        NaturesCure = Spell(88423, false, false, true);
        RampantGrowth = Spell(155834, false, false, true);
        Rebirth = Spell(20484, false, false, false, true);
        Rejuvenation = Spell(774, false, false, true);
        Regrowth = Spell(8936, false, false, false);
        Renewal = Spell(108238, false, false, true);
        Revive = Spell(50769, false, false, false, true);
        SoulOfTheForest = Spell(158478, false, false, true);
        SoulOfTheForestBuff = Spell(114108, false, false, true);
        Swiftmend = Spell(18562, false, false, true);
        Tranquility = Spell(740, false, false, true);
        TravelForm = Spell(783, false, false, true);
        WildGrowth = Spell(48438, false, false, false);


        -- Balance Affinity
        BalanceAffinity = Spell(197632);
        LunarEmpowerment = Spell(164547);
        LunarStrike = Spell(197628, true, true, false);
        MoonkinForm = Spell(197625, false, false, true);
        Moonfire = Spell(8921, true, true, true);
        MoonfireDebuff= Spell(164812);
        Sunfire = Spell(93402, true, true, true);
        SunfireDebuff= Spell(164815);
        SolarEmpowerment = Spell(164545);
        SolarWrath = Spell(5176, true, true, false);
        Starsurge = Spell(197626, true, true, true);

        -- Feral Affinity
        FeralAffinity = Spell(197490);
        CatForm = Spell(768, false, false, true);
        FerociousBite = Spell(22568 , true, true, true);
        Rake = Spell(1822, true, true, true);
        RakeDebuff = Spell(155722);
        Rip = Spell(1079 , true, true, true);
        Shred = Spell(5221 , true, true, true);
        Swipe = Spell(213764 , false, false, true);

        -- Guardian Affinity
        BearForm = Spell(5487, false, false, true);
        GuardianAffinity = Spell(197491);
        FrenziedRegeneration = Spell(22842, false, false, true);
        Ironfur = Spell(192081, false, false, true);
        Mangle = Spell(33917, true, true, true);
        Thrash = Spell(77758, false, false, true);
        ThrashDebuff = Spell(192090);

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Healing Settings");
        module.AddPage("Cooldowns Settings");
        module.AddPage("Offensive/Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        -- Add options to pages
        module.AddNewOption("General Settings", "Focus Assignation", 230, true, {2, "Main Tank", "Off Tank"}, nil, "Select which Tank slot should be given to the focussed unit.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Nature's Cure", 232, false, {1, "Auto", "High", "Normal"}, {0.2, 0, 1, 0.1}, "Use Nature's Cure to Dispel bad debuffs on allied units."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Auto").."Dispel Active Dispel Raid debuffs as High Priority and other not listed debuffs as Normal Priority."..C.TOOLTIP_SUBVALUE("High").."Dispel all debuffs as High Priority even before urgent cooldowns."..C.TOOLTIP_SUBVALUE("Normal").."Dispel all debuffs as Normal Priority after urgent cooldowns."..C.TOOLTIP_VALUE_2.."Define how long you want to wait before dispelling to look more human. This does not apply to Active Dispels Raid debuffs which will always be as soon as Global Cooldown ends."..C.TOOLTIP_HINT("Active Raid Dispels are based on an hardcoded list. Please report of any dispels you may encounter that requires specific strategies so that they can be properly added to the list."));
        module.AddOption("General Settings", "Rebirth", true, "Enable to automatically resurrect targeted dead player targets in combat.");
        module.AddOption("General Settings", "Rebirth Tank", false, "Enable to use rebirth to resuscitate a dead tank. Set the delay before using it.", true, 0, 0, 3, 0.1);
        module.AddNewOption("General Settings", "Revive", 210, true, nil, nil, "Enable to use Redemption on dead friendly players while out of combat.");
        module.AddSection("General Settings", "Active Healing", "Green");
        module.AddNewOption("General Settings", "Heal Target", 230, true, {1, "Known Unit", "Any Unit"}, nil, "Heal our current target if it is listed to be healed." .. C.TOOLTIP_VALUE .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Known Unit") .. "Allow Heal Target to be used only when we are targetting a unit listed for it." .. C.TOOLTIP_SUBVALUE("Any Unit") .. "Allow Heal Target to be used on any unit.");
        module.AddNewOption("General Settings", "Raid Debuffs", 220, true, {40, 0, 100, 1}, nil, "Use Rejuvenation/Germination on Debuffed units." .. C.TOOLTIP_VALUE .. "Helath threshold.");
        module.AddNewOption("General Settings", "Tank Debuffs", 220, true, {50, 0, 100, 1}, nil, "Use Rejuvenation/Germination on Debuffed tanks." .. C.TOOLTIP_VALUE .. "Helath threshold.");
        module.AddNewOption("General Settings", "Topping", 220, true, {100, 0, 100, 1}, nil, "Use Rejuvenation/Germination/Regrowth/Healing Touch on units to be topped." .. C.TOOLTIP_VALUE .. "Helath threshold.");

        module.AddSection("Healing Settings", "Common Healing Thresholds", "Green");
        module.AddNewOption("Healing Settings", "Efflorescence", 222, true, {3, 1, 10, 1}, {90, 0, 100, 1}, "Use when selected number of units are under health threshold." .. C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold.");
        module.AddNewOption("Healing Settings", "Healing Touch", 222, true, {80, 0, 100, 1}, {70, 0, 100, 1}, "Use Healing Touch." .. C.TOOLTIP_VALUE_1 .. "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Lifebloom", 220, true, { 80, 0, 100, 1 }, nil, "Use Lifebloom." .. C.TOOLTIP_VALUE .. "Health threshold under wich we want to let the Lifebloom bloom."..C.TOOLTIP_HINT("We will always apply Lifebloom and maintain it as long as the unit have more health than the specified value. Main Tank will be preferred but if it is not tanking then the Off Tank will be preferred."));
        module.AddNewOption("Healing Settings", "Regrowth", 222, true, {65, 0, 100, 1}, {55, 0, 100, 1}, "Use Regrowth." .. C.TOOLTIP_VALUE_1 .. "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Regrowth Emergency", 222, true, {40, 0, 100, 1}, {25, 0, 100, 1}, "Use Regrowth without Regrowth Buff check." .. C.TOOLTIP_VALUE_1 .. "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."..C.TOOLTIP_HINT("This should be set very low unless you know you can afford the high mana cost of Regrowth."));
        module.AddNewOption("Healing Settings", "Rejuvenation Counts", 122, true, {10, 1, 25, 1}, {10, 1, 25, 1}, "Maximum buffs counts for Rejuvenation and Germination." .. C.TOOLTIP_VALUE_1 .. "Maximum buffs counts for Rejuvenation." .. C.TOOLTIP_VALUE_2 .. "Maximum buffs counts for Germination.");
        module.AddNewOption("Healing Settings", "Rejuvenation", 222, true, {90, 0, 100, 1}, {80, 0, 100, 1}, "Use Rejuvenation." .. C.TOOLTIP_VALUE_1 .. "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Rejuvenation Germination", 222, true, {80, 0, 100, 1}, {70, 0, 100, 1}, "Use Rejuvenation for Germination." .. C.TOOLTIP_VALUE_1 .. "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Wild Growth", 222, true, {4, 1, 5, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold." .. C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold.");
        module.AddNewOption("Healing Settings", "Out Of Combat Healing", 210, true, nil, nil, "Allow Healing while Out of Combat." .. C.TOOLTIP_VALUE .. "Select Spell to use.");

        module.AddSection("Cooldowns Settings", "Cooldowns", "Green");
        module.AddNewOption("Cooldowns Settings", "Cenarion Ward", 222, true, {80, 0, 100, 1}, {70, 0, 100, 1}, "Use Cenarion Ward on tanking units." .. C.TOOLTIP_VALUE_1 .. "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.");
        module.AddNewOption("Cooldowns Settings", "Essence Of G'Hanir", 222, true, {1, 1, 5, 1}, {50, 0, 100, 1}, "Use when selected number of units are under health threshold." .. C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Incarnation: Tree Of Life", 222, true, {2, 1, 25, 1}, {60, 0, 100, 1}, "Use when selected number of units are under health threshold." .. C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Ironbark", 220, true, {30, 0, 100, 1}, nil, "Use Ironbark on a tank that fall under threshold.");
        module.AddNewOption("Cooldowns Settings", "Swiftmend", 222, true, {35, 0, 100, 1}, {15, 0, 100, 1}, "Use Swiftmend." .. C.TOOLTIP_VALUE_1 .. "Health threshold to use on Tanks." .. C.TOOLTIP_VALUE_2 .. "Health threshold to use on any Raid members.");
        module.AddNewOption("Cooldowns Settings", "Tranquility", 222, true, {3, 1, 25, 1}, {70, 0, 100, 1}, "Use when selected number of units are under health threshold." .. C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Soft Cooldowns Units", 120, true, {3, 1, 25, 1}, nil, "Number of units that needs to be under thresholds to use Racials and Trinkets with Health.");
        module.AddNewOption("Cooldowns Settings", "Use Racials", 220, true, {80, 0, 100, 1}, nil, "Use Racials. \n\n|cFF0088FFArcane Torrent:|r Mana threshold under which we want to use Arcane Torrent.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 1", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 1 with selected values." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Always") .." Use Always." .. C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value." .. C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold." .. C.TOOLTIP_VALUE_2 .. "Define Health or Mana threshold.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 2", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 2 with selected values." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Always") .." Use Always." .. C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value." .. C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold." .. C.TOOLTIP_VALUE_2 .. "Define Health or Mana threshold.");

        module.AddSection("Offensive/Defensive Settings", "DPS Offensive", "Green");
        module.AddPresetOption("TargetAttack");
        module.AddNewOption("Offensive/Defensive Settings", "DPS", 220, true, {95, 0, 100, 1}, nil, "Enables DPS options." .. C.TOOLTIP_VALUE .. "Will only DPS if the Lowest unit is above DPS health treshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Moonfire", 210, false, nil, nil, "Use Moonfire in the DPS rotation." .. C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Multi-Dot Moonfire", 222, false, { 5, 1, 10, 1 }, { 3, 0, 25, 0.1 }, "Multi-Dot Moonfire Cycle."..C.TOOLTIP_VALUE_1.."Number of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply."..C.TOOLTIP_HINT("Also applies to Balance, Guardian and Feral Affinities."));
        module.AddNewOption("Offensive/Defensive Settings", "Multi-Dot Sunfire", 222, false, { 10, 1, 10, 1 }, { 3, 0, 25, 0.1 }, "Multi-Dot Sunfire Cycle."..C.TOOLTIP_VALUE_1.."Number of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply."..C.TOOLTIP_HINT("Also applies to Balance Affinity."));
        module.AddNewOption("Offensive/Defensive Settings", "Sunfire", 210, false, nil, nil, "Use Sunfire in the DPS rotation." .. C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Solar Wrath", 210, false, nil, nil, "Use Solar Wrath in the DPS rotation." .. C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddSection("Offensive/Defensive Settings", "Balance Affinity", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Balance Affinity", 221, false, {70, 0, 100, 1, 15}, {90}, "Enable Balance Affinity DPS."..C.TOOLTIP_VALUE_1.."Swap out of Moonkin Form when the Lowest unit health is under this threshold."..C.TOOLTIP_VALUE_2.."Enter Moonkin Form when the Lowest unit's health is higher than this threshold.");
        module.AddSection("Offensive/Defensive Settings", "Feral Affinity", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Feral Affinity", 221, false, {70, 0, 100, 1, 15}, {90}, "Enable Feral Affinity DPS."..C.TOOLTIP_VALUE_1.."Swap out of Cat Form when the Lowest unit health is under this threshold."..C.TOOLTIP_VALUE_2.."Enter Cat Form when the Lowest unit's health is higher than this threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Rip", 210, true, nil, nil, "Use Rip.");
        module.AddNewOption("Offensive/Defensive Settings", "Swipe", 220, true, {3, 1, 10, 1}, nil, "Use Swipe."..C.TOOLTIP_VALUE.."Amount of units needed within 10 yards of player to use Swipe.");
        module.AddSection("Offensive/Defensive Settings", "Guardian Affinity", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Guardian Affinity", 210, false, nil, nil, "Enable Guardian Affinity Tanking.");
        module.AddNewOption("Offensive/Defensive Settings", "Frenzied Regeneration", 220, true, {35, 1, 100, 1}, nil, "Use Frenzied Regeneration."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Ironfur", 220, true, {90, 1, 100, 1}, nil, "Use Ironfur."..C.TOOLTIP_VALUE.."Health threshold."..C.TOOLTIP_HINT("Will be used regardless of health when rage is higher than 85."));
        module.AddSection("Offensive/Defensive Settings", "Defensive", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Barkskin", 220, true, {60, 1, 100, 1}, nil, "Use Barkskin." .. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Renewal", 220, true, {40, 1, 100, 1}, nil, "Use Renewal." .. C.TOOLTIP_VALUE .. "Health threshold.");

        -- Healers Specific
        module.AddOutput("|cFF9A2EFEMain Tank:");
        module.AddOutput("|cFF9A2EFEOff Tank:");
        module.AddOutput("|cFF9A2EFEBad Debuffs:");
        module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [HealingTouch:ID()] = "Healing Touch",
            [Regrowth:ID()] = "Regrowth",
            [SolarWrath:ID()] = "Solar Wrath",
            [Starsurge:ID()] = "Starsurge",
            [WildGrowth:ID()] = "Wild Growth"
        };
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:Buff(DraenicChanneledManaPotion) or not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or (Player:Buff(Dash) and Player:Buff(CatForm)) then
            return;
        end

        -- Define Main Tanks
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();

        if Player:IsInCombat() then
            self:Defensives();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end


    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Renewal
        if module.IsOptionEnabled("Renewal") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Renewal") and Player:CanCast(Renewal) then
            Player:Cast(Renewal);
            return;
        end
        -- Barkskin
        if module.IsOptionEnabled("Barkskin") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Barkskin") and Player:CanCast(Barkskin) then
            Player:Cast(Barkskin);
        end
    end

    function Rotation:OffGCDAbilities ()
        -- Guardian Affinity
        if GuardianAffinity:Exists() and module.IsOptionEnabled("Guardian Affinity") and Player:Buff(BearForm) then
            -- Ironfur
            if module.IsOptionEnabled("Ironfur") and Player:CanCast(Ironfur) then
                if Player:Rage() >= 85 or (Player:HealthPercentage() <= module.GetOptionValue("Ironfur") and Player:Rage() >= 40 and not Player:Buff(Ironfur)) then
                    Player:Cast(Ironfur);
                    return;
                end
            end
            -- Frenzied Regeneration
            if module.IsOptionEnabled("Frenzied Regeneration") and Player:CanCast(FrenziedRegeneration) and not Player:Buff(FrenziedRegeneration) then
                if Player:HealthPercentage() <= module.GetOptionValue("Frenzied Regeneration") and Player:Rage() >= 10 then
                    Player:Cast(FrenziedRegeneration);
                    return;
                end
            end
        end
    end

    -- Active Healing Heal Target handler
    local function HealTarget (ThisUnit)
        -- Regrowth
        if ThisUnit:CanHeal(Regrowth) then
            module.Bug("Heal Target - Regrowth");
            ThisUnit:Cast(Regrowth);
            return;
        end
    end

    -- Get Tanks Status
    local TanksStatus, MainTankTanking, OffTankTanking = {Main = {IsTanking = module.GetTime()},Off = {IsTanking = module.GetTime()}};
    local function RefreshTanksStatus ()
        TanksStatus = {
            Main = {IsTanking = MainTank and MainTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Main.IsTanking},
            Off = {IsTanking = OffTank and OffTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Off.IsTanking}
        };
        MainTankTanking = module.GetTime() - TanksStatus.Main.IsTanking < 3 or false;
        OffTankTanking = module.GetTime() - TanksStatus.Off.IsTanking < 3 or false;
    end

    local function Efflorescences ()
        if module.IsOptionEnabled("Efflorescence") and Player:CanCast(Efflorescence) and (not module.LastEfflorescenceTime or module.GetTime() - module.LastEfflorescenceTime > 8) then
            local UnitsTreshold = module.GetOptionValue("Efflorescence");
            if EfflorescenceUnits < UnitsTreshold or (not module.LastEfflorescenceTime or module.GetTime() - module.LastEfflorescenceTime > 30) then
                local HealthThreshold = module.GetSecondOptionValue("Efflorescence");
                local HealUnits = Player:HealUnitsAround(HealthThreshold, 35);
                local BestHealUnits = {};
                for i = 1, #HealUnits do
                    local ThisUnit = HealUnits[i]
                    if ThisUnit:CanHeal(HealingTouch) and not ThisUnit:IsMoving() then
                        local TheseHealUnits = ThisUnit:HealUnitsAround(HealthThreshold, 10);
                        if #TheseHealUnits + 1 >= UnitsTreshold and #TheseHealUnits > #BestHealUnits then
                            BestHealUnits = TheseHealUnits;
                            BestUnit = ThisUnit;
                        end
                    end
                end
                if #BestHealUnits >= UnitsTreshold then
                    module.LastEfflorescenceTime = module.GetTime();
                    Player:CastGroundHeal(Efflorescence, BestHealUnits, true);
                    return;
                end
            end
        end
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
    -- Init + Dispels
        HealingRange = AstralInfluence:Exists() and 45 or 40;

        -- T18 Lifebloom tweak
        if module.HasT18_4Pc and select(8,GetInstanceInfo()) ~= 1148 then
            Lifebloom = Spell(188550, false, false, true);
            MaxLifebloomValue = 2;
        else
            Lifebloom = Spell(33763, false, false, true);
            MaxLifebloomValue = 1;
        end

        -- Find best unit to attack
        if Target:Exists() and Target:CanCast(SolarWrath) then
            BestTarget = Target;
        elseif MainTankTarget and MainTankTarget:CanCast(SolarWrath) then
            BestTarget = MainTankTarget;
        elseif OffTankTarget and OffTankTarget:CanCast(SolarWrath) then
            BestTarget = OffTankTarget;
        elseif Mouseover:Exists() and Mouseover:CanCast(SolarWrath) then
            BestTarget = Mouseover;
        else
            BestTarget = Target;
        end

        -- Refresh tables every 0.5 seconds sync with CanCast to avoid refreshing too early during Casts or GCD.
        if RefreshTables < module.GetTime() and (RefreshTables == 0 or Player:CanCast(Rejuvenation)) then
            HealUnits = Player:HealUnitsAround(100, HealingRange);
            Lowest = Unit.Lowest(MainTank, OffTank);
            RefreshTanksStatus();
            LifebloomUnits = #Player:GroupUnitsWithLifebloom(Lifebloom);
            RejuvenationUnits = #Player:UnitsWithBuff(HealUnits, Rejuvenation, 4);
            GerminationUnits = #Player:UnitsWithBuff(HealUnits, GerminationRejuvenation, 4);
            WildGrowthUnit = module.IsOptionEnabled("Wild Growth") and WildGrowth:Exists() and ((Player:Buff(SoulOfTheForestBuff) and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Wild Growth") - 1, module.GetSecondOptionValue("Wild Growth"), 30)) or Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Wild Growth"), module.GetSecondOptionValue("Wild Growth"), 30)) or nil;
            TranquilityUnits = Tranquility:Exists() and Player:HealUnitsAround(module.GetSecondOptionValue("Tranquility"), HealingRange) or {};
            IncarnationTreeOfLifeUnits = IncarnationTreeOfLife:Exists() and Player:HealUnitsAround(module.GetSecondOptionValue("Incarnation: Tree Of Life"), HealingRange) or {};
            EssenceOfGHanirUnits = EssenceOfGHanir:Exists() and Player:HealUnitsAround(module.GetSecondOptionValue("Essence Of G'Hanir"), HealingRange) or {};
            Trinket1Units = module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 1"), HealingRange) or 0;
            Trinket2Units = module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 2"), HealingRange) or 0;
            RacialsUnits = module.IsOptionEnabled("Use Racials") and ((Berserking:Exists() and Player:CanCast(Berserking)) or (BloodFury:Exists() and Player:CanCast(BloodFury))) and #Player:HealUnitsAround(module.GetOptionValue("Use Racials"), HealingRange) or 0;
            Enemies = Player:EnemiesWithinDistance(40); -- 40 yards for Dots Cycles.
            EfflorescenceUnits = Unit.FriendliesNearMushroom(12);
            MoonfireUnit = Unit.DotCycle(Enemies, Moonfire, MoonfireDebuff, 22, "Multi-Dot Moonfire"); -- Moonfire DoT Cycle
            SunfireUnit = Unit.DotCycle(Enemies, Sunfire, SunfireDebuff, 22, "Multi-Dot Sunfire"); -- Sunfire DoT Cycle
            PlayerEnemies_10y = FeralAffinity:Exists() and module.IsOptionEnabled("Feral Affinity") and module.IsOptionEnabled("Swipe") and Player:EnemiesWithinDistance(10, true) or {};
            -- Bad Debuffs
            CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits);
            if CurrentBadDebuffs ~= nil then
                module.SetOutput("|cFF9A2EFEBad Debuffs:", #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff);
            end
            DispelUnit = Unit.Dispel(NaturesCure);
            RefreshTables = module.GetTime() + 0.5;
        end
        -- Guardian Affinity
        if GuardianAffinity:Exists() and module.IsOptionEnabled("Guardian Affinity") then
            -- Apply Bear Form
            if not Player:Buff(BearForm) and Player:CanCast(BearForm) then
                Player:Cast(BearForm);
                return;
            end
            -- Bear DPS
            if Player:IsWithinCastRange(BestTarget, Mangle) then
                if not BestTarget:Debuff(ThrashDebuff) and Player:CanCast(Thrash) then
                    Player:Cast(Thrash);
                    return;
                end
                if BestTarget:CanCast(Mangle) then
                    BestTarget:Cast(Mangle);
                    return;
                end
                if Player:CanCast(Thrash) then
                    Player:Cast(Thrash);
                    return;
                end
            end
            -- Apply Moonfire
            if Moonfire:Exists() then
                if BestTarget:DebuffRemains(MoonfireDebuff) < 6 and BestTarget:CanCast(Moonfire) then
                    BestTarget:Cast(Moonfire);
                    return;
                end
                if MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                    MoonfireUnit:Cast(Moonfire);
                    return;
                end
            end
            return;
        end
        -- Combat Res Tanks
        if MainTank and MainTank:Exists() and not MainTank:IsDeadOrGhost() then MainTankResDelay = nil; end
        if OffTank and OffTank:Exists() and not OffTank:IsDeadOrGhost() then OffTankResDelay = nil; end
        if module.IsOptionEnabled("Rebirth Tank") then
            if MainTank and MainTank:Exists() and MainTank:IsDeadOrGhost() and MainTank:IsPlayer() and MainTank:CanCast(Rebirth) then
                if not MainTankResDelay then MainTankResDelay = module.GetTime(); end
                if module.GetTime()-MainTankResDelay >= module.GetOptionValue("Rebirth Tank") then
                    MainTankResDelay = nil;
                    MainTank:Cast(Rebirth);
                    return;
                end
            elseif OffTank and OffTank:Exists() and OffTank:IsDeadOrGhost() and OffTank:IsPlayer() and OffTank:CanCast(Rebirth) then
                if not OffTankResDelay then OffTankResDelay = module.GetTime(); end
                if module.GetTime()-OffTankResDelay >= module.GetOptionValue("Rebirth Tank") then
                    OffTankResDelay = nil;
                    OffTank:Cast(Rebirth);
                    return;
                end
            end
        end
        -- Res Target
        if module.IsOptionEnabled("Rebirth") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and Target:IsPlayer() and Target:CanCast(Rebirth) then
            Target:Cast(Rebirth);
            return;
        end

        -- Dispels Handling
        Player:DispelHandler(NaturesCure, "Nature's Cure", DispelUnit, CurrentBadDebuffs.Dispel, "High");

        -- Feral Affinity
        if FeralAffinity:Exists() and module.IsOptionEnabled("Feral Affinity") and not (CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0) then
            LowestUnit = Unit.Lowest();
            -- Apply Cat Form
            if not Player:Buff(CatForm) and LowestUnit:HealthPercentage() > module.GetSecondOptionValue("Feral Affinity") and BestTarget and BestTarget:Exists() and Player:CanAttack(BestTarget) and Player:IsWithinCastRange(BestTarget, Shred) and Player:CanCast(CatForm) then
                Player:Cast(CatForm);
                return;
            end
            -- Swap out of Cat Form
            if Player:Buff(CatForm) and LowestUnit:HealthPercentage() < module.GetOptionValue("Feral Affinity") and Player:CanCast(CatForm) then
                Player:Cast(CatForm);
                return;
            end
            if BestTarget and BestTarget:Exists() and Player:Buff(CatForm) and LowestUnit:HealthPercentage() > module.GetOptionValue("Feral Affinity") then
                -- Use Combos
                -- Rip with 5 Combo Points
                -- actions.finisher=rip,if=combo=5&remains<=duration*0.3&(target.health.pct>25|!dot.rip.ticking)
                if Rip:Exists() and module.IsOptionEnabled("Rip") and Player:ComboPoints() >= 5 and BestTarget:DebuffRemains(Rip) < 7.2 and (BestTarget:HealthPercentage() > 25 or not BestTarget:Debuff(Rip)) and BestTarget:TimeToDie() > 12 and BestTarget:CanCast(Rip) then
                    BestTarget:Cast(Rip);
                    return;
                end
                -- actions.finisher=rip,if=combo>=1&!dot.rip.ticking&ttd<12&ttd>3
                if Rip:Exists() and module.IsOptionEnabled("Rip") and Player:ComboPoints() >= 1 and not BestTarget:Debuff(Rip) and BestTarget:TimeToDie() < 12 and BestTarget:TimeToDie() > 3 and BestTarget:CanCast(Rip) then
                    BestTarget:Cast(Rip);
                    return;
                end
                -- actions+=/ferocious_bite,if=combo>=1&dot.rip.ticking&dot.rip.remains<3&target.health.pct<25
                if FerociousBite:Exists() and Player:ComboPoints() >= 1 and BestTarget:Debuff(Rip) and BestTarget:DebuffRemains(Rip) < 3 and BestTarget:HealthPercentage() < 25 and BestTarget:CanCast(FerociousBite) then
                    BestTarget:Cast(FerociousBite);
                    return;
                end
                -- actions.finisher+=/ferocious_bite,max_energy=1,if=energy.time_to_max<1
                if FerociousBite:Exists() and Player:ComboPoints() >= 5 and Player:PowerTimeToMax() < 1 and BestTarget:CanCast(FerociousBite) then
                    BestTarget:Cast(FerociousBite);
                    return;
                end
                -- Swipe
                if module.IsOptionEnabled("Swipe") and #PlayerEnemies_10y >= module.GetOptionValue("Swipe") then
                    if Player:CanCast(Swipe) then
                        Player:Cast(Swipe);
                        return;
                    end
                else
                    -- Rake
                    if Rake:Exists() and BestTarget:DebuffRemains(RakeDebuff) < 4.5 and BestTarget:TimeToDie() > 6 and BestTarget:CanCast(Rake) then
                        BestTarget:Cast(Rake);
                        return;
                    end
                    -- Shred
                    if BestTarget:CanCast(Shred) then
                        BestTarget:Cast(Shred);
                        return;
                    end
                end
            end
            -- Prevent Swapout
            if Player:Buff(CatForm) and LowestUnit:HealthPercentage() > module.GetOptionValue("Feral Affinity") and BestTarget and BestTarget:Exists() and Player:IsWithinCastRange(BestTarget, Shred) then
                return;
            end
        end

        -- Balance Affinity
        if BalanceAffinity:Exists() and module.IsOptionEnabled("Balance Affinity") and BestTarget and BestTarget:Exists() and Player:CanAttack(BestTarget) and Player:IsWithinCastRange(BestTarget, Moonfire) and not (CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0) then
            LowestUnit = Unit.Lowest();
            -- Moonkin Form
            if MoonkinForm:Exists() and LowestUnit:HealthPercentage() > module.GetSecondOptionValue("Balance Affinity") and not Player:Buff(MoonkinForm) and (not Player:Buff(CatForm) or Player:Buff(DisplacerBeast)) and not Player:Buff(BearForm) and not Player:Buff(TravelForm) and Player:CanCast(MoonkinForm) then
                Player:Cast(MoonkinForm);
                return;
            end
            -- Swap out of Moonkin Form
            if Player:Buff(MoonkinForm) and LowestUnit:HealthPercentage() < module.GetOptionValue("Balance Affinity") and Player:CanCast(MoonkinForm) then
                Player:Cast(MoonkinForm);
                return;
            end
            if Player:Buff(MoonkinForm) and LowestUnit:HealthPercentage() > module.GetOptionValue("Balance Affinity") then
                -- Starsurge
                if Starsurge:Exists() and BestTarget:CanCast(Starsurge) then
                    BestTarget:Cast(Starsurge);
                    return;
                end
                -- Sunfire
                if Sunfire:Exists() then
                    if BestTarget:DebuffRemains(SunfireDebuff) < 5 and BestTarget:CanCast(Sunfire) then
                        BestTarget:Cast(Sunfire);
                        return;
                    end
                    if module.IsOptionEnabled("Multi-Dot Sunfire") and SunfireUnit and SunfireUnit:CanCast(Sunfire) then
                        SunfireUnit:Cast(Sunfire);
                        return;
                    end
                end
                -- Apply Moonfire
                if Moonfire:Exists() then
                    if BestTarget:DebuffRemains(MoonfireDebuff) < 6 and BestTarget:CanCast(Moonfire) then
                        BestTarget:Cast(Moonfire);
                        return;
                    end
                    if module.IsOptionEnabled("Multi-Dot Moonfire") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                        MoonfireUnit:Cast(Moonfire);
                        return;
                    end
                end
                -- Solar Wrath
                if SolarWrath:Exists() and Player:Buff(SolarEmpowerment) and BestTarget:CanCast(SolarWrath) then
                    BestTarget:Cast(SolarWrath);
                    return;
                end
                -- Lunar Strike
                if LunarStrike:Exists() and BestTarget:CanCast(LunarStrike) then
                    BestTarget:Cast(LunarStrike);
                    return;
                end
            end
            -- Prevent Swapout
            if Player:Buff(MoonkinForm) and LowestUnit:HealthPercentage() > module.GetOptionValue("Balance Affinity") and BestTarget and BestTarget:Exists() and Player:IsWithinCastRange(BestTarget, Moonfire) then
                return;
            end
        end
    -- DPS Management
        -- Only use DPS and Cooldowns during combat
        if Player:IsInCombat() then
            if BestTarget and module.IsOptionEnabled("DPS") and Lowest:HealthPercentage() >= module.GetOptionValue("DPS") and (not MainTank or MainTank:HealthPercentage() >= module.GetOptionValue("DPS")) and (not OffTank or OffTank:HealthPercentage() >= module.GetOptionValue("DPS")) and BestTarget:IsInCombat() then
                -- Sunfire
                if Sunfire:Exists() then
                    if module.IsOptionEnabled("Sunfire") and BestTarget:DebuffRemains(SunfireDebuff) < 5 and BestTarget:CanCast(Sunfire) then
                        BestTarget:Cast(Sunfire);
                        return;
                    end
                    if module.IsOptionEnabled("Multi-Dot Sunfire") and SunfireUnit and SunfireUnit:CanCast(Sunfire) then
                        SunfireUnit:Cast(Sunfire);
                        return;
                    end
                end
                -- Apply Moonfire
                if Moonfire:Exists() then
                    if module.IsOptionEnabled("Moonfire") and BestTarget:DebuffRemains(MoonfireDebuff) < 6 and BestTarget:CanCast(Moonfire) then
                        BestTarget:Cast(Moonfire);
                        return;
                    end
                    if module.IsOptionEnabled("Multi-Dot Moonfire") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                        MoonfireUnit:Cast(Moonfire);
                        return;
                    end
                end
                -- Wrath
                if SolarWrath:Exists() and module.IsOptionEnabled("Solar Wrath") and BestTarget:CanCast(SolarWrath) then
                    BestTarget:Cast(SolarWrath);
                    return;
                end
            end
    -- Cooldowns
            -- Racials with Specific Handlers
            if module.IsOptionEnabled("Use Racials") then
                if RacialsUnits >= module.GetOptionValue("Soft Cooldowns Units") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                        return;
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                        return;
                    end
                end
            end
            -- Trinkets with specific handlers
            if module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 1"), module.GetSecondOptionValue("Use Trinket 1");
                if Option1 == "Always" or (Option1 == "Health" and Trinket1Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 1")) then
                    Trinket1:UseInventory();
                end
            end
            if module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 2"), module.GetSecondOptionValue("Use Trinket 2");
                if Option1 == "Always" or (Option1 == "Health" and Trinket2Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 2")) then
                    Trinket2:UseInventory();
                end
            end
            if module.CooldownsAllowed() then
                -- Incarnation: Tree of Life
                if IncarnationTreeOfLife:Exists() and module.IsOptionEnabled("Incarnation: Tree Of Life") and #IncarnationTreeOfLifeUnits >= module.GetOptionValue("Incarnation: Tree Of Life") and not Player:Buff(IncarnationTreeOfLife) and Player:CanCast(IncarnationTreeOfLife) then
                    Player:Cast(IncarnationTreeOfLife);
                    return;
                end
                -- Tranquility
                if Tranquility:Exists() and module.IsOptionEnabled("Tranquility") and #TranquilityUnits >= module.GetOptionValue("Tranquility") and Player:CanCast(Tranquility) then
                    Player:Cast(Tranquility);
                    return;
                end
                -- Ironbark
                if Ironbark:Exists() and module.IsOptionEnabled("Ironbark") then
                    if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Ironbark") and MainTank:CanCast(Ironbark) then
                        module.Bug("Ironbark - MainTank");
                        MainTank:Cast(Ironbark);
                        return;
                    end
                    if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Ironbark") and OffTank:CanCast(Ironbark) then
                        module.Bug("Ironbark - OffTank");
                        OffTank:Cast(Ironbark);
                        return;
                    end
                end
                -- Essence of G'Hanir
                if EssenceOfGHanir:Exists() and module.IsOptionEnabled("Essence Of G'Hanir") and #EssenceOfGHanirUnits >= module.GetOptionValue("Essence Of G'Hanir") and Player:CanCast(EssenceOfGHanir) then
                    Player:Cast(EssenceOfGHanir);
                    return;
                end
            end
        end
        -- Swiftmend
        if Swiftmend:Exists() and module.IsOptionEnabled("Swiftmend") then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Swiftmend") and MainTank:CanHeal(Swiftmend) then
                module.Bug("Swiftmend - MainTank");
                MainTank:Cast(Swiftmend);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Swiftmend") and OffTank:CanHeal(Swiftmend) then
                module.Bug("Swiftmend - OffTank");
                OffTank:Cast(Swiftmend);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() < module.GetSecondOptionValue("Swiftmend") and Lowest:CanHeal(Swiftmend) then
                module.Bug("Swiftmend - Lowest");
                Lowest:Cast(Swiftmend);
                return;
            end
        end

        -- Dispels Handling
        Player:DispelHandler(NaturesCure, "Nature's Cure", DispelUnit, CurrentBadDebuffs.Dispel, "Normal");

    -- Active Healing Heal Target handler
        if Target:CanHeal(Regrowth) and module.IsOptionEnabled("Heal Target") and (module.GetOptionValue("Heal Target") == 2 or (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed())) then
            HealTarget(Target);
            return;
        end
    -- AoE Healing
        Efflorescences();
        -- Wild Growth
        if WildGrowthUnit and WildGrowthUnit:CanCast(WildGrowth) then
            -- Use Swiftmend with Soul Of The Forest
            if SoulOfTheForest:Exists() and not Swiftmend:IsOnCooldown() and not Player:Buff(SoulOfTheForestBuff) then
                local BestLowest, BestLowestHealth = nil, 100;
                if Lowest and Lowest:CanHeal(Swiftmend) then
                    BestLowest, BestLowestHealth = Lowest, Lowest:SpecialHealthPercentage();
                end
                if OffTank and OffTank:CanHeal(Swiftmend) and (not BestLowest or OffTank:SpecialHealthPercentage() < BestLowestHealth) then
                    BestLowest, BestLowestHealth = OffTank, OffTank:SpecialHealthPercentage();
                end
                if MainTank and MainTank:CanHeal(Swiftmend) and (not BestLowest or MainTank:SpecialHealthPercentage() < BestLowestHealth) then
                    BestLowest, BestLowestHealth = MainTank, MainTank:SpecialHealthPercentage();
                end
                if BestLowest and BestLowest:CanHeal(Swiftmend) then
                    BestLowest:Cast(Swiftmend);
                    return;
                end
            end
            if WildGrowthUnit:CanCast(WildGrowth) then
                WildGrowthUnit:Cast(WildGrowth);
                return;
            end
        end
    -- High Priority Healing
        -- Lifebloom
        if module.IsOptionEnabled("Lifebloom") and (MaxLifebloomValue == 2 or Lifebloom:TimeSinceCast() > 7) then
            if MainTank and MainTankTanking and (not MainTank:Buff(Lifebloom) or (MainTank:BuffRemains(Lifebloom) < 3 and MainTank:SpecialHealthPercentage() >= module.GetOptionValue("Lifebloom"))) and MainTank:CanCast(Lifebloom) then
                Lifebloom.LastCastTime = module.GetTime();
                MainTank:Cast(Lifebloom);
                return;
            end
            if OffTank and OffTankTanking and (not (MainTank and MainTankTanking) or LifebloomUnits < MaxLifebloomValue) and (not OffTank:Buff(Lifebloom) or (OffTank:BuffRemains(Lifebloom) < 3 and OffTank:SpecialHealthPercentage() >= module.GetOptionValue("Lifebloom"))) and OffTank:CanCast(Lifebloom) then
                Lifebloom.LastCastTime = module.GetTime();
                OffTank:Cast(Lifebloom);
                return;
            end
            if MainTank and (not (OffTank and OffTankTanking) or LifebloomUnits < MaxLifebloomValue) and not MainTank:Buff(Lifebloom) and MainTank:CanCast(Lifebloom) then
                Lifebloom.LastCastTime = module.GetTime();
                MainTank:Cast(Lifebloom);
                return;
            end
        end
        -- Cenarion Ward
        if CenarionWard:Exists() and module.IsOptionEnabled("Cenarion Ward") then
            if MainTank and MainTank:ThreatSituation() >= 2 and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Cenarion Ward") and MainTank:CanHeal(CenarionWard) then
                MainTank:Cast(CenarionWard);
                return;
            elseif OffTank and OffTank:ThreatSituation() >= 2 and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Cenarion Ward") and OffTank:CanHeal(CenarionWard) then
                OffTank:Cast(CenarionWard);
                return;
            elseif Lowest
                and Lowest:ThreatSituation() >= 2
                and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Cenarion Ward")
                and Lowest:CanHeal(CenarionWard) then
                Lowest:Cast(CenarionWard);
                return;
            end
        end
    -- Bad Debuffs - Tank
        if module.IsOptionEnabled("Tank Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Tanks do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Tanks[i], CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Rejuvenation) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if module.IsOptionEnabled("Tank Debuffs") and BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Tank Debuffs") then
                -- Rejuvenation
                if BestUnit:CanCast(Rejuvenation) and not BestUnit:Buff(Rejuvenation) then
                    BestUnit:Cast(Rejuvenation);
                    module.Bug("Rejuvenation on " .. BestUnit:Name() .. " to heal debuff");
                    return;
                end
                -- Germination
                if Germination:Exists() and BestUnit:CanCast(Rejuvenation) and not BestUnit:Buff(GerminationRejuvenation) then
                    BestUnit:Cast(Rejuvenation);
                    module.Bug("Germination on " .. BestUnit:Name() .. " to heal debuff");
                    return;
                end
            end
        end
    -- Bad Debuffs - Debuffs
        if module.IsOptionEnabled("Raid Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Debuff do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Debuff[i], CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Rejuvenation) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if module.IsOptionEnabled("Raid Debuffs") and BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Raid Debuffs") then
                -- Rejuvenation
                if BestUnit:CanCast(Rejuvenation) and not BestUnit:Buff(Rejuvenation) then
                    BestUnit:Cast(Rejuvenation);
                    module.Bug("Rejuvenation on " .. BestUnit:Name() .. " to heal debuff");
                    return;
                end
                -- Germination
                if Germination:Exists() and BestUnit:CanCast(Rejuvenation) and not BestUnit:Buff(GerminationRejuvenation) then
                    BestUnit:Cast(Rejuvenation);
                    module.Bug("Germination on " .. BestUnit:Name() .. " to heal debuff");
                    return;
                end
            end
        end
    -- Regular Healing
        -- Regrowth
        if module.IsOptionEnabled("Regrowth") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Regrowth") and MainTank:BuffRemains(Regrowth) < 3.6 + Regrowth:CastTime() and MainTank:CanHeal(Regrowth) then
                MainTank:Cast(Regrowth);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Regrowth") and OffTank:BuffRemains(Regrowth) < 3.6 + Regrowth:CastTime() and OffTank:CanHeal(Regrowth) then
                OffTank:Cast(Regrowth);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Regrowth") and Lowest:BuffRemains(Regrowth) < 3.6 + Regrowth:CastTime() and Lowest:CanHeal(Regrowth) then
                Lowest:Cast(Regrowth);
                return;
            end
        end
        -- Regrowth - Use Clearcasting Procs
        if module.IsOptionEnabled("Regrowth") and Player:Buff(Clearcasting) then
            -- Top priority add Regrowth Buff to priority targets
            if MainTank and MainTank:SpecialHealthPercentage() <= 95 and MainTank:BuffRemains(Regrowth) < 6 and MainTank:CanHeal(Regrowth) then
                MainTank:Cast(Regrowth);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= 95 and OffTank:BuffRemains(Regrowth) < 6 and OffTank:CanHeal(Regrowth) then
                OffTank:Cast(Regrowth);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= 95 and Lowest:BuffRemains(Regrowth) < 6 and Lowest:CanHeal(Regrowth) then
                Lowest:Cast(Regrowth);
                return;
            end
            -- Regrowth Cycle to apply buffs
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #HealUnits do
                local ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage();
                if ThisUnitHealth <= BestUnitHealth and ThisUnit:CanHeal(Regrowth) and not ThisUnit:Buff(Regrowth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnitHealth <= module.GetSecondOptionValue("Regrowth") then
                module.Bug("Regrowth - Cycle with Clearcast");
                BestUnit:Cast(Regrowth);
                return;
            end
            -- last Call, heal even without buff check
            if MainTank and MainTank:SpecialHealthPercentage() <= 80 and MainTank:CanHeal(Regrowth) then
                MainTank:Cast(Regrowth);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= 80 and OffTank:CanHeal(Regrowth) then
                OffTank:Cast(Regrowth);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= 80 and Lowest:CanHeal(Regrowth) then
                Lowest:Cast(Regrowth);
                return;
            end
        end
    -- Bad Debuffs - Topping
        if module.IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Top do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Top[i], CurrentBadDebuffs.Top[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Regrowth) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth <= module.GetOptionValue("Topping") then
                if BestUnit:CanCast(Regrowth) and not BestUnit:Buff(Regrowth) then
                    BestUnit:Cast(Regrowth);
                    module.Bug("Regrowth on " .. BestUnit:Name() .. " to top it");
                    return;
                end
                if not BestUnit:Buff(Rejuvenation) and BestUnit:CanCast(Rejuvenation)  then
                    BestUnit:Cast(Rejuvenation);
                    module.Bug("Rejuvenation on " .. BestUnit:Name() .. " to top it");
                    return;
                end
                if Germination:Exists() and not BestUnit:Buff(GerminationRejuvenation) and BestUnit:CanCast(Rejuvenation) then
                    BestUnit:Cast(Rejuvenation);
                    module.Bug("Germination on " .. BestUnit:Name() .. " to top it");
                    return;
                end
                if BestUnit:CanCast(HealingTouch) then
                    BestUnit:Cast(HealingTouch);
                    module.Bug("Healing Touch on " .. BestUnit:Name() .. " to top it");
                    return;
                end
            end
        end
    -- Low Priority Healing
        -- Rejuvenation
        if module.IsOptionEnabled("Rejuvenation") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Rejuvenation") and MainTank:CanHeal(Rejuvenation) and not (MainTank:Buff(Rejuvenation) or MainTank:Buff(GerminationRejuvenation)) then
                MainTank:Cast(Rejuvenation);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Rejuvenation") and OffTank:CanHeal(Rejuvenation) and not (OffTank:Buff(Rejuvenation) or OffTank:Buff(GerminationRejuvenation)) then
                OffTank:Cast(Rejuvenation);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Rejuvenation") and Lowest:CanHeal(Rejuvenation) and not (Lowest:Buff(Rejuvenation) or Lowest:Buff(GerminationRejuvenation)) then
                Lowest:Cast(Rejuvenation);
                return;
            end
        end
        -- Germination
        if module.IsOptionEnabled("Rejuvenation Germination") and Germination:Exists() then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Rejuvenation Germination") and MainTank:CanHeal(Rejuvenation) and not (MainTank:Buff(Rejuvenation) and MainTank:Buff(GerminationRejuvenation)) then
                MainTank:Cast(Rejuvenation);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Rejuvenation Germination") and OffTank:CanHeal(Rejuvenation) and not (OffTank:Buff(Rejuvenation) and OffTank:Buff(GerminationRejuvenation)) then
                OffTank:Cast(Rejuvenation);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Rejuvenation Germination") and Lowest:CanHeal(Rejuvenation) and not (Lowest:Buff(Rejuvenation) and Lowest:Buff(GerminationRejuvenation)) then
                Lowest:Cast(Rejuvenation);
                return;
            end
        end
        -- Regrowth Emergency
        if module.IsOptionEnabled("Regrowth Emergency") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Regrowth Emergency") and MainTank:CanHeal(Regrowth) then
                MainTank:Cast(Regrowth);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Regrowth Emergency") and OffTank:CanHeal(Regrowth) then
                OffTank:Cast(Regrowth);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Regrowth Emergency")  and Lowest:CanHeal(Regrowth) then
                Lowest:Cast(Regrowth);
                return;
            end
        end
        -- Rejuvenation Cycle
        if module.IsOptionEnabled("Rejuvenation") and RejuvenationUnits < module.GetOptionValue("Rejuvenation Counts") then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #HealUnits do
                local ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage();
                if ThisUnitHealth <= BestUnitHealth and ThisUnit:CanHeal(Rejuvenation) and ThisUnit:BuffRemains(Rejuvenation) < 3 and ThisUnit:BuffRemains(GerminationRejuvenation) < 3 then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnitHealth <= module.GetSecondOptionValue("Rejuvenation") then
                module.Bug("Rejuvenation - Cycle");
                BestUnit:Cast(Rejuvenation);
                return;
            end
        end
        -- Germination Cycle
        if Germination:Exists() and module.IsOptionEnabled("Rejuvenation Germination") and GerminationUnits < module.GetSecondOptionValue("Rejuvenation Counts") then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #HealUnits do
                local ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage();
                if ThisUnitHealth <= BestUnitHealth and ThisUnit:CanHeal(Rejuvenation) and (ThisUnit:BuffRemains(Rejuvenation) < 3 or not ThisUnit:Buff(GerminationRejuvenation)) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnitHealth <= module.GetSecondOptionValue("Rejuvenation Germination") then
                module.Bug("Germination - Cycle");
                BestUnit:Cast(Rejuvenation);
                return;
            end
        end
        -- Healing Touch - Tanks
        if module.IsOptionEnabled("Healing Touch") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Healing Touch") and MainTank:CanHeal(HealingTouch) then
                MainTank:Cast(HealingTouch);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Healing Touch") and OffTank:CanHeal(HealingTouch) then
                OffTank:Cast(HealingTouch);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Healing Touch") and Lowest:CanHeal(HealingTouch) then
                Lowest:Cast(HealingTouch);
                return;
            end
        end
    end



    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Resurrect Deads
        if Revive:Exists() and module.IsOptionEnabled("Revive") and Unit.ResurrectCycle(Revive) then
            return;
        end
        -- Proving Grounds Food
        if MainTank and MainTank:CreatureID() == 72218 and Player:PowerPercentage() < 95 and not Player:IsMoving() and LukewarmYakRoastBroth:InStock() and not LukewarmYakRoastBroth:IsOnCooldown() then
            LukewarmYakRoastBroth:Use(Player);
        end
        if module.IsOptionEnabled("Out Of Combat Healing") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Beastmaster Hunter
    local Rotation = {};
    module.SetRotation(253, Rotation);

    --- Localization
    -- Core
    local Enemies_40y, TargetEnemies_8y, BarrageEnemies, NumEnemies = {}, {}, {}, 1; -- Enemies
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local TriedToResurrectPet, TriedToSummonPet = 0, 0; -- Summon/Whistle Pet alternate
    local BestialWrathEnabled;
    local PlayerPet = module.PlayerPet;
    local PlayerPetTarget = module.Unit.PlayerPetTarget;


    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        --Racials
        ArcaneTorrent = Spell(80483, false, false, true);
        RocketBarrage = Spell(69041, true, true, true);
        BloodFury = Spell(20572, false, false, true);
        Berserking = Spell(26297, false, false, true);
        GiftOfTheNaaru = Spell(59543, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        AMurderOfCrows = Spell(131894, false, true, true);
        AspectOfTheTurtle = Spell(186265, false, false, true);
        AspectOfTheWild = Spell(193530, false, false, true);
        Barrage = Spell(120360, true, true, false);
        BeastCleave = Spell(118455, false, false, true);
        BestialWrath = Spell(19574, false, false, true);
        ChimaeraShot = Spell(53209, true, true, true);
        CobraShot = Spell(193455, true, true, false);
        ConcussiveShot = Spell(5116, true, true, true);
        CounterShot = Spell(147362, true, true, true);
        DireBeast = Spell(120679, false, true, true);
        DireFrenzy = Spell(217200, false, true, true);
        Exhilaration = Spell(109304, false, false, true);
        FeignDeath = Spell(5384, false, false, true);
        KillCommand = Spell(34026, false, true, true);
        KillerCobra = Spell(199532);
        MendPet = Spell(982, false, false, true);
        MendPetBuff = Spell(136, false, false, true);
        Misdirection = Spell(34477, false, false, true);
        MisdirectionBuff = Spell(35079, false, false, true);
        MultiShot = Spell(2643, true, true, true);
        Stampede = Spell(201430, false, true, true);
        TitansThunder = Spell(207068, false, false, true);
        Volley = Spell(194386, false, true, true);

        -- Pet Manager section
        CallPets = {Spell(883, false, false, true),
                    Spell(83242, false, false, true),
                    Spell(83243, false, false, true),
                    Spell(83244, false, false, true),
                    Spell(83245, false, false, true)}
        RevivePet = Spell(982, false, false, false);


        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        -- Add options to pages
        module.AddPresetOption("TargetAttack");
        module.AddPresetOption("BossCD");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Auto Summon/Revive Pet", 222, true, {3, 1, 25, 0.5}, {1, 1, 5, 1}, "Automatically Whistle/Revive your Pet."..C.TOOLTIP_VALUE_1.."How long would you like to wait before using Whistle when your pet is dismissed."..C.TOOLTIP_VALUE_2.."Which pet you would like to auto summon?");
        module.AddNewOption("General Settings", "Misdirection", 232, true, {1, "Always", "Engage", "Threath Any", "Threath Target"}, {80, 0, 100, 5}, "Use Misdirection on your Tank, Focus or Pet."..C.TOOLTIP_VALUE_1.."Choose prefered Mode."..C.TOOLTIP_VALUE_2.."Define threath percentage threshold. Set to 100 to use always.");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Pummel to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Will use Potion when the BossMod (Support DBM & BW) timer will met the timer set.");
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists()  or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Only Arcane Torrent is supported."));
        end
        module.AddPresetOption("Trinket");
        -- module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions (only if your target is a Boss).");
        module.AddNewOption("Offensive Settings", "A Murder Of Crows", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use A Murder Of Crows."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Aspect Of The Wild", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Aspect Of The Wild."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Bestial Wrath", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Bestial Wrath."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Stampede", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Stampede."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Titan's Thunder", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Titan's Thunder."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Barrage", 220, true, {1, 1, 5, 1}, nil, "Use Barrage."..C.TOOLTIP_VALUE.."Minimum number of units to use Barrage.");
        module.AddNewOption("Offensive Settings", "Concussive Shot", 210, false, nil, nil, "Maintain Concussive Shot on our current target.");
        module.AddNewOption("Offensive Settings", "Cobra Shot", 122, false, {90, 1, 120, 1}, {119, 1, 120, 1}, "Cobra Shot Focus thresholds."..C.TOOLTIP_VALUE_1.."Minimum Focus to use as filler without Killer Cobra."..C.TOOLTIP_VALUE_2.."Minimum Focus to use as filler with Killer Cobra.");
        module.AddNewOption("Offensive Settings", "Dire Beast", 210, true, nil, nil, "Use Dire Beast or Dire Frenzy.");
        module.AddNewOption("Offensive Settings", "Pet Damage Handling", 230, true, {1, "Handle Assist", "Do Not Handle Assist"}, nil, "Manage Pet."..C.TOOLTIP_VALUE_1.."Enable this to automatically change between assist and passive mode depending if you have a target or not.");
        module.AddNewOption("Offensive Settings", "Volley", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {1, 1, 20, 1}, "Use Spell on Target or Centered Between Units, Standing means spell will be used only if units are not moving.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddPresetOption("HealingItem");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Mend Pet", 222, true, {35, 0, 100, 1}, {85, 0, 100, 1}, "Enable use of Mend Pet when pet health fall under threshold. \n\n|cFF0088FFValue 1:|r In combat threshold. \n\n|cFF0088FFValue 2:|r Out of combat threshold.");
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Auto Feign Death", 220, true, {10, 0, 100, 1}, nil, "Use Feign Death."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Aspect Of The Turtle", 220, true, {35, 0, 100, 1}, nil, "Use Aspect Of The Turtle."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Exhilaration", 220, true, {20, 1, 100, 1}, nil, "Use Exhilaration."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {20, 1, 100, 1}, nil, "Use Gift Of The Naaru on self."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- Macro to queue Barrage
        module.RegisterCommand("barrage",
            function ()
                if Barrage:Exists() then
                    if module.ShouldBarrage == true then
                        module.ShouldBarrage = false;
                        module.Bug("Barrage Queue Canceled");
                    elseif Barrage:Cooldown() < 5 then
                        module.ShouldBarrage = true;
                        module.Bug("Barrage Queued");
                    end
                else
                    module.Bug("You do not have Barrage talented.");
                end
            end
        );
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Buff(FeignDeath) then
            return;
        end

        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Defensives ()
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Healing Item") and Player:HealthPercentage() <= module.GetOptionValue("Healing Item") then
            if HealingTonic:IsUsable() then
                Healthstone:Use(Player);
            elseif Healthstone:IsUsable() then
                HealingTonic:Use(Player);
            end
        end
        -- Exhilaration
        if Exhilaration:Exists() and module.IsOptionEnabled("Exhilaration") and Player:HealthPercentage() <= module.GetOptionValue("Exhilaration") and Player:CanCast(Exhilaration) then
            Player:Cast(Exhilaration);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
        -- Aspect of the Turtle
        if AspectOfTheTurtle:Exists() and module.IsOptionEnabled("Aspect Of The Turtle") and Player:HealthPercentage() <= module.GetOptionValue("Aspect Of The Turtle") and Player:CanCast(AspectOfTheTurtle) then
            Player:Cast(AspectOfTheTurtle);
            return;
        end
        -- Feign Death
        if FeignDeath:Exists() and module.IsOptionEnabled("Auto Feign Death") and Player:HealthPercentage() <= module.GetOptionValue("Auto Feign Death") and Player:CanCast(FeignDeath) then
            Player:Cast(FeignDeath);
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(CounterShot, ArcaneTorrent);
    end

    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(CobraShot, false) or Unit.Target;
    end

    -- Function to check if we can use Kill Command
    local function CanKillCommand ()
        return not module.KillFailTime or module.GetTime() > module.KillFailTime;
    end

    -- Pet Manager
    local function ManagePet ()
        if module.IsOptionEnabled("Auto Summon/Revive Pet") and (InstantWhistle or module.PetDismissed + module.GetOptionValue("Auto Summon/Revive Pet") < module.GetTime()) then
            InstantWhistle = false;
            -- if whistle works, fine, otherwise blacklist it fro 5 second (usually should work fine with 1 attempt)
            if not PlayerPet:Exists() and module.GetTime() > TriedToSummonPet and Player:CanCast(CallPets[module.GetSecondOptionValue("Auto Summon/Revive Pet")]) then
                TriedToSummonPet = module.GetTime() + 5;
                Player:Cast(CallPets[module.GetSecondOptionValue("Auto Summon/Revive Pet")]);
                return;
            end
            -- if revive didnt work then we blacklist it 3 seconds (usually happens when user moves during resurrection cast)
            if not Player:IsMoving() and (not PlayerPet:Exists() or PlayerPet:IsDead()) and Player:CanCast(RevivePet) and module.GetTime() > TriedToResurrectPet then
                TriedToResurrectPet = module.GetTime() + 3;
                Player:Cast(MendPet);
                return;
            end
        end
        -- Mend Pet
        if PlayerPet:Exists() and module.IsOptionEnabled("Mend Pet") and Player:CanCast(MendPet) and not PlayerPet:Buff(MendPetBuff) and MendPet:TimeSinceCast() > 8 then
            if (Player:IsInCombat() and PlayerPet:HealthPercentage() <= module.GetOptionValue("Mend Pet")) or (not Player:IsInCombat() and PlayerPet:HealthPercentage() <= module.GetSecondOptionValue("Mend Pet")) then
                PlayerPet:Cast(MendPet);
                return;
            end
        end
    end

    -- Misdirection
    local function MisdirectionHandler ()
        if module.IsOptionEnabled("Misdirection") and not Player:Buff(MisdirectionBuff) then
            local MisdirectionTarget = (Focus and Focus:Exists() and Focus:CanCast(Misdirection) and Focus) or (MainTank and MainTank:Exists() and MainTank:CanCast(Misdirection) and MainTank) or (OffTank and OffTank:Exists() and OffTank:CanCast(Misdirection) and OffTank) or (PlayerPet and PlayerPet:Exists() and PlayerPet:CanCast(Misdirection) and PlayerPet);
            if MisdirectionTarget then
                -- Always
                if module.GetOptionValue("Misdirection") == "Always" then
                    MisdirectionTarget:Cast(Misdirection);
                    return;
                end
                -- When Fight just started
                if module.GetOptionValue("Misdirection") == "Engage" and CombatTime() < 5 then
                    MisdirectionTarget:Cast(Misdirection);
                    return;
                end
                -- If Target Threath is too high
                if module.GetOptionValue("Misdirection") == "Threath Target" and Player:Threat(Target) >= module.GetSecondOptionValue("Misdirection") then
                    MisdirectionTarget:Cast(Misdirection);
                    return;
                end
                -- If Any Target Threath is too high
                if module.GetOptionValue("Misdirection") == "Threath Any" then
                    for i = 1, #BarrageEnemies do
                        local ThisUnit = BarrageEnemies[i];
                        if Player:Threat(ThisUnit) >= module.GetSecondOptionValue("Misdirection") then
                            module.Bug("Misdirection on " .. MisdirectionTarget:Name() .. " as " .. ThisUnit:Name() .. " is at " .. Player:Threat(ThisUnit) .. "% threath")
                            MisdirectionTarget:Cast(Misdirection);
                            return;
                        end
                    end
                end
            end
        end
    end


    -- Handling of Pet Actionbar Abilities
    local PetAssisting, PetForceAssistDelay = nil, 0;
    local function PlayerPetHandling ()
        -- Player Pet Handling
        if module.IsOptionEnabled("Pet Damage Handling") then
            if PlayerPet:Exists() then
                -- Assist/Passive Mode
                if module.GetOptionValue("Pet Damage Handling") == "Handle Assist" then
                    if Target:Exists() and not PetAssisting then
                        PetAssistMode();
                        RunMacroText("/petattack target");
                        PetAssisting = true;
                    elseif not Target:Exists() and PetAssisting then
                        PetPassiveMode();
                        PetAssisting = false;
                    end
                    if Target:Exists() and PetAssisting and PlayerPetTarget and PlayerPetTarget:GUID() ~= Target:GUID() and PetForceAssistDelay < module.GetTime() then
                        PetPassiveMode();
                        PetAssistMode();
                        RunMacroText("/petattack target");
                        PetForceAssistDelay = module.GetTime() + 2;
                    end
                end
            end
        end
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        ManagePet();
        PlayerPetHandling();
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and Player:IsFacing(Target) then
            -- Barrage Queueing Macro
            if Barrage:Exists() and module.ShouldBarrage == true then
                if Barrage:Cooldown() > 6 then
                    module.ShouldBarrage = false;
                else
                    if Player:Focus() < 60 then
                        if PlayerPet:Exists() and PlayerPetTarget:Exists() and not PlayerPet:IsDead() and CanKillCommand() and PlayerPet:DistanceTo(PlayerPetTarget) < 20 then
                            -- Chimaera Shot
                            if ChimaeraShot:Exists() and Target:CanCast(ChimaeraShot) then
                                Target:Cast(ChimaeraShot);
                                return;
                            end
                            -- Dire Beast
                            if DireBeast:Exists() and not DireFrenzy:Exists() and PlayerPetTarget:CanCast(DireBeast) then
                                PlayerPetTarget:Cast(DireBeast);
                                return;
                            end
                            -- Dire Frenzy (30 Talent)
                            if DireFrenzy:Exists() and PlayerPetTarget:CanCast(DireFrenzy) then
                                PlayerPetTarget:Cast(DireFrenzy);
                                return;
                            end
                        end
                        return;
                    end
                    if Player:Focus() >= 60 and Target:CanCast(Barrage) then
                        Target:Cast(Barrage);
                        return;
                    end
                end
            end
            -- Enemies Check
            if module.UseAOE() and RefreshEnemies < module.GetTime() then
                BarrageEnemies = Player:UnitsInFrontConeAroundUnit(Target, 45, 160);
                Enemies_40y = Player:EnemiesWithinDistance(40, false);
                TargetEnemies_8y = Target:EnemiesWithinDistance(8, true, true);
                NumEnemies = #TargetEnemies_8y;
                RefreshEnemies = module.GetTime() + 0.2;
            else
                BarrageEnemies, Enemies_40y, TargetEnemies_8y, NumEnemies = {}, {}, {}, 1;
            end
            -- Misdirection
            MisdirectionHandler();
            -- Concussive Shot
            if ConcussiveShot:Exists() and module.IsOptionEnabled("Concussive Shot") and Target:CanCast(ConcussiveShot) then
                Target:Cast(ConcussiveShot);
                return;
            end
            BestialWrathEnabled = module.IsOptionEnabled("Bestial Wrath") and (module.CooldownsAllowed() or module.GetOptionValue("Bestial Wrath") == "Always") or false;
            -- Common Cooldowns
            if Player:IsWithinCastRange(Target, CobraShot) then
                -- Trinkets
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and Player:Focus() < 85 and Player:CanCast(ArcaneTorrent) then
                        Player:Cast(ArcaneTorrent);
                        return;
                    end
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                end
            end
            -- Titan's Thunder

            -- actions+=/a_murder_of_crows
            if AMurderOfCrows:Exists() and module.IsOptionEnabled("A Murder Of Crows") and (module.CooldownsAllowed() or module.GetOptionValue("A Murder Of Crows") == "Always") and Target:TimeToDie() >= 20 and Target:CanCast(AMurderOfCrows) then
                Target:Cast(AMurderOfCrows);
                return;
            end
            -- actions+=/stampede,if=(buff.bloodlust.up)|target.time_to_die<=15
            if Stampede:Exists() and module.IsOptionEnabled("Stampede") and (module.CooldownsAllowed() or module.GetOptionValue("Stampede") == "Always") and Target:TimeToDie() >= 20 and Target:CanCast(Stampede) then
                Target:Cast(Stampede);
                return;
            end
            -- actions+=/dire_beast,if=cooldown.bestial_wrath.remains>2
            -- actions+=/dire_frenzy,if=cooldown.bestial_wrath.remains>2
            if module.IsOptionEnabled("Dire Beast") and PlayerPet:Exists() and PlayerPetTarget:Exists() and not PlayerPet:IsDead() and CanKillCommand() and PlayerPet:DistanceTo(PlayerPetTarget) < 20 and (BestialWrath:Cooldown() > 2 or not BestialWrathEnabled) then
                -- Dire Beast
                if DireBeast:Exists() and not DireFrenzy:Exists() and Target:CanCast(DireBeast) then
                    Target:Cast(DireBeast);
                    return;
                end
                -- Dire Frenzy (30 Talent)
                if DireFrenzy:Exists() and Target:CanCast(DireFrenzy) then
                    Target:Cast(DireFrenzy);
                    return;
                end
            end
            -- actions+=/aspect_of_the_wild,if=buff.bestial_wrath.up
            if AspectOfTheWild:Exists() and module.IsOptionEnabled("Aspect Of The Wild") and (module.CooldownsAllowed() or module.GetOptionValue("Aspect Of The Wild") == "Always") and Player:Buff(BestialWrath) and Target:TimeToDie() >= 20 and Player:CanCast(AspectOfTheWild) then
                Player:Cast(AspectOfTheWild);
                return;
            end
            -- actions+=/barrage,if=spell_targets.barrage>1|(spell_targets.barrage=1&focus>90)
            if Barrage:Exists() and module.IsOptionEnabled("Barrage") and #BarrageEnemies >= module.GetOptionValue("Barrage") and Barrage:Cooldown() < 5 then
                if Player:Focus() >= 60 and Target:CanCast(Barrage) then
                    Target:Cast(Barrage);
                    return;
                end
            end
            -- Volley (90 Talent)
            if Volley:Exists() and module.IsOptionEnabled("Volley") and Target:CanCast(Volley) then
                if Target:CastGroundSpell(Volley, "Volley", 6) then return; end
            end
            -- actions+=/titans_thunder,if=cooldown.dire_beast.remains>=3|talent.dire_frenzy.enabled
            if TitansThunder:Exists() and module.IsOptionEnabled("Titan's Thunder") and (module.CooldownsAllowed() or module.GetOptionValue("Titan's Thunder") == "Always") and (DireBeast:Cooldown() >= 3 or not DireBeast:Exists()) and Player:CanCast(TitansThunder) then
                Player:Cast(TitansThunder);
                return;
            end
            -- actions+=/bestial_wrath
            if BestialWrath:Exists() and BestialWrathEnabled and Player:CanCast(BestialWrath) then
                Player:Cast(BestialWrath);
                return;
            end
            -- actions+=/multishot,if=spell_targets.multi_shot>=3&pet.buff.beast_cleave.down
            if MultiShot:Exists() and NumEnemies >= 3 and Target:CanCast(MultiShot) and PlayerPet:BuffRemains(BeastCleave) < 1.2 then
                module.Bug("Multi-Shot - Beast Cleave");
                Target:Cast(MultiShot);
                return;
            end
            -- actions+=/kill_command
            if KillCommand:Exists() and PlayerPet:Exists() and PlayerPetTarget:Exists() and not PlayerPet:IsDead() and CanKillCommand() and PlayerPet:DistanceTo(PlayerPetTarget) - PlayerPetTarget:CombatReach() < 20 and PlayerPetTarget:CanCast(KillCommand) then
                PlayerPetTarget:Cast(KillCommand);
                return;
            end
            -- actions+=/cobra_shot,if=talent.killer_cobra.enabled&(cooldown.bestial_wrath.remains>=4&(buff.bestial_wrath.up&cooldown.kill_command.remains>=2)|focus>119)|!talent.killer_cobra.enabled&focus>90
            if CobraShot:Exists() and ((KillerCobra:Exists() and (BestialWrath:Cooldown() >= 4 and (Player:Buff(BestialWrath) and KillCommand:Cooldown() >= 2) or Player:Focus() > module.GetSecondOptionValue("Cobra Shot"))) or (not KillerCobra:Exists() and Player:Focus() > module.GetOptionValue("Cobra Shot"))) and Target:CanCast(CobraShot) then
                Target:Cast(CobraShot);
                return;
            end
            -- actions+=/chimaera_shot,if=focus<90
            if ChimaeraShot:Exists() and Player:Focus() < 90 and Target:CanCast(ChimaeraShot) then
                Target:Cast(ChimaeraShot);
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        ManagePet();
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Marksmanship Hunter
    local Rotation = {};
    module.SetRotation(254, Rotation);

    --- Localization
    -- Core
    local Enemies_40y, TargetEnemies_8y, BarrageEnemies, NumEnemies = {}, {}, {}, 1; -- Enemies
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local TriedToResurrectPet, TriedToSummonPet = 0, 0; -- Summon/Whistle Pet alternate

    local PlayerPet = module.PlayerPet;
    local PlayerPetTarget = module.Unit.PlayerPetTarget;
    local Detonate, DetonateTime = false, 0;


    local DraenicAgility, DraenicAgilityBuff, ArcaneTorrent, RocketBarrage, BloodFury, Berserking, GiftOfTheNaaru;
    local AimedShot, AMurderOfCrows, ArcaneShot, AspectOfTheTurtle, Barrage, BlackArrow, BurstingShot, CarefulAim, ConcussiveShot, CounterShot;
    local Exhilaration, ExplosiveShot, FeignDeath, HuntersMark, LockAndLoad, LoneWolf;
    local MarkedShot, MarkingTargets, MendPet, MendPetBuff, Misdirection, MisdirectionBuff, MultiShot;
    local PatientSniper, PiercingShot, Sentinel, Sidewinders, SteadyFocus, SteadyFocusBuff, TrueAim, TrueAimDebuff, Trueshot;
    local Volley, Vulnerable, Windburst, CallPets, RevivePet;

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        S = {
            -- Items
            DraenicAgility = Item(109217, false, false, true),
            DraenicAgilityBuff = Spell(156423, false, false, true),

            --Racials
            ArcaneTorrent = Spell(80483, false, false, true),
            RocketBarrage = Spell(69041, true, true, true),
            BloodFury = Spell(20572, false, false, true),
            Berserking = Spell(26297, false, false, true),
            GiftOfTheNaaru = Spell(59543, false, false, true),

            -- (ID, RequiresFacing, Hostile, instant)
            AimedShot = Spell(19434, true, true, false),
            AMurderOfCrows = Spell(131894, false, true, true),
            ArcaneShot = Spell(185358, true, true, true),
            AspectOfTheTurtle = Spell(186265, false, false, true),
            Barrage = Spell(120360, true, true, false),
            BlackArrow = Spell(194599, true, true, true),
            BurstingShot = Spell(186387, false, false, true),
            CarefulAim = Spell(53238),
            ConcussiveShot = Spell(5116, true, true, true),
            CounterShot = Spell(147362, true, true, true),
            Exhilaration = Spell(194291, false, false, true),
            ExplosiveShot = Spell(212431, false, false, true),
            FeignDeath = Spell(5384, false, false, true),
            HuntersMark = Spell(185365),
            LockAndLoad = Spell(194594),
            LoneWolf = Spell(155228),
            MarkedShot = Spell(185901, true, true, true),
            MarkingTargets = Spell(223138),
            MendPet = Spell(982, false, false, true),
            MendPetBuff = Spell(136, false, false, true),
            Misdirection = Spell(34477, false, false, true),
            MisdirectionBuff = Spell(35079, false, false, true),
            MultiShot = Spell(2643, true, true, true),
            PatientSniper = Spell(213423),
            PiercingShot = Spell(198670, true, true, true),
            Sentinel = Spell(206817, true, true, true),
            Sidewinders = Spell(214579, true, true, true),
            SteadyFocus = Spell(193533),
            SteadyFocusBuff = Spell(193534),
            TrueAim = Spell(199527),
            TrueAimDebuff = Spell(199803),
            Trueshot = Spell(193526, false, false, true),
            Volley = Spell(194386, false, true, true),
            Vulnerable = Spell(187131),
            Windburst = Spell(204147, true, true, true),

            -- Pet Manager section
            CallPets = {Spell(883, false, false, true),
                        Spell(83242, false, false, true),
                        Spell(83243, false, false, true),
                        Spell(83244, false, false, true),
                        Spell(83245, false, false, true)},
            RevivePet = Spell(982, false, false, false)
        };


        DraenicAgility = S.DraenicAgility;
        DraenicAgilityBuff = S.DraenicAgilityBuff;
        ArcaneTorrent = S.ArcaneTorrent;
        RocketBarrage = S.RocketBarrage;
        BloodFury = S.BloodFury;
        Berserking = S.Berserking;
        GiftOfTheNaaru = S.GiftOfTheNaaru;
        AimedShot = S.AimedShot;
        AMurderOfCrows = S.AMurderOfCrows;
        ArcaneShot = S.ArcaneShot;
        AspectOfTheTurtle = S.AspectOfTheTurtle;
        Barrage = S.Barrage;
        BlackArrow = S.BlackArrow;
        BurstingShot = S.BurstingShot;
        CarefulAim = S.CarefulAim;
        ConcussiveShot = S.ConcussiveShot;
        CounterShot = S.CounterShot;
        Exhilaration = S.Exhilaration;
        ExplosiveShot = S.ExplosiveShot;
        FeignDeath = S.FeignDeath;
        HuntersMark = S.HuntersMark;
        LockAndLoad = S.LockAndLoad;
        LoneWolf = S.LoneWolf;
        MarkedShot = S.MarkedShot;
        MarkingTargets = S.MarkingTargets;
        MendPet = S.MendPet;
        MendPetBuff = S.MendPetBuff;
        Misdirection = S.Misdirection;
        MisdirectionBuff = S.MisdirectionBuff;
        MultiShot = S.MultiShot;
        PatientSniper = S.PatientSniper;
        PiercingShot = S.PiercingShot;
        Sentinel = S.Sentinel;
        Sidewinders = S.Sidewinders;
        SteadyFocus = S.SteadyFocus;
        SteadyFocusBuff = S.SteadyFocusBuff;
        TrueAim = S.TrueAim;
        TrueAimDebuff = S.TrueAimDebuff;
        Trueshot = S.Trueshot;
        Volley = S.Volley;
        Vulnerable = S.Vulnerable;
        Windburst = S.Windburst;
        CallPets = S.CallPets;
        RevivePet = S.RevivePet;

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        -- Add options to pages
        module.AddPresetOption("TargetAttack");
        module.AddPresetOption("BossCD");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Auto Summon/Revive Pet", 222, true, {3, 1, 25, 0.5}, {1, 1, 5, 1}, "Automatically Whistle/Revive your Pet."..C.TOOLTIP_VALUE_1.."How long would you like to wait before using Whistle when your pet is dismissed."..C.TOOLTIP_VALUE_2.."Which pet you would like to auto summon?");
        module.AddNewOption("General Settings", "Misdirection", 232, true, {1, "Always", "Engage", "Threath Any", "Threath Target"}, {80, 0, 100, 5}, "Use Misdirection on your Tank, Focus or Pet."..C.TOOLTIP_VALUE_1.."Choose prefered Mode."..C.TOOLTIP_VALUE_2.."Define threath percentage threshold. Set to 100 to use always.");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Counter Shot to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists()  or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Only Arcane Torrent is supported."));
        end
        module.AddPresetOption("Trinket");
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "A Murder Of Crows", 230, true, {1, "Always", "With Cooldowns"}, nil, "Use A Murder of Crows."..C.TOOLTIP_VALUE.."Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Sentinel", 230, true, {2, "Always", "With Cooldowns"}, nil, "Use Sentinel."..C.TOOLTIP_VALUE.."Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Trueshot", 230, true, {2, "Always", "With Cooldowns"}, nil, "Use Trueshot."..C.TOOLTIP_VALUE.."Define if you want to always use the ability or only with cooldowns.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Barrage", 220, true, {3, 1, 10, 1}, nil, "Use Barrage."..C.TOOLTIP_VALUE.."Minimum amount of units to use.");
        module.AddNewOption("Offensive Settings", "Bursting Shot", 220, false, {5, 1, 10, 1}, nil, "Use Bursting Shot."..C.TOOLTIP_VALUE.."Minimum amount of units to use.");
        module.AddNewOption("Offensive Settings", "Concussive Shot", 210, false, nil, nil, "Maintain Concussive Shot on our current target.");
        module.AddNewOption("Offensive Settings", "Explosive Shot", 220, true, {1, 1, 10, 1}, nil, "Use Explosive Shot."..C.TOOLTIP_VALUE.."Minimum amount of units that needs to be in 8 yards of our target to use Explosive Shot.");
        module.AddNewOption("Offensive Settings", "Piercing Shot", 220, true, {1, 1, 10, 1}, nil, "Use Piercing Shot."..C.TOOLTIP_VALUE.."Minimum amount of units that needs to be in the path to our target to use Piercing Shot.");
        module.AddNewOption("Offensive Settings", "Multi-Shot", 220, true, {3, 1, 10, 1}, nil, "Use Multi-Shot."..C.TOOLTIP_VALUE.."Minimum amount of units that needs to be in 8 yards of our target to use Multi-Shot.");
        module.AddNewOption("Offensive Settings", "Pet Damage Handling", 230, true, {1, "Handle Assist", "Do Not Handle Assist"}, nil, "Manage Pet."..C.TOOLTIP_VALUE_1.."Enable this to automatically change between assist and passive mode depending if you have a target or not.");
        module.AddNewOption("Offensive Settings", "Volley", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {4, 1, 20, 1}, "Use Volley." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddPresetOption("HealingItem");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Mend Pet", 222, true, {35, 0, 100, 1}, {85, 0, 100, 1}, "Enable use of Mend Pet when pet health fall under threshold. \n\n|cFF0088FFValue 1:|r In combat threshold. \n\n|cFF0088FFValue 2:|r Out of combat threshold.");
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Auto Feign Death", 220, true, {10, 0, 100, 1}, nil, "Use Feign Death." .. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddNewOption("Defensive Settings", "Aspect Of The Turtle", 220, true, {35, 0, 100, 1}, nil, "Use Aspect Of The Turtle." .. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddNewOption("Defensive Settings", "Exhilaration", 220, true, {35, 0, 100, 1}, nil, "Use Exhilaration." .. C.TOOLTIP_VALUE .. "Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {35, 0, 100, 1}, nil, "Health Percentage to use Gift Of The Naaru on self");
        end

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- Macro to queue Barrage
        module.RegisterCommand("barrage",
            function ()
                if Barrage:Exists() then
                    if module.ShouldBarrage == true then
                        module.ShouldBarrage = false;
                        module.Bug("Barrage Queue Canceled");
                    elseif Barrage:Cooldown() < 5 then
                        module.ShouldBarrage = true;
                        module.Bug("Barrage Queued");
                    end
                else
                    module.Bug("You do not have Barrage talented.");
                end
            end
        );

        -- Explosive Shot Detonation
        local Frame = CreateFrame('Frame');
        local function DetonateExplosiveShot (self, ...)
            if Detonate and module.GetTime() > DetonateTime then
                Detonate = false;
                module.Bug("Explosive Shot - Explode");
                Player:Cast(ExplosiveShot);
            end
        end
        Frame:SetScript("OnUpdate", DetonateExplosiveShot);

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [Windburst:ID()] = "Windburst"
        };

    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Buff(FeignDeath) then
            return;
        end

        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Exhilaration
        if Exhilaration:Exists() and module.IsOptionEnabled("Exhilaration") and Player:HealthPercentage() <= module.GetOptionValue("Exhilaration") and Player:CanCast(Exhilaration) then
            Player:Cast(Exhilaration);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
        -- Aspect of the Turtle
        if AspectOfTheTurtle:Exists() and module.IsOptionEnabled("Aspect Of The Turtle") and Player:HealthPercentage() <= module.GetOptionValue("Aspect Of The Turtle") and Player:CanCast(AspectOfTheTurtle) then
            Player:Cast(AspectOfTheTurtle);
            return;
        end
        -- Feign Death
        if FeignDeath:Exists() and module.IsOptionEnabled("Auto Feign Death") and Player:HealthPercentage() <= module.GetOptionValue("Auto Feign Death") and Player:CanCast(FeignDeath) then
            Player:Cast(FeignDeath);
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(CounterShot, ArcaneTorrent);
    end

    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(AimedShot, false) or Unit.Target;
    end

    -- Pet Manager
    local function ManagePet ()
        if module.IsOptionEnabled("Auto Summon/Revive Pet") and (InstantWhistle or module.PetDismissed + module.GetOptionValue("Auto Summon/Revive Pet") < module.GetTime()) then
            InstantWhistle = false;
            -- if whistle works, fine, otherwise blacklist it fro 5 second (usually should work fine with 1 attempt)
            if not PlayerPet:Exists() and module.GetTime() > TriedToSummonPet and Player:CanCast(CallPets[module.GetSecondOptionValue("Auto Summon/Revive Pet")]) then
                TriedToSummonPet = module.GetTime() + 5;
                Player:Cast(CallPets[module.GetSecondOptionValue("Auto Summon/Revive Pet")]);
                return;
            end
            -- if revive didnt work then we blacklist it 3 seconds (usually happens when user moves during resurrection cast)
            if not Player:IsMoving() and (not PlayerPet:Exists() or PlayerPet:IsDead()) and Player:CanCast(RevivePet) and module.GetTime() > TriedToResurrectPet then
                TriedToResurrectPet = module.GetTime() + 3;
                Player:Cast(MendPet);
                return;
            end
        end
        -- Mend Pet
        if PlayerPet:Exists() and module.IsOptionEnabled("Mend Pet") and Player:CanCast(MendPet) and not PlayerPet:Buff(MendPetBuff) and MendPet:TimeSinceCast() > 8 then
            if (Player:IsInCombat() and PlayerPet:HealthPercentage() <= module.GetOptionValue("Mend Pet")) or (not Player:IsInCombat() and PlayerPet:HealthPercentage() <= module.GetSecondOptionValue("Mend Pet")) then
                PlayerPet:Cast(MendPet);
                return;
            end
        end
    end

    -- Misdirection
    local function MisdirectionHandler ()
        if module.IsOptionEnabled("Misdirection") and not Player:Buff(MisdirectionBuff) then
            local MisdirectionTarget = (Focus and Focus:Exists() and Focus:CanCast(Misdirection) and Focus) or (MainTank and MainTank:Exists() and MainTank:CanCast(Misdirection) and MainTank) or (OffTank and OffTank:Exists() and OffTank:CanCast(Misdirection) and OffTank) or (PlayerPet and PlayerPet:Exists() and PlayerPet:CanCast(Misdirection) and PlayerPet);
            if MisdirectionTarget then
                -- Always
                if module.GetOptionValue("Misdirection") == "Always" then
                    MisdirectionTarget:Cast(Misdirection);
                    return;
                end
                -- When Fight just started
                if module.GetOptionValue("Misdirection") == "Engage" and CombatTime() < 5 then
                    MisdirectionTarget:Cast(Misdirection);
                    return;
                end
                -- If Target Threath is too high
                if module.GetOptionValue("Misdirection") == "Threath Target" and Player:Threat(Target) >= module.GetSecondOptionValue("Misdirection") then
                    MisdirectionTarget:Cast(Misdirection);
                    return;
                end
                -- If Any Target Threath is too high
                if module.GetOptionValue("Misdirection") == "Threath Any" then
                    for i = 1, #BarrageEnemies do
                        local ThisUnit = BarrageEnemies[i];
                        if Player:Threat(ThisUnit) >= module.GetSecondOptionValue("Misdirection") then
                            module.Bug("Misdirection on " .. MisdirectionTarget:Name() .. " as " .. ThisUnit:Name() .. " is at " .. Player:Threat(ThisUnit) .. "% threath")
                            MisdirectionTarget:Cast(Misdirection);
                            return;
                        end
                    end
                end
            end
        end
    end

    -- Handling of Pet Actionbar Abilities
    local PetAssisting;
    local function PlayerPetHandling ()
        -- Player Pet Handling
        if module.IsOptionEnabled("Pet Damage Handling") then
            if PlayerPet:Exists() then
                -- Assist/Passive Mode
                if module.GetOptionValue("Pet Damage Handling") == "Handle Assist" then
                    if Target:Exists() and not PetAssisting then
                        RunMacroText("/petattack target");
                        PetAssistMode();
                        PetAssisting = true;
                    elseif not Target:Exists() and PetAssisting then
                        PetPassiveMode();
                        PetAssisting = false;
                    end
                end
            end
        end
    end

    local function CastExplosiveShot ()
        if ExplosiveShot:Exists() and module.IsOptionEnabled("Explosive Shot") and Player:CanCast(ExplosiveShot) then
            local RealDistance = Player:DistanceTo(Target, true);
            local CanExplosiveShot, ExplosiveShotTargets = false, 0;
            for i = 1, #ExplosiveShotEnemies do
                local ThisUnit = ExplosiveShotEnemies[i];
                if not CanExplosiveShot and ThisUnit:GUID() == Target:GUID() then
                    CanExplosiveShot = true;
                end
                if Player:DistanceTo(ThisUnit, true) < RealDistance + 3 and Player:DistanceTo(ThisUnit, true) > RealDistance - 3 then
                    ExplosiveShotTargets = ExplosiveShotTargets + 1;
                end
            end
            if CanExplosiveShot and ExplosiveShotTargets >= module.GetOptionValue("Explosive Shot") then
                local AdjustedDistance = RealDistance < 10 and RealDistance + 3 or RealDistance < 20 and RealDistance + 1.5 or RealDistance < 30 and RealDistance - 1 or RealDistance < 35 and RealDistance - 2 or RealDistance < 40 and RealDistance - 3 or RealDistance - 4;
                Detonate, DetonateTime = true, module.GetTime() + AdjustedDistance*0.0625;
                Player:Cast(ExplosiveShot);
                return;
            end
        end
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        if not LoneWolf:Exists() then
            ManagePet();
            PlayerPetHandling();
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and Player:IsFacing(Target) then
            -- Barrage Queueing Macro
            if Barrage:Exists() and module.ShouldBarrage == true then
                if Barrage:Cooldown() > 6 then
                    module.ShouldBarrage = false;
                else
                    if Player:Focus() < 60 then
                        if not Sidewinders:Exists() then
                            if Target:CanCast(ArcaneShot) then
                                module.Bug("Pool for Barrage");
                                Target:Cast(ArcaneShot);
                                return;
                            end
                        elseif Target:CanCast(Sidewinders) then
                            module.Bug("Pool for Barrage");
                            Target:Cast(Sidewinders);
                            return;
                        end
                    end
                    if Player:Focus() >= 60 and Target:CanCast(Barrage) then
                        Target:Cast(Barrage);
                        return;
                    end
                end
            end

            -- Enemies Check
            if module.UseAOE() and RefreshEnemies < module.GetTime() then
                BarrageEnemies = Barrage:Exists() and Player:UnitsInFrontConeAroundUnit(Target, 45, 100) or {};
                Enemies_40y = Player:EnemiesWithinDistance(40, false);
                ExplosiveShotEnemies = ExplosiveShot:Exists() and Player:UnitsInFrontRectangle(40, 5) or {};
                PiercingShotEnemies = PiercingShot:Exists() and Player:UnitsInFrontRectangle(Player:DistanceTo(Target, true), 3) or {};
                TargetEnemies_8y = Target:EnemiesWithinDistance(8, true, true);
                NumEnemies = #TargetEnemies_8y;
                RefreshEnemies = module.GetTime() + 0.2;
            else
                BarrageEnemies, Enemies_40y, ExplosiveShotEnemies, PiercingShotEnemies, TargetEnemies_8y, NumEnemies = {}, {}, {}, {}, {}, 1;
            end
            -- Steady Focus
            if SteadyFocus:Exists() and (Player:Focus() < 100 or module.ShotCount >= 2) and Player:BuffRemains(SteadyFocusBuff) < 1 and module.ShotCount >= 1 and Target:CanCast(ArcaneShot) then
                if module.IsOptionEnabled("Multi-Shot") and NumEnemies >= module.GetOptionValue("Multi-Shot") and Target:CanCast(MultiShot) then
                    module.Bug("Steady Focus - Multi-Shot");
                    Target:Cast(MultiShot);
                    return;
                else
                    module.Bug("Steady Focus - Arcane Shot");
                    Target:Cast(ArcaneShot);
                    return;
                end
            end
            -- Misdirection
            MisdirectionHandler();
            -- Concussive Shot
            if ConcussiveShot:Exists() and module.IsOptionEnabled("Concussive Shot") and Target:CanCast(ConcussiveShot) then
                Target:Cast(ConcussiveShot);
                return;
            end
            -- Cooldowns
            if Player:IsWithinCastRange(Target, AimedShot) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and Player:Focus() < 70 and Player:CanCast(ArcaneTorrent) then
                        Player:Cast(ArcaneTorrent);
                        return;
                    end
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Trueshot
                if Trueshot:Exists() and module.IsOptionEnabled("Trueshot") and (module.CooldownsAllowed() or module.GetOptionValue("Trueshot") == "Always") and Player:Focus() >= 50 and Player:CanCast(Trueshot) then
                    Player:Cast(Trueshot);
                    return;
                end
            end

            -- Bursting Shot
            if BurstingShot:Exists() and module.IsOptionEnabled("Bursting Shot") and #ExplosiveShotEnemies >= module.GetOptionValue("Bursting Shot") and Player:CanCast(BurstingShot) then
                Player:Cast(BurstingShot);
                return;
            end
            -- Volley (90 Talent)
            if Volley:Exists() and module.IsOptionEnabled("Volley") and Target:CanCast(Volley) then
                if Target:CastGroundSpell(Volley, "Volley", 6) then return; end
            end

            -- actions+=/trueshot,if=(target.time_to_die>195|target.health.pct<5)|buff.bullseye.stack>15
            -- actions+=/marked_shot,if=!talent.sidewinders.enabled&prev_gcd.sentinel&debuff.hunters_mark.up
            if MarkedShot:Exists() and not Sidewinders:Exists() and Sentinel:TimeSinceCast() < 1 and Target:Debuff(HuntersMark) and Target:CanCast(MarkedShot) then
                Target:Cast(MarkedShot);
                return;
            end


            -- actions+=/call_action_list,name=careful_aim,if=(talent.careful_aim.enabled&target.health.pct>80)&spell_targets.barrage=1
            if CarefulAim:Exists() and Target:HealthPercentage() > 80 and #BarrageEnemies < 2 then
                -- actions.careful_aim=windburst
                if Windburst:Exists() and Target:CanCast(Windburst) then
                    Target:Cast(Windburst);
                    return;
                end
                -- actions.careful_aim+=/arcane_shot,if=(talent.steady_focus.enabled&buff.steady_focus.down&spell_targets.arcane_shot=1)|(talent.true_aim.enabled&(debuff.true_aim.stack<1&focus.time_to_max>=2|debuff.true_aim.remains<2))
                -- actions.careful_aim+=/marked_shot,if=talent.sidewinders.enabled&(!talent.patient_sniper.enabled|debuff.vulnerability.remains<2)|!talent.sidewinders.enabled
                if MarkedShot:Exists() and ((Sidewinders:Exists() and (not PatientSniper:Exists() or Target:DebuffRemains(Vulnerable) < 2)) or not Sidewinders:Exists()) and Target:Debuff(HuntersMark) and Target:CanCast(MarkedShot) then
                    Target:Cast(MarkedShot);
                    return;
                end
                -- actions.careful_aim+=/aimed_shot,if=debuff.hunters_mark.down&cast_time<debuff.vulnerability.remains
                if AimedShot:Exists() and not Target:Debuff(HuntersMark) and AimedShot:CastTime() < Target:DebuffRemains(Vulnerable) and Target:CanCast(AimedShot) then
                    Target:Cast(AimedShot);
                    return;
                end
                -- actions.careful_aim+=/multishot,if=spell_targets.multishot>1&(buff.marking_targets.up|focus.time_to_max>=2)
                if MultiShot:Exists() and not Sidewinders:Exists() and module.IsOptionEnabled("Multi-Shot") and NumEnemies >= module.GetOptionValue("Multi-Shot") and (Player:Buff(MarkingTargets) or Player:FocusTimeToMax() >= 2) and Target:CanCast(MultiShot) then
                    Target:Cast(MultiShot);
                    return;
                end
                -- actions.careful_aim+=/arcane_shot,if=spell_targets.arcane_shot=1&(buff.marking_targets.up|focus.time_to_max>=2)
                if ArcaneShot:Exists() and not Sidewinders:Exists() and (Player:Buff(MarkingTargets) or Player:FocusTimeToMax() >= 2) and Target:CanCast(ArcaneShot) then
                    Target:Cast(ArcaneShot);
                    return;
                end
                -- actions.careful_aim+=/sidewinders,if=!debuff.hunters_mark.up&(buff.marking_targets.up|buff.trueshot.up|charges=2|focus<80&(charges<=1&recharge_time<=5))
                if Sidewinders:Exists() and (not Target:Debuff(HuntersMark) and (Player:Buff(MarkingTargets) or Player:Buff(Trueshot) or Sidewinders:Charges() == 2 or (Player:Focus() < 80 and (Sidewinders:Charges() <= 1  and Sidewinders:ReCharge() <=5)))) and Target:CanCast(Sidewinders) then
                    Target:Cast(Sidewinders);
                    return;
                end
            end


            -- actions+=/a_murder_of_crows
            if AMurderOfCrows:Exists() and module.IsOptionEnabled("A Murder Of Crows") and (module.CooldownsAllowed() or module.GetOptionValue("A Murder Of Crows") == "Always") and Target:CanCast(AMurderOfCrows) then
                Target:Cast(AMurderOfCrows);
                return;
            end
            -- actions+=/barrage
            if Barrage:Exists() and module.IsOptionEnabled("Barrage") and #BarrageEnemies >= module.GetOptionValue("Barrage") and Target:CanCast(Barrage) then
                Target:Cast(Barrage);
                return;
            end
            -- actions+=/piercing_shot,if=!talent.patient_sniper.enabled&focus>50
            if PiercingShot:Exists() and module.IsOptionEnabled("Piercing Shot") and #PiercingShotEnemies >= module.GetOptionValue("Piercing Shot") and not PatientSniper:Exists() and Player:Focus() > 50 and Target:CanCast(PiercingShot) then
                Target:Cast(PiercingShot);
                return;
            end
            -- actions+=/windburst
            if Windburst:Exists() and Target:CanCast(Windburst) then
                Target:Cast(Windburst);
                return;
            end


            -- actions+=/call_action_list,name=patientless,if=!talent.patient_sniper.enabled
            if not PatientSniper:Exists() then
                -- actions.patientless=arcane_shot,if=debuff.vulnerability.stack<3&buff.marking_targets.up&debuff.hunters_mark.down&spell_targets.arcane_shot=1
                if ArcaneShot:Exists() and not Sidewinders:Exists() and (Target:DebuffCount(Vulnerable) < 3 and Player:Buff(MarkingTargets) and not Target:Debuff(HuntersMark) and NumEnemies <= 1) and Target:CanCast(ArcaneShot) then
                    Target:Cast(ArcaneShot);
                    return;
                end
                -- actions.patientless+=/marked_shot,if=debuff.vulnerability.stack<3|debuff.hunters_mark.remains<5|(focus<50|focus>80)
                if MarkedShot:Exists() and (Target:DebuffCount(Vulnerable) < 3 or Target:DebuffRemains(HuntersMark) < 5 or (Player:Focus() < 50 or Player:Focus() > 80)) and Target:Debuff(HuntersMark) and Target:CanCast(MarkedShot) then
                    Target:Cast(MarkedShot);
                    return;
                end
                -- actions.patientless+=/sentinel,if=!talent.sidewinders.enabled&debuff.hunters_mark.down&spell_targets.sentinel>1
                if Sentinel:Exists() and not Sidewinders:Exists() and not Target:Debuff(HuntersMark) and NumEnemies > 1 and Target:CanCast(Sentinel) then
                    Target:Cast(Sentinel);
                    return;
                end
                -- actions.patientless+=/explosive_shot
                CastExplosiveShot();
                -- actions.patientless+=/aimed_shot,if=debuff.hunters_mark.down&cast_time<debuff.vulnerability.remains
                if AimedShot:Exists() and not Target:Debuff(HuntersMark) and AimedShot:CastTime() < Target:DebuffRemains(Vulnerable) and Target:CanCast(AimedShot) then
                    Target:Cast(AimedShot);
                    return;
                end
                -- actions.patientless+=/marked_shot,if=debuff.hunters_mark.remains>5
                if MarkedShot:Exists() and Target:DebuffRemains(HuntersMark) > 5 and Target:CanCast(MarkedShot) then
                    Target:Cast(MarkedShot);
                    return;
                end
                -- actions.patientless+=/black_arrow
                if BlackArrow:Exists() and Target:CanCast(BlackArrow) then
                    Target:Cast(BlackArrow);
                    return;
                end
                -- actions.patientless+=/multishot,if=spell_targets.multishot>1&(cast_regen+action.aimed_shot.cast_regen<=focus.deficit)
                if MultiShot:Exists() and not Sidewinders:Exists() and NumEnemies > 1 and Player:FocusRegen()*(Player:GCD() + AimedShot:CastTime()) <= Player:FocusDeficit() and Target:CanCast(MultiShot) then
                    Target:Cast(MultiShot);
                    return;
                end
                -- actions.patientless+=/arcane_shot,if=cast_regen+action.aimed_shot.cast_regen<=focus.deficit&spell_targets.arcane_shot=1
                if ArcaneShot:Exists() and not Sidewinders:Exists() and NumEnemies <= 1 and Player:FocusRegen()*(Player:GCD() + AimedShot:CastTime()) <= Player:FocusDeficit() and Target:CanCast(ArcaneShot) then
                    Target:Cast(ArcaneShot);
                    return;
                end
            end


            -- actions+=/arcane_shot,if=(talent.steady_focus.enabled&buff.steady_focus.down&focus.time_to_max>=2)|(talent.true_aim.enabled&(debuff.true_aim.stack<1&focus.time_to_max>=2|debuff.true_aim.remains<2))
            if ArcaneShot:Exists() and not Sidewinders:Exists() and ((SteadyFocus:Exists() and not Player:Buff(SteadyFocusBuff) and Player:FocusTimeToMax() >=2) or (TrueAim:Exists() and ((Target:DebuffCount(TrueAimDebuff) < 1 and Player:FocusTimeToMax() >= 2) or Target:DebuffRemains(TrueAimDebuff) < 2))) and Target:CanCast(ArcaneShot) then
                Target:Cast(ArcaneShot);
                return;
            end
            -- actions+=/multishot,if=(talent.steady_focus.enabled&buff.steady_focus.down&focus.time_to_max>=2&spell_targets.multishot>1)
            if MultiShot:Exists() and not Sidewinders:Exists() and (SteadyFocus:Exists() and not Player:Buff(SteadyFocusBuff) and Player:FocusTimeToMax() >=2) and NumEnemies > 1 and Target:CanCast(MultiShot) then
                Target:Cast(MultiShot);
                return;
            end
            -- actions+=/sidewinders,if=spell_targets.sidewinders>1&(!debuff.hunters_mark.up&(buff.marking_targets.up|buff.trueshot.up|charges=2|focus<80&(charges<=1&recharge_time<=5)))
            if Sidewinders:Exists() and NumEnemies > 1 and (not Target:Debuff(HuntersMark) and (Player:Buff(MarkingTargets) or Player:Buff(Trueshot) or Sidewinders:Charges() == 2 or (Player:Focus() < 80 and (Sidewinders:Charges() <= 1 and Sidewinders:Recharge() <= 5)))) and Target:CanCast(Sidewinders) then
                Target:Cast(Sidewinders);
                return;
            end
            -- actions+=/explosive_shot
            CastExplosiveShot();
            -- actions+=/piercing_shot,if=talent.patient_sniper.enabled&focus>80
            if PiercingShot:Exists() and module.IsOptionEnabled("Piercing Shot") and #PiercingShotEnemies >= module.GetOptionValue("Piercing Shot") and PatientSniper:Exists() and Player:Focus() > 80 and Target:CanCast(PiercingShot) then
                Target:Cast(PiercingShot);
                return;
            end
            -- actions+=/marked_shot,if=talent.sidewinders.enabled&(!talent.patient_sniper.enabled|debuff.vulnerability.remains<2)|!talent.sidewinders.enabled
            if MarkedShot:Exists() and ((Sidewinders:Exists() and (not PatientSniper:Exists() or Target:DebuffRemains(Vulnerable) < 2)) or not Sidewinders:Exists()) and Target:Debuff(HuntersMark) and Target:CanCast(MarkedShot) then
                Target:Cast(MarkedShot);
                return;
            end
            -- actions+=/aimed_shot,if=cast_time<debuff.vulnerability.remains&(focus+cast_regen>80|debuff.hunters_mark.down)
            if AimedShot:Exists() and (AimedShot:CastTime() < Target:DebuffRemains(Vulnerable) and (Player:Focus() + Player:FocusRegen()*AimedShot:CastTime() > 80 or not Target:Debuff(HuntersMark))) and Target:CanCast(AimedShot) then
                Target:Cast(AimedShot);
                return;
            end
            -- actions+=/black_arrow
            if BlackArrow:Exists() and Target:CanCast(BlackArrow) then
                Target:Cast(BlackArrow);
                return;
            end
            -- actions+=/multishot,if=spell_targets.multishot>1&(!debuff.hunters_mark.up&buff.marking_targets.up&cast_regen+action.aimed_shot.cast_regen<=focus.deficit)
            if MultiShot:Exists() and not Sidewinders:Exists() and NumEnemies > 1 and (not Target:Debuff(HuntersMark) and Player:Buff(MarkingTargets) and Player:FocusRegen()*(Player:GCD() + AimedShot:CastTime()) <= Player:FocusDeficit()) and Target:CanCast(MultiShot) then
                Target:Cast(MultiShot);
                return;
            end
            -- actions+=/arcane_shot,if=(!debuff.hunters_mark.up&buff.marking_targets.up)|focus.time_to_max>=2
            if ArcaneShot:Exists() and not Sidewinders:Exists() and ((not Target:Debuff(HuntersMark) and Player:Buff(MarkingTargets)) or Player:FocusTimeToMax() >= 2) and Target:CanCast(ArcaneShot) then
                Target:Cast(ArcaneShot);
                return;
            end
            -- actions+=/sidewinders,if=!debuff.hunters_mark.up&(buff.marking_targets.up|buff.trueshot.up|charges=2|focus<80&(charges<=1&recharge_time<=5))
            if Sidewinders:Exists() and (not Target:Debuff(HuntersMark) and (Player:Buff(MarkingTargets) or Player:Buff(Trueshot) or Sidewinders:Charges() == 2 or (Player:Focus() < 80 and (Sidewinders:Charges() <= 1 and Sidewinders:Recharge() <= 5)))) and Target:CanCast(Sidewinders) then
                Target:Cast(Sidewinders);
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        if not LoneWolf:Exists() then
            ManagePet();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Survival Hunter
    local Rotation = {};
    module.SetRotation(255, Rotation);

    --- Localization
    -- Core
    local FrontUnits, ButcheryEnemies, NumEnemies = {}, 0, 1; -- Enemies
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local TriedToResurrectPet, TriedToSummonPet = 0, 0; -- Summon/Whistle Pet alternate
    local GCDMax, Focus, FocusRegen;
    local PlayerPet = module.PlayerPet;
    local PlayerPetTarget = module.Unit.PlayerPetTarget;


    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        -- Items
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);

        --Racials
        ArcaneTorrent = Spell(80483, false, false, true);
        RocketBarrage = Spell(69041, true, true, true);
        BloodFury = Spell(20572, false, false, true);
        Berserking = Spell(26297, false, false, true);
        GiftOfTheNaaru = Spell(59543, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        AMurderOfCrows = Spell(206505, false, true, true);
        AspectOfTheEagle = Spell(186289, false, false, true);
        AspectOfTheTurtle = Spell(186265, false, false, true);
        Butchery = Spell(212436, false, false, true);
        Carve = Spell(187708, false, false, true);
        DragonsfireGrenade = Spell(194855, true, true, true);
        Exhilaration = Spell(194291, false, false, true);
        ExplosiveTrap = Spell(191433, false, false, true);
        FeignDeath = Spell(5384, false, false, true);
        FlankingStrike = Spell(202800, true, true, true);
        FuryOfTheEagle = Spell(203415, false, false, true);
        Harpoon = Spell(190925, true, true, true); -- 5 + HitBox - 30
        HatchetToss = Spell(193265, true, true, true); -- 5 - 30
        Lacerate = Spell(185855, true, true, true);
        MendPet = Spell(982, false, false, true);
        MendPetBuff = Spell(136, false, false, true);
        MongooseBite = Spell(190928, true, true, true);
        MongooseFury = Spell(190931);
        Muzzle = Spell(187707, true, true, true);
        RangersNet = Spell(200108, true, true, true);
        RaptorStrike = Spell(186270, true, true, true);
        RangersNetSlow = Spell(206755);
        SerpentSting = Spell(87935);
        SerpentStingDebuff = Spell(118253);
        SnakeHunter = Spell(201078, false, false, true);
        SpittingCobra = Spell(194407, false, false, true);
        SteelTrap = Spell(162488, false, true, true);
        ThrowingAxes = Spell(200163, true, true ,true);
        WayOfTheMokNathalBuff = Spell(201081);
        WayOfTheMokNathal = Spell(201082);
        WingClip = Spell(195645, true, true, true);

        -- Pet Manager section
        CallPets = {Spell(883, false, false, true),
                    Spell(83242, false, false, true),
                    Spell(83243, false, false, true),
                    Spell(83244, false, false, true),
                    Spell(83245, false, false, true)}
        RevivePet = Spell(982, false, false, false);


        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        -- Add options to pages
        module.AddPresetOption("TargetAttack");
        module.AddPresetOption("ReTarget");
        module.AddPresetOption("BossCD");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Auto Summon/Revive Pet", 222, true, {3, 1, 25, 0.5}, {1, 1, 5, 1}, "Automatically Whistle/Revive your Pet."..C.TOOLTIP_VALUE_1.."How long would you like to wait before using Whistle when your pet is dismissed."..C.TOOLTIP_VALUE_2.."Which pet you would like to auto summon?");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Muzzle to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Only Arcane Torrent is supported."));
        end
        module.AddPresetOption("Trinket");
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "A Murder Of Crows", 230, true, {1, "Always", "With Cooldowns"}, nil, "Use A Murder of Crows."..C.TOOLTIP_VALUE.."Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Aspect Of The Eagle", 230, true, {1, "Always", "With Cooldowns"}, nil, "Use Aspect Of The Eagle."..C.TOOLTIP_VALUE.."Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Dragonsfire Grenade", 230, true, {1, "Always", "With Cooldowns"}, nil, "Use Dragonsfire Grenade."..C.TOOLTIP_VALUE.."Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Snake Hunter", 230, true, {1, "Always", "With Cooldowns"}, nil, "Use Snake Hunter."..C.TOOLTIP_VALUE.."Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Spitting Cobra", 230, true, {1, "Always", "With Cooldowns"}, nil, "Use Spitting Cobra."..C.TOOLTIP_VALUE.."Define if you want to always use the ability or only with cooldowns.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Explosive Trap", 220, true, {2, 1, 10, 1}, nil, "Use Explosive Trap."..C.TOOLTIP_VALUE.."Minimum amount of units to use.");
        module.AddNewOption("Offensive Settings", "Fury Of The Eagle", 220, true, {2, 1, 10, 1}, nil, "Use Fury Of The Eagle."..C.TOOLTIP_VALUE.."Minimum amount of units to use.");
        module.AddNewOption("Offensive Settings", "Hatchet Toss", 210, true, nil, nil, "Use Hatchet Toss while we are out of range.");
        module.AddNewOption("Offensive Settings", "Pet Damage Handling", 230, true, {1, "Handle Assist", "Do Not Handle Assist"}, nil, "Manage Pet."..C.TOOLTIP_VALUE_1.."Enable this to automatically change between assist and passive mode depending if you have a target or not.");
        module.AddNewOption("Offensive Settings", "Wing Clip | Ranger's Net", 210, false, nil, nil, "Maintain Wing Clip or Ranger's Net on our current target.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddPresetOption("HealingItem");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Mend Pet", 222, true, {35, 0, 100, 1}, {85, 0, 100, 1}, "Enable use of Mend Pet when pet health fall under threshold. \n\n|cFF0088FFValue 1:|r In combat threshold. \n\n|cFF0088FFValue 2:|r Out of combat threshold.");
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Auto Feign Death", 220, true, {10, 0, 100, 1}, nil, "Use Feign Death." .. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddNewOption("Defensive Settings", "Aspect Of The Turtle", 220, true, {35, 0, 100, 1}, nil, "Use Aspect Of The Turtle." .. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddNewOption("Defensive Settings", "Exhilaration", 220, true, {35, 0, 100, 1}, nil, "Use Exhilaration." .. C.TOOLTIP_VALUE .. "Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {35, 0, 100, 1}, nil, "Health Percentage to use Gift Of The Naaru on self");
        end

        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Buff(FeignDeath) then
            return;
        end

        -- Put the Outputs here that we wait to keep updated
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Exhilaration
        if Exhilaration:Exists() and module.IsOptionEnabled("Exhilaration") and Player:HealthPercentage() <= module.GetOptionValue("Exhilaration") and Player:CanCast(Exhilaration) then
            Player:Cast(Exhilaration);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
        -- Aspect of the Turtle
        if AspectOfTheTurtle:Exists() and module.IsOptionEnabled("Aspect Of The Turtle") and Player:HealthPercentage() <= module.GetOptionValue("Aspect Of The Turtle") and Player:CanCast(AspectOfTheTurtle) then
            Player:Cast(AspectOfTheTurtle);
            return;
        end
        -- Feign Death
        if FeignDeath:Exists() and module.IsOptionEnabled("Auto Feign Death") and Player:HealthPercentage() <= module.GetOptionValue("Auto Feign Death") and Player:CanCast(FeignDeath) then
            Player:Cast(FeignDeath);
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Muzzle, ArcaneTorrent);
    end

    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(MongooseBite, false) or Unit.Target;
    end

    -- Pet Manager
    local function ManagePet ()
        if module.IsOptionEnabled("Auto Summon/Revive Pet") and (InstantWhistle or module.PetDismissed + module.GetOptionValue("Auto Summon/Revive Pet") < module.GetTime()) then
            InstantWhistle = false;
            -- if whistle works, fine, otherwise blacklist it fro 5 second (usually should work fine with 1 attempt)
            if not PlayerPet:Exists() and module.GetTime() > TriedToSummonPet and Player:CanCast(CallPets[module.GetSecondOptionValue("Auto Summon/Revive Pet")]) then
                TriedToSummonPet = module.GetTime() + 5;
                Player:Cast(CallPets[module.GetSecondOptionValue("Auto Summon/Revive Pet")]);
                return;
            end
            -- if revive didnt work then we blacklist it 3 seconds (usually happens when user moves during resurrection cast)
            if not Player:IsMoving() and (not PlayerPet:Exists() or PlayerPet:IsDead()) and Player:CanCast(RevivePet) and module.GetTime() > TriedToResurrectPet then
                TriedToResurrectPet = module.GetTime() + 3;
                Player:Cast(MendPet);
                return;
            end
        end
        -- Mend Pet
        if PlayerPet:Exists() and module.IsOptionEnabled("Mend Pet") and Player:CanCast(MendPet) and not PlayerPet:Buff(MendPetBuff) and MendPet:TimeSinceCast() > 8 then
            if (Player:IsInCombat() and PlayerPet:HealthPercentage() <= module.GetOptionValue("Mend Pet")) or (not Player:IsInCombat() and PlayerPet:HealthPercentage() <= module.GetSecondOptionValue("Mend Pet")) then
                PlayerPet:Cast(MendPet);
                return;
            end
        end
    end

    -- Handling of Pet Actionbar Abilities
    local PetAssisting, PetForceAssistDelay = nil, 0;
    local function PlayerPetHandling ()
        -- Player Pet Handling
        if module.IsOptionEnabled("Pet Damage Handling") then
            if PlayerPet:Exists() then
                -- Assist/Passive Mode
                if module.GetOptionValue("Pet Damage Handling") == "Handle Assist" then
                    if Target:Exists() and not PetAssisting then
                        PetAssistMode();
                        RunMacroText("/petattack target");
                        PetAssisting = true;
                    elseif not Target:Exists() and PetAssisting then
                        PetPassiveMode();
                        PetAssisting = false;
                    end
                    if Target:Exists() and PetAssisting and PlayerPetTarget and PlayerPetTarget:GUID() ~= Target:GUID() and PetForceAssistDelay < module.GetTime() then
                        PetPassiveMode();
                        PetAssistMode();
                        RunMacroText("/petattack target");
                        PetForceAssistDelay = module.GetTime() + 2;
                    end
                end
            end
        end
    end

    -- Function to check if we can use Kill Command
    local function CanKillCommand ()
        return not module.KillFailTime or module.GetTime() > module.KillFailTime;
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        ManagePet();
        PlayerPetHandling();
        -- Common values for SimC Calculations
        GCDMax, Focus, FocusRegen = Player:GCD(), Player:Focus(), Player:FocusRegen();
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and Player:IsFacing(Target) then
            -- Enemies Check
            if module.UseAOE() and RefreshEnemies < module.GetTime() then
                FrontUnits = Player:UnitsInFrontCone(7, 180);
                ButcheryEnemies = Butchery:Exists() and #Player:EnemiesWithinDistance(7, true) or 0;
                NumEnemies = #FrontUnits;
                RefreshEnemies = module.GetTime() + 0.2;
            else
                FrontUnits, ButcheryEnemies, NumEnemies = {}, 0, 1;
            end
            -- Ranger's Net | Wing Clip
            if module.IsOptionEnabled("Wing Clip | Ranger's Net") then
                if RangersNet:Exists() then
                    if not Target:Debuff(RangersNet) and not Target:Debuff(RangersNetSlow) and Target:CanCast(RangersNet) then
                        Target:Cast(RangersNet);
                        return;
                    end
                else
                    if not Target:Debuff(WingClip) and Target:CanCast(WingClip) then
                        Target:Cast(WingClip);
                        return;
                    end
                end
            end
            -- Cooldowns
            if Player:IsWithinCastRange(Target, MongooseBite) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and Focus < 70 and Player:CanCast(ArcaneTorrent) then
                        Player:Cast(ArcaneTorrent);
                        return;
                    end
                end
            end
            -- actions+=/explosive_trap
            if ExplosiveTrap:Exists() and Player:Standing() > 0.5 and module.IsOptionEnabled("Explosive Trap") and NumEnemies >= module.GetOptionValue("Explosive Trap") and Player:CanCast(ExplosiveTrap) then
                Player:Cast(ExplosiveTrap);
                return;
            end
            -- actions+=/dragonsfire_grenade
            if DragonsfireGrenade:Exists() and module.IsOptionEnabled("Dragonsfire Grenade") and (module.CooldownsAllowed() or module.GetOptionValue("Dragonsfire Grenade") == "Always") and Target:CanCast(DragonsfireGrenade) then
                Target:Cast(DragonsfireGrenade);
                return;
            end
            -- actions+=/carve,if=talent.serpent_sting.enabled&active_enemies>=3&(!dot.serpent_sting.ticking|dot.serpent_sting.remains<=gcd.max)
            if Carve:Exists() and SerpentSting:Exists() and NumEnemies >= 3 and Target:DebuffRemains(SerpentStingDebuff) < GCDMax and Player:CanCast(Carve) then
                Player:Cast(Carve);
                return;
            end
            -- actions+=/raptor_strike,cycle_targets=1,if=talent.serpent_sting.enabled&active_enemies<=2&(!dot.serpent_sting.ticking|dot.serpent_sting.remains<=gcd.max)|talent.way_of_the_moknathal.enabled&(buff.moknathal_tactics.remains<gcd.max|buff.moknathal_tactics.down)
            if RaptorStrike:Exists() and ((SerpentSting:Exists() and NumEnemies <= 2 and Target:DebuffRemains(SerpentStingDebuff) < GCDMax) or (WayOfTheMokNathal:Exists() and Player:BuffRemains(WayOfTheMokNathalBuff) < GCDMax)) and Target:CanCast(RaptorStrike) then
                Target:Cast(RaptorStrike);
                return;
            end
            -- actions+=/aspect_of_the_eagle
            if AspectOfTheEagle:Exists() and module.IsOptionEnabled("Aspect Of The Eagle") and (module.CooldownsAllowed() or module.GetOptionValue("Aspect Of The Eagle") == "Always") and MongooseBite:Charges() < 3 and Player:Buff(MongooseFury) and Player:CanCast(AspectOfTheEagle) then
                Player:Cast(AspectOfTheEagle);
                return;
            end
            -- actions+=/fury_of_the_eagle,if=buff.mongoose_fury.up&buff.mongoose_fury.remains<=gcd.max*2
            if FuryOfTheEagle:Exists() and module.IsOptionEnabled("Fury Of The Eagle") and NumEnemies >= module.GetOptionValue("Fury Of The Eagle") and (Player:Buff(MongooseFury) and Player:BuffRemains(MongooseFury) <= GCDMax*2) and Player:CanCast(FuryOfTheEagle) then
                Player:Cast(FuryOfTheEagle);
                return;
            end
            -- actions+=/mongoose_bite,if=buff.mongoose_fury.up|cooldown.fury_of_the_eagle.remains<5|charges=3
            if MongooseBite:Exists() and (Player:Buff(MongooseFury) or (FuryOfTheEagle:Exists() and FuryOfTheEagle:Cooldown() < 5) or MongooseBite:Charges() == 3) and Target:CanCast(MongooseBite) then
                Target:Cast(MongooseBite);
                return;
            end
            -- actions+=/steel_trap
            if SteelTrap:Exists() and not Target:IsMoving() and Target:CanCast(SteelTrap) then
                Target:Cast(SteelTrap);
                return;
            end
            -- actions+=/a_murder_of_crows
            if AMurderOfCrows:Exists() and module.IsOptionEnabled("A Murder Of Crows") and (module.CooldownsAllowed() or module.GetOptionValue("A Murder Of Crows") == "Always") and Target:CanCast(AMurderOfCrows) then
                Target:Cast(AMurderOfCrows);
                return;
            end
            -- actions+=/lacerate,if=dot.lacerate.ticking&dot.lacerate.remains<=3|target.time_to_die>=5
            if Lacerate:Exists() and Target:DebuffRemains(Lacerate) <= 3 and Target:CanCast(Lacerate) then
                Target:Cast(Lacerate);
                return;
            end
            -- actions+=/snake_hunter,if=action.mongoose_bite.charges<=1&buff.mongoose_fury.remains>gcd.max*4
            if SnakeHunter:Exists() and module.IsOptionEnabled("Snake Hunter") and (module.CooldownsAllowed() or module.GetOptionValue("Snake Hunter") == "Always") and MongooseBite:Charges() <= 1 and Player:BuffRemains(MongooseFury) > GCDMax*4 and Player:CanCast(SnakeHunter) then
                Player:Cast(SnakeHunter);
                return;
            end
            -- actions+=/flanking_strike,if=talent.way_of_the_moknathal.enabled&(focus>=55&buff.moknathal_tactics.remains>=3)|focus>=55
            if FlankingStrike:Exists() and ((WayOfTheMokNathal:Exists() and (Focus >= 55 and Player:BuffRemains(WayOfTheMokNathalBuff) >= 3)) or Focus >= 55) and PlayerPet:Exists() and PlayerPetTarget:Exists() and not PlayerPet:IsDead() and CanKillCommand() and PlayerPet:DistanceTo(PlayerPetTarget) - PlayerPetTarget:CombatReach() < 20 and PlayerPetTarget:CanCast(FlankingStrike) then
                PlayerPetTarget:Cast(FlankingStrike);
                return;
            end
            -- actions+=/butchery,if=spell_targets.butchery>=2
            if Butchery:Exists() and ButcheryEnemies >= 2 and Player:CanCast(Butchery) then
                Player:Cast(Butchery);
                return;
            end
            -- actions+=/carve,if=spell_targets.carve>=4
            if Carve:Exists() and NumEnemies >= 4 and Player:CanCast(Carve) then
                Player:Cast(Carve);
                return;
            end
            -- actions+=/spitting_cobra
            if SpittingCobra:Exists() and module.IsOptionEnabled("Spitting Cobra") and (module.CooldownsAllowed() or module.GetOptionValue("Spitting Cobra") == "Always") and Player:CanCast(SpittingCobra) then
                Player:Cast(SpittingCobra);
                return;
            end
            -- actions+=/throwing_axes
            if ThrowingAxes:Exists() and Target:CanCast(ThrowingAxes) then
                Target:Cast(ThrowingAxes);
                return;
            end
            -- actions+=/raptor_strike,if=focus>75-cooldown.flanking_strike.remains*focus.regen
            if RaptorStrike:Exists() and Focus > 75-FlankingStrike:Cooldown()*FocusRegen and Target:CanCast(RaptorStrike) then
                Target:Cast(RaptorStrike);
                return;
            end
            -- Hatchet Toss - 5-30 Yards
            if HatchetToss:Exists() and module.IsOptionEnabled("Hatchet Toss") and Target:CanCast(HatchetToss) then
                if Player:DistanceTo(Target) >= 5 and Player:DistanceTo(Target) < 30 then
                    Target:Cast(HatchetToss);
                    return;
                end
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        ManagePet();
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Arcane Mage
    local Rotation = {};
    module.SetRotation(62, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local ArcaneOrbUnits, Enemies_14y, TargetEnemies_10y, TargetEnemies_8y, NumEnemies = 0, {}, {}, {}, 0; -- Units
    local ShouldEvocation = nil; -- Evocation Managaement

    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicIntellect = Item(109218, false, false, true);
        DraenicIntellectBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);
        GiftOfTheNaaru = Spell(59548, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        ArcaneBarrage = Spell(44425, true, true, true);
        ArcaneBlast = Spell(30451, true, true, false);
        ArcaneExplosion = Spell(1449, false, false, true);
        ArcaneFamiliar = Spell(205022, false, false, true);
        ArcaneFamiliarBuff = Spell(210126);
        ArcaneMissiles = Spell(5143, true, true, false);
        ArcaneMissilesBuff = Spell(79683);
        ArcaneOrb = Spell(153626, false, false, true);
        ArcanePower = Spell(12042, false, false, true);
        ChargedUp = Spell(205032, false, false, true);
        ColdSnap = Spell(11958, false, false, true);
        Counterspell = Spell(2139, false, true, true);
        Evocation = Spell(12051, false, false, false);
        GreaterInvisibility = Spell(110959, false, false, true);
        GreaterInvisibilityBuff = Spell(110960);
        IceBarrier = Spell(11426, false, false, true);
        IceBlock = Spell(45438, false, false, true);
        IceFloes = Spell(108839, false, false, true);
        IncantersFlow = Spell(1463, false, false, false);
        IncantersFlowBuff = Spell(116267);
        IncantersFlowDirection = 0;
        MirrorImage = Spell(55342, false, false, true);
        NetherTempest = Spell(114923, false, true, true);
        Overpowered = Spell(155147);
        Polymorph = Spell(118, false, true, false);
        PresenceOfMind = Spell(205025, false, false, true);
        RuneOfPower = Spell(116011, false, false, false);
        RuneOfPowerBuff = Spell(116014);
        Supernova = Spell(157980, false, true, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {1, "Disabled", "Enabled"}, "|cffFF0044Target (Left Box)|r \nAutomatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode. \n|cFF0088FFClosest:|r Target the closest enemy. \n|cFF0088FFLeast HP:|r Target the enemy with the least health remaining. \n|cFF0088FFMost HP:|r Target the enemy with the most health remaining. \n|cFF0088FFTarget Closest:|r Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining. \n\n|cffFF0044Attack (Right Box)|r \nUse /startattack when you changes target. Good for melee classes.");
        module.AddOption("General Settings", "Cooldowns Only On Bosses", false, "Only cast CD's on boss targets.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddOption("General Settings", "Ice Floes", true);
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Counterspell to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Mirror Image", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Mirror Image."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Arcane Power", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Arcane Power."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Rune Of Power", 233, true, {2, "Always", "Cooldown Only"}, {2, "Anytime", "Before Arcane Power"}, "Use Rune Of Power."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Anytime", true).."Use Rune Of Power whenever it is ready."..C.TOOLTIP_SUBVALUE("Before Arcane Power", true).."Save one charge for Arcane Power. Use second charge after Evocation to take profit of full mana.");
        module.AddNewOption("Offensive Settings", "Presence Of Mind", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Presence Of Mind."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Arcane Explosion", 220, true, {5, 1, 10, 1}, nil, "Use Arcane Explosion."..C.TOOLTIP_VALUE.."Amount of units that needs to be within 8y around player to use.");
        module.AddNewOption("Offensive Settings", "Charged Up", 230, true, {1, "Always", "Not Out Of Combat", "Opener Only"}, nil, "Use Charged Up."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Use Charged Up when we have 0 Arcane Charges even when Out Of Combat."..C.TOOLTIP_SUBVALUE("Not Out Of Combat", true).."Only use Cahrged Up we are at 0 charges and are in Combat."..C.TOOLTIP_SUBVALUE("Opener Only", true).."Only use in the opener.");
        module.AddNewOption("Offensive Settings", "Evocation", 232, true, {1, "Anytime", "Not During Arcane Power"}, { 45, 10, 90, 1 }, "Use Evocation."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Anytime", true).."Use Evocation when we fall under threshold regardless of Arcane Power buff."..C.TOOLTIP_SUBVALUE("Not During Arcane Power", true).."Only use Evocation when Arcane Power ends, only if we are under the mana threshold."..C.TOOLTIP_VALUE_2.."Mana percentage to use Evocation.");
        module.AddNewOption("Offensive Settings", "Arcane Orb", 220, true, {1, 1, 10, 1}, nil, "Use Arcane Orb."..C.TOOLTIP_VALUE.."Amount of units that needs to be in 40y corridor in front of us to use.");
        module.AddNewOption("Offensive Settings", "Nether Tempest", 220, true, {1, 1, 10, 1}, nil, "Use Nether Tempest."..C.TOOLTIP_VALUE.."Amount of units that needs to be within 10y around our target to use.");
        module.AddNewOption("Offensive Settings", "Supernova", 220, true, {1, 1, 10, 1}, nil, "Use Supernova."..C.TOOLTIP_VALUE.."Amount of units that needs to be within 8y around our target to use.");


        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {40, 1, 100, 1}, nil, "Use Gift Of The Naaru on self."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Greater Invisibility", 220, true, {20, 1, 100, 1}, nil, "Use Greater Invisibility."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Ice Barrier", 220, true, {80, 1, 100, 1}, nil, "Use Ice Barrier."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Ice Block", 220, true, {30, 1, 100, 1}, nil, "Use Ice Block."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- Incanters Flow Tracker
        local Frame = CreateFrame('Frame');
        Frame:RegisterEvent("PLAYER_DAMAGE_DONE_MODS");
        local function IncantersFlowTracker (self, ...)
            IncantersFlowBuffCount = Player:BuffCount(IncantersFlowBuff);
            --module.Bug("Incanter's Flow: "..IncantersFlowBuffCount);
            if IncantersFlowBuffCount == 1 then
                IncantersFlowDirection = 1;
            elseif IncantersFlowBuffCount == 5 then
                IncantersFlowDirection = 2;
            end
        end
        Frame:SetScript("OnEvent", IncantersFlowTracker);
    end

    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Channeling(ArcaneMissiles) or (Player:Channeling(Evocation) and Player:PowerPercentage() < 95) then
            return;
        end

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end
        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        -- Charged Up
        if ChargedUp:Exists() and module.IsOptionEnabled("Charged Up") and Player:ArcaneCharges() ~= 4 and Player:CanCast(ChargedUp) then
            Player:Cast(ChargedUp);
        end
        -- Potion
        if module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + ArcaneBlast:CastTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) and Player:IsWithinCastRange(Target, ArcaneBlast) then
            if Player:Potion("Intellect", Potion) then module.Bug("Pre-Pull - Intellect Potion"); Potion = true; end
        end
        -- Mirror Images
        if MirrorImage:Exists() and BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + ArcaneBlast:CastTime() + Player:GCD() and module.IsOptionEnabled("Mirror Image") and (module.CooldownsAllowed() or module.GetOptionValue("Mirror Image") == "Always") and Player:CanCast(MirrorImage) then
            module.Bug("Mirror Image");
            Player:Cast(MirrorImage);
            return;
        end
        -- Rune Of Power
        if RuneOfPower:Exists() and BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + ArcaneBlast:CastTime() + RuneOfPower:CastTime() and module.IsOptionEnabled("Rune Of Power") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and Player:CanCast(RuneOfPower) then
            module.Bug("Rune of Power");
            Player:Cast(RuneOfPower);
            return;
        end
        -- Arcane Blast
        if ArcaneBlast:Exists() and BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + ArcaneBlast:CastTime() and Target:CanCast(ArcaneBlast) then
            module.Bug("Pre-Pull - Arcane Blast");
            Target:Cast(ArcaneBlast);
            return;
        end
        -- Ice Barrier
        if IceBarrier:Exists() and BMPullTime() > module.GetSecondOptionValue("Pre-Pull BossMod") + 3 and BMPullTime() < 5 and not Player:Buff(IceBarrier) and Player:CanCast(IceBarrier) then
            module.Bug("Pre-Pull - Ice Barrier");
            Player:Cast(IceBarrier);
            return;
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Counterspell, ArcaneTorrent);
    end


    function Rotation:OffGCDAbilities ()
        -- Ice floes if moving
        if module.IsOptionEnabled("Ice Floes") and IceFloes:Exists() and Player:IsMoving() and not Player:Buff(IceFloes) and Player:CanCast(IceFloes) and IceFloes:TimeSinceCast() > 1 then
            Player:Cast(IceFloes);
            IceFloes.LastCastTime = module.GetTime();
        end
        -- Charged Up
        if ChargedUp:Exists() and module.IsOptionEnabled("Charged Up") and not module.GetOptionValue("Charged Up") == "Opener Only" and Player:ArcaneCharges() == 0 and Player:CanCast(ChargedUp) then
            Player:Cast(ChargedUp);
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Ice Block
        if IceBlock:Exists() and module.IsOptionEnabled("Ice Block") and Player:HealthPercentage() <= module.GetOptionValue("Ice Block") and not Player:Buff(GreaterInvisibilityBuff) and Player:CanCast(IceBlock) then
            SpellStopCasting();
            Player:Cast(IceBlock);
            return;
        end
        -- Ice Barrier
        if IceBarrier:Exists() and module.IsOptionEnabled("Ice Barrier") and Player:HealthPercentage() <= module.GetOptionValue("Ice Barrier") and not Player:Buff(IceBarrier) and Player:CanCast(IceBarrier) then
            Player:Cast(IceBarrier);
            return;
        end
        -- Greater Invisibility
        if GreaterInvisibility:Exists() and module.IsOptionEnabled("Greater Invisibility") and Player:HealthPercentage() <= module.GetOptionValue("Greater Invisibility") and not Player:Buff(IceBlock) and Player:CanCast(GreaterInvisibility) then
            SpellStopCasting();
            Player:Cast(GreaterInvisibility);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    function Rotation:Combat ()
        local ArcaneCharges = Player:Casting(ArcaneBlast) and Player:ArcaneCharges() + 1 or Player:ArcaneCharges();
        -- Arcane Familiar
        if ArcaneFamiliar:Exists() and (not Player:Buff(ArcaneFamiliarBuff) or 3600 - (module.GetTime() - select(3,GetTotemInfo(4))) < 60) and Player:CanCast(ArcaneFamiliar) then
            Player:Cast(ArcaneFamiliar);
            return;
        end
        if Target:Exists() and Player:CanAttack(Target) then


            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                ArcaneOrbUnits = ArcaneOrb:Exists() and #Player:UnitsInFrontRectangle(40, 5) or 0; -- 40 Yards Corridor for Arcane Orb
                Enemies_14y = Player:EnemiesWithinDistance(14) or {}; -- 14 Yards for Arcane Explosion
                TargetEnemies_10y = Target:EnemiesWithinDistance(10); -- 10 yards for Nether Tempest
                TargetEnemies_8y = Target:FilterEnemiesByDistance(TargetEnemies_10y, 8, false);
                NumEnemies = #Enemies_14y;
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, ArcaneBlast) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Rune Of Power - Anytime
                if RuneOfPower:Exists() and module.IsOptionEnabled("Rune Of Power") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and module.GetSecondOptionValue("Rune Of Power") == "Anytime" and RuneOfPower:TimeSinceCast() >= 5 and not Player:Buff(RuneOfPowerBuff) and Player:Standing() >= 1 and Player:CanCast(RuneOfPower) then
                    module.Bug("Rune Of Power - Anytime");
                    Player:Cast(RuneOfPower);
                    RuneOfPower.LastCastTime = module.GetTime();
                    return;
                end
                -- Rune Of Power - After Evocation
                if RuneOfPower:Exists() and module.IsOptionEnabled("Rune Of Power") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and Evocation:TimeSinceCast() < 5 and RuneOfPower:TimeSinceCast() >= 5 and not Player:Buff(RuneOfPowerBuff) and Player:Standing() >= 1 and Player:CanCast(RuneOfPower) then
                    module.Bug("Rune Of Power - After Evocation");
                    Player:Cast(RuneOfPower);
                    RuneOfPower.LastCastTime = module.GetTime();
                    return;
                end
                -- Arcane Power
                if ArcanePower:Exists() and module.IsOptionEnabled("Arcane Power") and (module.CooldownsAllowed() or module.GetOptionValue("Arcane Power") == "Always") and ArcaneCharges >= 4 and Evocation:Cooldown() < 17 and Player:CanCast(ArcanePower) then
                    -- Rune Of Power
                    if RuneOfPower:Exists() and module.IsOptionEnabled("Rune Of Power") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and (module.GetSecondOptionValue("Rune Of Power") == "Before Arcane Power") and RuneOfPower:TimeSinceCast() >= 5 and not Player:Buff(RuneOfPowerBuff) and Player:Standing() >= 1 and Player:CanCast(RuneOfPower) then
                        module.Bug("Rune Of Power - Before Arcane Power");
                        Player:Cast(RuneOfPower);
                        RuneOfPower.LastCastTime = module.GetTime();
                        return;
                    end
                    ShouldEvocation = module.GetTime() + 16
                    Player:Cast(ArcanePower);
                    return;
                end
                -- Presence Of Mind
                if PresenceOfMind:Exists() and module.IsOptionEnabled("Presence Of Mind") and (module.CooldownsAllowed() or module.GetOptionValue("Presence Of Mind") == "Always") and Player:CanCast(PresenceOfMind) then
                    Player:Cast(PresenceOfMind);
                    return;
                end
                -- Mirror Images
                if MirrorImage:Exists() and module.IsOptionEnabled("Mirror Image") and (module.CooldownsAllowed() or module.GetOptionValue("Mirror Image") == "Always") and Player:CanCast(MirrorImage) then
                    Player:Cast(MirrorImage);
                    return;
                end
            end
            -- Evocation
            if Evocation:Exists() and ((Player:BuffRemains(ArcanePower) < ArcaneBlast:CastTime() and ShouldEvocation and ShouldEvocation < module.GetTime()) or Player:Power() < 35000) and Player:CanCast(Evocation) then
                ShouldEvocation = nil;
                Evocation.LastCastTime = module.GetTime();
                if Player:PowerPercentage() < 90 then
                    Player:Cast(Evocation);
                    return;
                end
            end

            -- Rotation
            -- Supernova
            if Supernova:Exists() and module.IsOptionEnabled("Supernova") and not Player:Buff(ArcanePower) and not Player:Buff(RuneOfPowerBuff) and #TargetEnemies_8y >= module.GetOptionValue("Supernova") and Target:CanCast(Supernova) then
                Target:Cast(Supernova);
                return;
            end
            -- Arcane Missiles - 4 Arcane Charges or 3 Arcane Missiles Buff
            if ArcaneMissiles:Exists() and (ArcaneCharges >= 4 or Player:BuffCount(ArcaneMissilesBuff) == 3) and Player:Buff(ArcaneMissilesBuff) and Target:CanCast(ArcaneMissiles) then
                Target:Cast(ArcaneMissiles);
                return;
            end
            -- Nether Tempest
            if NetherTempest:Exists() and module.IsOptionEnabled("Nether Tempest") and ArcaneCharges >= 4 and #TargetEnemies_10y >= module.GetOptionValue("Nether Tempest") and NetherTempest:TimeSinceCast() >= 10 and Target:CanCast(NetherTempest) then
                NetherTempest.LastCastTime = module.GetTime();
                Target:Cast(NetherTempest);
                return;
            end
            -- Arcane Barrage
            if ArcaneBarrage:Exists() and not ShouldEvocation and not Player:Buff(ArcanePower) and ArcaneCharges >= 4 and Player:PowerPercentage() < 90 and Target:CanCast(ArcaneBarrage) then
                Target:Cast(ArcaneBarrage);
                return;
            end
            -- Arcane Orb
            if ArcaneOrb:Exists() and module.IsOptionEnabled("Arcane Orb") and ArcaneOrbUnits >= module.GetOptionValue("Arcane Orb") and Player:CanCast(ArcaneOrb) then
                Player:Cast(ArcaneOrb);
                return;
            end
            -- Arcane Blast
            if ArcaneBlast:Exists() and Target:CanCast(ArcaneBlast) then
                Target:Cast(ArcaneBlast);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(ArcaneBlast, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        ShouldEvocation = nil;
        -- Arcane Familiar
        if ArcaneFamiliar:Exists() and (not Player:Buff(ArcaneFamiliarBuff) or 3600 - (module.GetTime() - select(3,GetTotemInfo(4))) < 60) and Player:CanCast(ArcaneFamiliar) then
            Player:Cast(ArcaneFamiliar);
            return;
        end
        -- Charged Up
        if ChargedUp:Exists() and module.IsOptionEnabled("Charged Up") and module.GetOptionValue("Charged Up") == "Always" and Player:ArcaneCharges() == 0 and Player:CanCast(ChargedUp) then
            Player:Cast(ChargedUp);
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Fire Mage
    local Rotation = {};
    module.SetRotation(63, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local Enemies, NumEnemies, LivingBombUnits, CombustionUnits, PyroblastUnits, DragonsBreathUnits = {}, 0, 0, 0, 0, 0;
    local CombustPhase, PyroChain, MeteorBuff = false, false, nil;
    local IncantersFlowDirection, PyroblastOpened = 0, false;
    local CinderstormEnemies = {};

    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicIntellect = Item(109218, false, false, true);
        DraenicIntellectBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);
        GiftOfTheNaaru = Spell(59548, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        BlastWave = Spell(157981, false, true, true);
        Cinderstorm = Spell(198929, false, false, false);
        Combustion = Spell(190319, false, false, true);
        Counterspell = Spell(2139, false, true, true);
        DragonsBreath = Spell(31661, true, false, true);
        Fireball = Spell(133, true, true, false);
        FireStarter = Spell(205026);
        FlameOn = Spell(205029, false, false, true);
        Flamestrike = Spell(2120, false, true, false);
        FlamestrikeInstant = Spell(2120, false, true, true);
        Invisibility = Spell(66, false, false, true);
        HeatingUp = Spell(48107, false, true, true);
        HotStreak = Spell(48108);
        IceBarrier = Spell(11426, false, false, true);
        IceBlock = Spell(45438, false, false, true);
        IceFloes = Spell(108839, false, false, true);
        IncantersFlow = Spell(1463, false, false, false);
        IncantersFlowBuff = Spell(116267, false, false, false);
        FireBlast = Spell(108853, true, true, true);
        Kindling = Spell(155148, false, true, true);
        LivingBomb = Spell(44457, false, true, true);
        Meteor = Spell(153561, false, true, true);
        MirrorImage = Spell(55342, false, false, true);
        PhoenixsFlames = Spell(194466, true, true, true);
        Pyroblast = Spell(11366, true, true, false);
        PyroblastInstant = Spell(11366, true, true, true);
        RuneOfPower = Spell(116011, false, false, false);
        RuneOfPowerBuff = Spell(116014, false, false, true);
        Scorch = Spell(2948, true, true, true);
        UnstableMagic = Spell(157976, false, false, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, { 4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest" }, { 2, "Disabled", "Enabled" }, "|cffFF0044Target (Left Box)|r \nAutomatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode. \n|cFF0088FFClosest:|r Target the closest enemy. \n|cFF0088FFLeast HP:|r Target the enemy with the least health remaining. \n|cFF0088FFMost HP:|r Target the enemy with the most health remaining. \n|cFF0088FFTarget Closest:|r Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining. \n\n|cffFF0044Attack (Right Box)|r \nUse /startattack when you changes target. Good for melee classes.");
        module.AddOption("General Settings", "Cooldowns Only On Bosses", false, "Only cast CD's on boss targets.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddOption("General Settings", "Ice Floes", true);
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Counterspell to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Mirror Image", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Mirror Image."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Rune Of Power", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Rune Of Power."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Combustion", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Combustion."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Blast Wave", 220, true, {1, 1, 10, 1}, nil, "Use Blast Wave."..C.TOOLTIP_VALUE.."Define minimum number of units that needs to be in 8 yards around our target to use Blast Wave.");
        module.AddNewOption("Offensive Settings", "Cinderstorm", 222, true, {1, 1, 10, 1}, {1, 1, 10, 1}, "Use Cinderstorm."..C.TOOLTIP_VALUE_1.."Define minimum number of units that needs to be in front of you for Cinderstorm."..C.TOOLTIP_VALUE_2.."Define minimum number of units that needs to be in front of you for Cinderstorm when at optimal range (between 27 and 29 yard).");
        module.AddNewOption("Offensive Settings", "Dragon's Breath", 220, true, {1, 1, 10, 1}, nil, "Use Dragon's Breath."..C.TOOLTIP_VALUE.."Define minimum number of units that needs to be in 10 yards in front of us to use Dragon's Breath.");
        module.AddNewOption("Offensive Settings", "Fire Starter Other Units", 210, true, {1, 1, 10, 1}, nil, "Use Fireball on other units above 90% Health."..C.TOOLTIP_HINT("Requires Fire Starter talent."));
        module.AddNewOption("Offensive Settings", "Flamestrike", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {8, 1, 25, 1}, "Use Flamestrike."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Target").."Always use on the current target."..C.TOOLTIP_SUBVALUE("Target Standing").."Always use on the current target. Target must be standing still."..C.TOOLTIP_SUBVALUE("Centered").."Use centered on a cluster of enemies."..C.TOOLTIP_SUBVALUE("Centered Standing").."Use centered on a cluster of enemies. Enemies must be standing still."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Flamestrike Hot Streak", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {5, 1, 25, 1}, "Use Flamestrike."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Target").."Always use on the current target."..C.TOOLTIP_SUBVALUE("Target Standing").."Always use on the current target. Target must be standing still."..C.TOOLTIP_SUBVALUE("Centered").."Use centered on a cluster of enemies."..C.TOOLTIP_SUBVALUE("Centered Standing").."Use centered on a cluster of enemies. Enemies must be standing still."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Fire Blast", 210, true, nil, nil, "Use Fire Blast.");
        module.AddNewOption("Offensive Settings", "Living Bomb", 222, false, { 1, 1, 10, 1 }, {3, 0, 25, 0.1}, "Use Living Bomb."..C.TOOLTIP_VALUE_1.."Amount of enemies that must be in the spell effect to use."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Meteor", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {2, 1, 25, 1}, "Use Meteor."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Target").."Always use on the current target."..C.TOOLTIP_SUBVALUE("Target Standing").."Always use on the current target. Target must be standing still."..C.TOOLTIP_SUBVALUE("Centered").."Use centered on a cluster of enemies."..C.TOOLTIP_SUBVALUE("Centered Standing").."Use centered on a cluster of enemies. Enemies must be standing still."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Phoenix's Flames", 222, true, {2, 1, 3, 1}, {1, 1, 10, 1}, "Use Phoenix's Flames."..C.TOOLTIP_VALUE_1.."How many charges should we keep for AoE."..C.TOOLTIP_VALUE_2.."Define minimum number of units that needs to be in 8 yards around our target to use Phoenix's Flames."..C.TOOLTIP_HINT("If set to 3, we will only use it when there are enough units around the target. Best if set to 2 as the ability will be constantly recharging. Phoenix's Flames will also be used as high priority within Combustion to quickly build Hot Streak."));

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {40, 1, 100, 1}, nil, "Use Gift Of The Naaru on self."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Ice Barrier", 220, true, {80, 1, 100, 1}, nil, "Use Ice Barrier."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Ice Block", 220, true, {30, 1, 100, 1}, nil, "Use Ice Block."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Invisibility", 220, true, {20, 1, 100, 1}, nil, "Use Invisibility."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- Incanters Flow Tracker
        local Frame = CreateFrame('Frame');
        Frame:RegisterEvent("PLAYER_DAMAGE_DONE_MODS");
        local function IncantersFlowTracker (self, ...)
            IncantersFlowBuffCount = Player:BuffCount(IncantersFlowBuff);
            --module.Bug("Incanter's Flow: "..IncantersFlowBuffCount);
            if IncantersFlowBuffCount == 1 then
                IncantersFlowDirection = 1;
            elseif IncantersFlowBuffCount == 5 then
                IncantersFlowDirection = 2;
            end
        end
        Frame:SetScript("OnEvent", IncantersFlowTracker);

        module.AddOutput("Target Distance:");
        module.SetOutput("Target Distance:", "No Target");
    end

    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Colored Distance Status
        if Target:Exists() then
            local PlayerDistance = math.floor(Player:DistanceTo(Target)*10)/10;
            local TargetReach = Target:CombatReach() and Target:CombatReach() > 0 and Target:CombatReach() or 1;
            local SuitedDistance = 41.25/TargetReach < 27 and 41.25/TargetReach or 27;
            local DistanceColor = PlayerDistance > SuitedDistance and PlayerDistance < 29 and "|cff00FF00" or "|cffFF0000";
            module.SetOutput("Target Distance:", DistanceColor .. PlayerDistance .. "|r");
        else
            module.SetOutput("Target Distance:", "No Target");
        end

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end
        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        -- 2) Potion
        if module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + Pyroblast:CastTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) and Player:IsWithinCastRange(Target, Pyroblast) then
            if Player:Potion("Intellect", Potion) then module.Bug("Pre-Pull - Intellect Potion"); Potion = true; end
        end
        -- 4) Cooldowns
        if PyroblastOpened then
            -- Mirror Images
            if MirrorImage:Exists() and module.IsOptionEnabled("Mirror Image") and (module.CooldownsAllowed() or module.GetOptionValue("Mirror Image") == "Always") and Player:CanCast(MirrorImage) then
                module.Bug("Mirror Image");
                RuneOfPower.LastCastTime = module.GetTime();
                Player:Cast(MirrorImage);
                return;
            end
            -- Rune Of Power
            if RuneOfPower:Exists() and module.IsOptionEnabled("Rune Of Power") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and Player:CanCast(RuneOfPower) then
                module.Bug("Rune of Power");
                RuneOfPower.LastCastTime = module.GetTime();
                Player:Cast(RuneOfPower);
                return;
            end
        end
        -- 3) Pyroblast
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + Pyroblast:CastTime() and Target:CanCast(Pyroblast) then
            PyroblastOpened = true;
            module.Bug("Pre-Pull - Pyroblast");
            Target:Cast(Pyroblast);
            return;
        end
        -- 1) Ice Barrier
        if BMPullTime() > module.GetSecondOptionValue("Pre-Pull BossMod") + 1.5 and BMPullTime() < 7 and BMPullTime() > 6 and not Player:Buff(IceBarrier) and Player:CanCast(IceBarrier) then
            module.Bug("Pre-Pull - Ice Barrier");
            Player:Cast(IceBarrier);
            return;
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Counterspell, ArcaneTorrent);
    end


    function Rotation:OffGCDAbilities ()
        -- Pyroblast whenever we have Hot Streak during combustion
        if (Player:Casting(Fireball) or Player:Casting(Scorch)) and Player:Buff(HotStreak) and Player:Buff(Combustion) then
            SpellStopCasting();
            Target:Cast(PyroblastInstant);
            PyroblastInstant.LastCastTime = module.GetTime();
            return;
        end

        -- if not heating up and rune of power and time in combat is less than 5 seconds
        if Combustion:Exists() and module.IsOptionEnabled("Combustion") and (module.CooldownsAllowed() or module.GetOptionValue("Combustion") == "Always") and CombatTime() < 5 and (Player:Buff(RuneOfPowerBuff) or RuneOfPower:TimeSinceCast() < 2) and not Player:Buff(HeatingUp) and Player:CanCast(Combustion) then
            -- Cast Scorch
            if Scorch:Exists() and Target:CanCast(Scorch) then
                module.Bug("Scorch to get Heating Up");
                Target:Cast(Scorch);
                return;
            end
            -- Cast Combustion when Scorch is almost over
            if Combustion:Exists() and Player:Casting(Scorch) and Player:CastedPercent() >= 25 then
                module.Bug("Combutstion Scorch to get Heating Up");
                Player:Cast(Combustion);
            end
        end

        if not Player:Buff(Combustion) then
            -- Flame On - If no Fire Blast charges left
            if FlameOn:Exists() and FireBlast:Charges() == 0 and FireBlast:Recharge() >= 3 and Combustion:Cooldown() > 30 and Player:CanCast(FlameOn) then
                module.Bug("Flame On - Without Combustion.");
                Player:Cast(FlameOn);
                return;
            end
            -- FireBlast - If we are casting Fireball and we have Heating Up
            if FireBlast:Exists() and (Player:Casting(Fireball) or Player:Casting(Scorch))
                and ((Player:Buff(HeatingUp) and Player:CastedPercent() >= 75 and Player:CastedPercent() < 92) or CombatTime() < 1)
                and FireBlast:TimeSinceCast() > 1
                and (Combustion:Cooldown() > 25 or ((FireBlast:Charges() >= 1 and FireBlast:Recharge() < 1.5) or FireBlast:Charges() >= 2)) and Target:CanCast(FireBlast) then
                module.Bug("Fire Blast - Without Combustion.");
                Target:Cast(FireBlast);
                FireBlast.LastCastTime = module.GetTime();
                return;
            end
        else
            -- Flame On - If no Fire Blast charges left
            if FlameOn:Exists() and FireBlast:Charges() == 0 and Player:CanCast(FlameOn) then
                module.Bug("Flame On - With Combustion.");
                Player:Cast(FlameOn);
                return;
            end
            -- FireBlast - If we are casting Fireball and we have Heating Up
            if FireBlast:Exists() and Player:Buff(HeatingUp) and FireBlast:TimeSinceCast() > 0.5 and Target:CanCast(FireBlast) then
                module.Bug("Fire Blast - With Combustion.");
                Target:Cast(FireBlast);
                FireBlast.LastCastTime = module.GetTime();
                return;
            end
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Ice Block
        if IceBlock:Exists() and module.IsOptionEnabled("Ice Block") and Player:HealthPercentage() <= module.GetOptionValue("Ice Block") and not Player:Buff(Invisibility) and Player:CanCast(IceBlock) then
            SpellStopCasting();
            Player:Cast(IceBlock);
            return;
        end
        -- Ice Barrier
        if IceBarrier:Exists() and module.IsOptionEnabled("Ice Barrier") and Player:HealthPercentage() <= module.GetOptionValue("Ice Barrier") and not Player:Buff(IceBarrier) and Player:CanCast(IceBarrier) then
            Player:Cast(IceBarrier);
            return;
        end
        -- Greater Invisibility
        if Invisibility:Exists() and module.IsOptionEnabled("Invisibility") and Player:HealthPercentage() <= module.GetOptionValue("Invisibility") and not Player:Buff(IceBlock) and Player:CanCast(Invisibility) then
            SpellStopCasting();
            Player:Cast(Invisibility);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    function Rotation:Combat ()
        if Target:Exists() and Player:CanAttack(Target) then
            -- Ice floes if moving
            if module.IsOptionEnabled("Ice Floes") and IceFloes:Exists() and Player:IsMoving() and not Player:Buff(IceFloes) and Player:CanCast(IceFloes) and IceFloes:TimeSinceCast() > 1 then
                Player:Cast(IceFloes);
                IceFloes.LastCastTime = module.GetTime();
            end

            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                Enemies = FireStarter:Exists() and Player:EnemiesWithinDistance(40) or {}; -- 40 yards for Fire Starter.
                DragonsBreathUnits = #Player:UnitsInFrontCone(10, 140); -- Frontal Cone.
                CinderstormEnemies = #Player:UnitsInFrontRectangle(32, 5); -- Cinderstorm
                Enemies_10y = Target:EnemiesWithinDistance(10); -- 10 yards for Fire Blast.
                Enemies_8y = Target:FilterEnemiesByDistance(Enemies_10y, 8, true); -- Using 8 yards (real range) for Blast Wave.
                NumEnemies = #Enemies_10y;
                BlastWaveEnemies = #Enemies_8y;
                RefreshEnemies = module.GetTime() + 0.25;
            end
            -- Cooldowns
            if Player:IsWithinCastRange(Target, Fireball) and (Player:Moving() == 0 or RuneOfPower:Exists()) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Rune Of Power
                if RuneOfPower:Exists() and module.IsOptionEnabled("Rune Of Power") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and Player:Buff(HotStreak) and (RuneOfPower:Charges() >= 2 or (RuneOfPower:Charges() >= 1 and RuneOfPower:Recharge() < 10 and Combustion:Cooldown() > 12) or Combustion:Cooldown() < RuneOfPower:CastTime()) and RuneOfPower:TimeSinceCast() > 2 and Player:CanCast(RuneOfPower) and not Player:Buff(RuneOfPowerBuff) then
                    Player:Cast(RuneOfPower);
                    RuneOfPower.LastCastTime = module.GetTime();
                    return;
                end
                -- Mirror Images
                if MirrorImage:Exists() and module.IsOptionEnabled("Mirror Image") and (module.CooldownsAllowed() or module.GetOptionValue("Mirror Image") == "Always") and Player:Buff(HotStreak) and Combustion:Cooldown() < 2 and Player:CanCast(MirrorImage) then
                    Player:Cast(MirrorImage);
                    return;
                end
                -- Combustion
                if Combustion:Exists() and module.IsOptionEnabled("Combustion") and (module.CooldownsAllowed() or module.GetOptionValue("Combustion") == "Always") and Player:Buff(HotStreak) and Player:CanCast(Combustion) then
                    Player:Cast(Combustion);
                    return;
                end
            end

            -- Rotation
            -- Flamestrike - Hot Streak
            if FlamestrikeInstant:Exists() and Player:Buff(HotStreak) and module.IsOptionEnabled("Flamestrike Hot Streak") and Target:CanCast(FlamestrikeInstant) then
                if Target:CastGroundSpell(FlamestrikeInstant, "Flamestrike Hot Streak", 8) then return; end
            end
            -- Pyroblast - Hot Streak
            if PyroblastInstant:Exists() and Player:Buff(HotStreak) and ((PyroblastInstant:TimeSinceCast() > 2 and not PyroblastInstant:WasLastCast()) or Player:Buff(Combustion)) and Target:CanCast(PyroblastInstant) then
                Target:Cast(PyroblastInstant);
                PyroblastInstant.LastCastTime = module.GetTime();
                return;
            end
            -- Meteor
            if Meteor:Exists() and module.IsOptionEnabled("Meteor") and Target:CanCast(Meteor) then
                if Target:CastGroundSpell(Meteor, "Meteor", 8) then return; end
            end

            -- Wait for Pyro proc during combustion
            if PyroblastInstant:TimeSinceCast() < 1.25 and Player:Buff(Combustion) and FireBlast:Charges() >= 1 then return; end
            if Player:Buff(HeatingUp) and Player:Buff(Combustion) and FireBlast:Charges() >= 1 then return; end

            -- Phoenix Flames - Combustion
            if PhoenixsFlames:Exists() and module.IsOptionEnabled("Phoenix's Flames") and Player:Buff(Combustion) and Target:CanCast(PhoenixsFlames) then
                Target:Cast(PhoenixsFlames);
                return;
            end
            -- Scorch - Combustion
            if Scorch:Exists() and Player:BuffRemains(Combustion) > Scorch:CastTime() + Player:GCD() and Target:CanCast(Scorch, true) then
                Target:Cast(Scorch);
                return;
            end
            -- Fireball to get Heating Up
            if Fireball:Exists() and Player:Buff(Combustion) and not Player:IsMoving() and Target:CanCast(Fireball) then
                Target:Cast(Fireball);
                return;
            end

            -- Cinderstorm
            if Cinderstorm:Exists() and module.IsOptionEnabled("Cinderstorm") then
                local TargetReach = Target:CombatReach() and Target:CombatReach() > 0 and Target:CombatReach() or 1;
                local SuitedDistance = 41.25/TargetReach < 27 and 41.25/TargetReach or 27;
                if (Player:DistanceTo(Target) > SuitedDistance and Player:DistanceTo(Target) < 29) and CinderstormEnemies >= module.GetSecondOptionValue("Cinderstorm") and Player:CanCast(Cinderstorm) then
                    module.Bug("Cinderstorm - High Priority");
                    Player:Cast(Cinderstorm);
                    return;
                end
            end
            -- Living Bomb - With Units Count
            if LivingBomb:Exists() and module.IsOptionEnabled("Living Bomb") and #Enemies_10y >= module.GetOptionValue("Living Bomb") and Target:Health() >= module.GetSecondOptionValue("Living Bomb")*1000000 and Target:CanCast(LivingBomb) then
                Target:Cast(LivingBomb);
                return;
            end
            -- Blast Wave
            if BlastWave:Exists() and module.IsOptionEnabled("Blast Wave") and #Enemies_8y >= module.GetOptionValue("Blast Wave") and Target:CanCast(BlastWave) then
                Target:Cast(BlastWave);
                return;
            end
            -- Dragon's Breath
            if DragonsBreath:Exists() and module.IsOptionEnabled("Dragon's Breath") and DragonsBreathUnits >= module.GetOptionValue("Dragon's Breath") and Player:CanCast(DragonsBreath) then
                Player:Cast(DragonsBreath);
                return;
            end
            -- Flamestrike
            if Flamestrike:Exists() and module.IsOptionEnabled("Flamestrike") and Target:CanCast(Flamestrike) then
                if Target:CastGroundSpell(Flamestrike, "Flamestrike", 8) then return; end
            end
            -- Fire Starter Fireball Tweak
            if FireStarter:Exists() and module.IsOptionEnabled("Fire Starter Other Units") then
                -- Fireball on other target above 90% Health if our target is under 90%
                local BestFireballUnit = Target:HealthPercentage() < 90 and Unit.LightEnemyAvailableForSpellHP(Enemies, Fireball, 90, true) or nil;
                if BestFireballUnit and BestFireballUnit:CanCast(Fireball) then
                    module.Bug("Fireball Other Unit - With Fire Starter");
                    BestFireballUnit:Cast(Fireball);
                    return;
                end
            end
            -- Phoenix Flames
            if PhoenixsFlames:Exists() and module.IsOptionEnabled("Phoenix's Flames") and (PhoenixsFlames:Charges() >= module.GetOptionValue("Phoenix's Flames") or (PhoenixsFlames:Charges() >= module.GetOptionValue("Phoenix's Flames") and PhoenixsFlames:Recharge() < 3)) and #Enemies_8y >= module.GetSecondOptionValue("Phoenix's Flames") and not Player:Buff(HotStreak) and Target:CanCast(PhoenixsFlames) then
                Target:Cast(PhoenixsFlames);
                return;
            end
            -- Cinderstorm
            if Cinderstorm:Exists() and module.IsOptionEnabled("Cinderstorm") and CinderstormEnemies >= module.GetOptionValue("Cinderstorm") and Player:CanCast(Cinderstorm) then
                module.Bug("Cinderstorm - Low Priority");
                Player:Cast(Cinderstorm);
                return;
            end
            -- Fireball to get Heating Up
            if Fireball:Exists() and not Player:IsMoving() and Target:CanCast(Fireball) then
                Target:Cast(Fireball);
                return;
            end
            -- Scorch if we are moving
            if Scorch:Exists() and Target:CanCast(Scorch, true) then
                Target:Cast(Scorch);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Fireball, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        PyroblastOpened = false;
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Frost Mage
    local Rotation = {};
    module.SetRotation(64, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local FrozenOrbCount, TargetEnemies_10y, TargetEnemies_8y, TargetEnemies_4y = 0, {}, {}, {}; -- Units

    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicIntellect = Item(109218, false, false, true);
        DraenicIntellectBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);
        GiftOfTheNaaru = Spell(59548, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        ArcticGale = Spell(205038);
        Blizzard = Spell(190356, false, true, false);
        BoneChilling = Spell(205027);
        BoneChillingBuff = Spell(205766);
        BrainFreeze = Spell(190446);
        ChainReaction = Spell(195418);
        ColdSnap = Spell(11958, false, false, true);
        CometStorm = Spell(153595, true, true, true);
        ConeOfCold = Spell(120, false, false, true);
        Counterspell = Spell(2139, false, true, true);
        Ebonbolt = Spell(214634, true, true, false);
        FingersOfFrost = Spell(44544);
        Flurry = Spell(44614, true, true, false);
        FlurryInstant = Spell(44614, true, true, true);
        Freeze = Spell(33395, false, true, true);
        Frostbolt = Spell(116, true, true, true);
        FrostBomb = Spell(112948, true, true, false);
        FrozenOrb = Spell(84714, false, false, true);
        FrozenTouch = Spell(205030, false, false, true);
        GlacialSpike = Spell(199786, true, true, false);
        IceBarrier = Spell(11426, false, false, true);
        IceBlock = Spell(45438, false, false, true);
        IceFloes = Spell(108839, false, false, true);
        IceLance = Spell(30455, true, true, true);
        IceNova = Spell(157997, true, true, true);
        Icicles = Spell(205473);
        IcyVeins = Spell(12472, false, false, true);
        Invisibility = Spell(66, false, false, true);
        InvisibilityBuff = Spell(32612);
        LonelyWinter = Spell(205024);
        MirrorImage = Spell(55342, false, false, true);
        Polymorph = Spell(118, false, true, false);
        RayOfFrost = Spell(205021, true, true, false);
        RuneOfPower = Spell(116011, false, false, false);
        RuneOfPowerBuff = Spell(116014);
        SpellSteal = Spell(30449, true, true, true);
        SummonWaterElemental = Spell(31687, false, false, false);
        ThermalVoid = Spell(155149);
        Waterbolt = Spell(31707, true, true, true);
        WaterJet = Spell(135029, true, true, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {1, "Disabled", "Enabled"}, "|cffFF0044Target (Left Box)|r \nAutomatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode. \n|cFF0088FFClosest:|r Target the closest enemy. \n|cFF0088FFLeast HP:|r Target the enemy with the least health remaining. \n|cFF0088FFMost HP:|r Target the enemy with the most health remaining. \n|cFF0088FFTarget Closest:|r Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining. \n\n|cffFF0044Attack (Right Box)|r \nUse /startattack when you changes target. Good for melee classes.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Ice Floes", 210, true, nil, nil, "");
        module.AddSection("General Settings", "Pet Options", "Green");
        module.AddNewOption("General Settings", "Auto Summon Elemental", 220, true, {3, 1, 25, 0.5}, nil, "Automatically Summon your Pet."..C.TOOLTIP_VALUE_1.."How long would you like to wait before using Summon when your Elemental is dismissed.");
        module.AddNewOption("General Settings", "Freeze", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {2, 1, 5, 1}, "Use Freeze." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use."..C.TOOLTIP_HINT("This ability uses the same cooldown as Water Jet. It should only be used for dungeons or questing.")..C.TOOLTIP_HINT("Pet Damage Handling must be checked."));
        module.AddNewOption("General Settings", "Pet Damage Handling", 233, true, {1, "Handle Assist", "Do Not Handle Assist"}, {1, "Handle Spells", "Do Not Handle Spells"}, "Manage Pet Casts."..C.TOOLTIP_VALUE_1.."Enable this to automatically change between assist and passive mode depending if you have a target or not."..C.TOOLTIP_VALUE_2.."Enable this to automatically disable spells the profile should be handling so that they are handled by the rotation."..C.TOOLTIP_HINT("Spells handling applies to Waterbolt(Enable Auto) and Water Jet(Disable Auto)."));
        module.AddNewOption("General Settings", "Water Jet", 210, false, nil, {1, 1, 10, 1}, "Use Water Jet while we are casting Frostbolt to get Fingers Of Frost buffs."..C.TOOLTIP_HINT("Pet Damage Handling must be checked."));
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Counterspell to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Icy Veins", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Icy Veins."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Frozen Touch", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Frozen Touch."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Mirror Image", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Mirror Image."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Rune Of Power", 233, true, {2, "Always", "Cooldown Only"}, {2, "Anytime", "Before Icy Veins"}, "Use Rune Of Power."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Anytime", true).."Use Rune Of Power whenever it is ready."..C.TOOLTIP_SUBVALUE("Before Icy Veins", true).."Save one charge for Icy Veins.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Blizzard", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {3, 1, 10, 1}, "Use Blizzard." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use."..C.TOOLTIP_HINT("Also used for Defile."));
        module.AddNewOption("Offensive Settings", "Comet Storm", 220, true, {1, 1, 10, 1}, nil, "Use Comet Storm."..C.TOOLTIP_VALUE.."Amount of units that needs to be within 4 yards of the target to use.");
        module.AddNewOption("Offensive Settings", "Frost Bomb", 220, true, {3, 1, 10, 1}, nil, "Use Frost Bomb."..C.TOOLTIP_VALUE.."Amount of units that needs to be within 10 yards of the target to use.");
        module.AddNewOption("Offensive Settings", "Frozen Orb", 220, true, {1, 1, 10, 1}, nil, "Use Frozen Orb."..C.TOOLTIP_VALUE.."Amount of units that needs to be in 40y corridor in front of us to use.");
        module.AddNewOption("Offensive Settings", "Ice Nova", 220, true, {3, 1, 10, 1}, nil, "Use Ice Nova."..C.TOOLTIP_VALUE.."Amount of units that needs to be within 8 yards of the target to use.");
        module.AddNewOption("Offensive Settings", "Ray Of Frost", 210, true, nil, nil, "Use Ray Of Frost.");


        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {40, 1, 100, 1}, nil, "Use Gift Of The Naaru on self."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Invisibility", 220, true, {20, 1, 100, 1}, nil, "Use Greater Invisibility."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Ice Barrier", 220, true, {80, 1, 100, 1}, nil, "Use Ice Barrier."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Ice Block", 220, true, {30, 1, 100, 1}, nil, "Use Ice Block."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- Incanters Flow Tracker
        IncantersFlow = Spell(1463, false, false, false);
        IncantersFlowBuff = Spell(116267);
        IncantersFlowDirection = 0;
        local Frame = CreateFrame('Frame');
        Frame:RegisterEvent("PLAYER_DAMAGE_DONE_MODS");
        local function IncantersFlowTracker (self, ...)
            IncantersFlowBuffCount = Player:BuffCount(IncantersFlowBuff);
            --module.Bug("Incanter's Flow: "..IncantersFlowBuffCount);
            if IncantersFlowBuffCount == 1 then
                IncantersFlowDirection = 1;
            elseif IncantersFlowBuffCount == 5 then
                IncantersFlowDirection = 2;
            end
        end
        Frame:SetScript("OnEvent", IncantersFlowTracker);

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [Blizzard:ID()] = "Blizzard",
            [FrostBomb:ID()] = "Frost Bomb",
            [GlacialSpike:ID()] = "Glacial Spike"
        };
    end

    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Channeling(RayOfFrost) then
            return;
        end

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end
        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and not Player:Casting(Frostbolt) and not Player:Casting(Ebonbolt) then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        -- Potion
        if module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + Frostbolt:CastTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) and Player:IsWithinCastRange(Target, Frostbolt) then
            if Player:Potion("Intellect", Potion) then module.Bug("Pre-Pull - Intellect Potion"); Potion = true; end
        end
        -- Mirror Images
        if MirrorImage:Exists() and BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + Frostbolt:CastTime() + Player:GCD() and module.IsOptionEnabled("Mirror Image") and (module.CooldownsAllowed() or module.GetOptionValue("Mirror Image") == "Always") and Player:CanCast(MirrorImage) then
            module.Bug("Mirror Image");
            Player:Cast(MirrorImage);
            return;
        end
        -- Rune Of Power
        if RuneOfPower:Exists() and BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + Frostbolt:CastTime() + RuneOfPower:CastTime() and module.IsOptionEnabled("Rune Of Power") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and Player:CanCast(RuneOfPower) then
            module.Bug("Rune of Power");
            Player:Cast(RuneOfPower);
            return;
        end
        -- WaterBolt
        if PlayerPet:Exists() and BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + WaterBolt:CastTime() and Target:PetCanCast(Waterbolt) then
            Target:Cast(Waterbolt);
            return;
        end
        -- Ebonbolt
        if Ebonbolt:Exists() and BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + Ebonbolt:CastTime() and Target:CanCast(Ebonbolt) and not Player:Casting(Ebonbolt) then
            module.Bug("Pre-Pull - Ebonbolt");
            Target:Cast(Ebonbolt);
            return;
        end
        -- Frostbolt
        if Frostbolt:Exists() and BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + Frostbolt:CastTime() and Target:CanCast(Frostbolt) and not Player:Casting(Frostbolt) then
            module.Bug("Pre-Pull - Frostbolt");
            Target:Cast(Frostbolt);
            return;
        end
        -- Ice Barrier
        if IceBarrier:Exists() and BMPullTime() > module.GetSecondOptionValue("Pre-Pull BossMod") + 3 and BMPullTime() < 5 and not Player:Buff(IceBarrier) and Player:CanCast(IceBarrier) then
            module.Bug("Pre-Pull - Ice Barrier");
            Player:Cast(IceBarrier);
            return;
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Counterspell, ArcaneTorrent);
    end


    -- Handling of Pet Actionbar Abilities
    local PetActionName, IsPetActionActive, PetActionID; -- Used to store GetPetActionInfo Data
    local WaterboltPosition, WaterJetPosition, ShouldFindAbilities = 5, 6, false; -- Used to prevent Cycling to find abilities when we can avoid it
    local function PlayerPetHandling ()
        if PlayerPet:Exists() then
            if module.IsOptionEnabled("Pet Damage Handling") then
                if module.GetSecondOptionValue("Pet Damage Handling") == "Handle Spells" then
                    -- Enable Waterbolt
                    PetActionName, _, _, _, _, _, IsPetActionActive, PetActionID = GetPetActionInfo(WaterboltPosition)
                    if PetActionID == 31707 and not IsPetActionActive then
                        EnableSpellAutocast(PetActionName);
                    else
                        ShouldFindAbilities = true;
                    end
                    -- Disable WaterJet
                    PetActionName, _, _, _, _, _, IsPetActionActive, PetActionID = GetPetActionInfo(WaterJetPosition)
                    if PetActionID == 135029 and IsPetActionActive then
                        DisableSpellAutocast(PetActionName);
                    else
                        ShouldFindAbilities = true;
                    end
                    -- If positions were not found, try to find these and store them
                    if ShouldFindAbilities == true then
                        for i = 1, 10 do
                            PetActionName, _, _, _, _, _, IsPetActionActive, PetActionID = GetPetActionInfo(i);
                            if PetActionID == 31707 and not IsPetActionActive then
                                WaterboltPosition = i;
                                EnableSpellAutocast(PetActionName);
                            end
                            if PetActionID == 135029 and IsPetActionActive then
                                WaterJetPosition = i;
                                DisableSpellAutocast(PetActionName);
                            end
                        end
                        ShouldFindAbilities = false;
                    end
                end
                -- Assist/Passive Mode
                if module.GetOptionValue("Pet Damage Handling") == "Handle Assist" then
                    if Target:Exists() and Player:CanAttack(Target) and not IsPetAttackActive() then
                        -- Enable Assist
                        PetAssistMode();
                    elseif (not Target:Exists() or not Player:CanAttack(Target)) and IsPetAttackActive() then
                        PetPassiveMode();
                    end
                end
                -- Profile Handled Abilities
                if Player:BuffCount(FingersOfFrost) < 2 then
                    -- Freeze
                    if module.IsOptionEnabled("Freeze") and Target:PetCanCast(Freeze) then
                        if Target:CastGroundSpell(Freeze, "Freeze", 10) then return; end
                    end
                    -- Water Jet
                    if module.IsOptionEnabled("Water Jet") and Target:PetCanCast(WaterJet) and Frostbolt:TimeSinceCast() > 1 and Frostbolt:TimeSinceCast() < 1.5 then
                        Target:Cast(WaterJet);
                    end
                end
            else
                -- Enable Waterbolt
                PetActionName, _, _, _, _, _, IsPetActionActive, PetActionID = GetPetActionInfo(WaterboltPosition)
                if PetActionID == 31707 and not IsPetActionActive then
                    EnableSpellAutocast(PetActionName);
                else
                    ShouldFindAbilities = true;
                end
                -- Enable WaterJet
                PetActionName, _, _, _, _, _, IsPetActionActive, PetActionID = GetPetActionInfo(WaterJetPosition)
                if PetActionID == 135029 and not IsPetActionActive then
                    EnableSpellAutocast(PetActionName);
                else
                    ShouldFindAbilities = true;
                end
                -- If positions were not found, try to find these and store them
                if ShouldFindAbilities == true then
                    for i = 1, 10 do
                        PetActionName, _, _, _, _, _, IsPetActionActive, PetActionID = GetPetActionInfo(i);
                        if PetActionID == 31707 and not IsPetActionActive then
                            WaterboltPosition = i;
                            EnableSpellAutocast(PetActionName);
                        end
                        if PetActionID == 135029 and not IsPetActionActive then
                            WaterJetPosition = i;
                            EnableSpellAutocast(PetActionName);
                        end
                    end
                    ShouldFindAbilities = false;
                end
            end
        end
    end

    function Rotation:OffGCDAbilities ()
        PlayerPetHandling();
        -- Ice floes if moving
        if module.IsOptionEnabled("Ice Floes") and IceFloes:Exists() and Player:IsMoving() and not Player:Buff(IceFloes) and Player:CanCast(IceFloes) and IceFloes:TimeSinceCast() > 1 then
            Player:Cast(IceFloes);
            IceFloes.LastCastTime = module.GetTime();
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Ice Block
        if IceBlock:Exists() and module.IsOptionEnabled("Ice Block") and Player:HealthPercentage() <= module.GetOptionValue("Ice Block") and not Player:Buff(IceBlock) and not Player:Buff(InvisibilityBuff) and not Player:Buff(Invisibility) and Player:CanCast(IceBlock) then
            SpellStopCasting();
            Player:Cast(IceBlock);
            return;
        end
        -- Ice Barrier
        if IceBarrier:Exists() and module.IsOptionEnabled("Ice Barrier") and Player:HealthPercentage() <= module.GetOptionValue("Ice Barrier") and not Player:Buff(IceBarrier) and Player:CanCast(IceBarrier) then
            Player:Cast(IceBarrier);
            return;
        end
        -- Greater Invisibility
        if Invisibility:Exists() and module.IsOptionEnabled("Invisibility") and Player:HealthPercentage() <= module.GetOptionValue("Invisibility") and not Player:Buff(IceBlock) and Player:CanCast(Invisibility) then
            SpellStopCasting();
            Player:Cast(Invisibility);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    -- Frost Bolt + Ice Floes Handling
    local function FrostboltHandler ()
        if IceFloes:Exists() and Player:IsMoving() and not Player:Buff(IceFloes) and Player:CanCast(IceFloes) then
            Player:Cast(IceFloes);
            return;
        end
        if (not Player:IsMoving() or Player:Buff(IceFloes)) and Target:CanCast(Frostbolt) then
            Frostbolt.LastCastTime = module.GetTime();
            Target:Cast(Frostbolt);
            return;
        end
    end

    -- Frost Bomb
    local function FrostBombHandler ()
        if FrostBomb:Exists() and module.IsOptionEnabled("Frost Bomb") and #TargetEnemies_10y >= module.GetOptionValue("Frost Bomb") and not Target:Debuff(FrostBomb) and Target:CanCast(FrostBomb) then
            Target:Cast(FrostBomb);
            return;
        end
    end

    -- Pet Manager
    local function ManagePet ()
        if module.IsOptionEnabled("Auto Summon Elemental") and not LonelyWinter:Exists() and not PlayerPet:Exists() and module.PetDismissed + module.GetOptionValue("Auto Summon Elemental") < module.GetTime() and Player:CanCast(SummonWaterElemental) then
            Player:Cast(SummonWaterElemental);
            return;
        end
    end

    function Rotation:Combat ()
        ManagePet();
        if Target:Exists() and Player:CanAttack(Target) then

            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                FrozenOrbCount = FrozenOrb:Exists() and #Player:UnitsInFrontRectangle(40, 5) or 0; -- 40 Yards Corridor for Frozen Orb
                TargetEnemies_10y = Target:EnemiesWithinDistance(10, false); -- Frost Bomb
                TargetEnemies_8y = Target:FilterEnemiesByDistance(TargetEnemies_10y, 8, false); -- Ice Nova
                TargetEnemies_4y = Target:FilterEnemiesByDistance(TargetEnemies_8y, 4, false); -- Comet Storm
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, Frostbolt) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Icy Veins Handling
                IcyVeinsSoon = IcyVeins:Exists() and module.IsOptionEnabled("Icy Veins") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and Player:Standing() > 1 and IcyVeins:IsOnCooldown() and IcyVeins:Cooldown() < 30;
                ShouldRayOfFrost = RayOfFrost:Exists() and module.IsOptionEnabled("Ray Of Frost") and not IcyVeinsSoon and Player:Standing() >= 1 and Target:CanCast(RayOfFrost);
                ShouldIcyVeins = IcyVeins:Exists() and module.IsOptionEnabled("Icy Veins") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and Player:Standing() > 1 and (not RayOfFrost:Exists() or not module.IsOptionEnabled("Ray Of Frost") or ShouldRayOfFrost) and Player:CanCast(IcyVeins);
                -- Rune Of Power - Anytime
                if RuneOfPower:Exists() and module.IsOptionEnabled("Rune Of Power") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and RuneOfPower:TimeSinceCast() >= 5 and not Player:Buff(RuneOfPowerBuff) and Player:Standing() >= 1 and Player:CanCast(RuneOfPower) then
                    if RuneOfPower:Charges() == 2 or ShouldRayOfFrost or ShouldIcyVeins or module.GetSecondOptionValue("Rune Of Power") == "Anytime" then
                        Player:Cast(RuneOfPower);
                        RuneOfPower.LastCastTime = module.GetTime();
                        return;
                    end
                end
                -- Icy Veins
                if ShouldIcyVeins then
                    Player:Cast(IcyVeins);
                    return;
                end
                -- Mirror Images
                if MirrorImage:Exists() and module.IsOptionEnabled("Mirror Image") and (module.CooldownsAllowed() or module.GetOptionValue("Mirror Image") == "Always") and Player:CanCast(MirrorImage) then
                    Player:Cast(MirrorImage);
                    return;
                end
            end
            -- Rotation
            -- Thermal Void - Ice Lances
            if ThermalVoid:Exists() and Player:Buff(IcyVeins) and Player:BuffRemains(IcyVeins) < 5 and Player:Buff(FingersOfFrost) and Target:CanCast(IceLance) then
                Target:Cast(IceLance);
                return;
            end
            -- Frostbolt - With Water Jet
            if Frostbolt:Exists() and module.WaterJetChanneling > module.GetTime() + Frostbolt:CastTime() and Player:BuffCount(FingersOfFrost) < 3 and Target:CanCast(Frostbolt) then
                FrostboltHandler();
            end
            -- GlacialSpike
            if GlacialSpike:Exists() and Target:CanCast(GlacialSpike) then
                Target:Cast(GlacialSpike);
                return;
            end
            -- Comet Storm
            if CometStorm:Exists() and module.IsOptionEnabled("Comet Storm") and #TargetEnemies_4y >= module.GetOptionValue("Comet Storm") and Target:CanCast(CometStorm) then
                Target:Cast(CometStorm);
                return;
            end
            -- Ice Nova
            if IceNova:Exists() and module.IsOptionEnabled("Ice Nova") and #TargetEnemies_8y >= module.GetOptionValue("Ice Nova") and Target:CanCast(IceNova) then
                Target:Cast(IceNova);
                return;
            end
            -- Frozen Orb
            if FrozenOrb:Exists() and FrozenOrbCount >= module.GetOptionValue("Frozen Orb") and Player:CanCast(FrozenOrb) then
                Player:Cast(FrozenOrb);
                return;
            end
            -- Blizzard - Arctic Gale
            if ArcticGale:Exists() and Blizzard:Exists() and module.IsOptionEnabled("Blizzard") and Target:CanCast(Blizzard) then
                if Target:CastGroundSpell(Blizzard, "Blizzard", 12) then return; end
            end
            -- Frostbolt - Bone Chilling
            if BoneChilling:Exists() and Player:Buff(BoneChillingBuff) and Player:BuffRemains(BoneChillingBuff) < 4 and Target:CanCast(Frostbolt) then
                FrostboltHandler();
            end
            -- Ice Lance
            if IceLance:Exists() and Player:Buff(FingersOfFrost) and (Player:Buff(ChainReaction) or Player:BuffCount(FingersOfFrost) > 2 or Player:BuffRemains(FingersOfFrost) < 5) and Target:CanCast(IceLance) then
                FrostBombHandler();
                Target:Cast(IceLance);
                return;
            end
            -- Ice Lance - Before Water Jet
            if IceLance:Exists() and PlayerPet:Exists() and Player:BuffCount(FingersOfFrost) >= 1 and ((PlayerPet:Exists() and WaterJet:Cooldown() < 3) or (RayOfFrost:Exists() and RayOfFrost:Cooldown() < 3) or (FrozenOrbCount >= module.GetOptionValue("Frozen Orb") and FrozenOrb:Cooldown() < 3) or Ebonbolt:Cooldown() < 3) and Target:CanCast(IceLance) then
                FrostBombHandler();
                Target:Cast(IceLance);
                return;
            end
            -- Flurry
            if Flurry:Exists() and Player:Buff(BrainFreeze) and Target:CanCast(FlurryInstant) then
                Target:Cast(FlurryInstant);
                return;
            end
            -- Ebonbolt
            if Ebonbolt:Exists() and Target:CanCast(Ebonbolt) then
                Target:Cast(Ebonbolt);
                return;
            end
            -- Frozen Touch
            if Player:IsWithinCastRange(Target, Frostbolt) and FrozenTouch:Exists() and module.IsOptionEnabled("Frozen Touch") and (module.CooldownsAllowed() or module.GetOptionValue("Frozen Touch") == "Always") and Player:BuffCount(FingersOfFrost) <= 1 and Player:CanCast(FrozenTouch) then
                Player:Cast(FrozenTouch);
                return;
            end
            -- Ray Of Frost
            if not Player:IsMoving() and ShouldRayOfFrost then
                Target:Cast(RayOfFrost);
                return;
            end
            -- Blizzard
            if Blizzard:Exists() and module.IsOptionEnabled("Blizzard") and Target:CanCast(Blizzard) then
                if Target:CastGroundSpell(Blizzard, "Blizzard", 10) then return; end
            end
            -- Frostbolt
            if Frostbolt:Exists() and Target:CanCast(Frostbolt) then
                FrostboltHandler();
            end
            -- Ice Lance Filler
            if IceLance:Exists() and Target:CanCast(IceLance) then
                FrostBombHandler();
                Target:Cast(IceLance);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Frostbolt, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        ManagePet();
        PlayerPetHandling();
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Brewmaster Monk
    local Rotation = {};
    module.SetRotation(268, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local Enemies_30y, Enemies_8y, BreathOfFireUnits, ChiBurstUnits, NumEnemies = {}, {}, 0, 0, 0; -- Enemies

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        --Racials
        ArcaneTorrent = Spell(69179, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, resurrect)
        BlackoutCombo = Spell(196736);
        BlackoutComboBuff = Spell(228563);
        BlackoutStrike = Spell(205523, true, true, true);
        BlackOxBrew = Spell(115399, false, false, true);
        BreathOfFire = Spell(115181, false, false, true);
        ChiBurst = Spell(123986, false, false, true);
        ChiWave = Spell(115098, true, true, true);
        CracklingJadeLightning = Spell(117952, true, true, false);
        DampenHarm = Spell(122278, false, false, true);
        Detox = Spell(218164, false, false, true);
        DiffuseMagic = Spell(122783, false, false, true);
        Effuse = Spell(116694, false, false, false);
        FlamingKeg = Spell(214326, false, true, true);
        FortifyingBrew = Spell(115203, false, false, true);
        InvokeNiuzao = Spell(132578, true, true, true);
        IronskinBrew = Spell(115308, false, false, true);
        HealingElixir = Spell(122281, false, false, true);
        KegSmash = Spell(121253, true, true, true);
        LightBrewing = Spell(196721, false, false, true);
        Paralysis = Spell(115078, false, true, true);
        Provoke = Spell(115546, false, true, true);
        PurifyingBrew = Spell(119582, false, false, true);
        Resuscitate = Spell(115178, false, false, false, true);
        RushingJadeWind = Spell(116847, false, false, true);
        SpearHandStrike = Spell(116705, true, true, true);
        TigerPalm = Spell(100780, true, true, true);
        ZenMeditation = Spell(115176, false, false, false);

        -- Staggering Debuffs
        HeavyStagger = Spell(124273, false, false, true);
        LightStagger = Spell(124275, false, false, true);
        ModerateStagger = Spell(124274, false, false, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {6, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest", "Untanked"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_SUBVALUE("Untanked").."Integrate tanking logic that will priorise the untaked units."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.TauntManagerOptions("Provoke");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddOption("General Settings", "Resuscitate", true, "Resurrect dead allies with Resuscitate while Out of Combat.");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Pummel to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Invoke Niuzao", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Invoke Niuzao."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Blackout Combo", 130, true, {1, "Breath of Fire", "Tiger Palm"}, nil, "Handle Blackout Combo priority."..C.TOOLTIP_VALUE.."Spell to use with Blackout Combo.");
        module.AddNewOption("Offensive Settings", "Breath Of Fire", 220, true, {1, 1, 10, 1}, nil, "Use Breath Of Fire."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range to use.");
        module.AddNewOption("Offensive Settings", "Chi Burst", 220, true, {1, 1, 10, 1}, nil, "Use Chi Burst."..C.TOOLTIP_VALUE.."Amount of units that needs to be in the effect zone to use.");
        module.AddNewOption("Offensive Settings", "Flaming Keg", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {4, 1, 20, 1}, "Use Flaming Keg." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Rushing Jade Wind", 220, true, {2, 1, 10, 1}, nil, "Use Rushing Jade Wind."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range to use.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Purifying Brew", 232, true, {2, "Normal", "Purifying If Capping", "Inronskin If Capping"}, {25, 1, 100, 1}, "Use Purifying Brew."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Normal", true).."Only use when health stagger is high enough."..C.TOOLTIP_SUBVALUE("Purifying If Capping", true).."Use Purifying Brew automatically as soon as we have stagger when we are at max charges."..C.TOOLTIP_SUBVALUE("Ironskin If Capping", true).."Use Ironskin Brew automatically as soon as we have stagger when we are at max charges."..C.TOOLTIP_VALUE_2.."Stagger Percent Before Using Purifying Brew."..C.TOOLTIP_HINT((Player:MaxHealth()/100).." damage taken per second per percent."));
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Dampen Harm", 220, true, {30, 1, 100, 1}, nil, "Use Dampen Harm."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Diffuse Magic", 220, true, {30, 1, 100, 1}, nil, "Use Diffuse Magic."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Fortifying Brew", 220, true, {20, 1, 100, 1}, nil, "Use Fortifying Brew."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Healing Elixir", 220, true, {50, 1, 100, 1}, nil, "Use one charge of Healing Elixir."..C.TOOLTIP_VALUE.."Health threshold."..C.TOOLTIP_HINT("Second charge will always be kept and will be used automatically when your health fall under 35%."));

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pot BossMod") and Target:Exists() and BMPullTime() < 7 then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(SpearHandStrike, ArcaneTorrent);
    end


    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Purrifying Brew
        if PurifyingBrew:Exists() and module.IsOptionEnabled("Purifying Brew") and Player:CanCast(PurifyingBrew) then
            if Player:Debuff(HeavyStagger) and module.GetNumbersForDebuff(Player, HeavyStagger)[1]/Player:MaxHealth() *100 >= module.GetSecondOptionValue("Purifying Brew") then
                Player:Cast(PurifyingBrew);
            end
            if Player:Debuff(ModerateStagger) and module.GetNumbersForDebuff(Player, ModerateStagger)[1]/Player:MaxHealth() *100 >= module.GetSecondOptionValue("Purifying Brew") then
                Player:Cast(PurifyingBrew);
            end
            if Player:Debuff(LightStagger) and module.GetNumbersForDebuff(Player, LightStagger)[1]/Player:MaxHealth() *100 >= module.GetSecondOptionValue("Purifying Brew") then
                Player:Cast(PurifyingBrew);
            end
            if module.GetOptionValue("Purifying Brew") ~= "Normal" and (Player:Debuff(HeavyStagger) or Player:Debuff(ModerateStagger) or Player:Debuff(LightStagger)) then
                local MaxCharges, ChoosedSpell = LightBrewing:Exists() and 4 or 3, module.GetOptionValue("Purifying Brew") == "Purifying If Capping" and PurifyingBrew or IronskinBrew;
                if PurifyingBrew:Charges() == MaxCharges or (PurifyingBrew:Charges() == MaxCharges - 1 and PurifyingBrew:Recharge() < 3) then
                    Player:Cast(PurifyingBrew)
                end
            end
        end
        -- Defensive Items
        Player:UseHealingItem();
        -- Healing Elixir
        if HealingElixir:Exists() and HealingElixir:Charges() == 2 and module.IsOptionEnabled("Healing Elixir") and Player:HealthPercentage() <= module.GetOptionValue("Healing Elixir") and HealingElixir:TimeSinceCast() > 2 and Player:CanCast(HealingElixir) then
            Player:Cast(HealingElixir);
            HealingElixir.LastCastTime = module.GetTime();
        end
        -- Diffuse Magic
        if DiffuseMagic:Exists() and module.IsOptionEnabled("Diffuse Magic") and Player:HealthPercentage() <= module.GetOptionValue("Diffuse Magic") and Player:CanCast(DiffuseMagic) then
            Player:Cast(DiffuseMagic);
        end
        -- Dampen Harm
        if DampenHarm:Exists() and module.IsOptionEnabled("Dampen Harm") and Player:HealthPercentage() <= module.GetOptionValue("Dampen Harm") and Player:CanCast(DampenHarm) then
            Player:Cast(DampenHarm);
        end
        -- Fortifying Brew
        if FortifyingBrew:Exists() and module.IsOptionEnabled("Fortifying Brew") and Player:HealthPercentage() <= module.GetOptionValue("Fortifying Brew") and Player:CanCast(FortifyingBrew) then
            Player:Cast(FortifyingBrew);
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end


    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(TigerPalm, false) or Unit.Target;
    end

    function Rotation:Opening ()
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") then
            if Player:Potion("Armor", Potion) then Potion = true; end
        end
    end

    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then

            -- Enemies Check
            if module.UseAOE() then
                ChiBurstUnits = ChiBurst:Exists() and #Player:UnitsInFrontRectangle(40, 5) or 0;
                BreathOfFireUnits = #Player:UnitsInFrontCone(10, 140); -- Frontal Cone.
                Enemies_30y = Player:EnemiesWithinDistance(30, false);
                Enemies_8y = Player:FilterEnemiesByDistance(Enemies_30y, 8, true);
                NumEnemies = #Enemies_8y;
            else
                NumEnemies, ChiBurstEnemies, BreathOfFireUnits = 1, 0, 0;
            end

            -- Provoke
            if Player:TauntManager(Provoke, "Provoke", Target, Enemies_30y, PlayerPet) then
                return;
            end

            if Player:IsWithinCastRange(Target, TigerPalm) then
                --- Cooldowns ---
                if module.CooldownsAllowed() then
                    Player:UseTrinkets();
                    -- Racials
                    if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                        -- Blood Fury
                        if BloodFury:Exists() and Player:CanCast(BloodFury) then
                            Player:Cast(BloodFury);
                        end
                        -- Berserking
                        if Berserking:Exists() and Player:CanCast(Berserking) then
                            CastSpellByID(26297, "player")
                        end
                        -- Arcane Torrent
                        if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Energy() < 60 then
                            Player:Cast(ArcaneTorrent);
                        end
                    end
                end
                -- Invoke Niuzao
                if InvokeNiuzao:Exists() and module.IsOptionEnabled("Invoke Niuzao") and (module.CooldownsAllowed() or module.GetOptionValue("Invoke Niuzao") == "Always") and Target:CanCast(InvokeNiuzao) then
                    Target:Cast(InvokeNiuzao);
                    return;
                end
            end

            -- Rotation
            -- Keg Smash
            if KegSmash:Exists() and Player:DistanceTo(Target) < 20 and Target:CanCast(KegSmash) then
                Target:Cast(KegSmash);
                return;
            end
            if KegSmash:Cooldown() < 0.5 then return; end
            -- Blackout Combo
            if BlackoutCombo:Exists() then
                -- Tiger Palm
                if module.GetOptionValue("Blackout Combo") == "Tiger Palm" then
                    if not Player:Buff(BlackoutComboBuff) and (Player:Power() >= 45 or not KegSmash:Exists() or KegSmash:Cooldown() > 3) and Target:CanCast(BlackoutStrike) then
                        Target:Cast(BlackoutStrike);
                        return;
                    end
                    if Player:Buff(BlackoutComboBuff) and Target:CanCast(TigerPalm) then
                        Target:Cast(TigerPalm);
                        return;
                    end
                else
                    -- Breath Of Fire
                    if BreathOfFire:Exists() and module.IsOptionEnabled("Breath Of Fire") and BreathOfFireUnits >= module.GetOptionValue("Breath Of Fire") then
                        if not Player:Buff(BlackoutComboBuff) and Target:CanCast(BlackoutStrike) then
                            Target:Cast(BlackoutStrike);
                            return;
                        end
                        if Player:Buff(BlackoutComboBuff) and Player:CanCast(BreathOfFire) then
                            Player:Cast(BreathOfFire);
                            return;
                        end
                    end
                end
            end
            -- Blackout Strike
            if BlackoutStrike:Exists() and Target:CanCast(BlackoutStrike) then
                Target:Cast(BlackoutStrike);
                return;
            end
            -- Breath Of Fire
            if BreathOfFire:Exists() and Player:IsWithinCastRange(Target, TigerPalm) and Target:Debuff(KegSmash) and module.IsOptionEnabled("Breath Of Fire") and module.GetOptionValue("Blackout Combo") ~= "Breath Of Fire" and BreathOfFireUnits >= module.GetOptionValue("Breath Of Fire") and Player:CanCast(BreathOfFire) then
                Player:Cast(BreathOfFire);
                return;
            end
            -- Chi Burst
            if ChiBurst:Exists() and module.IsOptionEnabled("Chi Burst") and ChiBurstUnits >= module.GetOptionValue("Chi Burst") and Player:CanCast(ChiBurst) then
                Player:Cast(ChiBurst);
                return;
            end
            -- Rushing Jade Wind
            if RushingJadeWind:Exists() and module.IsOptionEnabled("Rushing Jade Wind") and NumEnemies >= module.GetOptionValue("Rushing Jade Wind") and Player:CanCast(RushingJadeWind) then
                Player:Cast(RushingJadeWind);
                return;
            end
            -- Chi Wave
            if ChiWave:Exists() and Target:CanCast(ChiWave) then
                Target:Cast(ChiWave);
                return;
            end
            -- Flaming Keg
            if FlamingKeg:Exists() and module.IsOptionEnabled("Flaming Keg") and Target:CanCast(FlamingKeg) then
                if Target:CastGroundSpell(FlamingKeg, "Flaming Keg", 8) then return; end
            end
            -- Tiger Palm
            if TigerPalm:Exists() and (Player:Power() >= 55 or KegSmash:Cooldown() > 3) and Target:CanCast(TigerPalm) then
                Target:Cast(TigerPalm);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(TigerPalm, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Resuscitate
        if module.IsOptionEnabled("Resuscitate") and Unit.ResurrectCycle(Resuscitate) then
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Mistweaver Monk
    local Rotation = {};
    module.SetRotation(270, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshTables = 0, 0.1, 0; -- Combat Module Throttle
    -- Healers Specific
    local MainTank, MainTankTarget, OffTank, OffTankTarget, HealUnits, Lowest, CurrentBadDebuffs, BestTarget, DispelUnit;
    local Trinket1Units, Trinket2Units, RacialsUnits;
    local Option1, Option2, Option3, Option4;
    -- Profile Specific
    local MistDelay, SoothingUnit, SoothingUnitGUID, SoothingUnitHealth = 0, nil, nil, 100;
    local VivifyCyclesUnit, VivifyUpliftingTranceUnit = nil, nil;
    local TheseHealUnits = {};
    local JadeSerpentStatue, JadeSerpentStatueCount = nil, 0;
    local Enemies_8y, ChiBurstCount, EssenceFontCount, InvokeChiJiCount, JadeSerpentStatueCount = {}, 0, 0, 0, 0;
    local RevivalCount, VivifyUnit, ZenPulseMainTankCount, ZenPulseOffTankCount, ZenPulseLowestCount = 0, nil, 0, 0, 0;

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        LukewarmYakRoastBroth = Item(120293, false, false, true);
        DraenicChanneledManaPotion = Spell(156432, false, false, false);
        --Racials
        ArcaneTorrent = Spell(25046, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33697, false, false, true);
        GiftOfTheNaaru = Spell(121093, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        BlackoutKick = Spell(100784, true, true, true);
        ChiBurst = Spell(123986, false, false, false);
        CracklingJadeLightning = Spell(117952, true, true, false);
        DampenHarm = Spell(122278, false, false, true);
        Detox = Spell(115450, false, false, true);
        DiffuseMagic = Spell(122783, false, false, true);
        Effuse = Spell(116694, false, false, false);
        EnvelopingMist = Spell(124682, false, false, false);
        EssenceFont = Spell(191837, false, false, true); -- not castable while moving if not under Thunder Focus Tea
        HealingElixir = Spell(122281, false ,false, true);
        InvokeChiJi = Spell(198664, false, false, true);
        LegSweep = Spell(119381, false, false, true);
        LifeCocoon = Spell(116849, false, false, true);
        LifeCyclesEnvelopingMist = Spell(197919);
        LifeCyclesVifvify = Spell(197916);
        ManaTea = Spell(197908, false, false, true);
        Paralysis = Spell(115078, true, false, true);
        Reawaken = Spell(212051, false, false, false);
        RenewingMist = Spell(115151, false, false, true);
        RenewingMistBuff = Spell(119611);
        Resuscitate = Spell(115178, false, false, false);
        Revival = Spell(115310, false, false, true);
        RisingSunKick = Spell(107428, true, true, true);
        RisingThunder = Spell(210804);
        SheilunsGift = Spell(205406, false, false, false);
        ShroudOfMist = Spell(214478);
        SoothingMist = Spell(193884);
        SpinningCraneKick = Spell(101546, false, false, true);
        SpiritOfTheCrane = Spell(210802);
        SummonJadeSerpentStatue = Spell(115313, false, false, true);
        TeachingOfTheMonastery = Spell(202090);
        ThunderFocusTea = Spell(116680, false, false, true);
        TigerPalm = Spell(100780, true, true, true);
        UpliftingTrance = Spell(197206);
        Vivify = Spell(116670, false, false, false);
        ZenPulse = Spell(124081, false, false, true);

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Healing Settings");
        module.AddPage("Cooldowns Settings");
        module.AddPage("Offensive/Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Focus Assignation", 230, true, {2, "Main Tank", "Off Tank"}, nil, "Select which Tank slot should be given to the focussed unit.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Detox", 232, false, {1, "Auto", "High", "Normal"}, {0.2, 0, 1, 0.1}, "Use Detox to Dispel bad debuffs on allied units."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Auto").."Dispel Active Dispel Raid debuffs as High Priority and other not listed debuffs as Normal Priority."..C.TOOLTIP_SUBVALUE("High").."Dispel all debuffs as High Priority even before urgent cooldowns."..C.TOOLTIP_SUBVALUE("Normal").."Dispel all debuffs as Normal Priority after urgent cooldowns."..C.TOOLTIP_VALUE_2.."Define how long you want to wait before dispelling to look more human. This does not apply to Active Dispels Raid debuffs which will always be as soon as Global Cooldown ends."..C.TOOLTIP_HINT("Active Raid Dispels are based on an hardcoded list. Please report of any dispels you may encounter that requires specific strategies so that they can be properly added to the list."));
        module.AddNewOption("General Settings", "Resuscitate", 210, true, nil, nil, "Resurrect dead Target with Ancestral Spirit while out of combat.");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Paralysis to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Healing Settings", "Common Healing Thresholds", "Green");
        module.AddNewOption("Healing Settings", "Chi Burst", 222, true, {3, 1, 25, 1}, {85, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Effuse", 222, true, {80, 0, 100, 1}, {65, 0, 100, 1}, "Use Effuse."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Enveloping Mist", 222, true, {80, 0, 100, 1}, {15, 0, 100, 1}, "Use Enveloping Mist."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Essence Font", 222, true, {4, 1, 12, 1}, {85, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Renewing Mist", 222, true, {99, 0, 100, 1}, {95, 0, 100, 1}, "Use Renewing Mist."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Summon Jade Serpent Statue", 232, true, {2, "Between Player And Tanks", "Centered On Raid"}, {20, 1, 25, 1}, "Use Summon Jade Serpent Statue."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Between Player And Tanks").."Place the Statue between the player and the tanks."..C.TOOLTIP_SUBVALUE("Centered On Raid").."Place the Statue so that it can reach as many raid members as possible."..C.TOOLTIP_VALUE_2.."Replace statue if less than this amount of valid healing units can be found around it. This value is built on an average of 25 players. In Example: If you define the value to 20 and you are in a 5 man group, the statue will be placed on at least 4 players and replaced if the statue can reach less than 4 players."..C.TOOLTIP_HINT("Summon Jade Serpent Statue will only be used when the player and at least one tank are standing."));
        module.AddNewOption("Healing Settings", "Vivify", 222, true, {3, 1, 3, 1}, {90, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Zen Pulse", 222, true, {2, 1, 5, 1}, {90, 0, 100, 1}, "Use when selected number of enemy units are around Lowest, OffTank or MainTank that is under health threshold."..C.TOOLTIP_VALUE_1.."Number of Enemy Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Out Of Combat Healing", 210, true, nil, nil, "Allow Healing while Out of Combat.");
        module.AddSection("Healing Settings", "Procs Management", "Green");
        module.AddNewOption("Healing Settings", "Life Cycles Enveloping Mist", 222, true, {85, 0, 100, 1}, {25, 0, 100, 1}, "Use Enveloping Mist with Life Cycles."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Life Cycles Vivify", 222, true, {2, 1, 3, 1}, {90, 0, 100, 1}, "Use when selected number of units are under health threshold with Life Cycles."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Uplifting Trance Vivify", 222, true, {2, 1, 3, 1}, {90, 0, 100, 1}, "Use when selected number of units are under health threshold  with Uplifting Trance."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddSection("Healing Settings", "Active Healing", "Green");
        module.AddNewOption("Healing Settings", "Heal Target", 230, false, {1, "Known Unit", "Any Unit"}, nil, "Heal our current target if it is listed to be healed."..C.TOOLTIP_VALUE.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Known Unit").."Allow Heal Target to be used only when we are targetting a unit listed for it."..C.TOOLTIP_SUBVALUE("Any Unit").."Allow Heal Target to be used on any unit.");
        module.AddNewOption("Healing Settings", "Raid Debuffs", 220, true, {40, 0, 100, 1}, nil, "Use Renewing Mist on Debuffed units."..C.TOOLTIP_VALUE.."Helath threshold.");
        module.AddNewOption("Healing Settings", "Tank Debuffs", 220, true, {50, 0, 100, 1}, nil, "Use Renewing Mist on Debuffed tanks."..C.TOOLTIP_VALUE.."Helath threshold.");
        module.AddNewOption("Healing Settings", "Topping", 220, true, {100, 0, 100, 1}, nil, "Use Renewing Mist/Enveloping Mist/Effuse on units to be topped."..C.TOOLTIP_VALUE.."Helath threshold.");

        module.AddSection("Cooldowns Settings", "Cooldowns", "Green");
        module.AddNewOption("Cooldowns Settings", "Invoke Chi-Ji", 222, true, {3, 1, 25, 1}, {55, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Life Cocoon", 222, true, {20, 0, 100, 1}, {10, 0, 100, 1}, "Use Life Cocoon."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Cooldowns Settings", "Mana Tea", 232, true, {1, "Auto", "Essence Font", "Vivify"}, {90, 1, 100, 1}, "Use with the selected spell when it is about to be casted whenever our mana is under threshold."..C.TOOLTIP_VALUE_1.."Spell to use with. Auto will use with both."..C.TOOLTIP_VALUE_2.."Mana threshold.");
        module.AddNewOption("Cooldowns Settings", "Revival", 222, true, {3, 1, 25, 1}, {30, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Sheilun's Gift", 222, true, {40, 0, 100, 1}, {15, 0, 100, 1}, "Use Sheilun's Gift when we have at least three Clouds."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Cooldowns Settings", "Thunder Focus Tea", 233, true, {5, "None", "Always", "Auto", "Effuse", "Enveloping Mist", "Essence Font", "Renewing Mist", "Vivify"}, {6, "None", "Effuse", "Enveloping Mist", "Essence Font", "Renewing Mist", "Vivify"}, "Use with the selected spell when it is about to be casted."..C.TOOLTIP_VALUE_1.."Define Auto to use it whenever with any listed spell. Define to Always to use it whenever it is ready. Select any other spell to only use it with that particular spell whenever it is ready."..C.TOOLTIP_VALUE_2.."If not set to Auto or Always, select a second spell to use with whenever it is ready."..C.TOOLTIP_HINT("You can define the option to Auto if you want to use with any spells. In other cases, choose the spells you want to be used with it."));
        module.AddNewOption("Cooldowns Settings", "Thunder Focus Tea Spells", 133, true, {1, "None", "Effuse", "Enveloping Mist", "Essence Font", "Renewing Mist", "Vivify"}, {1, "None", "Effuse", "Enveloping Mist", "Essence Font", "Renewing Mist", "Vivify"}, "Choose more spells to use with Thunder Focus Tea. Only usefull if Thunder Focus Tea's first option not set to Auto or Always."..C.TOOLTIP_VALUE_1.."Third spell to use with Thunder Focus Tea."..C.TOOLTIP_VALUE_2.."Fourth spell to use with Thunder Focus Tea.");
        module.AddSection("Cooldowns Settings", "Trinkets And Racials", "Green");
        module.AddNewOption("Cooldowns Settings", "Soft Cooldowns Units", 120, true, {3, 1, 25, 1}, nil, "Number of units that needs to be under thresholds to use Racials and Trinkets with Health.");
        module.AddNewOption("Cooldowns Settings", "Use Racials", 220, true, {80, 0, 100, 1}, nil, "Use Racials."..C.TOOLTIP_VALUE.."Use when number of units under threshold is greater or equal to Soft Cooldowns Units value.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 1", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 1 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always") .." Use Always."..C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 2", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 2 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always") .." Use Always."..C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");

        module.AddSection("Offensive/Defensive Settings", "Offensive", "Green");
        module.AddPresetOption("TargetAttack");
        module.AddNewOption("Offensive/Defensive Settings", "Fistweaving", 222, true, {80, 0, 100, 1}, {50, 0, 100, 1}, "Enables Fistweaving. This will only use Tiger Palm to get the Teaching of the Monastery buff and then Blackout Kick to trigger the mana regeration from Spirit Of The Crane talent."..C.TOOLTIP_VALUE_1.."Fistweave if our mana is under this threshold."..C.TOOLTIP_VALUE_2.."Only Fistweave if the Lowest unit have more than this health threshold."..C.TOOLTIP_HINT("Requires Spirit of the Crane talent."));
        module.AddNewOption("Offensive/Defensive Settings", "Rising Thunder", 220, true, {50, 0, 100, 1}, nil, "Enables using Rising Sun Kick to reset Thunder Focus Tea cooldown."..C.TOOLTIP_VALUE.."Only use if the Lowest unit have more than this health threshold."..C.TOOLTIP_HINT("Requires Rising Thunder talent."));
        module.AddSection("Offensive/Defensive Settings", "DPS Offensive", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "DPS", 220, false, {95, 0, 100, 1}, nil, "Enables DPS options."..C.TOOLTIP_VALUE.."Will only DPS if the Lowest unit is above DPS health treshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Spinning Crane Kick", 220, true, {7, 1, 25, 1}, nil, "Use Spinning Crane Kick in the DPS rotation."..C.TOOLTIP_VALUE.."Amount of units required to be in 12 yards of Player to use."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Tiger Palm", 210, true, nil, nil, "Use Tiger Palm in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Blackout Kick", 210, true, nil, nil, "Use Blackout Kick in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Rising Sun Kick", 210, true, nil, nil, "Use Rising Sun Kick in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddSection("Offensive/Defensive Settings", "Defensive", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Dampen Harm", 220, true, {60, 1, 100, 1}, nil, "Use Dampen Harm."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Diffuse Magic", 220, true, {60, 1, 100, 1}, nil, "Use Diffuse Magic."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Healing Elixir", 220, true, {60, 1, 100, 1}, nil, "Use Healing Elixir."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Offensive/Defensive Settings", "Gift Of The Naaru", 222, true, {45, 0, 100, 1}, {35, 0, 100, 1}, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        end

        -- Healers Specific
        module.AddOutput("|cFF9A2EFEMain Tank:");
        module.AddOutput("|cFF9A2EFEOff Tank:");
        module.AddOutput("|cFF9A2EFELowest:");
        module.AddOutput("|cFF9A2EFEBad Debuffs:");
        module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- New Improved Spell Casting Logic
        module.ISCL = {
            [Effuse:ID()] = "Effuse",
            [EnvelopingMist:ID()] = "Enveloping Mist",
            [EssenceFont:ID()] = "Essence Font",
            [SheilunsGift:ID()] = "Sheilun's Gift",
            [Vivify:ID()] = "Vivify"
        };
        SheilunsGift.LastCastTime = module.GetTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Channeling(EssenceFont) then
            return;
        end

        -- Define Main Tanks
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Paralysis, ArcaneTorrent);
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Healing Elixir
        if HealingElixir:Exists() and module.IsOptionEnabled("Healing Elixir") and Player:HealthPercentage() <= module.GetOptionValue("Healing Elixir") and Player:CanCast(HealingElixir) then
            Player:Cast(HealingElixir);
            return;
        end
        -- Diffuse Magic
        if DiffuseMagic:Exists() and module.IsOptionEnabled("Diffuse Magic") and Player:HealthPercentage() <= module.GetOptionValue("Diffuse Magic") and Player:CanCast(DiffuseMagic) then
            Player:Cast(DiffuseMagic);
            return;
        end
        -- Dampen Harm
        if DampenHarm:Exists() and module.IsOptionEnabled("Dampen Harm") and Player:HealthPercentage() <= module.GetOptionValue("Dampen Harm") and Player:CanCast(DampenHarm) then
            Player:Cast(DampenHarm);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and MainTank:CanCast(GiftOfTheNaaru) then
                MainTank:Cast(GiftOfTheNaaru);
                return;
            elseif MainTank and OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and OffTank:CanCast(GiftOfTheNaaru) then
                OffTank:Cast(GiftOfTheNaaru);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Gift Of The Naaru") and Lowest:CanCast(GiftOfTheNaaru) then
                Lowest:Cast(GiftOfTheNaaru);
                return;
            end
        end
    end

    -- Get Tanks Status
    local TanksStatus, MainTankTanking, OffTankTanking = {Main = {IsTanking = module.GetTime()},Off = {IsTanking = module.GetTime()}}, nil, nil;
    local function RefreshTanksStatus ()
        TanksStatus = {
            Main = {IsTanking = MainTank and MainTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Main.IsTanking},
            Off = {IsTanking = OffTank and OffTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Off.IsTanking}
        };
        MainTankTanking = module.GetTime() - TanksStatus.Main.IsTanking < 3 or false;
        OffTankTanking = module.GetTime() - TanksStatus.Off.IsTanking < 3 or false;
    end

    -- Active Healing Heal Target handler
    local function HealTarget (ThisUnit)
        -- Renewing Mist
        if ThisUnit:BuffRemains(RenewingMist) < 2 and ThisUnit:CanCast(RenewingMist) then
            ThisUnit:Cast(RenewingMist);
            return;
        end
        if not Player:IsMoving() and ThisUnit:CanCast(Effuse) then
            -- Enveloping Mist
            if ThisUnit:SpecialHealthPercentage() < 60 and not ThisUnit:Buff(EnvelopingMist) and ThisUnit:CanCast(EnvelopingMist) then
                ThisUnit:Cast(EnvelopingMist);
                return;
            end
            -- Effuse
            if ThisUnit:SpecialHealthPercentage() < 100 and SoothingUnitGUID ~= ThisUnit:GUID() and ThisUnit:CanCast(Effuse) then
                ThisUnit:Cast(Effuse);
                return;
            end
        end
    end

    local function FocusTea (FirstOption, SecondOption)
        Option1, Option2 = module.GetOptionValue("Thunder Focus Tea"), module.GetSecondOptionValue("Thunder Focus Tea")
        Option3, Option4 = module.GetOptionValue("Thunder Focus Tea Spells"), module.GetSecondOptionValue("Thunder Focus Tea Spells")
        if ThunderFocusTea:Exists() and module.IsOptionEnabled("Thunder Focus Tea") then
            if (Option1 == FirstOption or Option1 == SecondOption or Option2 == SecondOption or Option3 == SecondOption or Option4 == SecondOption) and Player:CanCast(ThunderFocusTea) then
                ThunderFocusTea.LastCastTime = module.GetTime();
                Player:Cast(ThunderFocusTea);
            end
        end
    end

    local function ManaTeaTalent (FirstOption, SecondOption)
        if ManaTea:Exists() and module.IsOptionEnabled("Mana Tea") and Player:PowerPercentage() <= module.GetSecondOptionValue("Mana Tea") and (module.GetOptionValue("Mana Tea") == FirstOption or module.GetOptionValue("Mana Tea") == SecondOption) and Player:CanCast(ManaTea) then
            Player:Cast(ManaTea);
        end
    end

    --- Run the beta rotation's healing logic.
    function Rotation:Combat ()
        -- Find best unit to attack
        if Target:Exists() and Target:CanCast(TigerPalm) then
            BestTarget = Target;
        elseif MainTankTarget and MainTankTarget:CanCast(TigerPalm) then
            BestTarget = MainTankTarget;
        elseif OffTankTarget and OffTankTarget:CanCast(TigerPalm) then
            BestTarget = OffTankTarget;
        elseif Mouseover:Exists() and Mouseover:CanCast(TigerPalm) then
            BestTarget = Mouseover;
        else
            BestTarget = Target;
        end

        -- Define Jade Serpent Statue Unit
        if module.JadeSerpentStatue and module.JadeSerpentStatue.UnitID then
            JadeSerpentStatue = Unit(module.JadeSerpentStatue.UnitID);
        end

        -- Refresh tables every 0.5 seconds
        if RefreshTables < module.GetTime() then
            DispelUnit = Unit.Dispel(Detox);
            HealUnits = Player:HealUnitsAround(100, 40);
            Lowest = Unit.Lowest(MainTank, OffTank);
            module.SetOutput("|cFF9A2EFELowest:", Lowest and Lowest:Name() or "");
            RefreshTanksStatus();
            Enemies_8y = module.UseAOE() and Player:EnemiesWithinDistance(8) or {}; -- 8 yards of Player for Spinning Crane Kick.
            ChiBurstCount = ChiBurst:Exists() and #Player:UnitsInFrontRectangle(40, 5, true, module.GetSecondOptionValue("Chi Burst")) or 0;
            EssenceFontCount = EssenceFont:Exists() and module.IsOptionEnabled("Essence Font") and #Player:HealUnitsAround(module.GetSecondOptionValue("Essence Font"), 25) or 0;
            InvokeChiJiCount = InvokeChiJi:Exists() and module.IsOptionEnabled("Invoke Chi-Ji") and #Player:HealUnitsAround(module.GetSecondOptionValue("Invoke Chi-Ji"), 40) or 0;
            JadeSerpentStatueCount = JadeSerpentStatue and JadeSerpentStatue:Exists() and Unit.FriendliesNearTotem(JadeSerpentStatue, HealUnits, 40, 100) or 0;
            RevivalCount = Revival:Exists() and module.IsOptionEnabled("Revival") and #Player:HealUnitsAround(module.GetSecondOptionValue("Revival"), 40) or 0;
            VivifyUnit = Vivify:Exists() and module.IsOptionEnabled("Vivify") and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Vivify"), module.GetSecondOptionValue("Vivify"), 20) or nil;
            VivifyCyclesUnit = Vivify:Exists() and module.IsOptionEnabled("Life Cycles Vivify") and Player:Buff(LifeCyclesVifvify) and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Life Cycles Vivify"), module.GetSecondOptionValue("Life Cycles Vivify"), 20) or nil;
            VivifyUpliftingTranceUnit = Vivify:Exists() and module.IsOptionEnabled("Uplifting Trance Vivify") and Player:Buff(UpliftingTrance) and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Uplifting Trance Vivify"), module.GetSecondOptionValue("Uplifting Trance Vivify"), 20) or nil;
            ZenPulseMainTankCount = ZenPulse:Exists() and MainTank and MainTank:SpecialHealthPercentage() <= module.GetSecondOptionValue("Zen Pulse") and #MainTank:EnemiesWithinDistance(8, true) or 0;
            ZenPulseOffTankCount = ZenPulse:Exists() and OffTank and OffTank:SpecialHealthPercentage() <= module.GetSecondOptionValue("Zen Pulse") and #OffTank:EnemiesWithinDistance(8, true) or 0;
            ZenPulseLowestCount = ZenPulse:Exists() and Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Zen Pulse") and #Lowest:EnemiesWithinDistance(8, true) or 0;
            RacialsUnits = module.IsOptionEnabled("Use Racials") and ((Berserking:Exists() and Player:CanCast(Berserking)) or (BloodFury:Exists() and Player:CanCast(BloodFury))) and #Player:HealUnitsAround(module.GetOptionValue("Use Racials"), 40) or 0;
            Trinket1Units = module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 1"), 40) or 0;
            Trinket2Units = module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 2"), 40) or 0;
            -- Bad Debuffs Output
            CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits);
            if CurrentBadDebuffs ~= nil then
                module.SetOutput("|cFF9A2EFEBad Debuffs:", #CurrentBadDebuffs.Tanks + #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff);
            end
            RefreshTables = module.GetTime() + 0.5;
        end

        -- Dispels Handling
        Player:DispelHandler(Detox, "Detox", DispelUnit, CurrentBadDebuffs.Dispel, "High");

        -- Active Healing Heal Target handler
        if Target:CanCast(Effuse) and module.IsOptionEnabled("Heal Target") and (module.GetOptionValue("Heal Target") == 2 or (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed())) then
            HealTarget(Target);
            return;
        end

    -- Cooldowns
        -- Only use DPS and Cooldowns during combat
        if Player:IsInCombat() then
            -- DPS
            if module.IsOptionEnabled("DPS") and BestTarget and (not Lowest or Lowest:HealthPercentage() >= module.GetOptionValue("DPS")) and (not MainTank or MainTank:HealthPercentage() >= module.GetOptionValue("DPS")) and (not OffTank or OffTank:HealthPercentage() >= module.GetOptionValue("DPS")) and BestTarget:IsInCombat() then
                -- Tiger Palm for Teaching Of The Monastery
                if TigerPalm:Exists() and SpiritOfTheCrane:Exists() and not Player:Buff(TeachingOfTheMonastery) and module.IsOptionEnabled("Tiger Palm") and BestTarget:CanCast(TigerPalm) then
                    BestTarget:Cast(TigerPalm);
                    return;
                end
                -- Blackout Kick
                if BlackoutKick:Exists() and module.IsOptionEnabled("Blackout Kick") and BestTarget:CanCast(BlackoutKick) then
                    BestTarget:Cast(BlackoutKick);
                    return;
                end
                -- Spinning Crane Kick
                if SpinningCraneKick:Exists() and #Enemies_8y >= module.GetOptionValue("Spinning Crane Kick") and Player:CanCast(SpinningCraneKick) then
                    Player:Cast(SpinningCraneKick);
                    return;
                end
                -- Rising Sun Kick
                if RisingSunKick:Exists() and module.IsOptionEnabled("Rising Sun Kick") and BestTarget:CanCast(RisingSunKick) then
                    BestTarget:Cast(RisingSunKick);
                    return;
                end
                -- Tiger Palm
                if TigerPalm:Exists() and module.IsOptionEnabled("Tiger Palm") and BestTarget:CanCast(TigerPalm) then
                    BestTarget:Cast(TigerPalm);
                    return;
                end
                -- Find New Target
                if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
                    local NewTargetUnit = Unit.AutoTarget(TigerPalm, module.GetOptionValue("Target | Attack"));
                    if NewTargetUnit then
                        NewTargetUnit:Attack();
                        return;
                    end
                end
            end
            -- Racials with Specific Handlers
            if module.IsOptionEnabled("Use Racials") then
                if RacialsUnits >= module.GetOptionValue("Soft Cooldowns Units") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                        return;
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                        return;
                    end
                end
            end
            -- Trinkets with specific handlers
            if module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 1"), module.GetSecondOptionValue("Use Trinket 1");
                if Option1 == "Always" or (Option1 == "Health" and Trinket1Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 1")) then
                    Trinket1:UseInventory();
                end
            end
            if module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 2"), module.GetSecondOptionValue("Use Trinket 2");
                if Option1 == "Always" or (Option1 == "Health" and Trinket2Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 2")) then
                    Trinket2:UseInventory();
                end
            end
            -- Revival - Used when # of people under treshold exceed desired number of units
            if Revival:Exists() and module.IsOptionEnabled("Revival") and RevivalCount >= module.GetOptionValue("Revival") and Player:CanCast(Revival) then
                Player:Cast(Revival);
                return;
            end
            -- Invoke Chi-Ji - Used when # of people under treshold exceed desired number of units
            if InvokeChiJi:Exists() and module.IsOptionEnabled("Invoke Chi-Ji") and InvokeChiJiCount >= module.GetOptionValue("Invoke Chi-Ji") and Player:CanCast(InvokeChiJi) then
                Player:Cast(InvokeChiJi);
                return;
            end
            -- Sheilun's Gift
            if SheilunsGift:Exists() and module.IsOptionEnabled("Sheilun's Gift") and module.SheilunsCharges >= 3 then
                if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Sheilun's Gift") and MainTank:CanCast(SheilunsGift) then
                    MainTank:Cast(SheilunsGift);
                    return;
                end
                if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Sheilun's Gift") and OffTank:CanCast(SheilunsGift) then
                    OffTank:Cast(SheilunsGift);
                    return;
                end
                if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Sheilun's Gift") and Lowest:CanCast(SheilunsGift) then
                    Lowest:Cast(SheilunsGift);
                    return;
                end
            end
            -- Life Cocoon
            if LifeCocoon:Exists() and module.IsOptionEnabled("Life Cocoon") then
                if MainTank and not MainTank:BuffAny(LifeCocoon) and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Life Cocoon") and MainTank:CanCast(LifeCocoon) then
                    MainTank:Cast(LifeCocoon);
                    return;
                end
                if OffTank and not OffTank:Buff(LifeCocoon) and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Life Cocoon") and OffTank:CanCast(LifeCocoon) then
                    OffTank:Cast(LifeCocoon);
                    return;
                end
                if Lowest and not Lowest:Buff(LifeCocoon) and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Life Cocoon") and Lowest:CanCast(LifeCocoon) then
                    Lowest:Cast(LifeCocoon);
                    return;
                end
            end
            -- Thunder Focus Tea - Always
            FocusTea("Always");
        end

        -- Dispels Handling
        Player:DispelHandler(Detox, "Detox", DispelUnit, CurrentBadDebuffs.Dispel, "Normal");

        -- Soothing Mist Handling
        if MistDelay < module.GetTime() and not Player:Channeling(SoothingMist) then
            MistDelay, SoothingUnit, SoothingUnitGUID, SoothingUnitHealth = 0, nil, nil, 100;
        end
        if SoothingUnit then
            SoothingUnitGUID = SoothingUnit:GUID();
            SoothingUnitHealth = SoothingUnit:SpecialHealthPercentage();
        else
            SoothingUnitGUID = "No Soothing";
            SoothingUnitHealth = 100;
        end

    -- High Priority Healing
        -- Summon Jade Serpent Statue
        if SummonJadeSerpentStatue:Exists() and module.IsOptionEnabled("Summon Jade Serpent Statue") and #HealUnits > 1 and not Player:IsMoving() and Player:CanCast(SummonJadeSerpentStatue) then
            -- See if we should reposition
            if JadeSerpentStatueCount < module.GetSecondOptionValue("Summon Jade Serpent Statue")/25 and #HealUnits >= module.GetSecondOptionValue("Summon Jade Serpent Statue")/25 then
                -- If option is set to Tanks and there is at least one Tank in the group
                if (module.GetOptionValue("Summon Jade Serpent Statue") == "Between Player And Tanks" and (MainTank or OffTank)) then
                    -- Placed Between Player and Main Tank
                    -- If at least one tank is not moving
                    if (MainTank and not MainTank:IsMoving()) or (OffTank and not OffTank:IsMoving()) then
                        TheseHealUnits = MainTank and OffTank and {Player,MainTank,OffTank} or MainTank and {Player, MainTank} or OffTank and {Player, OffTank};
                        Player:CastGroundHeal(SummonJadeSerpentStatue, TheseHealUnits);
                        return;
                    end
                else
                    if (MainTank and not MainTank:IsMoving()) or (OffTank and not OffTank:IsMoving()) or (not MainTank and not OffTank) then
                        -- Centered On Raid
                        Player:CastGroundHeal(SummonJadeSerpentStatue, HealUnits);
                        return;
                    end
                end
            end
        end
        -- Fistweaving Only
        if SpiritOfTheCrane:Exists() and module.IsOptionEnabled("Fistweaving") and (not CurrentBadDebuffs or #CurrentBadDebuffs.Top == 0) and Player:PowerPercentage() <= module.GetOptionValue("Fistweaving") and BestTarget and (not Lowest or Lowest:HealthPercentage() >= module.GetSecondOptionValue("Fistweaving")) and (not MainTank or MainTank:HealthPercentage() >= module.GetSecondOptionValue("Fistweaving")) and (not OffTank or OffTank:HealthPercentage() >= module.GetSecondOptionValue("Fistweaving")) and BestTarget:IsInCombat() then
            -- Tiger Palm for Teaching Of The Monastery
            if TigerPalm:Exists() and BlackoutKick:Exists() and BlackoutKick:TimeSinceCast() > 3 and not Player:Buff(TeachingOfTheMonastery) and BestTarget:CanCast(TigerPalm) then
                BestTarget:Cast(TigerPalm);
                return;
            end
            -- Blackout Kick
            if BlackoutKick:Exists() and Player:Buff(TeachingOfTheMonastery) and BestTarget:CanCast(BlackoutKick) then
                BlackoutKick.LastCastTime = module.GetTime();
                BestTarget:Cast(BlackoutKick);
                return;
            end
        end
        -- Rising Sun Kick - Rising Thunder
        if RisingThunder:Exists() and RisingSunKick:Exists() and module.IsOptionEnabled("Rising Thunder") and not Player:Buff(ThunderFocusTea) and ThunderFocusTea:Cooldown() > 5 and (not CurrentBadDebuffs or #CurrentBadDebuffs.Top == 0) and BestTarget and (not Lowest or Lowest:HealthPercentage() >= module.GetOptionValue("Rising Thunder")) and (not MainTank or MainTank:HealthPercentage() >= module.GetOptionValue("Rising Thunder")) and (not OffTank or OffTank:HealthPercentage() >= module.GetOptionValue("Rising Thunder")) and BestTarget:IsInCombat() and BestTarget:CanCast(RisingSunKick) then
            BestTarget:Cast(RisingSunKick);
            return;
        end
        -- Renewing Mist - Tanks
        if RenewingMist:Exists() and module.IsOptionEnabled("Renewing Mist") then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Renewing Mist") and MainTank:BuffRemains(RenewingMistBuff) <= 5 and MainTank:CanCast(RenewingMist) then
                FocusTea("Auto", "Renewing Mist");
                MainTank:Cast(RenewingMist);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Renewing Mist") and OffTank:BuffRemains(RenewingMistBuff) <= 5 and OffTank:CanCast(RenewingMist) then
                FocusTea("Auto", "Renewing Mist");
                OffTank:Cast(RenewingMist);
                return;
            end
        end
        -- Enveloping Mist - Tanks
        if EnvelopingMist:Exists() and module.IsOptionEnabled("Enveloping Mist") then
            if MainTank and not MainTank:Buff(EnvelopingMist) and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Enveloping Mist") and MainTank:CanCast(EnvelopingMist) then
                FocusTea("Auto", "Enveloping Mist");
                MistDelay, SoothingUnit = module.GetTime() + EnvelopingMist:CastTime() + 0.3, MainTank;
                MainTank:Cast(EnvelopingMist);
                return;
            end
            if OffTank and not OffTank:Buff(EnvelopingMist) and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Enveloping Mist") and OffTank:CanCast(EnvelopingMist) then
                FocusTea("Auto", "Enveloping Mist");
                MistDelay, SoothingUnit = module.GetTime() + EnvelopingMist:CastTime() + 0.3, OffTank;
                OffTank:Cast(EnvelopingMist);
                return;
            end
        end







        -- Enveloping Mist
        if EnvelopingMist:Exists() and module.IsOptionEnabled("Life Cycles Enveloping Mist") and Player:Buff(LifeCyclesEnvelopingMist) then
            if MainTank and not MainTank:Buff(EnvelopingMist) and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Life Cycles Enveloping Mist") and MainTank:CanCast(EnvelopingMist) then
                FocusTea("Auto", "Enveloping Mist");
                MistDelay, SoothingUnit = module.GetTime() + EnvelopingMist:CastTime() + 0.3, MainTank;
                MainTank:Cast(EnvelopingMist);
                return;
            end
            if OffTank and not OffTank:Buff(EnvelopingMist) and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Life Cycles Enveloping Mist") and OffTank:CanCast(EnvelopingMist) then
                FocusTea("Auto", "Enveloping Mist");
                MistDelay, SoothingUnit = module.GetTime() + EnvelopingMist:CastTime() + 0.3, OffTank;
                OffTank:Cast(EnvelopingMist);
                return;
            end
            if Lowest and not Lowest:Buff(EnvelopingMist) and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Life Cycles Enveloping Mist") and Lowest:CanCast(EnvelopingMist) then
                FocusTea("Auto", "Enveloping Mist");
                MistDelay, SoothingUnit = module.GetTime() + EnvelopingMist:CastTime() + 0.3, Lowest;
                Lowest:Cast(EnvelopingMist);
                return;
            end
        end







        -- Essence Font
        if EssenceFont:Exists() and module.IsOptionEnabled("Essence Font") and EssenceFontCount >= module.GetOptionValue("Essence Font") then
            if Player:Channeling(EssenceFont) then
                return;
            elseif Player:CanCast(EssenceFont) then
                if Player:IsMoving() then
                    FocusTea("Auto", "Essence Font");
                end
                if not Player:IsMoving() or Player:Buff(ThunderFocusTea) or ThunderFocusTea:TimeSinceCast() < 0.1 then
                    ManaTeaTalent("Auto", "Essence Font");
                    Player:Cast(EssenceFont);
                    return;
                end
            end
        end
        -- Renewing Mist - Cycle
        if Player:IsInCombat() and RenewingMist:Exists() and module.IsOptionEnabled("Renewing Mist") then
            local BestUnit, BestUnitHealth, ThisUnit, ThisUnitHealth, HealthThreshold = nil, 100, nil, nil, module.GetSecondOptionValue("Renewing Mist");
            for i = 1, #HealUnits do
                ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage();
                if ThisUnitHealth <= HealthThreshold and ThisUnitHealth <= BestUnitHealth and ThisUnit:CanCast(RenewingMist) and ThisUnit:BuffRemains(RenewingMistBuff) < 3 then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit then
                FocusTea("Auto", "Renewing Mist");
                BestUnit:Cast(RenewingMist);
                return;
            end
        end
        -- Enveloping Mist - Lowest
        if EnvelopingMist:Exists() and module.IsOptionEnabled("Enveloping Mist") then
            if Lowest and not Lowest:Buff(EnvelopingMist) and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Enveloping Mist") and Lowest:CanCast(EnvelopingMist) then
                FocusTea("Auto", "Enveloping Mist");
                MistDelay, SoothingUnit = module.GetTime() + EnvelopingMist:CastTime() + 0.3, Lowest;
                Lowest:Cast(EnvelopingMist);
                return;
            end
        end




        -- Life Cycles Vivify
        if module.IsOptionEnabled("Life Cycles Vivify") and VivifyCyclesUnit and VivifyCyclesUnit:CanCast(Vivify) then
            FocusTea("Auto", "Vivify");
            ManaTeaTalent("Auto", "Vivify");
            MistDelay, SoothingUnit = module.GetTime() + Vivify:CastTime() + 0.3, VivifyCyclesUnit;
            VivifyCyclesUnit:Cast(Vivify);
            return;
        end
        -- Uplifting Trance
        if module.IsOptionEnabled("Uplifting Trance Vivify") and VivifyUpliftingTranceUnit and VivifyUpliftingTranceUnit:CanCast(Vivify) then
            FocusTea("Auto", "Vivify");
            ManaTeaTalent("Auto", "Vivify");
            MistDelay, SoothingUnit = module.GetTime() + Vivify:CastTime() + 0.3, VivifyUpliftingTranceUnit;
            VivifyUpliftingTranceUnit:Cast(Vivify);
            return;
        end








        -- Vivify
        if module.IsOptionEnabled("Vivify") and VivifyUnit and VivifyUnit:CanCast(Vivify) then
            FocusTea("Auto", "Vivify");
            ManaTeaTalent("Auto", "Vivify");
            MistDelay, SoothingUnit = module.GetTime() + Vivify:CastTime() + 0.3, VivifyUnit;
            VivifyUnit:Cast(Vivify);
            return;
        end
        -- Chi Burst
        if ChiBurst:Exists() and module.IsOptionEnabled("Chi Burst") and ChiBurstCount >= module.GetOptionValue("Chi Burst") and Player:CanCast(ChiBurst) then
            Player:Cast(ChiBurst);
            return;
        end
        -- Zen Pulse
        if ZenPulse:Exists() and module.IsOptionEnabled("Zen Pulse") then
            if MainTank and ZenPulseMainTankCount >= module.GetOptionValue("Zen Pulse") and MainTank:CanCast(ZenPulse) then
                MainTank:Cast(ZenPulse);
                return;
            end
            if OffTank and ZenPulseOffTankCount >= module.GetOptionValue("Zen Pulse") and OffTank:CanCast(ZenPulse) then
                OffTank:Cast(ZenPulse);
                return;
            end
            if Lowest and ZenPulseLowestCount >= module.GetOptionValue("Zen Pulse") and Lowest:CanCast(ZenPulse) then
                Lowest:Cast(ZenPulse);
                return;
            end
        end
        -- Effuse - Tanks
        if Effuse:Exists() and module.IsOptionEnabled("Effuse") and not Player:IsMoving() then
            if MainTank and SoothingUnitGUID ~= MainTank:GUID() and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Effuse") and MainTank:SpecialHealthPercentage() <= SoothingUnitHealth - 15 and MainTank:CanCast(Effuse) then
                module.Bug("Effuse - Main Tank");
                FocusTea("Auto", "Effuse");
                MistDelay, SoothingUnit = module.GetTime() + Effuse:CastTime() + 0.3, MainTank;
                MainTank:Cast(Effuse);
                return;
            end
            if OffTank and SoothingUnitGUID ~= OffTank:GUID() and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Effuse") and OffTank:SpecialHealthPercentage() <= SoothingUnitHealth - 15 and OffTank:CanCast(Effuse) then
                module.Bug("Effuse - Offtank");
                FocusTea("Auto", "Effuse");
                MistDelay, SoothingUnit = module.GetTime() + Effuse:CastTime() + 0.3, OffTank;
                OffTank:Cast(Effuse);
                return;
            end
        end
    -- Bad Debuffs - Tank
        if RenewingMist:Exists() and module.IsOptionEnabled("Tank Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Tanks do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Tanks[i], CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(RenewingMist) and not ThisUnit:Buff(RenewingMist) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Tank Debuffs") then
                FocusTea("Auto", "Renewing Mist");
                module.Bug("Renewing Mist on " .. BestUnit:Name() .. " to heal tank debuff");
                BestUnit:Cast(RenewingMist);
                return;
            end
        end
    -- Bad Debuffs - Debuffs
        if RenewingMist:Exists() and module.IsOptionEnabled("Raid Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Debuff do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Debuff[i], CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(RenewingMist) and not ThisUnit:Buff(RenewingMist) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Raid Debuffs") then
                FocusTea("Auto", "Renewing Mist");
                module.Bug("Renewing Mist on " .. BestUnit:Name() .. " to mitigate debuff");
                BestUnit:Cast(RenewingMist);
                return;
            end
        end
    -- Bad Debuffs - Topping
        if module.IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Top do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Top[i], CurrentBadDebuffs.Top[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Effuse) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil then
                if RenewingMist:Exists() and BestUnitHealth <= module.GetOptionValue("Topping") and not BestUnit:Buff(RenewingMist) and BestUnit:CanCast(RenewingMist) then
                    FocusTea("Auto", "Renewing Mist");
                    module.Bug("Renewing Mist on " .. BestUnit:Name() .. " to top it");
                    BestUnit:Cast(RenewingMist);
                    return;
                end
                if EnvelopingMist:Exists() and BestUnitHealth <= module.GetOptionValue("Topping") and not BestUnit:Buff(EnvelopingMist) and BestUnit:CanCast(EnvelopingMist) then
                    FocusTea("Auto", "Enveloping Mist");
                    module.Bug("Enveloping Mist on " .. BestUnit:Name() .. " to top it");
                    MistDelay, SoothingUnit = module.GetTime() + Effuse:CastTime() + 0.3, BestUnit;
                    BestUnit:Cast(EnvelopingMist);
                    return;
                end
                if Effuse:Exists() and SoothingUnitGUID ~= BestUnit:GUID() and BestUnitHealth <= module.GetOptionValue("Topping") and BestUnit:CanCast(Effuse) then
                    FocusTea("Auto", "Effuse");
                    module.Bug("Effuse on " .. BestUnit:Name() .. " to top it");
                    MistDelay, SoothingUnit = module.GetTime() + Effuse:CastTime() + 0.3, BestUnit;
                    BestUnit:Cast(Effuse);
                    return;
                end
            end
        end
    -- Low Priority Healing
        -- Effuse
        if Effuse:Exists() and module.IsOptionEnabled("Effuse") then
            if Lowest and SoothingUnitGUID ~= Lowest:GUID() and Lowest:SpecialHealthPercentage() <= module.GetOptionValue("Effuse") and Lowest:SpecialHealthPercentage() <= SoothingUnitHealth - 25 and Lowest:CanCast(Effuse) then
                module.Bug("Effuse - Low Prio");
                MistDelay, SoothingUnit = module.GetTime() + Effuse:CastTime() + 0.3, Lowest;
                Lowest:Cast(Effuse);
                return;
            end
        end
        -- Effuse Filler
        if Effuse:Exists() and module.IsOptionEnabled("Effuse") and MainTank and MainTankTanking and SoothingUnitGUID ~= MainTank:GUID() and MainTank:CanCast(Effuse) then
            module.Bug("Effuse - Filler");
            MistDelay, SoothingUnit = module.GetTime() + Effuse:CastTime() + 0.3, MainTank;
            MainTank:Cast(Effuse);
            return;
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Resurrect Deads
        if module.IsOptionEnabled("Resuscitate") and Unit.ResurrectCycle(AncestralSpirit) then
            return;
        end
        if module.IsOptionEnabled("Out Of Combat Healing") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Windwalker Monk Rotation
    local Rotation = {};
    module.SetRotation(269, Rotation);

    --- Localization
    -- Core
    local Enemies_8y, Enemies_5y, NumEnemies = {}, {}, 1; -- Enemies
    local SpamPrevention, TPSTime = 0, 0.1; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local ChiBurstStanding = 0.7; -- Chi Burst Handler
    local UnitNeedRes, Lowest = nil, nil; -- OoC Res & Heal Handler

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        --- Spells
        -- (ID, RequiresFacing, Hostile, Instant, Resurrect)
        -- Racials
        ArcaneTorrent = Spell(25046, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);
        -- Items
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Common Misc
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Abilities
        BlackoutKick = Spell(100784, true, true, true);
        ChiBurst = Spell(123986, false, false, false);
        ChiWave = Spell(115098, false, true, true);
        ComboBreaker = Spell(116768, false, false, false);
        CracklingJadeLightning = Spell(117952, true, true, true);
        FistsOfFury = Spell(113656, true, true, true);
        RisingSunKick = Spell(107428, true, true, true);
        RushingJadeWind = Spell(116847, false, false, true);
        SpinningCraneKick = Spell(101546, false, false, true);
        StrikeoftheWindlord = Spell(205320, true, true, true);
        TigerPalm = Spell(100780, true, true, true);
        WhirlingDragonPunch = Spell(152175, false, false, true); -- Casted on Player like SCK, 5-8y range TBD
        -- Offensive Cooldowns
        EnergizingElixir = Spell(115288, false, false, true);
        InvokeXuen = Spell(123904, false, true, true);
        Serenity = Spell(152173, false, false, true);
        StormEarthAndFire = Spell(137639, false, true, true);
        TouchOfDeath = Spell(115080, true, true, true);
        -- Defensive Abilities
        Effuse = Spell(116694, false, false, true);
        HealingElixir = Spell(122281, false, false, true);
        Resuscitate = Spell(115178, false, false, true, true);
        -- Defensive Cooldowns
        DampenHarm = Spell(122278, false, false, true);
        DiffuseMagic = Spell(122783, false, false, true);
        -- Utility
        Detox = Spell(115450, false, false, true);
        SpearHandStrike = Spell(116705, true, true, true);


        --- GUI Frame
        -- Pages
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        module.AddCommonOptions();
        module.AddPresetOption("TargetAttack");
        module.AddPresetOption("ReTarget");
        module.AddPresetOption("BossCD");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddPresetOption("Interrupt");
        module.AddSection("General Settings", "Out of Combat", "Green");
        module.AddPresetOption("AutoResuscitate");
        module.AddPresetOption("AutoHeal");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddPresetOption("PrePot");
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Strike of the Windlord", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Strike of the Windlord."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Energizing Elixir", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Energizing Elixir."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Storm, Earth and Fire", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Storm, Earth and Fire."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Serenity", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Serenity."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Touch of Death", 223, true, {10, 0, 50, 0.5}, {2, "Always", "Cooldown Only"}, "Enable for the automatic usage of Touch of Death."..C.TOOLTIP_VALUE_1.."Set the minimum number of health in million the unit must have in order to use ToD."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Invoke Xuen", 210, true, nil, nil, "Enable for the automatic usage of Invoke Xuen, the White Tiger.");
        module.AddPresetOption("Trinket");
        module.AddPresetOption("Potion");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Chi Wave Pre-Combat", 210, true, nil, nil, "Enable to cast Chi Wave while walking to the target.");
        module.AddNewOption("Offensive Settings", "Chi Wave, Chi Burst", 220, true, {75, 40, 150, 1}, nil, "Enable for the automatic usage of Chi Wave / Chi Burst."..C.TOOLTIP_VALUE.."Set the minimum number of units that needs to be in Chi Burst path in order to use it.");
        module.AddNewOption("Offensive Settings", "Crackling Jade Lightning", 220, true, {1.3, 0.3, 3, 0.1}, nil, "Enable for the automatic usage of Crackling Jade Lightning while not moving and not being in melee range."..C.TOOLTIP_VALUE.."Set the minimum standing time to start using it.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddPresetOption("HealingItem");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddPresetOption("HoPCancel");
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "HE, DM, DH", 220, true, {45, 1, 100, 1}, nil, "Health Percentage to use Healing Elixir / Dampen Harm / Diffuse Magic.");

        --- Misc
        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
        -- Improved Spell Casting Logic
        module.ISCL = {
            [Effuse:ID()] = "Effuse",
            [Resuscitate:ID()] = "Resuscitate"
        };
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated
        Player:SetCommonMeleeStatus();
        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        if module.IsOptionEnabled("HE, DM, DH") and Player:SpecialHealthPercentage() <= module.GetOptionValue("HE, DM, DH") then
            if HealingElixir:Exists() then
                if Player:CanCast(HealingElixir) then Player:Cast(HealingElixir); end
            elseif DampenHarm:Exists() then
                if Player:CanCast(DampenHarm) then Player:Cast(DampenHarm); end
            elseif DiffuseMagic:Exists() then
                if Player:CanCast(DiffuseMagic) then Player:Cast(DiffuseMagic); end
            end
        end
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift of the Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift of the Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(SpearHandStrike, ArcaneTorrent);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(TigerPalm, false) or Unit.Target;
    end

    --- Run the rotation's in gcd combat logic.
    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Enemies Check:
            if module.UseAOE() then
                Enemies_8y = Player:EnemiesWithinDistance(8, true); -- Using 8y (real range) for SCK & RJW and true as they are PlayerCenteredAoE Spells.
                Enemies_5y = Player:FilterEnemiesByDistance(Enemies_8y, 5, false); -- This table is used for Melee Range Cycling Abilities.
                NumEnemies = #Enemies_8y;
            else
                NumEnemies = 1;
            end
            -- Cooldowns
            if Player:IsWithinCastRange(Target, TigerPalm) then
                if module.CooldownsAllowed() then
                    -- Invoke Xuen
                    if module.IsOptionEnabled("Invoke Xuen") and InvokeXuen:Exists() and Target:CanCast(InvokeXuen) then
                        Target:Cast(InvokeXuen);
                        return;
                    end
                    -- Trinkets
                    if Trinket1:IsUsableInventory() and module.GetOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket1:UseInventory();
                    end
                    if Trinket2:IsUsableInventory() and module.GetSecondOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket2:UseInventory();
                    end
                end
                -- Touch of Death
                if module.IsOptionEnabled("Touch of Death") and (module.CooldownsAllowed() or module.GetSecondOptionValue("Touch of Death") == "Always") and Target:Health() >= module.GetOptionValue("Touch of Death")*1000000 and Target:CanCast(TouchOfDeath) then
                    Target:Cast(TouchOfDeath);
                    return;
                end
                -- Serenity
                if module.IsOptionEnabled("Serenity") and (module.CooldownsAllowed() or module.GetOptionValue("Serenity") == "Always") and Serenity:Exists() and Player:CanCast(Serenity) then
                    Player:Cast(Serenity);
                    return;
                end
                -- Energizing Elixir
                if module.IsOptionEnabled("Energizing Elixir") and (module.CooldownsAllowed() or module.GetOptionValue("Energizing Elixir") == "Always") and EnergizingElixir:Exists() and Player:Chi() == 0 and Player:Power() < Player:PowerMax() and not Player:Buff(Serenity) and Player:CanCast(EnergizingElixir) then
                    Player:Cast(EnergizingElixir);
                    return;
                end
                -- Energizing Elixir
                if module.IsOptionEnabled("Storm, Earth and Fire") and (module.CooldownsAllowed() or module.GetOptionValue("Storm, Earth and Fire") == "Always") and not Player:Buff(StormEarthAndFire) and Target:CanCast(StormEarthAndFire) then
                    Target:Cast(StormEarthAndFire);
                    return;
                end
            end
            -- Fists of Fury
            if Target:CanCast(FistsOfFury) then
                Target:Cast(FistsOfFury);
                return;
            end
            -- Whirling Dragon Punch
            if Player:CanCast(WhirlingDragonPunch) then
                Player:Cast(WhirlingDragonPunch);
                return;
            end
            -- Rushing Jade Wind
            if RushingJadeWind:Exists() and (Player:Chi() > 1 or Player:Buff(Serenity)) and Player:CanCast(RushingJadeWind) then
                Player:Cast(RushingJadeWind);
                return;
            end
            -- Rising Sun Kick
            if Target:CanCast(RisingSunKick) then
                Target:Cast(RisingSunKick);
                return;
            end
            -- Chi Burst
            if module.IsOptionEnabled("Chi Wave, Chi Burst") and ChiBurst:Exists() and Player:Standing() >= ChiBurstStanding and Target:CanCast(ChiBurst) and #Player:UnitsInFrontRectangle(40, 5) >= module.GetOptionValue("Chi Wave, Zen Sphere, Chi Burst") then
                Target:Cast(ChiBurst);
                return;
            end
            -- Blackout Kick
            if not BlackoutKick:WasLastCast() and (Player:Chi() > 1 or Player:Buff(ComboBreaker) or Player:Buff(Serenity)) and Target:CanCast(BlackoutKick) then
                Target:Cast(BlackoutKick);
                return;
            end
            -- Chi Wave
            if module.IsOptionEnabled("Chi Wave, Chi Burst") and ChiWave:Exists() and Player:CanCast(ChiWave) then
                Target:Cast(ChiWave);
                return;
            end
            -- Artifact (Strike of the Windlord)
            if module.IsOptionEnabled("Strike of the Windlord") and (module.CooldownsAllowed() or module.GetOptionValue("Strike of the Windlord") == "Always") and StrikeoftheWindlord:Exists() and Target:CanCast(StrikeoftheWindlord) then
                Target:Cast(StrikeoftheWindlord);
                return;
            end
            -- Spinning Crane Kick
            if Player:Chi() > 4 and Player:CanCast(SpinningCraneKick) then
                Player:Cast(SpinningCraneKick);
                return;
            end
            -- Tiger Palm
            if (not TigerPalm:WasLastCast() or Player:Chi() < 2) and Target:CanCast(TigerPalm) then
                Target:Cast(TigerPalm);
                return;
            end
            -- CracklingJadeLightning if target is out of range
            if module.IsOptionEnabled("Crackling Jade Lightning") and not Player:IsWithinCastRange(Target, TigerPalm) and not Player:Channeling(CracklingJadeLightning) and Player:Standing() >= module.GetOptionValue("Crackling Jade Lightning") and Target:CanCast(CracklingJadeLightning) then
                Target:Cast(CracklingJadeLightning);
                return;
            end
            return;
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        if Player:Standing() >= 0.7 then
            -- Auto-Resuscitate Friends
            if module.IsOptionEnabled("Auto-Resuscitate Friends") then
                UnitNeedRes = Unit.Resurrect(Resuscitate);
                if UnitNeedRes and UnitNeedRes:CanCast(Resuscitate) then
                    UnitNeedRes:Cast(Resuscitate);
                    return;
                end
                if not UnitNeedRes then Unit:ResurrectCheck(true); end
            end
            -- Auto-Heal OutOfCombat
            if module.IsOptionEnabled("Auto-Heal OutOfCombat") then
                if Player:SpecialHealthPercentage() <= module.GetOptionValue("Auto-Heal OutOfCombat") and Player:CanCast(Effuse) then
                    Player:Cast(Effuse);
                    return;
                end
                -- TODO : Add Heal on Friends
            end
        end
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- ChiWave Pre-Combat
            if module.IsOptionEnabled("Chi Wave Pre-Combat") and ChiWave:Exists() and Player:CanCast(ChiWave) and Player:DistanceTo(Target) < 15 then
                Target:Cast(ChiWave);
                return;
            end
            if Target:CanCast(TigerPalm) then
                Target:Cast(TigerPalm);
                return;
            end
        end
        return;
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Holy Paladin
    local Rotation = {};
    module.SetRotation(65, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshTables = 0, 0.1, 0; -- Combat Module Throttle
    -- Healers Specific
    local MainTank, MainTankTarget, OffTank, OffTankTarget, HealUnits, Lowest, CurrentBadDebuffs, BestTarget, ThisUnit;
    local Trinket1Units, Trinket2Units;
    -- Profile Specific
    local DispelUnit, HolyPrismUnitsTarget, HolyPrismUnitsMainTank, HolyPrismUnitsOffTank, LightOfDawnUnits, AvengingWrathUnits = nil, 0, 0, 0, 0, 0;
    local AuraMasteryUnits, TyrsDeliveranceUnits, HolyAvengerUnits = 0, 0, 0;
    local Enemies_30y, Enemies_15y, Enemies_10y, Enemies_8y, ThisSpell = {}, {}, {}, {}, nil;
    --- Initialize the rotation.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        LukewarmYakRoastBroth = Item(120293, false, false, true);
        DraenicChanneledManaPotion = Spell(156432, false, false, false);
        --Racials
        ArcaneTorrent = Spell(155145, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        AuraMastery = Spell(31821, false, false, true);
        AvengingWrath = Spell(31842, false, false, true);
        BeaconOfFaith = Spell(156910, false, false, true);
        BeaconOfLight = Spell(53563, false, false, true);
        BeaconOfTheLightbringer = Spell(197446);
        BeaconOfVirtue = Spell(200025, false, false, false);
        BestowFaith = Spell(223306, false, false, true);
        BlessingOfFreedom = Spell(1044, false, false, true);
        BlessingOfSacrifice = Spell(6940, false, false, true);
        BlessingOfProtection = Spell(1022, false, false, true);
        Cleanse = Spell(4987, false, false, true);
        Clemency = Spell(105922);
        CrusadersMight = Spell(196926);
        DivineProtection = Spell(498, false, false, true);
        DivinePurpose = Spell(197646);
        DivinePurposeDawn = Spell(216413);
        DivinePurposeShock = Spell(216411);
        DivineShield = Spell(642, false, false, true);
        FistOfJustice = Spell(105593, false, true, true);
        FlashOfLight = Spell(19750, false, false, false);
        Forbearance = Spell(25771);
        GiftOfTheNaaru = Spell(59547, false, false, true);
        HammerOfJustice = Spell(853, false, true, true);
        HolyAvenger = Spell(105809);
        HolyLight = Spell(82326, false, false, false);
        HolyPrismHeal = Spell(114165, false, false, true);
        HolyPrismDamage = Spell(114165, true, true, true);
        HolyShock = Spell(20473, false, false, true);
        HolyShockDamage = Spell(20473, true, true, true);
        InfusionOfLight = Spell(54149, false, false, true);
        JudgmentOfLight = Spell(183778);
        JudgmentOfLightDebuff = Spell(196941);
        LayOnHands = Spell(633, false, false, true);
        LightOfDawn = Spell(85222, false, false, false);
        LightOfTheMartyr = Spell(183998, false, false, true);
        LightsHammer = Spell(114158, false, false, true);
        Redemption = Spell(7328, false, false, true, true);
        RuleOfLaw = Spell(214202, false, false, true);
        SanctifiedWrath = Spell(53376);
        TyrsDeliverance = Spell(200652, false, false, false);
        -- Attacks
        Consecration = Spell(26573, false, false, true);
        CrusaderStrike = Spell(35395, true, true, true);
        HammerOfWrath = Spell(24275, true, true, true);
        Judgment = Spell(20271, true, true, true);
        JudgmentDebuff = Spell(214222);
        Rebuke = Spell(96231, true, true, true);

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Healing Settings");
        module.AddPage("Cooldowns Settings");
        module.AddPage("Offensive/Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        -- Add options to pages
        module.AddNewOption("General Settings", "Focus Assignation", 230, true, {2, "Main Tank", "Off Tank"}, nil, "Select which Tank slot should be given to the focussed unit.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Beacons (Light + Faith)", 230, true, {3, "Focus + Player", "Main + Focus", "Main + Off", "Main + Player", "Off + Focus", "Off + Player", "Player + Focus"}, nil, "Use Beacons handlers."..C.TOOLTIP_VALUE_1.."Define the two preferred units to use Beacons. If Beacon of Faith is not talented, Only the first unit will have a Beacon and the second unit will be the first fallback. Main and Off refers to the Tanks as they are displayed in the status frame."..C.TOOLTIP_HINT("If option is enabled but a valid target cannot be found to match the selection, the Beacon will fall back to the next unit in the priority. The priorities are: Main Tank, Off Tank, Focus, Player."));
        module.AddNewOption("General Settings", "Cleanse", 232, false, {1, "Auto", "High", "Normal"}, {0.2, 0, 1, 0.1}, "Use Cleanse to Dispel bad debuffs on allied units."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Auto").."Dispel Active Dispel Raid debuffs as High Priority and other not listed debuffs as Normal Priority."..C.TOOLTIP_SUBVALUE("High").."Dispel all debuffs as High Priority even before urgent cooldowns."..C.TOOLTIP_SUBVALUE("Normal").."Dispel all debuffs as Normal Priority after urgent cooldowns."..C.TOOLTIP_VALUE_2.."Define how long you want to wait before dispelling to look more human. This does not apply to Active Dispels Raid debuffs which will always be as soon as Global Cooldown ends."..C.TOOLTIP_HINT("Active Raid Dispels are based on an hardcoded list. Please report of any dispels you may encounter that requires specific strategies so that they can be properly added to the list."));
        module.AddNewOption("General Settings", "Redemption", 210, true, nil, nil, "Enable to use Redemption on dead friendly players while out of combat.");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Hammer Of Justice", 210, true, nil, nil, "Use Hammer of Justice to stun non-boss casting units");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {40, 20, 90, 5, 20}, {60}, "Will use Rebuke to interrupt the target when its cast time meets this % range.");
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range. "..C.TOOLTIP_HINT("Works only if Interrupt between % is enabled."));
        module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Healing Settings", "Common Healing Thresholds", "Green");
        module.AddNewOption("Healing Settings", "Bestow Faith", 222, true, {70, 0, 100, 1}, {50, 0, 100, 1}, "Use Bestow Faith."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Flash Of Light", 222, true, {50, 0, 100, 1}, {35, 0, 100, 1}, "Use Flash of Light."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Holy Light", 222, true, {90, 0, 100, 1}, {80, 0, 100, 1}, "Use Holy Light."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Holy Shock", 222, true, {95, 0, 100, 1}, {90, 0, 100, 1}, "Use Holy Shock."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Holy Prism", 222, true, {4, 1, 5, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Infusion Of Light", 230, false, {2, "Flash Of Light", "Holy Light"}, nil, "Enable to define a favorite spell to use with Infusion of Light procs. Disable to let the profile work as usual regarding of procs."..C.TOOLTIP_VALUE.."Choose which spell you want to use with Infusion of Light procs.");
        module.AddNewOption("Healing Settings", "Light's Hammer", 222, true, {3, 1, 10, 1}, {70, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Light Of Dawn", 222, true, {3, 1, 6, 1}, {92, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Light Of The Martyr", 222, true, {40, 0, 100, 1}, {25, 0, 100, 1}, "Use Light Of The Martyr."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Light Of The Martyr Options", 132, true, {1, "Anytime", "While Moving"}, {55, 0, 100, 1}, "More Light Of The Martyr options."..C.TOOLTIP_VALUE_1.."Define if you want to only use it while moving or anytime."..C.TOOLTIP_VALUE_2.."Player minimum Health threshold.");
        module.AddNewOption("Healing Settings", "Out Of Combat Healing", 210, true, nil, nil, "Allow Healing while Out of Combat.");
        module.AddSection("Healing Settings", "Active Healing", "Green");
        module.AddNewOption("Healing Settings", "Heal Target", 230, false, {1, "Known Unit", "Any Unit"}, nil, "Heal our current target if it is listed to be healed."..C.TOOLTIP_VALUE.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Known Unit").."Allow Heal Target to be used only when we are targetting a unit listed for it."..C.TOOLTIP_SUBVALUE("Any Unit").."Allow Heal Target to be used on any unit.");
        module.AddNewOption("Healing Settings", "Raid Debuffs", 220, true, {30, 0, 100, 1}, nil, "Use Holy Shock/Flash of Light on Debuffed units."..C.TOOLTIP_VALUE.."Helath threshold.");
        module.AddNewOption("Healing Settings", "Tank Debuffs", 220, true, {50, 0, 100, 1}, nil, "Use Holy Shock/Flash of Light on Debuffed tanks."..C.TOOLTIP_VALUE.."Helath threshold.");
        module.AddNewOption("Healing Settings", "Topping Heal", 220, true, {100, 0, 100, 1}, nil, "Use Holy Shock/Flash of Light on units to be topped."..C.TOOLTIP_VALUE.."Helath threshold.");

        module.AddSection("Cooldowns Settings", "Blessings", "Green");
        module.AddNewOption("Cooldowns Settings", "Blessing Of Protection", 232, true, {3, "Anyone", "Anyone Except Tanks", "Healers"}, {30, 1, 100, 1}, "Use Hand of Protection on a unit that has threath on it."..C.TOOLTIP_VALUE_1.."Select if you want to use Hand of Protection on Anyone, Anyone Except Tanks or only on Healers."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Blessing Of Sacrifice", 222, true, {50, 0, 100, 1}, {75, 30, 100, 1}, "Use Blessing of Sacrifice."..C.TOOLTIP_VALUE_1.."Unit Health threshold."..C.TOOLTIP_VALUE_2.."Player minimum Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Blessing Of Sacrifice Options", 133, true, {2, "Any Unit", "Tanks Only"}, {2, "Disabled", "Enabled"}, "More Blessing of Sacrifice options."..C.TOOLTIP_VALUE_1.."Which units should we consider valid for Blessing of Sacrifice."..C.TOOLTIP_VALUE_2.."Enable to sync Divine Protection with Blessing of Sacrifice.");
        module.AddSection("Cooldowns Settings", "Cooldowns", "Green");
        module.AddNewOption("Cooldowns Settings", "Aura Mastery", 222, true, {3, 1, 25, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Avenging Wrath", 222, true, {3, 1, 25, 1}, {60, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Beacon Of Virtue", 222, true, {3, 1, 5, 1}, {90, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Holy Avenger", 222, true, {3, 1, 25, 1}, {70, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Lay On Hands", 222, true, {25, 0, 100, 1}, {15, 0, 100, 1}, "Use Lay on Hands."..C.TOOLTIP_VALUE_1.."Health threshold to use on Tanks."..C.TOOLTIP_VALUE_2.."Health threshold to use on any Raid members.");
        module.AddNewOption("Cooldowns Settings", "Rule Of Law", 222, true, {4, 1, 25, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold. It will also be used without health checks if we have two charges."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Tyr's Deliverance", 222, true, {3, 1, 25, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddSection("Cooldowns Settings", "Common Cooldowns", "Green");
        module.AddNewOption("Cooldowns Settings", "Soft Cooldowns Units", 120, true, {3, 1, 25, 1}, nil, "Number of units that needs to be under thresholds to use Racials and Trinkets with Health.");
        module.AddNewOption("Cooldowns Settings", "Use Racials", 220, true, {80, 0, 100, 1}, nil, "Use Racials."..C.TOOLTIP_VALUE.."Mana threshold under which we want to use Arcane Torrent.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 1", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 1 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always") .." Use Always."..C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 2", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 2 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always") .." Use Always."..C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");

        module.AddSection("Offensive/Defensive Settings", "Offensive DPS", "Green");
        module.AddPresetOption("TargetAttack");
        module.AddNewOption("Offensive/Defensive Settings", "DPS", 220, true, {95, 0, 100, 1}, nil, "Enables DPS options."..C.TOOLTIP_VALUE.."Will only DPS if the Lowest unit is above DPS health treshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Consecration", 222, true, {2, 1, 10, 1}, {1, 1, 10, 1}, "Use Consecration."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be within 8 yards of Player to use as High Priority."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be within 8 yards of Player to use as Low Priority."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Crusader Strike", 210, true, nil, nil, "Use Crusader Strike in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Hammer Of Wrath", 210, false, nil, nil, "Use Hammer Of Wrath in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Holy Prism Damage", 222, true, {3, 1, 5, 1}, {100, 1, 100, 1}, "Use Holy Prism on Player."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be within 15 yards of Player to use.."..C.TOOLTIP_VALUE_2.."Health Threshold to use on player."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Holy Shock Damage", 210, false, nil, nil, "Use Holy shock in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Light's Hammer Damage", 222, true, {3, 1, 10, 1}, {100, 1, 100, 1}, "Use Light's Hammer on Player."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be within 10 yards of Player to use.."..C.TOOLTIP_VALUE_2.."Health Threshold to use on player."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Judgment", 210, true, nil, nil, "Use Judgment in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddSection("Offensive/Defensive Settings", "Offensive Healing", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Crusader's Might", 230, true, {1, "Auto", "High Priority", "Low Priority"}, nil, "Use Crusader Strike to lower remaining Cooldown on Holy Shock and Light of Dawn."..C.TOOLTIP_VALUE_1.."Select High Priority to do this very soon in the rotation or Low Priority to use as filler. Auto will use as High Priority if we have two charges of Crusader Strike and as Low Priority if we have only one charge."..C.TOOLTIP_HINT("This will be used regardless of Offensive DPS settings."));
        module.AddNewOption("Offensive/Defensive Settings", "Judgment Of Light", 233, true, {1, "Auto", "Focus", "Main Tank", "Off Tank", "Target"}, {1, "High Priority", "Low Priority"}, "Use Judgment to apply Judgment of Light."..C.TOOLTIP_VALUE_1.."Select which unit you want to apply Judgment of Light on."..C.TOOLTIP_SUBVALUE("Auto").."Auto will apply Judgment of Light following this priority: Main Tank Target, Off Tank Target, Focus, Target. It will attempt to put it on different target if priority target is already debuffed."..C.TOOLTIP_VALUE_2.."Select High Priority to do this very soon in the rotation or Low Priority to use as filler."..C.TOOLTIP_HINT("This will be used regardless of Offensive DPS settings."));
        module.AddNewOption("Offensive/Defensive Settings", "Judgment Of Light Cycle", 222, true, {6, 1, 10, 1}, {3, 0, 25, 0.1}, "Use Judgment Of Light Cycle."..C.TOOLTIP_VALUE_1.."Amount of debuffs to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddSection("Offensive/Defensive Settings", "Defensive", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Divine Protection", 220, true, {50, 1, 100, 1}, nil, "Use Divine Protection."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Divine Shield", 220, true, {20, 1, 100, 1}, nil, "Use Divine Shield."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Gift Of The Naaru", 220, true, {30, 1, 100, 1}, nil, "Use Gift Of The Naaru on ourself."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Healers Specific
        module.AddOutput("|cFF9A2EFEMain Tank:");
        module.AddOutput("|cFF9A2EFEOff Tank:");
        module.AddOutput("|cFF9A2EFEBad Debuffs:");
        module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:Buff(DraenicChanneledManaPotion) or not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Define Main Tanks
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end


    function Rotation:Defensives ()
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Healing Item") and Player:HealthPercentage() <= module.GetOptionValue("Healing Item") then
            if HealingTonic:IsUsable() then
                Healthstone:Use(Player);
            elseif Healthstone:IsUsable() then
                HealingTonic:Use(Player);
            end
        end
        -- Divine Protection
        if DivineProtection:Exists() and module.IsOptionEnabled("Divine Protection") and Player:CanCast(DivineProtection) and Player:SpecialHealthPercentage() <= module.GetOptionValue("Divine Protection") then
            Player:Cast(DivineProtection);
        end
        -- Divine Shield
        if DivineShield:Exists() and module.IsOptionEnabled("Divine Shield") and Player:CanCast(DivineShield) and Player:SpecialHealthPercentage() <= module.GetOptionValue("Divine Shield") and not Player:DebuffAny(Forbearance) then
            Player:Cast(DivineShield);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        -- Rebuke
        Player:UseInterrupt(nil, ArcaneTorrent);
    end

    -- Hand Of Protection
    local Option1, Option2;
    local function BlessingOfProtectionHandler ()
        if module.IsOptionEnabled("Blessing Of Protection") and not BlessingOfProtection:IsOnCooldown() then
            Option1, Option2 = module.GetOptionValue("Blessing Of Protection"), module.GetSecondOptionValue("Blessing Of Protection");
            for i = 1, #HealUnits do
                ThisUnit = HealUnits[i];
                if ThisUnit:ThreatSituation() == 3 and not ThisUnit:DebuffAny(Forbearance) then
                    if (Option1 == "Anyone" or (Option1 == "Anyone Except Tanks" and not ThisUnit:IsTank()) or (Option1 == "Healers" and ThisUnit:IsHealer())) and ThisUnit:SpecialHealthPercentage() <= Option2 and ThisUnit:CanCast(BlessingOfProtection) then
                        module.Bug("Blessing of Protection on "..ThisUnit:Name());
                        ThisUnit:Cast(BlessingOfProtection);
                        return;
                    end
                end
            end
        end
    end

    -- Active Healing Heal Target handler
    local function HealTarget (ThisUnit)
        -- Holy Shock
        if HolyShock:Exists() and ThisUnit:CanHeal(HolyShock) then
            module.Bug("Heal Target - Holy Shock");
            ThisUnit:Cast(HolyShock);
            return;
        end
        -- Flash of Light
        if FlashOfLight:Exists() and ThisUnit:CanHeal(FlashOfLight) then
            module.Bug("Heal Target - Flash of Light");
            ThisUnit:Cast(FlashOfLight);
            return;
        end
    end

    -- Get Tanks Status
    local TanksStatus, MainTankTanking, OffTankTanking = {Main = {IsTanking = module.GetTime()},Off = {IsTanking = module.GetTime()}};
    local function RefreshTanksStatus ()
        TanksStatus = {
            Main = {IsTanking = MainTank and MainTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Main.IsTanking},
            Off = {IsTanking = OffTank and OffTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Off.IsTanking}
        };
        MainTankTanking = module.GetTime() - TanksStatus.Main.IsTanking < 3 or false;
        OffTankTanking = module.GetTime() - TanksStatus.Off.IsTanking < 3 or false;
    end

    local InvertBeacons, BeaconOfLightFallBack, BeaconOfFaithFallBack;
    local BeaconOption, Unit1, Unit2, Unit3, Unit4;
    local function BeaconsHandler ()
        if not BeaconOfVirtue:Exists() and module.IsOptionEnabled("Beacons (Light + Faith)") then
            InvertBeacons, BeaconOfLightFallBack, BeaconOfFaithFallBack = nil, false, false;
            -- First check The Beacon of Light
            if BeaconOfLight:Exists() and not BeaconOfLight:IsOnCooldown() then
                BeaconOption = module.GetOptionValue("Beacons (Light + Faith)");
                -- Apply Beacon to Unit1 and Unit2, if one of these cannot be found, apply to Unit3 and if no Unit3 then apply to Self
                --"Focus + Player", "Main + Focus", "Main + Off", "Main + Player", "Off + Focus", "Off + Player", "Player + Focus"
                if BeaconOption == "Focus + Player" then
                    Unit1, Unit2, Unit3, Unit4 = Focus, Player, MainTank, OffTank;
                elseif BeaconOption == "Main + Focus" then
                    Unit1, Unit2, Unit3, Unit4 = MainTank, Focus, OffTank, Player;
                elseif BeaconOption == "Main + Off" then
                    Unit1, Unit2, Unit3, Unit4 = MainTank, OffTank, Focus, Player;
                elseif BeaconOption == "Main + Player" then
                    Unit1, Unit2, Unit3, Unit4 = MainTank, Player, Focus, OffTank;
                elseif BeaconOption == "Off + Focus" then
                    Unit1, Unit2, Unit3, Unit4 = OffTank, Focus, MainTank, Player;
                elseif BeaconOption == "Off + Player" then
                    Unit1, Unit2, Unit3, Unit4 = OffTank, Player, MainTank, Focus;
                elseif BeaconOption == "Player + Focus" then
                    Unit1, Unit2, Unit3, Unit4 = Player, Focus, MainTank, OffTank;
                end
                -- Unit1
                if Unit1 and Unit1:CanHeal(FlashOfLight) then
                    InvertBeacons = Unit1:Buff(BeaconOfFaith);
                    if not InvertBeacons and not Unit1:Buff(BeaconOfLight) and Unit1:CanCast(BeaconOfLight) then
                        module.Bug("Beacon of Light - Unit1 (Normal)");
                        Unit1:Cast(BeaconOfLight);
                        return;
                    end
                else
                    BeaconOfLightFallBack = true;
                end
                -- Unit2
                if BeaconOfFaith:Exists() then
                    if Unit2 and Unit2:CanHeal(FlashOfLight) then
                        if InvertBeacons then
                            if not Unit2:Buff(BeaconOfLight) and Unit2:CanCast(BeaconOfLight) then
                                module.Bug("Beacon of Light - Unit2 (Invert Beacons)");
                                Unit2:Cast(BeaconOfLight);
                                return;
                            end
                        else
                            if not Unit2:Buff(BeaconOfFaith) and not Unit2:Buff(BeaconOfLight) and Unit2:CanCast(BeaconOfFaith) then
                                module.Bug("Beacon of Faith - Unit2 (Normal)");
                                Unit2:Cast(BeaconOfFaith);
                                return;
                            end
                        end
                    else
                        BeaconOfFaithFallBack = true;
                    end
                else
                    -- Unit2 Fall Back
                    if Unit2 and Unit2:CanHeal(FlashOfLight) then
                        if BeaconOfLightFallBack then
                            if Unit2:Buff(BeaconOfLight) then
                                BeaconOfLightFallBack = false;
                            else
                                if not Unit2:Buff(BeaconOfLight) and Unit2:CanCast(BeaconOfLight) then
                                    BeaconOfLightFallBack = false;
                                    module.Bug("Beacon of Light - Unit2 (Fall Back)");
                                    Unit2:Cast(BeaconOfLight);
                                    return;
                                end
                            end
                        end
                    end
                end
                -- Unit3 Fall Back
                if Unit3 and Unit3:CanHeal(FlashOfLight) then
                    if BeaconOfLightFallBack then
                        if Unit3:Buff(BeaconOfLight) then
                            BeaconOfLightFallBack = false;
                        else
                            if not Unit3:Buff(BeaconOfLight) and not Unit3:Buff(BeaconOfFaith) and Unit3:CanCast(BeaconOfLight) then
                                BeaconOfLightFallBack = false;
                                module.Bug("Beacon of Light - Unit3 (Fall Back)");
                                Unit3:Cast(BeaconOfLight);
                                return;
                            end
                        end
                    end
                    if BeaconOfFaithFallBack then
                        if Unit3:Buff(BeaconOfFaith) then
                            BeaconOfFaithFallBack = false;
                        else
                            if not Unit3:Buff(BeaconOfFaith) and not Unit3:Buff(BeaconOfLight) and Unit3:CanCast(BeaconOfFaith) then
                                BeaconOfFaithFallBack = false;
                                module.Bug("Beacon of Faith - Unit3 (Fall Back)");
                                Unit3:Cast(BeaconOfFaith);
                                return;
                            end
                        end
                    end
                end
                -- Unit4 Fall Back
                if Unit4 and Unit4:CanHeal(FlashOfLight) then
                    if BeaconOfLightFallBack then
                        if not Unit4:Buff(BeaconOfLight) and not Unit4:Buff(BeaconOfFaith) and Unit4:CanCast(BeaconOfLight) then
                            BeaconOfLightFallBack = false;
                            module.Bug("Beacon of Light - Unit4 (Fall Back)");
                            Unit4:Cast(BeaconOfLight);
                            return;
                        end
                    end
                    if BeaconOfFaithFallBack then
                        if not Unit4:Buff(BeaconOfFaith) and not Unit4:Buff(BeaconOfLight) and Unit4:CanCast(BeaconOfFaith) then
                            BeaconOfLightFallBack = false;
                            module.Bug("Beacon of Faith - Unit4 (Fall Back)");
                            Unit4:Cast(BeaconOfFaith);
                            return;
                        end
                    end
                end
            end
        end
    end


    local function JudgmentOfLightHandler (Priority)
        -- Judgment of Light
        if JudgmentOfLight:Exists() and module.IsOptionEnabled("Judgment Of Light") and not Judgment:IsOnCooldown() and (module.GetSecondOptionValue("Judgment Of Light") == "High Priority" or Priority ~= "High") then
            Option1 = module.GetOptionValue("Judgment Of Light");
            -- Main Tank Target
            if Option1 == "Auto" or Option1 == "Main Tank" then
                if MainTankTarget and MainTankTarget:Exists() and not MainTankTarget:Debuff(JudgmentOfLightDebuff) and MainTankTarget:CanCast(Judgment) then
                    module.Bug("Judgment Of Light - Main Tank Target");
                    MainTankTarget:Cast(Judgment);
                    return;
                end
            end
            -- Off Tank Target
            if Option1 == "Auto" or Option1 == "Off Tank" then
                if OffTankTarget and OffTankTarget:Exists() and not OffTankTarget:Debuff(JudgmentOfLightDebuff) and OffTankTarget:CanCast(Judgment) then
                    module.Bug("Judgment Of Light - Off Tank Target");
                    OffTankTarget:Cast(Judgment);
                    return;
                end
            end
            -- Focus
            if Option1 == "Auto" or Option1 == "Focus" then
                if Focus and Focus:Exists() and not Focus:Debuff(JudgmentOfLightDebuff) and Focus:CanCast(Judgment) then
                    module.Bug("Judgment Of Light - Focus");
                    Focus:Cast(Judgment);
                    return;
                end
            end
            -- Target
            if Option1 == "Auto" or Option1 == "Target" then
                if Target and Target:Exists() and not Target:Debuff(JudgmentOfLightDebuff) and Target:CanCast(Judgment) then
                    module.Bug("Judgment Of Light - Target");
                    Target:Cast(Judgment);
                    return;
                end
            end
            -- Cycle
            if module.IsOptionEnabled("Judgment Of Light Cycle") and JudgmentOfLightUnit and JudgmentOfLightUnit:CanCast(Judgment) then
                module.Bug("Judgment Of Light - Cycle");
                JudgmentOfLightUnit:Cast(Judgment);
                return;
            end
        end
    end

    local function CrusadersMightHandler (Priority)
        if CrusaderStrike:Exists() and CrusadersMight:Exists() and module.IsOptionEnabled("Crusader's Might") and not CrusaderStrike:IsOnCooldown() and (HolyShock:IsOnCooldown() or LightOfDawn:IsOnCooldown()) then
            if module.GetOptionValue("Crusader's Might") == "High Priority" or Priority == "Low" or (module.GetOptionValue("Crusader's Might") == "Auto" and ((Priority == "High" and (CrusaderStrike:Charges() >= 2 or CrusaderStrike:Charges() >= 1 and CrusaderStrike:Recharge() < 1)))) then
                if BestTarget and BestTarget:CanCast(CrusaderStrike) then
                    module.Bug("Crusader Strike - Crusader's Might "..Priority.." Priority");
                    BestTarget:Cast(CrusaderStrike);
                    return;
                end
            end
        end
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
    -- Init + Dispels

        -- Find best unit to attack
        if Target:Exists() and Target:CanCast(CrusaderStrike) then
            BestTarget = Target;
        elseif MainTankTarget and MainTankTarget:CanCast(CrusaderStrike) then
            BestTarget = MainTankTarget;
        elseif OffTankTarget and OffTankTarget:CanCast(CrusaderStrike) then
            BestTarget = OffTankTarget;
        elseif Mouseover:Exists() and Mouseover:CanCast(CrusaderStrike) then
            BestTarget = Mouseover;
        elseif MainTankTarget and MainTankTarget:CanCast(Judgment) then
            BestTarget = MainTankTarget;
        elseif OffTankTarget and OffTankTarget:CanCast(Judgment) then
            BestTarget = OffTankTarget;
        else
            BestTarget = Target;
        end

        -- Refresh tables every 0.5 seconds
        if RefreshTables < module.GetTime() then
            -- Common
            HealUnits = Player:GroupUnitsAvailableForHealing(100, true, 40, true);
            CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits);
            if CurrentBadDebuffs ~= nil then
                module.SetOutput("|cFF9A2EFEBad Debuffs:", #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff);
            end
            DispelUnit = Unit.Dispel(Cleanse);
            Lowest = Unit.Lowest(MainTank, OffTank);
            RefreshTanksStatus();
            -- Profile Specific
            AuraMasteryUnits = AuraMastery:Exists() and not AuraMastery:IsOnCooldown() and #Player:HealUnitsAround(module.GetSecondOptionValue("Aura Mastery"), 10) or 0;
            AvengingWrathUnits = AvengingWrath:Exists() and not AvengingWrath:IsOnCooldown() and #Player:HealUnitsAround(module.GetSecondOptionValue("Avenging Wrath"), 40) or 0;
            BeaconOfVirtueUnit = BeaconOfVirtue:Exists() and module.IsOptionEnabled("Beacon Of Virtue") and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Beacon Of Virtue"), module.GetSecondOptionValue("Beacon Of Virtue"), 30) or nil;
            Enemies_30y = Player:EnemiesWithinDistance(30); -- Judgment Of Light
            Enemies_15y = HolyPrismDamage:Exists() and Player:FilterEnemiesByDistance(Enemies_30y, 15, true) or {}; -- Holy Prism
            Enemies_10y = Player:FilterEnemiesByDistance(Enemies_30y, 10); -- Hammer Of Justice
            Enemies_8y = Player:FilterEnemiesByDistance(Enemies_30y, 8, true); -- Consecration
            HolyAvengerUnits = HolyAvenger:Exists() and not HolyAvenger:IsOnCooldown() and #Player:HealUnitsAround(module.GetSecondOptionValue("Holy Avenger"), 40) or 0;
            HolyPrismUnitsTarget = HolyPrismDamage:Exists() and not HolyPrismDamage:IsOnCooldown() and Target and Target:CanCast(HolyPrismDamage) and #Target:HealUnitsAround(module.GetSecondOptionValue("Holy Prism"), 15) or 0;
            HolyPrismUnitsMainTank = HolyPrismDamage:Exists() and not HolyPrismDamage:IsOnCooldown() and MainTankTarget and MainTankTarget:CanCast(HolyPrismDamage) and #MainTankTarget:HealUnitsAround(module.GetSecondOptionValue("Holy Prism"), 15) or 0;
            HolyPrismUnitsOffTank = HolyPrismDamage:Exists() and not HolyPrismDamage:IsOnCooldown() and OffTankTarget and OffTankTarget:CanCast(HolyPrismDamage) and #OffTankTarget:HealUnitsAround(module.GetSecondOptionValue("Holy Prism"), 15) or 0;
            JudgmentOfLightUnit = JudgmentOfLight:Exists() and not Judgment:IsOnCooldown() and Unit.DotCycle(Enemies_30y, Judgment, JudgmentOfLightDebuff, 40, "Judgment Of Light Cycle", false, true) or nil;
            LightOfDawnUnits = LightOfDawn:Exists() and not LightOfDawn:IsOnCooldown() and #Player:UnitsInFrontCone(BeaconOfTheLightbringer:Exists() and 19 or 15, 90, true, Player:Buff(DivinePurposeDawn) and 95 or module.GetSecondOptionValue("Light Of Dawn")) or 0;
            RuleOfLawUnits = RuleOfLaw:Exists() and not RuleOfLaw:IsOnCooldown() and #Player:HealUnitsAround(module.GetSecondOptionValue("Rule Of Law"), 60) or 0;
            TyrsDeliveranceUnits = TyrsDeliverance:Exists() and not TyrsDeliverance:IsOnCooldown() and #Player:HealUnitsAround(module.GetSecondOptionValue("Tyr's Deliverance"), 40) or 0;
            Trinket1Units = module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 1"), 40) or 0;
            Trinket2Units = module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 2"), 40) or 0;
            -- Bad Debuffs
            RefreshTables = module.GetTime() + 0.5;
        end

        -- Dispels Handling
        Player:DispelHandler(Cleanse, "Cleanse", DispelUnit, CurrentBadDebuffs.Dispel, "High");

        -- Hammer of Justice - Stun Casting
        if HammerOfJustice:Exists() and module.IsOptionEnabled("Hammer Of Justice") and not HammerOfJustice:IsOnCooldown() then
            for i = 1, #Enemies_10y do
                ThisUnit = Enemies_10y[i];
                if not ThisUnit:IsBoss() and not ThisUnit:IsDeadOrGhost() and ThisUnit:IsInCombat() and ThisUnit:CanCast(HammerOfJustice) and ThisUnit:IsCasting() and Player:CanAttack(ThisUnit) then
                    module.Bug("Hammer Of Justice - Interrupt ");
                    ThisUnit:Cast(HammerOfJustice);
                    return;
                end
            end
        end

        -- Beacons
        BeaconsHandler();
        JudgmentOfLightHandler("High");
        if BestTarget then
            -- DPS Management
            if module.IsOptionEnabled("DPS") and (not Lowest or Lowest:HealthPercentage() >= module.GetOptionValue("DPS")) and (not MainTank or MainTank:HealthPercentage() >= module.GetOptionValue("DPS")) and (not OffTank or OffTank:HealthPercentage() >= module.GetOptionValue("DPS")) and BestTarget:IsInCombat() then
                -- Consecration
                if Consecration:Exists() and module.IsOptionEnabled("Consecration") and #Enemies_8y >= module.GetOptionValue("Consecration") and Player:CanCast(Consecration) then
                    module.Bug("DPS - Consecration - High Priority");
                    Player:Cast(Consecration);
                    return;
                end
                -- Holy Prism
                if HolyPrismHeal:Exists() and module.IsOptionEnabled("Holy Prism Damage") and #Enemies_15y >= module.GetOptionValue("Holy Prism Damage") and Player:SpecialHealthPercentage() <= module.GetSecondOptionValue("Holy Prism Damage") and Player:CanCast(HolyPrismHeal) then
                    module.Bug("DPS - Holy Prism");
                    Player:Cast(HolyPrismHeal);
                    return;
                end
                -- Light's Hammer
                if LightsHammer:Exists() and module.IsOptionEnabled("Light's Hammer Damage") and not Player:IsMoving() and not IsFalling() and #Enemies_10y >= module.GetOptionValue("Light's Hammer Damage") and Player:SpecialHealthPercentage() <= module.GetSecondOptionValue("Light's Hammer Damage") and Player:CanCast(LightsHammer) then
                    module.Bug("DPS - Light's Hammer");
                    Player:Cast(LightsHammer);
                    return;
                end
                -- Judgment
                if Judgment:Exists() and module.IsOptionEnabled("Judgment") and BestTarget:CanCast(Judgment) then
                    module.Bug("DPS - Judgment");
                    BestTarget:Cast(Judgment);
                    return;
                end
                -- Hammer Of Wrath
                if HammerOfWrath:Exists() and module.IsOptionEnabled("Hammer Of Wrath") and not BestTarget:Debuff(JudgmentDebuff) and BestTarget:CanCast(HammerOfWrath) then
                    module.Bug("DPS - Hammer Of Wrath");
                    BestTarget:Cast(HammerOfWrath);
                    return;
                end
                -- Holy Shock
                if HolyShockDamage:Exists() and module.IsOptionEnabled("Holy Shock Damage") and BestTarget:CanCast(HolyShockDamage) then
                    module.Bug("DPS - Holy Shock");
                    BestTarget:Cast(HolyShockDamage);
                    return;
                end
                -- Crusader Strike
                if CrusaderStrike:Exists() and module.IsOptionEnabled("Crusader Strike") and (CrusaderStrike:Charges() == 2 or BestTarget:Debuff(JudgmentDebuff) or (CrusaderStrike:Charges() >= 1 and CrusaderStrike:Recharge() < 3)) and BestTarget:CanCast(CrusaderStrike) then
                    module.Bug("DPS - Crusader Strike");
                    BestTarget:Cast(CrusaderStrike);
                    return;
                end
                -- Hammer Of Wrath
                if HammerOfWrath:Exists() and module.IsOptionEnabled("Hammer Of Wrath") and BestTarget:CanCast(HammerOfWrath) then
                    module.Bug("DPS - Hammer Of Wrath");
                    BestTarget:Cast(HammerOfWrath);
                    return;
                end
                -- Consecration - Low Priority
                if Consecration:Exists() and module.IsOptionEnabled("Consecration") and #Enemies_8y >= module.GetSecondOptionValue("Consecration") and Player:CanCast(Consecration) then
                    module.Bug("DPS - Consecration - Low Priority");
                    Player:Cast(Consecration);
                    return;
                end
            end
        end
    -- Cooldowns

        if module.CooldownsAllowed() and Player:IsInCombat() then
            -- Racials with Specific Handlers
            if module.IsOptionEnabled("Use Racials") then
                if ArcaneTorrent:Exists() and Player:PowerPercentage() < module.GetOptionValue("Use Racials") and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent);
                    return;
                end
            end
            -- Trinkets with specific handlers
            if module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 1"), module.GetSecondOptionValue("Use Trinket 1");
                if Option1 == "Always" or (Option1 == "Health" and Trinket1Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 1")) then
                    Trinket1:UseInventory();
                end
            end
            if module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 2"), module.GetSecondOptionValue("Use Trinket 2");
                if Option1 == "Always" or (Option1 == "Health" and Trinket2Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 2")) then
                    Trinket2:UseInventory();
                end
            end

            -- Rule of Law
            if RuleOfLaw:Exists() and module.IsOptionEnabled("Rule Of Law") and RuleOfLaw:TimeSinceCast() >= 10 and (RuleOfLawUnits >= module.GetOptionValue("Rule Of Law") or RuleOfLaw:Charges() >= 2) and Player:CanCast(RuleOfLaw) then
                RuleOfLaw.LastCastTime = module.GetTime();
                Player:Cast(RuleOfLaw);
            end

            -- Avenging Wrath
            if AvengingWrath:Exists() and module.IsOptionEnabled("Avenging Wrath") and AvengingWrathUnits >= module.GetOptionValue("Avenging Wrath") and Player:CanCast(AvengingWrath) then
                Player:Cast(AvengingWrath);
            end

            -- Holy Avenger
            if HolyAvenger:Exists() and module.IsOptionEnabled("Holy Avenger") and HolyAvengerUnits >= module.GetOptionValue("Holy Avenger") and Player:CanCast(HolyAvenger) then
                Player:Cast(HolyAvenger);
            end

            -- Aura Mastery
            if AuraMastery:Exists() and module.IsOptionEnabled("Aura Mastery") and AuraMasteryUnits >= module.GetOptionValue("Aura Mastery") and Player:CanCast(AuraMastery) then
                Player:Cast(AuraMastery);
            end

            -- Lay on Hands
            if LayOnHands:Exists() and module.IsOptionEnabled("Lay On Hands") then
                if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Lay On Hands") and not MainTank:DebuffAny(Forbearance) and MainTank:CanHeal(LayOnHands) then
                    module.Bug("Lay On Hands - MainTank");
                    MainTank:Cast(LayOnHands);
                    return;
                end
                if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Lay On Hands") and not OffTank:DebuffAny(Forbearance) and OffTank:CanHeal(LayOnHands) then
                    module.Bug("Lay On Hands - OffTank");
                    OffTank:Cast(LayOnHands);
                    return;
                end
                if Lowest and Lowest:SpecialHealthPercentage() < module.GetSecondOptionValue("Lay On Hands") and not Lowest:DebuffAny(Forbearance) and Lowest:CanHeal(LayOnHands) then
                    module.Bug("Lay On Hands - Lowest");
                    Lowest:Cast(LayOnHands);
                    return;
                end
            end

            -- Blessing of Sacrifice
            if BlessingOfSacrifice:Exists() and module.IsOptionEnabled("Blessing Of Sacrifice") and Player:SpecialHealthPercentage() >= module.GetSecondOptionValue("Blessing Of Sacrifice") then
                -- Sync with Divine Protection if option is enabled
                local function DivineProtectionHandler ()
                    if module.GetSecondOptionValue("Blessing Of Sacrifice Options") == "Enabled" and Player:CanCast(DivineProtection) then
                        Player:Cast(DivineProtection);
                    end
                end
                -- MainTank
                if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Blessing Of Sacrifice") and not MainTank:BuffAny(BlessingOfFreedom) and not MainTank:BuffAny(BlessingOfProtection) and not MainTank:BuffAny(BlessingOfSacrifice) and MainTank:CanCast(BlessingOfSacrifice) then
                    DivineProtectionHandler();
                    module.Bug("Blessing Of Sacrifice - MainTank");
                    MainTank:Cast(BlessingOfSacrifice);
                    return;
                end
                -- OffTank
                if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Blessing Of Sacrifice") and not OffTank:BuffAny(BlessingOfFreedom) and not OffTank:BuffAny(BlessingOfProtection) and not OffTank:BuffAny(BlessingOfSacrifice) and OffTank:CanCast(BlessingOfSacrifice) then
                    DivineProtectionHandler();
                    module.Bug("Blessing Of Sacrifice - OffTank");
                    OffTank:Cast(BlessingOfSacrifice);
                    return;
                end
                -- Any Unit with option
                if module.GetOptionValue("Blessing Of Sacrifice") == "Any Unit" and Lowest and Lowest:SpecialHealthPercentage() <= module.GetOptionValue("Blessing Of Sacrifice") and not Lowest:BuffAny(BlessingOfFreedom) and not Lowest:BuffAny(BlessingOfProtection) and not Lowest:BuffAny(BlessingOfSacrifice) and Lowest:CanCast(BlessingOfSacrifice) then
                    DivineProtectionHandler();
                    module.Bug("Blessing Of Sacrifice - OffTank");
                    Lowest:Cast(BlessingOfSacrifice);
                    return;
                end
            end

            BlessingOfProtectionHandler();

            -- Tyr's Deliverance
            if TyrsDeliverance:Exists() and module.IsOptionEnabled("Tyr's Deliverance") and TyrsDeliveranceUnits >= module.GetOptionValue("Tyr's Deliverance") and Player:CanCast(TyrsDeliverance) then
                Player:Cast(TyrsDeliverance);
                return;
            end
        end
        -- Dispels Handling
        Player:DispelHandler(Cleanse, "Cleanse", DispelUnit, CurrentBadDebuffs.Dispel, "Normal");

    -- Active Healing
    -- Active Healing Heal Target handler
        if Target:CanHeal(FlashOfLight) and module.IsOptionEnabled("Heal Target") and (module.GetOptionValue("Heal Target") == 2 or (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed())) then
            HealTarget(Target);
            return;
        end
    -- Healing Rotation
        -- Beacon Of Virtue
        if BeaconOfVirtue:Exists() and module.IsOptionEnabled("Beacon Of Virtue") then
            if BeaconOfVirtueUnit and BeaconOfVirtueUnit:CanCast(BeaconOfVirtue) then
                BeaconOfVirtueUnit:Cast(BeaconOfVirtue);
                return;
            end
        end

        -- Divine Purpose - Light Of Dawn - 216413
        if LightOfDawn:Exists() and Player:Buff(DivinePurposeDawn) and module.IsOptionEnabled("Light Of Dawn") and (LightOfDawnUnits >= module.GetOptionValue("Light Of Dawn") or Player:BuffRemains(DivinePurposeDawn) < 3) and Player:CanCast(LightOfDawn) then
            module.Bug("Light of Dawn - Divine Purpose");
            Player:Cast(LightOfDawn);
            return;
        end

        -- Divine Purpose - Holy Shock - 216411
        if HolyShock:Exists() and Player:Buff(DivinePurposeShock) and module.IsOptionEnabled("Holy Shock") and Player:BuffRemains(DivinePurposeShock) < 3 then
            if MainTank and MainTank:SpecialHealthPercentage() <= 95 and MainTank:CanHeal(HolyShock) then
                MainTank:Cast(HolyShock);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= 95 and OffTank:CanHeal(HolyShock) then
                OffTank:Cast(HolyShock);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= 95 and Lowest:CanHeal(HolyShock) then
                Lowest:Cast(HolyShock);
                return;
            end
        end

        -- Holy Prism on Target / MainTank Target / OffTank Target
        if HolyPrismDamage:Exists() and module.IsOptionEnabled("Holy Prism") then
            local BestPrismUnits = HolyPrismUnitsTarget >= HolyPrismUnitsMainTank and HolyPrismUnitsTarget >= HolyPrismUnitsOffTank and HolyPrismUnitsTarget or HolyPrismUnitsMainTank > HolyPrismUnitsTarget and HolyPrismUnitsMainTank >= HolyPrismUnitsOffTank and HolyPrismUnitsMainTank or HolyPrismUnitsOffTank > HolyPrismUnitsTarget and HolyPrismUnitsOffTank >= HolyPrismUnitsMainTank and HolyPrismUnitsOffTank;
            local HolyPrismUnitsValue, HolyPrismHealthValue = module.GetOptionValue("Holy Prism"), module.GetSecondOptionValue("Holy Prism");
            if BestPrismUnits >= module.GetOptionValue("Holy Prism") then
                if HolyPrismUnitsTarget >= BestPrismUnits then
                    Target:Cast(HolyPrismDamage);
                    return;
                elseif MainTankTarget and HolyPrismUnitsMainTank >= BestPrismUnits then
                    MainTankTarget:Cast(HolyPrismDamage);
                    return;
                elseif OffTankTarget and HolyPrismUnitsOffTank >= BestPrismUnits then
                    OffTankTarget:Cast(HolyPrismDamage);
                    return;
                end
            end
        end

        -- Light Of Dawn
        if LightOfDawn:Exists() and module.IsOptionEnabled("Light Of Dawn") and LightOfDawnUnits >= module.GetOptionValue("Light Of Dawn") and Player:CanCast(LightOfDawn) then
            module.Bug("Light of Dawn - Divine Purpose");
            Player:Cast(LightOfDawn);
            return;
        end

        -- Holy Shock
        if HolyShock:Exists() and module.IsOptionEnabled("Holy Shock") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Holy Shock") and MainTank:CanHeal(HolyShock) then
                MainTank:Cast(HolyShock);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Holy Shock") and OffTank:CanHeal(HolyShock) then
                OffTank:Cast(HolyShock);
                return;
            elseif  Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Holy Shock") and Lowest:CanHeal(HolyShock) then
                Lowest:Cast(HolyShock);
                return;
            end
        end

        -- Light Of The Martyr
        if LightOfTheMartyr:Exists() and module.IsOptionEnabled("Light Of The Martyr") and (module.GetOptionValue("Light Of The Martyr Options") == "Anytime" or Player:IsMoving()) and Player:HealthPercentage() >= module.GetSecondOptionValue("Light Of The Martyr Options") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetSecondOptionValue("Light Of The Martyr") and MainTank:GUID() ~= Player:GUID() and MainTank:CanHeal(LightOfTheMartyr) then
                MainTank:Cast(LightOfTheMartyr);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetSecondOptionValue("Light Of The Martyr") and OffTank:GUID() ~= Player:GUID() and OffTank:CanHeal(LightOfTheMartyr) then
                OffTank:Cast(LightOfTheMartyr);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetOptionValue("Light Of The Martyr") and Lowest:GUID() ~= Player:GUID() and Lowest:CanHeal(LightOfTheMartyr) then
                Lowest:Cast(LightOfTheMartyr);
                return;
            end
        end

        -- Bestow Faith
        if BestowFaith:Exists() and module.IsOptionEnabled("Bestow Faith") and not BestowFaith:IsOnCooldown() then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Bestow Faith") and MainTank:CanHeal(BestowFaith) then
                MainTank:Cast(BestowFaith);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Bestow Faith") and OffTank:CanHeal(BestowFaith) then
                OffTank:Cast(BestowFaith);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Bestow Faith") and Lowest:CanHeal(BestowFaith) then
                Lowest:Cast(BestowFaith);
                return;
            end
        end

        CrusadersMightHandler("High");

        -- Light's Hammer
        if LightsHammer:Exists() and module.IsOptionEnabled("Light's Hammer") and Player:CanCast(LightsHammer) then
            local ValueLightsHammer = module.GetSecondOptionValue("Light's Hammer");
            local BestHealUnits = {};
            for i = 1, #HealUnits do
                local ThisUnit = HealUnits[i]
                if ThisUnit:CanHeal(HolyLight) and not ThisUnit:IsMoving() then
                    TheseHealUnits = ThisUnit:GroupUnitsAvailableForHealing(ValueLightsHammer, true, 12, true);
                    if #TheseHealUnits >= module.GetOptionValue("Light's Hammer") and #TheseHealUnits > #BestHealUnits then
                        BestHealUnits = TheseHealUnits;
                    end
                end
            end
            if #BestHealUnits >= module.GetOptionValue("Light's Hammer") then
                Player:CastGroundHeal(LightsHammer, BestHealUnits);
                return;
            end
        end

        JudgmentOfLightHandler("Low");

        -- Flash Of Light
        if FlashOfLight:Exists() and module.IsOptionEnabled("Flash Of Light") then
            ThisSpell = Player:Buff(InfusionOfLight) and module.IsOptionEnabled("Infusion Of Light") and module.GetOptionValue("Infusion Of Light") == "Holy Light" and HolyLight or FlashOfLight;
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Flash Of Light") and MainTank:CanHeal(ThisSpell) then
                MainTank:Cast(ThisSpell);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Flash Of Light") and OffTank:CanHeal(ThisSpell) then
                OffTank:Cast(ThisSpell);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Flash Of Light") and Lowest:CanHeal(ThisSpell) then
                Lowest:Cast(ThisSpell);
                return;
            end
        end

    -- Bad Debuffs - Tank
        if module.IsOptionEnabled("Tank Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            local BestHoTUnit, BestHoTUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Tanks do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Tanks[i], CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(FlashOfLight) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
                if ThisUnit:CanCast(FlashOfLight) and (BestHoTUnit == nil or ThisUnitHealth < BestHoTUnitHealth) then
                    BestHoTUnit, BestHoTUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if module.IsOptionEnabled("Tank Debuffs") and BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Tank Debuffs") then
                if BestUnit:CanCast(HolyShock) and ShouldShock then
                    BestUnit:Cast(HolyShock);
                    module.Bug("Holy Shock on "..BestUnit:Name().." to heal debuff");
                    return;
                end
                if BestUnit:CanCast(FlashOfLight) then
                    BestUnit:Cast(FlashOfLight);
                    module.Bug("Flash Of Light on "..BestUnit:Name().." to heal debuff");
                    return;
                end
            end
        end
    -- Bad Debuffs - Debuffs
        if module.IsOptionEnabled("Raid Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            local BestHoTUnit, BestHoTUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Debuff do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Debuff[i], CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(FlashOfLight) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
                if ThisUnit:CanCast(FlashOfLight) and (BestHoTUnit == nil or ThisUnitHealth < BestHoTUnitHealth) then
                    BestHoTUnit, BestHoTUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if module.IsOptionEnabled("Raid Debuffs") and BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Raid Debuffs") then
                if BestUnit:CanCast(HolyShock) and ShouldShock then
                    BestUnit:Cast(HolyShock);
                    module.Bug("Holy Shock on "..BestUnit:Name().." to heal debuff");
                    return;
                end
                if BestUnit:CanCast(FlashOfLight) then
                    BestUnit:Cast(FlashOfLight);
                    module.Bug("Flash Of Light on "..BestUnit:Name().." to heal debuff");
                    return;
                end
            end
        end

        -- Bad Debuffs - Topping
        if module.IsOptionEnabled("Active Healing") and module.IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Top do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Top[i], CurrentBadDebuffs.Top[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(FlashOfLight) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil then
                if module.IsOptionEnabled("Topping Heal") and BestUnitHealth <= module.GetOptionValue("Topping Heal") then
                    if BestUnit:CanCast(HolyShock) and ShouldShock then
                        BestUnit:Cast(HolyShock);
                        module.Bug("Holy Shock on "..BestUnit:Name().." to top it");
                        return;
                    elseif BestUnit:CanCast(FlashOfLight) then
                        BestUnit:Cast(FlashOfLight);
                        module.Bug("Flash Of Light on "..BestUnit:Name().." to top it");
                        return;
                    end
                end
            end
        end

        CrusadersMightHandler("Low");

        -- Holy Light
        if HolyLight:Exists() and module.IsOptionEnabled("Holy Light") then
            ThisSpell = Player:Buff(InfusionOfLight) and module.IsOptionEnabled("Infusion Of Light") and module.GetOptionValue("Infusion Of Light") == "Flash Of Light" and FlashOfLight or HolyLight;
            if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Holy Light") and Lowest:CanHeal(ThisSpell) then
                Lowest:Cast(ThisSpell);
                return;
            elseif MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Holy Light") and MainTank:CanHeal(ThisSpell) then
                MainTank:Cast(ThisSpell);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Holy Light") and OffTank:CanHeal(ThisSpell) then
                OffTank:Cast(ThisSpell);
                return;
            end
        end
        SpamPrevention = module.GetTime() + 0.2;
    end



    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Redemption
        if module.IsOptionEnabled("Redemption") and Unit.ResurrectCycle(Redemption) then
            return;
        end
        -- Proving Grounds Food
        if MainTank and MainTank:CreatureID() == 72218 and Player:PowerPercentage() < 95 and not Player:IsMoving() and LukewarmYakRoastBroth:InStock() and not LukewarmYakRoastBroth:IsOnCooldown() then
            LukewarmYakRoastBroth:Use(Player);
        end
        -- Out of Combat Healing
        if module.IsOptionEnabled("Out Of Combat Healing") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Protection Paladin
    local Rotation = {};
    module.SetRotation(66, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local Enemies_30y, Enemies_8y, TargetEnemies_8y, NumEnemies = {}, {}, {}, 0; -- Enemies

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        --Racials
        ArcaneTorrent = Spell(69179, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, resurrect)
        AegisOfLight = Spell(204150);
        ArdentDefender = Spell(31850, false, false, true);
        AvengersShield = Spell(31935, true, true, true);
        AvengingWrath = Spell(31884, false, false, true);
        BastionOfLight = Spell(204035, false, false, true);
        BlessingOfProtection = Spell(1022, false, false, true);
        BlessingOfSacrifice = Spell(6940, false, false, true);
        CleanseToxins = Spell(213644, false, false, true);
        ConsecratedHammer = Spell(203785);
        Consecration = Spell(26573, false, false, true);
        DivineShield = Spell(642, false, false, true);
        EyeOfTyr = Spell(209202, false, false, true);
        FlashOfLight = Spell(19750, false, false, false);
        Forbearance = Spell(25771);
        GuardianOfAncientKings = Spell(86659, false, false, true);
        HammerOfJustice = Spell(853, false, true, true);
        HammerOfTheRighteous = Spell(53595, true, true, true);
        HandOfReckoning = Spell(62124, false, true, true);
        HandOfTheProtector = Spell(213652, false, false, true);
        Judgment = Spell(20271, false, true, true);
        LayOnHands = Spell(633, false, false, true);
        LightOfTheProtector = Spell(184092, false, false, true);
        Rebuke = Spell(96231, true, true, true);
        Redemption = Spell(7328, false, false, false, true);
        ShieldOfTheRighteous = Spell(53600, true, true, true);
        ShieldOfTheRighteousBuff = Spell(132403);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {6, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest", "Untanked"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_SUBVALUE("Untanked").."Integrate tanking logic that will priorise the untaked units."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.TauntManagerOptions("Hand Of Reckoning");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddOption("General Settings", "Redemption", true, "Resurrect dead allies with Redemption while Out of Combat.");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Pummel to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Avenging Wrath", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Avenging Wrath."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Avenger's Shield", 130, true, {4, "Disable", "Interrupt Only", "Normal", "Optimal"}, nil, "Choose Avenger's Shield mode."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Disabled", true).."Never use Avenger's Shield."..C.TOOLTIP_SUBVALUE("Interrupt Only").."Use on the fartest unit that is casting as high priority."..C.TOOLTIP_SUBVALUE("Normal").."Use normally in the rotation but not for interrupts."..C.TOOLTIP_SUBVALUE("Optimal").."Use on the fartest unit that is casting as high priority. If there is no unit casting, use normally in the rotation.");
        module.AddNewOption("Offensive Settings", "Consecration", 220, true, {1, 1, 10, 1}, nil, "Use Consecration."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range.");
        module.AddNewOption("Offensive Settings", "Eye Of Tyr", 220, true, {100, 1, 100, 1}, nil, "Use Eye Of Tyr."..C.TOOLTIP_VALUE.."Health threshold."..C.TOOLTIP_HINT("Set to 100 to use Always."));
        module.AddNewOption("Offensive Settings", "Hammer Of The Righteous", 220, true, {3, 1, 10, 1}, nil, "Use Hammer of the Righteous as high priority."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, true, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddNewOption("Defensive Settings", "Hand Of The Protector", 220, true, {30, 1, 100, 1}, nil, "Use Hand Of The Protector on self."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Light Of The Protector", 220, true, {30, 1, 100, 1}, nil, "Use Light Of The Protector."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Shield Of The Righteous", 232, true, {2, "Normal", "Prevent Capping"}, {40, 1, 100, 1}, "Use Shield of the Righteous."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Normal", true).."Only use when health is lower than threshold."..C.TOOLTIP_SUBVALUE("Prevent Capping", true).."Use automatically as soon as we are at max charges."..C.TOOLTIP_VALUE_2.."Health threshold to use.");
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Ardent Defender", 220, true, {20, 1, 100, 1}, nil, "Use Ardent Defender."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Bastion Of Light", 210, true, nil, nil, "Use Bastion Of Light when we do not have remaining Shield Of The Righteous charges.");
        module.AddNewOption("Defensive Settings", "Guardian Of Ancient Kings", 220, true, {30, 1, 100, 1}, nil, "Use Guardian of Ancient Kings."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Hand of Protection Buff (Auto Cancel)
        HandofProtection = Spell(1022, false, false, true);
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Channeling(AegisOfLight) then
            return;
        end

        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pot BossMod") and Target:Exists() and BMPullTime() < 7 then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Rebuke, ArcaneTorrent);
    end


    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Guardian Of Ancient Kings
        if GuardianOfAncientKings:Exists() and module.IsOptionEnabled("Guardian Of Ancient Kings") and Player:HealthPercentage() <= module.GetOptionValue("Guardian Of Ancient Kings") and Player:CanCast(GuardianOfAncientKings) then
            Player:Cast(GuardianOfAncientKings);
        end
        -- Ardent Defender
        if ArdentDefender:Exists() and module.IsOptionEnabled("Ardent Defender") and Player:HealthPercentage() <= module.GetOptionValue("Ardent Defender") and Player:CanCast(ArdentDefender) then
            Player:Cast(ArdentDefender);
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end


    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(HammerOfTheRighteous, false) or Unit.Target;
        -- Bastion Of Light
        if BastionOfLight:Exists() and module.IsOptionEnabled("Bastion Of Light") and ShieldOfTheRighteous:Charges() == 0 and Player:CanCast(BastionOfLight) then
            Player:Cast(BastionOfLight);
            return;
        end
        -- Shield Of The Righteous
        if ShieldOfTheRighteous:Exists() and ShieldOfTheRighteous:TimeSinceCast() > 2 and (Player:HealthPercentage() <= module.GetSecondOptionValue("Shield Of The Righteous") or (module.GetOptionValue("Shield Of The Righteous") == "Prevent Capping" and ShieldOfTheRighteous:Charges() == 3)) and Player:BuffRemains(ShieldOfTheRighteousBuff) < 1 and Target:CanCast(ShieldOfTheRighteous) then
            Target:Cast(ShieldOfTheRighteous);
            ShieldOfTheRighteous.LastCastTime = module.GetTime();
            return;
        end
        -- Light Of The Protector
        if not HandOfTheProtector:Exists() and LightOfTheProtector:Exists() and module.IsOptionEnabled("Light Of The Protector") and Player:HealthPercentage() <= module.GetOptionValue("Light Of The Protector") and Player:CanCast(LightOfTheProtector) then
            Player:Cast(LightOfTheProtector);
            return;
        end
        -- Hand Of The Protector
        if HandOfTheProtector:Exists() and module.IsOptionEnabled("Hand Of The Protector") and Player:HealthPercentage() <= module.GetOptionValue("Hand Of The Protector") and Player:CanCast(HandOfTheProtector) then
            Player:Cast(HandOfTheProtector);
            return;
        end
    end

    function Rotation:Opening ()
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") then
            if Player:Potion("Armor", Potion) then Potion = true; end
        end
    end

    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then

            -- Enemies Check
            if module.UseAOE() then
                Enemies_30y = Player:EnemiesWithinDistance(40, false);
                Enemies_8y = Player:FilterEnemiesByDistance(Enemies_30y, 8, false);
                TargetEnemies_8y = Target:EnemiesWithinDistance(8, true);
                NumEnemies = #Enemies_8y;
            else
                NumEnemies, Enemies_8y, TargetEnemies_8y = 1, {}, {};
            end

            -- Provoke
            if Player:TauntManager(HandOfReckoning, "Hand Of Reckoning", Target, Enemies_30y) then
                return;
            end
            -- Avenger's Shield - AoE Interrupt
            if (module.GetOptionValue("Avenger's Shield") == "Optimal" or module.GetOptionValue("Avenger's Shield") == "Interrupt Only") and not AvengersShield:IsOnCooldown() then
                local FartestUnit, FartestUnitDistance, ThisUnit = nil, 0, nil;
                for i = 1, #Enemies_30y do
                    ThisUnit = Enemies_30y[i];
                    if not ThisUnit:IsDeadOrGhost() and ThisUnit:IsInCombat() and ThisUnit:IsCasting() and ThisUnit:IsInterruptible() and ThisUnit:CanCast(AvengersShield) and Player:CanAttack(ThisUnit) and (FartestUnit == nil or FartestUnitDistance < Player:DistanceTo(ThisUnit)) then
                        FartestUnit = ThisUnit;
                        FartestUnitDistance = Player:DistanceTo(ThisUnit);
                    end
                end
                if FartestUnit ~= nil then
                    module.Bug("Avenger's Shield - Interrupt");
                    FartestUnit:Cast(AvengersShield);
                    return;
                end
            end

            if Player:IsWithinCastRange(Target, HammerOfTheRighteous) then
                --- Cooldowns ---
                Player:UseTrinkets();
                -- Avenging Wrath
                if AvengingWrath:Exists() and module.IsOptionEnabled("Avenging Wrath") and (module.CooldownsAllowed() or module.GetOptionValue("Avenging Wrath") == "Always") and Player:CanCast(AvengingWrath) then
                    Player:Cast(AvengingWrath);
                    return;
                end
            end

            -- Rotation
            -- Eye Of Tyr
            if EyeOfTyr:Exists() and module.IsOptionEnabled("Eye Of Tyr") and Player:HealthPercentage() <= module.GetOptionValue("Eye Of Tyr") and Player:IsWithinCastRange(Target, ShieldOfTheRighteous) and Player:CanCast(EyeOfTyr) then
                Player:Cast(EyeOfTyr);
                return;
            end
            -- Avenger's Shield
            if AvengersShield:Exists() and (module.GetOptionValue("Avenger's Shield") == "Normal" or module.GetOptionValue("Avenger's Shield") == "Optimal") and Target:CanCast(AvengersShield) then
                Target:Cast(AvengersShield);
                return;
            end
            -- Consecration
            if Consecration:Exists() and module.IsOptionEnabled("Consecration") and NumEnemies >= module.GetOptionValue("Consecration") and Player:IsWithinCastRange(Target, ShieldOfTheRighteous) and Player:CanCast(Consecration) then
                Player:Cast(Consecration);
                return;
            end
            -- Hammer Of The Righteous
            if HammerOfTheRighteous:Exists() and module.IsOptionEnabled("Hammer Of The Righteous") and #TargetEnemies_8y >= module.GetOptionValue("Hammer Of The Righteous") and Target:CanCast(HammerOfTheRighteous) then
                Target:Cast(HammerOfTheRighteous);
                return;
            end
            -- Judgment
            if Judgment:Exists() and Target:CanCast(Judgment) then
                Target:Cast(Judgment);
                return;
            end
            -- Hammer Of The Righteous
            if HammerOfTheRighteous:Exists() and module.IsOptionEnabled("Hammer Of The Righteous") and (ConsecratedHammer:Exists() or HammerOfTheRighteous:Charges() == 2 or (HammerOfTheRighteous:Charges() == 1 and HammerOfTheRighteous:Recharge() < 2)) and Target:CanCast(HammerOfTheRighteous) then
                Target:Cast(HammerOfTheRighteous);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(HammerOfTheRighteous, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Resuscitate
        if module.IsOptionEnabled("Resuscitate") and Unit.ResurrectCycle(Redemption) then
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Retribution Paladin
    local Rotation = {};
    module.SetRotation(70, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local Enemies_8y, WakeOfAshesUnits, NumEnemies = {}, 0, 0; -- Enemies
    local MainTank, MainTankTarget, OffTank, OffTankTarget, Lowest

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        --Racials
        ArcaneTorrent = Spell(69179, false, false, true);
        GiftOfTheNaaru = Spell(59542, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, resurrect)
        AvengingWrath = Spell(31884, false, false, true);
        BladeOfJustice = Spell(184575, true, true, true);
        BladeOfWrath = Spell(202270, true, true, true);
        BlessingOfProtection = Spell(1022, false, false, true);
        CleanseToxins = Spell(213644, false, false, true);
        Consecration = Spell(205228, false, false, true);
        CrusaderStrike = Spell(35395, true, true, true);
        DivineHammer = Spell(198034, false, false, true);
        DivinePurpose = Spell(223819);
        DivineShield = Spell(642, false, false, true);
        DivineStorm = Spell(53385, false, false, true);
        ExecutionSentance = Spell(213757, true, true, true);
        EyeForAnEye = Spell(205191, false, false, true);
        FlashOfLight = Spell(19750, false, false, false);
        Forbearance = Spell(25771);
        GreaterBlessingOfKings = Spell(203538, false, false, true);
        GreaterBlessingOfMight = Spell(203528, false, false, true);
        GreaterBlessingOfWisdom = Spell(203539, false, false, true);
        HammerOfJustice = Spell(853, false, true, true);
        HandOfHindrance = Spell(183218, true, true, true);
        HandOfReckoning = Spell(62124, false, true, true);
        Judgment = Spell(20271, false, true, true);
        JudgmentDebuff = Spell(197277);
        JusticarsVengeance = Spell(215661, true, true, true);
        LayOnHands = Spell(633, false, false, true);
        Rebuke = Spell(96231, true, true, true);
        Redemption = Spell(7328, false, false, false, true);
        SanctifiedWrath = Spell(224668, false, false, true);
        ShieldOfVengeance = Spell(184662, false, false, true);
        TemplarsVerdict = Spell(85256, true, true, true);
        WakeOfAshes = Spell(205273, false, false, true);
        WordOfGlory = Spell(210191, false, false, true);
        Zeal = Spell(217020, true, true, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Greater Blessings", 210, true, nil, nil, "Apply Greater Blessings on ourself while not in combat.");
        module.AddNewOption("General Settings", "Redemption", 210, true, nil, nil, "Resurrect dead allies with Redemption while Out of Combat.");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Pummel to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Avenging Wrath", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Avenging Wrath."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Sanctified Wrath", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Sanctified Wrath."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Consecration", 220, true, {1, 1, 10, 1}, nil, "Use Consecration."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range.");
        module.AddNewOption("Offensive Settings", "Divine Storm", 220, true, {3, 1, 10, 1}, nil, "Use Divine Storm."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range.");
        module.AddNewOption("Offensive Settings", "Wake Of Ashes", 220, true, {1, 1, 10, 1}, nil, "Use Wake Of Ashes."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Flash Of Light Self", 222, true, {30, 1, 100, 1}, {80, 1, 100, 1}, "Use Healing Touch on ourself."..C.TOOLTIP_VALUE_1.."Health threshold while In Combat."..C.TOOLTIP_VALUE_2.."Health threshold while Out of Combat.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, true, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Divine Shield", 220, true, {20, 1, 100, 1}, nil, "Use Divine Shield."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Eye For An Eye", 220, true, {40, 1, 100, 1}, nil, "Use Eye For An Eye."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Lay On Hands", 222, true, {25, 0, 100, 1}, {15, 0, 100, 1}, "Use Lay on Hands." .. C.TOOLTIP_VALUE_1 .. "Health threshold to use on Tanks." .. C.TOOLTIP_VALUE_2 .. "Health threshold to use on any Raid members.");
        module.AddNewOption("Defensive Settings", "Shield Of Vengeance", 220, true, {50, 1, 100, 1}, nil, "Use Shield Of Vengeance."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Word Of Glory", 220, true, {40, 1, 100, 1}, nil, "Use Word Of Glory."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Hand of Protection Buff (Auto Cancel)
        HandofProtection = Spell(1022, false, false, true);
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:InVehicle() or Player:IsEating() then
            return;
        end
        -- Check mounted status and only return if the current mount is not the talent buff.
        if Player:IsMounted() and not Player:Buff(Spell(221883)) and not Player:Buff(Spell(221885)) and not Player:Buff(Spell(221886)) and not Player:Buff(Spell(221887)) then
            return;
        end

        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pot BossMod") and Target:Exists() and BMPullTime() < 7 then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Rebuke, ArcaneTorrent);
    end


    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Divine Shield
        if DivineShield:Exists() and module.IsOptionEnabled("Divine Shield") and Player:HealthPercentage() <= module.GetOptionValue("Divine Shield") and Player:CanCast(DivineShield) then
            Player:Cast(DivineShield);
            return;
        end
        -- Eye For An Eye
        if EyeForAnEye:Exists() and module.IsOptionEnabled("Eye For An Eye") and Player:HealthPercentage() <= module.GetOptionValue("Eye For An Eye") and Player:CanCast(EyeForAnEye) then
            Player:Cast(EyeForAnEye);
            return;
        end
        -- Shield Of Vengeance
        if ShieldOfVengeance:Exists() and module.IsOptionEnabled("Shield Of Vengeance") and Player:HealthPercentage() <= module.GetOptionValue("Shield Of Vengeance") and Player:CanCast(ShieldOfVengeance) then
            Player:Cast(ShieldOfVengeance);
            return;
        end
        -- Word Of Glory
        if WordOfGlory:Exists() and module.IsOptionEnabled("Word Of Glory") and Player:HolyPower() >= 3 and Player:HealthPercentage() <= module.GetOptionValue("Word Of Glory") and Player:CanCast(WordOfGlory) then
            Player:Cast(WordOfGlory);
            return;
        end
        -- Lay on Hands
        if module.IsOptionEnabled("Lay On Hands") then
            MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();
            Lowest = Unit.Lowest(MainTank, OffTank);
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Lay On Hands") and not MainTank:DebuffAny(Forbearance) and MainTank:CanHeal(LayOnHands) then
                module.Bug("Lay On Hands - MainTank");
                MainTank:Cast(LayOnHands);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Lay On Hands") and not OffTank:DebuffAny(Forbearance) and OffTank:CanHeal(LayOnHands) then
                module.Bug("Lay On Hands - OffTank");
                OffTank:Cast(LayOnHands);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() < module.GetSecondOptionValue("Lay On Hands") and not Lowest:DebuffAny(Forbearance) and Lowest:CanHeal(LayOnHands) then
                module.Bug("Lay On Hands - Lowest");
                Lowest:Cast(LayOnHands);
                return;
            end
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end


    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(CrusaderStrike, false) or Unit.Target;
    end

    function Rotation:Opening ()
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") then
            if Player:Potion("Strength", Potion) then Potion = true; end
        end
    end

    local function GreaterBlessings ()
        if module.IsOptionEnabled("Greater Blessings") then
            if GreaterBlessingOfKings:Exists() and Player:BuffRemains(GreaterBlessingOfKings) < 300 and Player:CanCast(GreaterBlessingOfKings) then
                Player:Cast(GreaterBlessingOfKings);
                return;
            end
            if GreaterBlessingOfWisdom:Exists() and Player:BuffRemains(GreaterBlessingOfWisdom) < 300 and Player:CanCast(GreaterBlessingOfWisdom) then
                Player:Cast(GreaterBlessingOfWisdom);
                return;
            end
            if GreaterBlessingOfMight:Exists() and Player:BuffRemains(GreaterBlessingOfMight) < 300 and Player:CanCast(GreaterBlessingOfMight) then
                Player:Cast(GreaterBlessingOfMight);
                return;
            end
        end
    end

    function Rotation:Combat ()
        -- Flash Of Light
        if FlashOfLight:Exists() and Player:Standing() > 1.5 and module.IsOptionEnabled("Flash Of Light Self") and Player:HealthPercentage() <= module.GetOptionValue("Flash Of Light Self") and Player:CanCast(FlashOfLight) then
            Player:Cast(FlashOfLight);
            return;
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then

            -- Enemies Check
            if module.UseAOE() then
                Enemies_8y = Player:EnemiesWithinDistance(8, true);
                WakeOfAshesUnits = module.IsOptionEnabled("Wake Of Ashes") and #Player:UnitsInFrontCone(12, 140) or 0; -- Frontal Cone.
                NumEnemies = #Enemies_8y;
            else
                NumEnemies, Enemies_8y, WakeOfAshesUnits = 1, {}, 1;
            end

            if Player:IsWithinCastRange(Target, CrusaderStrike) then
                --- Cooldowns ---
                Player:UseTrinkets();
                -- Avenging Wrath
                if AvengingWrath:Exists() and not SanctifiedWrath:Exists() and module.IsOptionEnabled("Avenging Wrath") and (module.CooldownsAllowed() or module.GetOptionValue("Avenging Wrath") == "Always") and Player:CanCast(AvengingWrath) then
                    Player:Cast(AvengingWrath);
                    return;
                end
                -- Sanctified Wrath
                if SanctifiedWrath:Exists() and module.IsOptionEnabled("Sanctified Wrath") and (module.CooldownsAllowed() or module.GetOptionValue("Sanctified Wrath") == "Always") and Player:CanCast(SanctifiedWrath) then
                    Player:Cast(SanctifiedWrath);
                    return;
                end
            end
            -- Rotation
            -- Judgment
            if Judgment:Exists() and Target:CanCast(Judgment) and Player:HolyPower() >= 5 then
                Target:Cast(Judgment);
                return;
            end
            if (Target:Debuff(JudgmentDebuff) and Player:HolyPower() >= 3) or Player:HolyPower() >= 5 or Player:Buff(DivinePurpose) or (Player:HolyPower() >= 3 and WakeOfAshes:Exists() and WakeOfAshesUnits >= module.GetOptionValue("Wake Of Ashes") and Player:CanCast(WakeOfAshes)) then

                -- Divine Storm
                if DivineStorm:Exists() and module.IsOptionEnabled("Divine Storm") and NumEnemies >= module.GetOptionValue("Divine Storm") and Player:CanCast(DivineStorm) then
                    Player:Cast(DivineStorm);
                    return;
                -- Execution Sentance
                elseif ExecutionSentance:Exists() and Target:CanCast(ExecutionSentance) then
                    Target:Cast(ExecutionSentance);
                    return;
                -- Justicar's Vengeance
                elseif JusticarsVengeance:Exists() and Player:Buff(DivinePurpose) and Target:CanCast(JusticarsVengeance) then
                    Target:Cast(JusticarsVengeance);
                    return;
                -- Templars Verdict
                elseif TemplarsVerdict:Exists() and Target:CanCast(TemplarsVerdict) then
                    Target:Cast(TemplarsVerdict);
                    return;
                end
            end
            -- Wake Of Ashes
            if WakeOfAshes:Exists() and Player:HolyPower() <= 1 and WakeOfAshesUnits >= module.GetOptionValue("Wake Of Ashes") and Player:CanCast(WakeOfAshes) then
                Player:Cast(WakeOfAshes);
                return;
            end
            -- Blade Of Justice
            if BladeOfJustice:Exists() and not BladeOfWrath:Exists() and not DivineHammer:Exists() and Player:HolyPower() <= 3 and Target:CanCast(BladeOfJustice) then
                Target:Cast(BladeOfJustice);
                return;
            end
            -- Blade Of Wrath
            if BladeOfWrath:Exists() and Player:HolyPower() <= 3 and Target:CanCast(BladeOfWrath) then
                Target:Cast(BladeOfWrath);
                return;
            end
            -- Divine Hammer
            if DivineHammer:Exists() and NumEnemies >= 1 and Player:CanCast(DivineHammer) then
                Player:Cast(DivineHammer);
                return;
            end
            -- Crusader Strike
            if CrusaderStrike:Exists() and not Zeal:Exists() and (CrusaderStrike:Charges() == 2 or (CrusaderStrike:Charges() == 1 and CrusaderStrike:Recharge() < 3)) and Target:CanCast(CrusaderStrike) then
                Target:Cast(CrusaderStrike);
                return;
            end
            -- Zeal
            if Zeal:Exists() and (Zeal:Charges() == 2 or (Zeal:Charges() == 1 and Zeal:Recharge() < 3)) and Target:CanCast(Zeal) then
                Target:Cast(Zeal);
                return;
            end
            -- Crusader Strike
            if CrusaderStrike:Exists() and not Zeal:Exists() and CrusaderStrike:Charges() >= 1 and Target:CanCast(CrusaderStrike) then
                Target:Cast(CrusaderStrike);
                return;
            end
            -- Zeal
            if Zeal:Exists() and Zeal:Charges() >= 1 and Target:CanCast(Zeal) then
                Target:Cast(Zeal);
                return;
            end
            -- Consecration
            if Consecration:Exists() and module.IsOptionEnabled("Consecration") and NumEnemies >= module.GetOptionValue("Consecration") and Player:IsWithinCastRange(Target, CrusaderStrike) and Player:CanCast(Consecration) then
                Player:Cast(Consecration);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(CrusaderStrike, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Blessings
        GreaterBlessings();
        -- Flash Of Light
        if FlashOfLight:Exists() and Player:Standing() > 1.5 and module.IsOptionEnabled("Flash Of Light Self") and Player:HealthPercentage() <= module.GetSecondOptionValue("Flash Of Light Self") and Player:CanCast(FlashOfLight) then
            Player:Cast(FlashOfLight);
            return;
        end
        -- Resuscitate
        if module.IsOptionEnabled("Redemption") and Unit.ResurrectCycle(Redemption) then
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Discipline Priest
    local Rotation = {};
    module.SetRotation(256, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshTables = 0, 0.1, 0; -- Combat Module Throttle
    -- Proving Grounds Handlers
    local Friendlies, LavaUnit, BlastUnit, AquaUnit2, AquaUnit
    -- Healers Specific
    local MainTank, MainTankTarget, OffTank, OffTankTarget, HealUnits, Lowest, CurrentBadDebuffs, BestTarget, DispelWait, DispelUnit;
    -- Trinkets + Racials Handlers
    local Option1, Option2, Trinket1Units, Trinket2Units, RacialsUnits;
    -- Active Healing
    local BestUnit, BestUnitHealth, BestShieldUnit, BestShieldUnitHealth, ThisUnit, ThisUnitHealth = nil, 100, nil, 100, nil, 100;
    -- Profile Specific
    local HaloUnits, HaloEmergencyUnits, CascadeUnits, DivineStarUnits, MendedPlayers, BestHealUnits, BestTank, RaptureUnits;
    local ShieldUnit, ShieldPIUnit, NovaHealingUnits, DispelUnit, PoHNormalUnit, PoHWithEAUnit, PoHWithPIUnit, AtonementUnits;
    local BestAtonementUnit, BestAtonementUnitHealth, RadianceUnits, LightsWrathUnits, AtonedUnits = nil, 100, 0, 0, 0;

    --- Initialize the rotation.
    function Rotation:Initialize ()
        module.UpdateSettings();

        -- ID, Requires Facing, Hostile, Instant
        -- Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);
        GiftOfTheNaaru = Spell(59544, false, false, true);

        -- Items
        DraenicChanneledManaPotion = Spell(156432, false, false, false);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);
        LukewarmYakRoastBroth = Item(120293, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);

        -- Spells
        AngelicFeather = Spell(121536, false, false, true); -- lvl 30 talent
        AngelicFeatherBuff = Spell(121557, false, false, true); -- lvl 30 talent
        Atonement = Spell(194384, false, false, true);
        Barrier = Spell(62618, false, false, true);
        BodyAndSoul = Spell(64129); -- lvl 30 talent
        BodyAndSoulBuff = Spell(65081); -- lvl 30 talent
        ClarityOfWill = Spell(152118, false, false, false);
        DispelMagic = Spell(528, false, false, true);
        DivineStar = Spell(110744, true, false, true); -- lvl 90 talent
        Fade = Spell(586, false, false, true);
        Halo = Spell(120517, false, false, true); -- lvl 90 talent
        LightsWrath = Spell(207946, true, true, false);
        MassDispel =  Spell(32375, false, false, true);
        Mindbender = Spell(123040, false, true, true); -- lvl 60 talent
        Pain = Spell(589, false, true, true);
        PainSuppression = Spell(33206, false, false, true);
        PenanceDamage = Spell(47540, true, true, true);
        PenanceHeal = Spell(47540, false, false, true); -- Requires The Penitent
        Plea = Spell(200829, false, false, true);
        PowerInfusion = Spell(10060, false, false, true); -- lvl 75 talent
        Purify = Spell(527, false, false, true);
        PurgeTheWicked = Spell(204197, true, true, true); -- lvl 100 talent
        PurgeTheWickedDebuff = Spell(204213, false, true, true); -- lvl 100 talent
        Radiance = Spell(194509, false, false, false);
        Rapture = Spell(47536, false, false, true);
        Resurrection = Spell(2006, false, false, false, true);
        Schism = Spell(214621, true, true, false);
        ShadowCovenant = Spell(204065, false, false, false); -- lvl 100 talent
        Shadowfiend = Spell(34433, true, true, true);
        ShadowMend = Spell(186263, false, false, true);
        Shield = Spell(17, false, false, true);
        Smite = Spell(585, true, true, false);
        Solace = Spell(129250, true, true, true); -- lvl 60 talent
        ThePenitent = Spell(200347, false, false, true); -- lvl 15 talent

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Healing Settings");
        module.AddPage("Cooldowns Settings");
        module.AddPage("Offensive/Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        -- Add options to pages
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable for Cooldowns to be saved for Bosses");
        module.AddNewOption("General Settings", "Focus Assignation", 230, true, {2, "Main Tank", "Off Tank"}, nil, "Select which Tank slot should be given to the focussed unit.");
        module.AddNewOption("General Settings", "Purify", 232, false, {1, "Auto", "High", "Normal"}, {0.2, 0, 1, 0.1}, "Use Purify to Dispel bad debuffs on allied units."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Auto").."Dispel Active Dispel Raid debuffs as High Priority and other not listed debuffs as Normal Priority."..C.TOOLTIP_SUBVALUE("High").."Dispel all debuffs as High Priority even before urgent cooldowns."..C.TOOLTIP_SUBVALUE("Normal").."Dispel all debuffs as Normal Priority after urgent cooldowns."..C.TOOLTIP_VALUE_2.."Define how long you want to wait before dispelling to look more human. This does not apply to Active Dispels Raid debuffs which will always be as soon as Global Cooldown ends."..C.TOOLTIP_HINT("Active Raid Dispels are based on an hardcoded list. Please report of any dispels you may encounter that requires specific strategies so that they can be properly added to the list."));
        module.AddNewOption("General Settings", "Resurrection", 220, true, {0.2, 0, 1, 0.1}, nil, "Resurrect dead Target with Resurrection while out of combat.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Angelic Feather", 220, true, {1.5, 0, 10, 0.1}, nil, "Use Angelic Feather on player."..C.TOOLTIP_VALUE.."Time to wait when you start moving to use it.(In seconds)");
        module.AddNewOption("General Settings", "Body And Soul", 220, true, {1.5, 0, 10, 0.1}, nil, "Use Power Word: Shield on player for Body and Soul."..C.TOOLTIP_VALUE.."Time to wait when you start moving to use it.(In seconds)");

        module.AddSection("Healing Settings", "Common Healing Thresholds", "Green");
        module.AddNewOption("Healing Settings", "Atonement", 222, true, {95, 0, 100, 1}, {95, 0, 100, 1}, "Apply Atonement using Power Word: Shield, Plea and Power Word: Radiance."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Atonement Plea", 222, true, {5, 1, 10, 1}, {40, 0, 100, 1}, "Apply Atonement using Plea."..C.TOOLTIP_VALUE_1.."Maximum Atonements before we avoid using Plea as it becomes too expensive."..C.TOOLTIP_VALUE_2.."Threshold to use Plea regardless of Atonement count.");
        module.AddNewOption("Healing Settings", "Clarity Of Will", 222, true, {200, 0, 400, 1}, {30, 0, 100, 1}, "Apply Clarity of Will on the tanking tanks."..C.TOOLTIP_VALUE_1.."Maximum Overshield."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Divine Star", 222, true, {3, 1, 25, 1 }, {90, 0, 100, 1}, "Use Divine Star."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Healing Settings", "Gift Of The Naaru", 222, true, {40, 0, 100, 1}, {25, 0, 100, 1}, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid."..C.TOOLTIP_HINT("Requires The Penitent talent."));
        end
        module.AddNewOption("Healing Settings", "Halo", 222, true, {5, 1, 25, 1}, {90, 0, 100, 1}, "Use Halo."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Healing Settings", "Penance Heal", 222, true, {60, 0, 100, 1}, {40, 0, 100, 1}, "Use Penance to heal."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid."..C.TOOLTIP_HINT("Requires The Penitent talent."));
        module.AddNewOption("Healing Settings", "Power Word: Radiance", 222, true, {3, 1, 25, 1}, {70, 0, 100, 1}, "Use Power Word: Radiance."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Healing Settings", "Shadow Covenant", 222, true, {4, 1, 25, 1}, {85, 0, 100, 1}, "Use Shadow Covenant."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Healing Settings", "Shadow Mend", 222, true, {65, 0, 100, 1}, {50, 0, 100, 1}, "Use Shadow Mend as low priority."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Shadow Mend Emergency", 222, true, {35, 0, 100, 1}, {25, 0, 100, 1}, "Use Shadow Mend."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Out Of Combat Healing", 210, true, nil, nil, "Allow Healing while Out of Combat.");
        module.AddSection("Healing Settings", "Active Healing", "Green");
        module.AddNewOption("Healing Settings", "Heal Target", 220, true, {1, 1, 2, 1}, nil, "Heal our current target if it is listed to be healed. Define Healing mode: 1-Known Units/2-Any Target");
        module.AddNewOption("Healing Settings", "Debuff", 220, true, {90, 0, 100, 1}, nil, "Manage Debuffed units"..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Healing Settings", "Expiration", 220, true, {90, 0, 100, 1}, nil, "Help units that have debuffs that explode on expiration to survive"..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Healing Settings", "Shielding", 220, true, {80, 0, 100, 1}, nil, "Use Shield on Debuffs that prevent healing on units under specified value"..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Healing Settings", "Speed", 220, true, {100, 0, 100, 1}, nil, "Buff players so that they can run quicker"..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Healing Settings", "Tank", 220, true, {40, 0, 100, 1}, nil, "Buff/Save tanks that have important debuffs"..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Healing Settings", "Topping", 220, true, {95, 0, 100, 1}, nil, "Top players to 100 hp to remove bad debuffs"..C.TOOLTIP_VALUE.."Health threshold.");

        module.AddSection("Cooldowns Settings", "Cooldowns", "Green");
        module.AddNewOption("Cooldowns Settings", "Pain Suppression", 222, true, {30, 0, 100, 1}, {15, 0, 100, 1}, "Use Pain Suppression."..C.TOOLTIP_VALUE_1.."Health threshold to use on Tanks."..C.TOOLTIP_VALUE_2.."Health threshold to use on any Raid members.");
        module.AddNewOption("Cooldowns Settings", "Power Infusion", 222, true, {3, 1, 25, 1}, {50, 0, 100, 1}, "Use Power Infusion."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Cooldowns Settings", "Power Word: Barrier", 222, true, {3, 1, 25, 1}, {40, 0, 100, 1}, "Use Power Word: Barrier."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Cooldowns Settings", "Rapture", 222, true, {4, 1, 25, 1}, {60, 1, 100, 1}, "Use Rapture."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Cooldowns Settings", "Rapture Shields Cycle", 210, true, nil, nil, "Apply Atonement via Power Word: Shield to as many units as we can during Rapture.");
        module.AddNewOption("Cooldowns Settings", "Soft Cooldowns Units", 120, true, {3, 1, 25, 1}, nil, "Amount of units that needs to be under thresholds to use Racials and Trinkets with Health.");
        if Berserking:Exists() or BloodFury:Exists() or ArcaneTorrent:Exists() then
            module.AddNewOption("Cooldowns Settings", "Use Racials", 220, true, {80, 0, 100, 1}, nil, "Use Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Berserking and Blood Rage").."Health threshold under which the units must be to be considered damaged. Racials will then be used if the amount of damaged units is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Arcane Torrent").."Mana threshold under which we want to use Arcane Torrent.");
        end
        module.AddNewOption("Cooldowns Settings", "Use Trinket 1", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 1 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always").."Use Always."..C.TOOLTIP_SUBVALUE("Health").."Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana").."Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 2", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 2 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always").."Use Always."..C.TOOLTIP_SUBVALUE("Health").."Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana").."Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");

        module.AddSection("Offensive/Defensive Settings", "DPS Offensive", "Green");
        module.AddPresetOption("TargetAttack");
        module.AddNewOption("Offensive/Defensive Settings", "Divine Star Damage", 220, true, {3, 1, 25, 1}, nil, "Use Divine Star."..C.TOOLTIP_VALUE.."Amount of enemies that needs to be in the effect area."..C.TOOLTIP_HINT("The calculation will also include enemies and also units that need healing from the Healing counterpart options."));
        module.AddNewOption("Offensive/Defensive Settings", "Halo Damage", 220, true, {3, 1, 25, 1}, nil, "Use Halo."..C.TOOLTIP_VALUE.."Amount of enemies that needs to be in the effect area."..C.TOOLTIP_HINT("The calculation will also include enemies and also units that need healing from the Healing counterpart options."));
        module.AddNewOption("Offensive/Defensive Settings", "Penance", 210, true, nil, nil, "Use Penance in the DPS rotation.");
        module.AddNewOption("Offensive/Defensive Settings", "Power Word: Solace", 210, true, { 1, "High", "Normal" }, { 80, 1, 100, 1 }, "Use Power Word: Solace.");
        module.AddNewOption("Offensive/Defensive Settings", "Purge The Wicked", 210, true, nil, nil, "Use Purge The Wicked in the DPS rotation.");
        module.AddNewOption("Offensive/Defensive Settings", "Schism", 210, true, nil, nil, "Use Schism in the DPS rotation.");
        module.AddNewOption("Offensive/Defensive Settings", "Shadow Word: Pain", 210, true, nil, nil, "Use Shadow Word: Pain in the DPS rotation.");
        module.AddNewOption("Offensive/Defensive Settings", "Smite", 210, true, nil, nil, "Use Smite in the DPS rotation.");
        module.AddSection("Offensive/Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Light's Wrath", 222, true, {3, 1, 10, 1}, {80, 0, 100, 1}, "Use Light's Wrath."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Offensive/Defensive Settings", "Light's Wrath For Tanks", 222, true, {1, 1, 5, 1}, {80, 0, 100, 1}, "Use Light's Wrath to save the Tanks."..C.TOOLTIP_VALUE_1.."Minimum amount of Atoned Units."..C.TOOLTIP_VALUE_2.."Threshold health under which the Tank must be.");
        module.AddNewOption("Offensive/Defensive Settings", "Mindbender", 220, true, {80, 0, 100, 1}, nil, "Mana treshold to use Mindbender.");
        module.AddNewOption("Offensive/Defensive Settings", "Shadowfiend", 222, true, {3, 1, 25, 1}, {80, 0, 100, 1}, "Use Shadowfiend."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddSection("Offensive/Defensive Settings", "Defensive", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Fade", 220, true, {50, 1, 100, 1}, nil, "Use Divine Protection." .. C.TOOLTIP_VALUE .. "Health threshold.");

        module.AddOutput("|cFF9A2EFEMain Tank:");
        module.AddOutput("|cFF9A2EFEOff Tank:");
        module.AddOutput("|cFF9A2EFEBad Debuffs:");
        module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);
        module.AddOutput("|cFFFFDE73Atonements:");
        module.SetOutput("|cFFFFDE73Atonements:", 0);

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [ClarityOfWill:ID()] = "Clarity of Will",
            [ShadowMend:ID()] = "Shadow Mend",
            [ShadowCovenant:ID()] = "Shadow Covenant"
        };
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        -- ISCL Spells: Clarity Of Will / Power Word: Radiance / Shadow Covenant
        if Player:Buff(DraenicChanneledManaPotion) or not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end
        -- Define Main Tanks
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();

        if Player:IsInCombat() then
            self:Defensives();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    -- Get Tanks Status
    local TanksStatus, MainTankTanking, OffTankTanking = {Main = {IsTanking = module.GetTime()},Off = {IsTanking = module.GetTime()}};
    local function RefreshTanksStatus ()
        TanksStatus = {
            Main = {IsTanking = MainTank and MainTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Main.IsTanking},
            Off = {IsTanking = OffTank and OffTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Off.IsTanking}
        };
        MainTankTanking = module.GetTime() - TanksStatus.Main.IsTanking < 3 or false;
        OffTankTanking = module.GetTime() - TanksStatus.Off.IsTanking < 3 or false;
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();

        -- Defensive Cooldowns
        -- Fade
        if module.IsOptionEnabled("Fade") and Player:ThreatSituation() == 3 and Player:CanCast(Fade) and Player:IsInGroup() then
            Player:Cast(Fade);
            return;
        end
    end

    -- Active Healing Heal Target handler
    local function HealTarget (ThisUnit)
        -- Penance
        if ThePenitent:Exists() and ThisUnit:CanHeal(PenanceHeal) then
            ThisUnit:Cast(PenanceHeal);
            return;
        end
        -- Shadow Mend
        if not Player:IsMoving() and ThisUnit:CanCast(ShadowMend) then
            ThisUnit:Cast(ShadowMend);
            return;
        end
        -- Power Word: Shield
        if ThisUnit:CanCast(Shield) then
            ThisUnit:Cast(Shield);
            return;
        end
    end

    -- Clarity of Will on tanks
    local function Overshield()
        if ClarityOfWill:Exists() and not Player:IsMoving() and module.IsOptionEnabled("Clarity Of Will") then
            -- Clarity of Will on tanks
            local OvershieldUnits = {MainTank, OffTank};
            for i = 1, #OvershieldUnits do
                local ThisUnit = OvershieldUnits[i];
                if ThisUnit and ThisUnit:CanCast(ClarityOfWill) and (not ThisUnit:Buff(ClarityOfWill) or (ThisUnit:Buff(ClarityOfWill) and (module.GetNumbersForBuff(ThisUnit, ClarityOfWill)[1]*1 < module.GetOptionValue("Clarity Of Will")*1000 or ThisUnit:BuffRemains(ClarityOfWill) < 4.5))) then
                    ThisUnit:Cast(ClarityOfWill);
                    return;
                end
            end
        end
    end

    local function DPSHandler (Comment)
        AlternateDamage = false;
        -- Divine Star
        if DivineStar:Exists() and module.IsOptionEnabled("Divine Star Damage") and DivineStarEnemies + DivineStarUnits >= module.GetOptionValue("Divine Star Damage") and Player:CanCast(DivineStar) then
            module.Bug("DPS - Divine Star " .. Comment);
            Player:Cast(DivineStar);
            return;
        end
        -- Halo
        if Halo:Exists() and module.IsOptionEnabled("Halo Damage") and HaloEnemies + HaloUnits >= module.GetOptionValue("Halo Damage") and Player:CanCast(Halo) then
            module.Bug("DPS - Halo " .. Comment);
            Player:Cast(Halo);
            return;
        end
        -- Schism
        if Schism:Exists() and module.IsOptionEnabled("Schism") and BestTarget:CanCast(Schism) then
            module.Bug("DPS - Schism " .. Comment);
            BestTarget:Cast(Schism);
            return;
        end
        -- Power Word: Solace
        if Solace:Exists() and module.IsOptionEnabled("Power Word: Solace") and BestTarget:CanCast(Solace) then
            module.Bug("DPS - Solace " .. Comment);
            BestTarget:Cast(Solace);
            return;
        end
        -- Shadow Word: Pain
        if not PurgeTheWicked:Exists() and Pain:Exists() and module.IsOptionEnabled("Shadow Word: Pain") and BestTarget:DebuffRemains(Pain) < 5.4 and BestTarget:TimeToDie() > 8 and BestTarget:CanCast(Pain) then
            module.Bug("DPS - Shadow Word: Pain " .. Comment);
            BestTarget:Cast(Pain);
            return;
        end
        -- Purge The Wicked
        if PurgeTheWicked:Exists() and module.IsOptionEnabled("Purge The Wicked") and BestTarget:DebuffRemains(PurgeTheWickedDebuff) < 6 and BestTarget:CanCast(PurgeTheWicked) then
            module.Bug("DPS - Purge The Wicked " .. Comment);
            BestTarget:Cast(PurgeTheWicked);
            return;
        end
        -- Penance
        if PenanceDamage:Exists() and module.IsOptionEnabled("Penance") and BestTarget:CanCast(PenanceDamage) then
            module.Bug("DPS - Penance Damage " .. Comment);
            BestTarget:Cast(PenanceDamage);
            return;
        end
        -- Smite
        if Smite:Exists() and module.IsOptionEnabled("Smite") and BestTarget:CanCast(Smite) then
            module.Bug("DPS - Smite " .. Comment);
            BestTarget:Cast(Smite);
            return;
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Smite, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
    -- Init + Dispels

        -- Find best unit to attack
        if Target:Exists() and Target:CanCast(Smite) then
            BestTarget = Target;
        elseif MainTankTarget and MainTankTarget:CanCast(Smite) then
            BestTarget = MainTankTarget;
        elseif OffTankTarget and OffTankTarget:CanCast(Smite) then
            BestTarget = OffTankTarget;
        elseif Mouseover:Exists() and Mouseover:CanCast(Smite) then
            BestTarget = Mouseover;
        else
            BestTarget = Target;
        end

        if module.GetTime() - RefreshTables > 1 then    HealUnits = Player:HealUnitsAround(100, 40);
            HealUnits = Player:HealUnitsAround(100, 40);
            Lowest = Unit.Lowest(MainTank, OffTank);
            RefreshTanksStatus();
            DivineStarEnemies = DivineStar:Exists() and #Player:UnitsInFrontRectangle(24, 5);
            DivineStarUnits = DivineStar:Exists() and #Player:UnitsInFrontRectangle(24, 5, true, module.GetSecondOptionValue("Divine Star")) or 0;
            HaloEnemies = #Player:EnemiesWithinDistance(30, true);
            HaloUnits = Halo:Exists() and #Player:HealUnitsAround(module.GetSecondOptionValue("Halo"), 30) or 0;
            PowerInfusionUnits = PowerInfusion:Exists() and #Player:GroupUnitsAvailableForHealing(module.GetSecondOptionValue("Power Infusion"), true, 40, true) or 0;
            RaptureUnits = Rapture:Exists() and module.IsOptionEnabled("Rapture") and #Player:HealUnitsAround(module.GetSecondOptionValue("Rapture"), 40) or 0;
            ShadowCovenantUnit = ShadowCovenant:Exists() and module.IsOptionEnabled("Shadow Covenant") and Player:CanCast(ShadowCovenant) and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Shadow Covenant"), module.GetSecondOptionValue("Shadow Covenant") ,30) or nil;
            ShadowfiendUnits = not Mindbender:Exists() and #Player:GroupUnitsAvailableForHealing(module.GetSecondOptionValue("Shadowfiend"), true, 40, true) or 0;
            Trinket1Units = module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 1"), 40) or 0;
            Trinket2Units = module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 2"), 40) or 0;
            RacialsUnits = module.IsOptionEnabled("Use Racials") and ((Berserking:Exists() and Player:CanCast(Berserking)) or (BloodFury:Exists() and Player:CanCast(BloodFury))) and #Player:HealUnitsAround(module.GetOptionValue("Use Racials"), 40) or 0;
            -- Bad Debuffs
            CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits);
            if CurrentBadDebuffs ~= nil then
                module.SetOutput("|cFF9A2EFEBad Debuffs:", #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff + #CurrentBadDebuffs.Tanks + #CurrentBadDebuffs.Speed + #CurrentBadDebuffs.Expiration + #CurrentBadDebuffs.Shield);
            end
            DispelUnit = Unit.Dispel(Purify);
            AtonementUnits = #Player:UnitsWithBuff(HealUnits, Atonement, 0.1);
            module.SetOutput("|cFFFFDE73Atonements:", AtonementUnits);
            RefreshTables = module.GetTime() + 0.5;
        end


        -- Dispels Handling
        Player:DispelHandler(Purify, "Purify", DispelUnit, CurrentBadDebuffs.Dispel, "High");

        -- Cooldowns
        if module.CooldownsAllowed() then
            -- Racials with Specific Handlers
            if module.IsOptionEnabled("Use Racials") then
                if RacialsUnits >= module.GetOptionValue("Soft Cooldowns Units") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                        return;
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                        return;
                    end
                end
                -- Arcane Torrent
                if ArcaneTorrent:Exists() and Player:PowerPercentage() < module.GetOptionValue("Use Racials") and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent);
                    return;
                end
            end
            -- Trinkets with specific handlers
            if module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() then
                Option1, Option2 = module.GetOptionValue("Use Trinket 1"), module.GetSecondOptionValue("Use Trinket 1");
                if Option1 == "Always" or (Option1 == "Health" and Trinket1Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 1")) then
                    Trinket1:UseInventory();
                end
            end
            if module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() then
                Option1, Option2 = module.GetOptionValue("Use Trinket 2"), module.GetSecondOptionValue("Use Trinket 2");
                if Option1 == "Always" or (Option1 == "Health" and Trinket2Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 2")) then
                    Trinket2:UseInventory();
                end
            end
            -- Power Infusion
            if PowerInfusion:Exists() and module.IsOptionEnabled("Power Infusion") and PowerInfusionUnits >= module.GetOptionValue("Power Infusion") and Player:CanCast(PowerInfusion) then
                Player:Cast(PowerInfusion);
            end
            -- Gift Of The Naaru
            if GiftOfTheNaaru:Exists() then
                if module.IsOptionEnabled("Gift Of The Naaru") and GiftOfTheNaaru:Exists() then
                    if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and MainTank:CanCast(GiftOfTheNaaru) then
                        MainTank:Cast(GiftOfTheNaaru);
                        return;
                    end
                    if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and OffTank:CanCast(GiftOfTheNaaru) then
                        OffTank:Cast(GiftOfTheNaaru);
                        return;
                    end
                    if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Gift Of The Naaru") and Lowest:CanCast(GiftOfTheNaaru) then
                        Lowest:Cast(GiftOfTheNaaru);
                        return;
                    end
                end
            end
            -- Pain Suppression
            if PainSuppression:Exists() and module.IsOptionEnabled("Pain Suppression") then
                if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Pain Suppression") and MainTank:CanHeal(PainSuppression) then
                    MainTank:Cast(PainSuppression);
                    return;
                end
                if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Pain Suppression") and OffTank:CanHeal(PainSuppression) then
                    OffTank:Cast(PainSuppression);
                    return;
                end
                if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Pain Suppression") and Lowest:CanCast(PainSuppression) then
                    Lowest:Cast(PainSuppression);
                    return;
                end
            end
            -- Shadowfiend
            if not Mindbender:Exists() and module.IsOptionEnabled("Shadowfiend") and BestTarget:Exists() and BestTarget:CanCast(Shadowfiend) and BestTarget:TimeToDie() > 12 and ShadowfiendUnits >= module.GetOptionValue("Shadowfiend") then
                BestTarget:Cast(Shadowfiend);
                return;
            end
            -- Rapture
            if RaptureUnits >= module.GetOptionValue("Rapture") and Player:CanCast(Rapture) then
                Player:Cast(Rapture);
                return;
            end
        end

        -- Rapture Cycle
        if Rapture:Exists() and Player:Buff(Rapture) and module.IsOptionEnabled("Rapture") then
            if MainTank and not MainTank:Buff(Atonement) and MainTank:CanHeal(Shield) then
                MainTank:Cast(Shield);
                return;
            end
            if OffTank and not OffTank:Buff(Atonement) and OffTank:CanHeal(Shield) then
                OffTank:Cast(Shield);
                return;
            end
            BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #HealUnits do
                ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage();
                if not ThisUnit:Buff(Atonement) and ThisUnit:CanCast(Shield) then
                    if not BestUnit or ThisUnitHealth < BestUnitHealth then
                        BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                    end
                end
            end
            if BestUnit then
                module.Bug("Power Word: Shield on " .. BestUnit:Name() .. " via Rapture Cycle.");
                BestUnit:Cast(Shield);
                return;
            end
        end
        -- Dispels Handling
        Player:DispelHandler(Purify, "Purify", DispelUnit, CurrentBadDebuffs.Dispel, "Normal");

        -- Active Healing Heal Target handler
        if Target:CanHeal(Heal) and module.IsOptionEnabled("Heal Target") and (module.GetOptionValue("Heal Target") == 2 or (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed())) then
            HealTarget(Target);
            return;
        end
        -- Mindbender
        if Mindbender:Exists() and module.IsOptionEnabled("Mindbender") and Player:PowerPercentage() <= module.GetOptionValue("Mindbender") and BestTarget:Exists() and BestTarget:CanCast(Mindbender) and BestTarget:TimeToDie() > 12 then
            BestTarget:Cast(Mindbender);
            return;
        end
        -- Force Pet To attack something
        if UnitExists("playerpet") and UnitName("playerpettarget") == nil and BestTarget:Exists() then
            RunMacroText("/petattack "..BestTarget.UnitID);
        end
        -- Angelic Feather
        if AngelicFeather:Exists() and module.IsOptionEnabled("Angelic Feather") and Player:Moving() > module.GetOptionValue("Angelic Feather") and not IsFalling() and Player:BuffRemains(AngelicFeatherBuff) < .5 and Player:CanCast(AngelicFeather) then
            Player:Cast(AngelicFeather);
            return;
        end
        -- Body And Soul
        if BodyAndSoul:Exists() and module.IsOptionEnabled("Body And Soul") and Player:Moving() > module.GetOptionValue("Body And Soul") and not Player:Buff(BodyAndSoulBuff) and Player:CanCast(Shield) and not Player:Buff(Shield) then
            Player:Cast(Shield);
            return;
        end
        -- Halo
        if Halo:Exists() and module.IsOptionEnabled("Halo") and Player:CanCast(Halo) and HaloUnits >= module.GetOptionValue("Halo") then
            Player:Cast(Halo);
            return;
        end
        -- Divine Star
        if DivineStar:Exists() and module.IsOptionEnabled("Divine Star") and Player:CanCast(DivineStar) and DivineStarUnits >= module.GetOptionValue("Divine Star") then
            Player:Cast(DivineStar);
            return;
        end
        -- Alternate DPS and Atonements
        if AlternateDamage then
            DPSHandler("(Alternate Damage)");
        end
    -- Bad Debuffs - Expiration
        if module.IsOptionEnabled("Expiration") and CurrentBadDebuffs and #CurrentBadDebuffs.Expiration > 0 and not Shield:IsOnCooldown() then
            BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Expiration do
                ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Expiration[i], CurrentBadDebuffs.Expiration[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Shield) and not ThisUnit:BuffAny(Shield) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil then
                if module.IsOptionEnabled("Expiration") and BestUnit:CanCast(Shield) and BestUnitHealth <= module.GetOptionValue("Expiration") then
                    BestUnit:Cast(Shield);
                    module.Bug("Power Word: Shield on " .. BestUnit:Name() .. " to mitigate expiring debuff");
                    return;
                end
            end
        end

    -- Bad Debuffs - Tank
        if module.IsOptionEnabled("Tank") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            BestUnit, BestUnitHealth = nil, 100;
            BestShieldUnit, BestShieldUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Tanks do
                ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Tanks[i], CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage();
                if not ThisUnit:Buff(Atonement) and ThisUnit:CanCast(Plea) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth <= module.GetOptionValue("Tank") then
                if BestUnit:CanCast(Shield) then
                    AlternateDamage = true;
                    BestUnit:Cast(Shield);
                    module.Bug("Power Word: Shield on " .. BestUnit:Name() .. " to apply Atonement on it (Tank Debuff)");
                    return;
                end
                if not BestUnit:Buff(Atonement) and BestUnit:CanCast(Plea) then
                    AlternateDamage = true;
                    BestUnit:Cast(Plea);
                    module.Bug("Plea on " .. BestUnit:Name() .. " to apply Atonement on it (Tank Debuff)");
                    return;
                end
            end
        end

    -- Bad Debuffs - Debuffs
        if module.IsOptionEnabled("Debuff") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            BestUnit, BestUnitHealth = nil, 100;
            BestShieldUnit, BestShieldUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Debuff do
                ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Debuff[i], CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage();
                if not ThisUnit:Buff(Atonement) and ThisUnit:CanCast(Plea) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth <= module.GetOptionValue("Debuff") then
                if BestUnit:CanCast(Shield) then
                    AlternateDamage = true;
                    BestUnit:Cast(Shield);
                    module.Bug("Power Word: Shield on " .. BestUnit:Name() .. " to apply Atonement on it (Debuff)");
                    return;
                end
                if not BestUnit:Buff(Atonement) and BestUnit:CanCast(Plea) then
                    AlternateDamage = true;
                    BestUnit:Cast(Plea);
                    module.Bug("Plea on " .. BestUnit:Name() .. " to apply Atonement on it (Debuff)");
                    return;
                end
            end
        end

    -- Bad Debuffs - Shielding
        if module.IsOptionEnabled("Shielding") and CurrentBadDebuffs and #CurrentBadDebuffs.Shield > 0 and not Shield:IsOnCooldown() then
            -- Cycle units to find the most injured
            BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Shield do
                ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Shield[i], CurrentBadDebuffs.Shield[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Shield) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil then
                if module.IsOptionEnabled("Shielding") and not BestUnit:BuffAny(Shield) and BestUnit:CanCast(Shield) and BestUnitHealth <= module.GetOptionValue("Shielding") then
                    AlternateDamage = true;
                    BestUnit:Cast(Shield);
                    module.Bug("Power Word: Shield on " .. BestUnit:Name() .. " as it have a healing immunity debuff");
                    return;
                end
            end
        end

    -- Bad Debuffs - Speed method
        if module.IsOptionEnabled("Active Healing") and module.IsOptionEnabled("Speed") and CurrentBadDebuffs and #CurrentBadDebuffs.Speed > 0 and (BodyAndSoul:Exists() or AngelicFeather:Exists()) then
            -- Cycle units to find the most injured
            BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Speed do
                ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Speed[i], CurrentBadDebuffs.Speed[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Shield) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil then
                if BodyAndSoul:Exists() and BestUnit:CanCast(Shield) and BestUnitHealth <= module.GetOptionValue("Speed") then
                    BestUnit:Cast(Shield);
                    module.Bug("Power Word: Shield on " .. BestUnit:Name() .. " to help it run away");
                    return;
                end
                if AngelicFeather:Exists() and AngelicFeather:Charges() >= 1 and BestUnit:CanCast(AngelicFeather) and BestUnitHealth <= module.GetOptionValue("Speed") then
                    BestUnit:Cast(AngelicFeather);
                    module.Bug("Angelic Feather on " .. BestUnit:Name() .. " to help it run away");
                    return;
                end
            end
        end

    -- Bad Debuffs - Topping
        if module.IsOptionEnabled("Active Healing") and module.IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            BestUnit, BestUnitHealth = nil, 100;
            BestShieldUnit, BestShieldUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Top do
                ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Top[i], CurrentBadDebuffs.Top[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Plea) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth <= module.GetOptionValue("Topping") then
                if not BestUnit:Buff(Atonement) and BestUnit:CanCast(Shield) then
                    AlternateDamage = true;
                    BestUnit:Cast(Shield);
                    module.Bug("Power Word: Shield on on " .. BestUnit:Name() .. " to top it");
                    return;
                end
                if not BestUnit:Buff(Atonement) and BestUnit:CanCast(Plea) then
                    AlternateDamage = true;
                    BestUnit:Cast(Plea);
                    module.Bug("Plea on " .. BestUnit:Name() .. " to top it");
                    return;
                end
            end
        end

        -- Power Word: Barrier
        if Barrier:Exists() and module.IsOptionEnabled("Power Word: Barrier") and Player:CanCast(Barrier) then
            Option1 = module.GetSecondOptionValue("Power Word: Barrier");
            BestHealUnits = {};
            for i = 1, #HealUnits do
                ThisUnit = HealUnits[i]
                if ThisUnit:CanHeal(Plea) and not ThisUnit:IsMoving() then
                    ThisHealUnits = ThisUnit:HealUnitsAround(Option1, 13);
                    if #ThisHealUnits >= module.GetOptionValue("Power Word: Barrier") and #ThisHealUnits > #BestHealUnits then
                        BestHealUnits = ThisHealUnits;
                    end
                end
            end
            if #BestHealUnits >= module.GetOptionValue("Power Word: Barrier") then
                Player:CastGroundHeal(Barrier, BestHealUnits);
                return;
            end
        end
        -- Atonement Handling
        -- 1) Look for best unit to Atone
        -- 2) Calc how many need Atonement for Radiance
        -- 3) Calc how many have Atonement for Light's Wrath
        BestAtonementUnit, BestAtonementUnitHealth, RadianceUnits, LightsWrathUnits, AtonedUnits = nil, 100, 0, 0, 0;
        for i = 1, #HealUnits do
            ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage();
            if ThisUnit:BuffRemains(Atonement) < 3 then
                if ThisUnit:CanCast(Plea) and ThisUnit:SpecialHealthPercentage() < module.GetOptionValue("Atonement") then
                    RadianceUnits = ThisUnit:SpecialHealthPercentage() < module.GetSecondOptionValue("Power Word: Radiance") and RadianceUnits + 1 or RadianceUnits;
                    if (BestAtonementUnit == nil or ThisUnitHealth < BestAtonementUnitHealth) then
                        BestAtonementUnit, BestAtonementUnitHealth = ThisUnit, ThisUnitHealth;
                    end
                end
            else
                AtonedUnits = AtonedUnits + 1;
                if ThisUnit:SpecialHealthPercentage() < module.GetSecondOptionValue("Light's Wrath") then
                    LightsWrathUnits = LightsWrathUnits + 1;
                end
            end
        end
        -- Light's Wrath
        if LightsWrath:Exists() and BestTarget:TimeToDie() > 4 and BestTarget:CanCast(LightsWrath) then
            if module.IsOptionEnabled("Light's Wrath") and LightsWrathUnits >= module.GetOptionValue("Light's Wrath") then
                module.Bug("Light's Wrath for Raid");
                BestTarget:Cast(LightsWrath);
                return;
            end
            if module.IsOptionEnabled("Light's Wrath For Tanks") then
                if MainTank and MainTank:SpecialHealthPercentage() < module.GetSecondOptionValue("Light's Wrath For Tanks") and AtonedUnits >= module.GetOptionValue("Light's Wrath For Tanks") then
                    module.Bug("Light's Wrath for Main Tank");
                    BestTarget:Cast(LightsWrath);
                    return;
                end
                if OffTank and OffTank:SpecialHealthPercentage() < module.GetSecondOptionValue("Light's Wrath For Tanks") and AtonedUnits >= module.GetOptionValue("Light's Wrath For Tanks") then
                    module.Bug("Light's Wrath for Off Tank");
                    BestTarget:Cast(LightsWrath);
                    return;
                end
            end
        end

        -- Shadow Covenant
        if ShadowCovenant:Exists() and ShadowCovenantUnit and ShadowCovenantUnit:CanCast(ShadowCovenant) and ShadowCovenant:TimeSinceCast() >= 4 then
            ShadowCovenantUnit:Cast(ShadowCovenant);
            ShadowCovenant.LastCastTime = module.GetTime();
            return;
        end

        -- Penance Healing
        if ThePenitent:Exists() and PenanceHeal:Exists() and module.IsOptionEnabled("Penance Heal") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Penance Heal") and MainTank:CanHeal(PenanceHeal) then
                MainTank:Cast(PenanceHeal);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Penance Heal") and OffTank:CanHeal(PenanceHeal) then
                OffTank:Cast(PenanceHeal);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Penance Heal") and Lowest:CanCast(PenanceHeal) then
                Lowest:Cast(PenanceHeal);
                return;
            end
        end

        -- Shadow Mend
        if ShadowMend:Exists() and module.IsOptionEnabled("Shadow Mend Emergency") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Shadow Mend Emergency") and MainTank:CanHeal(ShadowMend) then
                MainTank:Cast(ShadowMend);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Shadow Mend Emergency") and OffTank:CanHeal(ShadowMend) then
                OffTank:Cast(ShadowMend);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Shadow Mend Emergency") and Lowest:CanCast(ShadowMend) then
                Lowest:Cast(ShadowMend);
                return;
            end
        end

    -- Atonement
        -- Shield Tanks
        if Shield:Exists() and module.IsOptionEnabled("Atonement") and not Shield:IsOnCooldown() then
            BestTank = MainTank and (MainTank:SpecialHealthPercentage() < module.GetOptionValue("Atonement") or MainTankTanking) and MainTank:BuffRemains(Shield) < 5 and MainTank:CanCast(Shield) and MainTank or OffTank and (OffTank:SpecialHealthPercentage() < module.GetOptionValue("Atonement") or OffTankTanking) and OffTank:BuffRemains(Shield) < 5 and OffTank:CanCast(Shield) and OffTank;
            if BestTank then
                AlternateDamage = true;
                BestTank:Cast(Shield);
                return;
            end
        end
        -- Power Word: Radiance
        if Radiance:Exists() and module.IsOptionEnabled("Power Word: Radiance") and RadianceUnits >= module.GetOptionValue("Power Word: Radiance") and BestAtonementUnit and BestAtonementUnit:CanCast(Radiance) then
            AlternateDamage = true;
            module.Bug("Radiance - Atonement");
            BestAtonementUnit:Cast(Radiance);
            return;
        end
        -- Apply Atonements
        if BestAtonementUnit then
            if BestAtonementUnit:CanCast(Plea) then
                if Player:Buff(Rapture) and BestAtonementUnit:CanCast(Shield) then
                    AlternateDamage = true;
                    module.Bug("Power Word: Shield (Rapture) - Atonement");
                    BestAtonementUnit:Cast(Shield);
                    return;
                elseif AtonementUnits < module.GetOptionValue("Atonement Plea") then
                    AlternateDamage = true;
                    module.Bug("Plea - Atonement");
                    BestAtonementUnit:Cast(Plea);
                    return;
                end
            end
        end

    -- DPS Management
        -- Penance Healing Filler
        if ThePenitent:Exists() and PenanceHeal:Exists() and module.IsOptionEnabled("Penance Heal") then
            if MainTank and MainTank:SpecialHealthPercentage() <= 80 and MainTank:CanHeal(PenanceHeal) then
                MainTank:Cast(PenanceHeal);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= 80 and OffTank:CanHeal(PenanceHeal) then
                OffTank:Cast(PenanceHeal);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= 80 and Lowest:CanCast(PenanceHeal) then
                Lowest:Cast(PenanceHeal);
                return;
            end
        end
        -- Shadow Mend
        if ShadowMend:Exists() and module.IsOptionEnabled("Shadow Mend") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Shadow Mend") and MainTank:CanHeal(ShadowMend) then
                AlternateDamage = true;
                MainTank:Cast(ShadowMend);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Shadow Mend") and OffTank:CanHeal(ShadowMend) then
                AlternateDamage = true;
                OffTank:Cast(ShadowMend);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Shadow Mend") and Lowest:CanCast(ShadowMend) then
                AlternateDamage = true;
                Lowest:Cast(ShadowMend);
                return;
            end
        end
        DPSHandler("(Filler)");
        Overshield();
        -- Plea Filler
        if MainTank and MainTank:BuffRemains(Atonement) < 3 and (MainTank:SpecialHealthPercentage() < module.GetSecondOptionValue("Atonement Plea") or (MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Atonement") and AtonementUnits < module.GetOptionValue("Atonement Plea"))) and MainTank:CanCast(Plea) then
            AlternateDamage = true;
            MainTank:Cast(Plea);
            return;
        end
        if OffTank and OffTank:BuffRemains(Atonement) < 3 and (OffTank:SpecialHealthPercentage() < module.GetSecondOptionValue("Atonement Plea") or (OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Atonement") and AtonementUnits < module.GetOptionValue("Atonement Plea"))) and OffTank:CanCast(Plea) then
            AlternateDamage = true;
            OffTank:Cast(Plea);
            return;
        end
        if Lowest and Lowest:BuffRemains(Atonement) < 3 and (Lowest:SpecialHealthPercentage() < module.GetSecondOptionValue("Atonement Plea") or (Lowest:SpecialHealthPercentage() <= module.GetOptionValue("Atonement") and AtonementUnits < module.GetOptionValue("Atonement Plea"))) and Lowest:CanCast(Plea) then
            AlternateDamage = true;
            Lowest:Cast(Plea);
            return;
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Clarity of Will on tanks
        Overshield();
        -- Power Word: Shield Main Tank In Combat
        if Shield:Exists() and MainTank and module.IsOptionEnabled("Power Word: Shield") and not MainTank:Buff(Atonement) and MainTank:IsInCombat() and not MainTank:Buff(Shield) and MainTank:CanHeal(Shield) then
            MainTank:Cast(Shield);
            return;
        end
        -- Penance Top Off
        if PenanceHeal:Exists() and ThePenitent:Exists() and Lowest and Lowest:SpecialHealthPercentage() < 90 and Lowest:CanHeal(PenanceHeal) then
            Lowest:Cast(PenanceHeal);
            return;
        end
        -- Angelic Feather
        if AngelicFeather:Exists() and module.IsOptionEnabled("Angelic Feather") and Player:Moving() > module.GetOptionValue("Angelic Feather") and not IsFalling() and Player:BuffRemains(AngelicFeatherBuff) < .5 and Player:CanCast(AngelicFeather) then
            Player:Cast(AngelicFeather);
            return;
        end
        -- Body And Soul
        if BodyAndSoul:Exists() and module.IsOptionEnabled("Body And Soul") and Player:Moving() > module.GetOptionValue("Body And Soul") and not Player:Buff(BodyAndSoulBuff) and Player:CanCast(Shield) and not Player:Buff(Shield) then
            Player:Cast(Shield);
            return;
        end
        -- Resurrect Deads
        if Resurrection:Exists() and module.IsOptionEnabled("Resurrection") and Unit.ResurrectCycle(Resurrection) then
            return;
        end
        -- Proving Grounds Food
        if MainTank and MainTank:CreatureID() == 72218 and Player:PowerPercentage() < 95 and not Player:IsMoving() and LukewarmYakRoastBroth:InStock() and not LukewarmYakRoastBroth:IsOnCooldown() then
            LukewarmYakRoastBroth:Use(Player);
        end
        if module.IsOptionEnabled("Out Of Combat Healing") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Holy Priest
    local Rotation = {};
    module.SetRotation(257, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshTables = 0, 0.1, 0; -- Combat Module Throttle
    -- Healers Specific
    local MainTank, MainTankTarget, OffTank, OffTankTarget, HealUnits, Lowest, CurrentBadDebuffs, BestTarget, DispelUnit;
    local Trinket1Units, Trinket2Units, RacialsUnits;
    -- Profile Specific
    local CascadeUnit, PoHUnit, CoHUnit, HolyNovaUnits = nil, nil, nil, 0; -- Best Heal Units per spell
    local DivineStarUnits, HaloUnits, DivineHymnUnits, MendingUnits = 0, 0, 0, 0; -- Units Counts

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        LukewarmYakRoastBroth = Item(120293, false, false, true);
        DraenicChanneledManaPotion = Spell(156432, false, false, false);
        --Racials
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33697, false, false, true);
        ArcaneTorrent = Spell(28730, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        AngelicFeather = Spell(121536, false, false, true);
        AngelicFeatherBuff = Spell(121557);
        BindingHeal = Spell(32546, false, false, true);
        BodyAndMind = Spell(214121, false, false, true);
        CircleOfHealing = Spell(204883, false, false, false);
        DesperatePrayer = Spell(19236, false, false, true);
        DispelMagic = Spell(528, false, false, true);
        DivineHymn = Spell(64843, false, false, false);
        DivineStar = Spell(110744, false, false, true);
        Fade = Spell(586, false, false, true);
        FlashHeal = Spell(2061, false, false, false);
        GiftOfTheNaaru = Spell(59544, false, false, true);
        GuardianSpirit = Spell(47788, false, false, true);
        Halo = Spell(120517, false, false, true);
        Heal = Spell(2060, false, false, false);
        HolyFire = Spell(14914, false, true, true);
        HolyNova = Spell(132157, false, false, true);
        HolyWordChastise = Spell(88625, true, true, true);
        HolyWordSanctify = Spell(34861, false, false, true);
        HolyWordSerenity = Spell(2050, false, false, true);
        LightOfTuure = Spell(208065, false, false, true);
        PrayerOfHealing = Spell(596, false, false, false);
        PrayerOfMending = Spell(33076, false, false, true);
        PrayerOfMendingBuff = Spell(41635, false, false, true);
        Purify = Spell(527, false, false, true);
        Renew = Spell(139, false, false, true);
        Resurrection = Spell(2006, false, false, false, true);
        SpiritOfRedemption = Spell(27827, false, false, true);
        SurgeOfLight = Spell(114255);
        Smite = Spell(585, true, true, false);

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Healing Settings");
        module.AddPage("Cooldowns Settings");
        module.AddPage("Offensive/Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Focus Assignation", 230, true, {2, "Main Tank", "Off Tank"}, nil, "Select which Tank slot should be given to the focussed unit.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Purify", 232, false, {1, "Auto", "High", "Normal"}, {0.2, 0, 1, 0.1}, "Use Purify to Dispel bad debuffs on allied units."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Auto").."Dispel Active Dispel Raid debuffs as High Priority and other not listed debuffs as Normal Priority."..C.TOOLTIP_SUBVALUE("High").."Dispel all debuffs as High Priority even before urgent cooldowns."..C.TOOLTIP_SUBVALUE("Normal").."Dispel all debuffs as Normal Priority after urgent cooldowns."..C.TOOLTIP_VALUE_2.."Define how long you want to wait before dispelling to look more human. This does not apply to Active Dispels Raid debuffs which will always be as soon as Global Cooldown ends."..C.TOOLTIP_HINT("Active Raid Dispels are based on an hardcoded list. Please report of any dispels you may encounter that requires specific strategies so that they can be properly added to the list."));
        module.AddNewOption("General Settings", "Resurrection", 210, true, nil, nil, "Resurrect dead Target with Resurrection while out of combat.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Angelic Feather", 220, true, {1.5, 0, 10, 0.1}, nil, "Use Angelic Feather on player."..C.TOOLTIP_VALUE.."Select desired time to wait when you start moving to use it.(seconds)");
        module.AddNewOption("General Settings", "Body And Mind", 220, true, {1.5, 0, 10, 0.1}, nil, "Use Body and Mind on player."..C.TOOLTIP_VALUE.."Select desired time to wait when you start moving to use it.(seconds)");

        module.AddSection("Healing Settings", "Common Healing Thresholds", "Green");
        module.AddNewOption("Healing Settings", "Binding Heal", 222, true, {90, 0, 100, 1}, {80, 0, 100, 1}, "Use Binding Heal when our health is under 100%."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Circle Of Healing", 222, true, {3, 1, 5, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Flash Heal", 222, true, {70, 0, 100, 1}, {35, 0, 100, 1}, "Use Flash Heal."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Flash Heal Surge Of Light", 222, true, {80, 0, 100, 1}, {55, 0, 100, 1}, "Use Flash Heal with Surge Of Light procs."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Heal", 222, true, {90, 0, 100, 1}, {80, 0, 100, 1}, "Use Heal."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Renew", 222, true, {95, 0, 100, 1}, {92, 0, 100, 1}, "Use Renew."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Prayer Of Healing", 222, true, {3, 1, 5, 1}, {70, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Prayer Of Mending", 222, true, {1, 1, 5, 1}, {95, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Out Of Combat Healing", 210, true, nil, nil, "Allow Healing while Out of Combat.");
        module.AddSection("Healing Settings", "Active Healing", "Green");
        module.AddNewOption("Healing Settings", "Heal Target", 230, true, {1, "Known Unit", "Any Unit"}, nil, "Heal our current target if it is listed to be healed."..C.TOOLTIP_VALUE.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Known Unit").."Allow Heal Target to be used only when we are targetting a unit listed for it."..C.TOOLTIP_SUBVALUE("Any Unit").."Allow Heal Target to be used on any unit.");
        module.AddNewOption("Healing Settings", "Raid Debuffs", 220, true, {40, 0, 100, 1}, nil, "Use Renew on Debuffed units."..C.TOOLTIP_VALUE.."Helath threshold.");
        module.AddNewOption("Healing Settings", "Tank Debuffs", 220, true, {50, 0, 100, 1}, nil, "Use Renew on Debuffed tanks."..C.TOOLTIP_VALUE.."Helath threshold.");
        module.AddNewOption("Healing Settings", "Topping", 220, true, {100, 0, 100, 1}, nil, "Use Renew/Flash Heal on units to be topped."..C.TOOLTIP_VALUE.."Helath threshold.");

        module.AddSection("Cooldowns Settings", "Cooldowns", "Green");
        module.AddNewOption("Cooldowns Settings", "Divine Hymn", 222, true, {3, 1, 25, 1}, {70, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Divine Star", 222, true, {2, 1, 25, 1}, {90, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Guardian Spirit", 222, true, {30, 0, 100, 1}, {0, 0, 100, 1}, "Use Guardian Spirit."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Cooldowns Settings", "Halo", 222, true, {4, 1, 25, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Holy Word: Sanctify", 222, true, {3, 1, 10, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold." .. C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Holy Word: Serenity", 222, true, {50, 0, 100, 1}, {30, 0, 100, 1}, "Use Holy Word Serenity."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Cooldowns Settings", "Light Of T'uure", 222, true, {60, 0, 100, 1}, {40, 0, 100, 1}, "Use Light Of T'uure."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddSection("Cooldowns Settings", "Common Cooldowns", "Green");
        module.AddNewOption("Cooldowns Settings", "Soft Cooldowns Units", 120, true, {3, 1, 25, 1}, nil, "Number of units that needs to be under thresholds to use Racials and Trinkets with Health.");
        module.AddNewOption("Cooldowns Settings", "Use Racials", 220, true, {80, 0, 100, 1}, nil, "Use Racials. \n\n|cFF0088FFArcane Torrent:|r Mana threshold under which we want to use Arcane Torrent.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 1", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 1 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always") .." Use Always."..C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 2", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 2 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always") .." Use Always."..C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");

        module.AddSection("Offensive/Defensive Settings", "DPS Offensive", "Green");
        module.AddPresetOption("TargetAttack");
        module.AddNewOption("Offensive/Defensive Settings", "DPS", 220, true, {95, 0, 100, 1}, nil, "Enables DPS options."..C.TOOLTIP_VALUE.."Will only DPS if the Lowest unit is above DPS health treshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Holy Fire", 210, true, nil, nil, "Use Holy Fire in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Holy Nova", 220, true, {3, 1, 10, 1}, nil, "Use Holy Nova in the DPS rotation."..C.TOOLTIP_VALUE.."Amount of units required to be in 12 yards of Player to use."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Smite", 210, true, nil, nil, "Use Smite in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddSection("Offensive/Defensive Settings", "Defensive", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Desperate Prayer", 220, true, {30, 1, 100, 1}, nil, "Use Desperate Prayer."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Fade", 220, true, {20, 1, 100, 1}, nil, "Use Fade when there is threath on us."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Offensive/Defensive Settings", "Gift Of The Naaru", 222, true, {65, 0, 100, 1}, {55, 0, 100, 1}, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        end
        module.AddSection("Offensive/Defensive Settings", "Spirit Of Redemption Abilities", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Spirit Circle Of Healing", 222, true, {2, 1, 5, 1}, {90, 0, 100, 1}, "Use Circle Of Healing during Spirit of Redemption."..C.TOOLTIP_VALUE_1.."Number of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Offensive/Defensive Settings", "Spirit Prayer Of Healing", 222, true, {2, 1, 5, 1}, {90, 0, 100, 1}, "Use Prayer Of Healing during Spirit of Redemption."..C.TOOLTIP_VALUE_1.."Number of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Offensive/Defensive Settings", "Spirit Divine Hymn", 222, true, {3, 1, 25, 1}, {80, 0, 100, 1}, "Use Divine Hymn during Spirit of Redemption."..C.TOOLTIP_VALUE_1.."Number of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Offensive/Defensive Settings", "Spirit Guardian Spirit", 222, true, {30, 0, 100, 1}, {0, 0, 100, 1}, "Use Guardian Spirit during Spirit of Redemption."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Offensive/Defensive Settings", "Spirit Guardian Spirit Before Expiration", 210, true, nil, nil, "Will use Guardian Spirit on the Lowest Tank before Spirit of Redemption buff fades");
        module.AddNewOption("Offensive/Defensive Settings", "Spirit Flash Heal", 222, true, {75, 0, 100, 1}, {65, 0, 100, 1}, "Use Flash Heal during Spirit of Redemption."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Offensive/Defensive Settings", "Spirit Renew", 220, true, {95, 0, 100, 1}, nil, "Use Renew during Spirit of Redemption."..C.TOOLTIP_VALUE.."Health Threshold.");

        -- Healers Specific
        module.AddOutput("|cFF9A2EFEMain Tank:");
        module.AddOutput("|cFF9A2EFEOff Tank:");
        module.AddOutput("|cFF9A2EFELowest:");
        module.AddOutput("|cFF9A2EFEBad Debuffs:");
        module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [Heal:ID()] = "Heal",
            [FlashHeal:ID()] = "Flash Heal"
        };
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:Channeling(DivineHymn) or Player:Buff(DraenicChanneledManaPotion) or not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Define Main Tanks
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();

        if Player:IsInCombat() then
            self:Defensives();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Fade
        if module.IsOptionEnabled("Fade") and Player:ThreatSituation() == 3 and Player:CanCast(Fade) and Player:IsInGroup() then
            Player:Cast(Fade);
            return;
        end
        --Desperate Prayer
        if DesperatePrayer:Exists() and module.IsOptionEnabled("Desperate Prayer") and Player:HealthPercentage() <= module.GetOptionValue("Desperate Prayer") and Player:CanCast(DesperatePrayer) then
            Player:Cast(DesperatePrayer);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and MainTank:CanHeal(GiftOfTheNaaru) then
                MainTank:Cast(GiftOfTheNaaru);
                return;
            elseif MainTank and OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and OffTank:CanHeal(GiftOfTheNaaru) then
                OffTank:Cast(GiftOfTheNaaru);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Gift Of The Naaru") and Lowest:CanHeal(GiftOfTheNaaru) then
                Lowest:Cast(GiftOfTheNaaru);
                return;
            end
        end
    end

    -- Get Tanks Status
    local TanksStatus, MainTankTanking, OffTankTanking = {Main = {IsTanking = module.GetTime()},Off = {IsTanking = module.GetTime()}};
    local function RefreshTanksStatus ()
        TanksStatus = {
            Main = {IsTanking = MainTank and MainTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Main.IsTanking},
            Off = {IsTanking = OffTank and OffTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Off.IsTanking}
        };
        MainTankTanking = module.GetTime() - TanksStatus.Main.IsTanking < 3 or false;
        OffTankTanking = module.GetTime() - TanksStatus.Off.IsTanking < 3 or false;
    end

    -- Active Healing Heal Target handler
    local function HealTarget (ThisUnit)
        -- Renew
        if ThisUnit:CanCast(Renew) and ThisUnit:BuffRemains(Renew) < 2 then
            ThisUnit:Cast(Renew);
            return;
        end
        if not Player:IsMoving() then
            -- Flash Heal
            if ThisUnit:CanCast(FlashHeal) and ThisUnit:SpecialHealthPercentage() < 100 then
                ThisUnit:Cast(FlashHeal);
                return;
            end
            -- Heal
            if ThisUnit:CanCast(Heal) then
                ThisUnit:Cast(Heal);
                return;
            end
        end
    end

    local function SpiritRotation ()
        -- Guardian Spirit
        if module.IsOptionEnabled("Spirit Guardian Spirit") then
            if MainTank and MainTank:HealthPercentage() <= module.GetOptionValue("Spirit Guardian Spirit") and MainTank:CanHeal(GuardianSpirit) then
                MainTank:Cast(GuardianSpirit);
                return;
            elseif OffTank and OffTank:HealthPercentage() <= module.GetOptionValue("Spirit Guardian Spirit") and OffTank:CanHeal(GuardianSpirit) then
                OffTank:Cast(GuardianSpirit);
                return;
            end
        end
        if module.IsOptionEnabled("Spirit Guardian Spirit Before Expiration") and Player:BuffRemains(SpiritOfRedemption) < 3 then
            local BestGuardianUnit = nil;
            if MainTank and MainTank:CanHeal(GuardianSpirit) then
                BestGuardianUnit = MainTank;
            elseif OffTank and OffTank:CanHeal(GuardianSpirit) and OffTank:SpecialHealthPercentage() <= MainTank:SpecialHealthPercentage() then
                BestGuardianUnit = OffTank;
            end
            if BestGuardianUnit then
                BestGuardianUnit:Cast(GuardianSpirit);
                return;
            end
        end
        -- Divine Hymn
        if module.IsOptionEnabled("Spirit Divine Hymn") and Player:CanCast(DivineHymn) and #Player:HealUnitsAround(module.GetSecondOptionValue("Spirit Divine Hymn"), 40) >= module.GetOptionValue("Spirit Divine Hymn") then
            Player:Cast(DivineHymn);
            return;
        end

        -- Dispels Handling
        Player:DispelHandler(Purify, "Purify", DispelUnit, CurrentBadDebuffs.Dispel, "Normal");

        -- Circle of Healing
        if module.IsOptionEnabled("Spirit Circle Of Healing") and Player:CanCast(CircleOfHealing) then
            if CircleUnit and CircleUnit:CanCast(CircleOfHealing) then
                CircleUnit:Cast(CircleOfHealing);
                return;
            end
        end
        -- Prayer of Healing
        if PrayerOfHealing:Exists() and module.IsOptionEnabled("Spirit Prayer Of Healing") and PoHUnit and PoHUnit:CanCast(PrayerOfHealing) then
            PoHUnit:Cast(PrayerOfHealing);
            return;
        end

        -- Cast Flash Heal
        if module.IsOptionEnabled("Spirit Flash Heal") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Spirit Flash Heal") and MainTank:CanHeal(FlashHeal) then
                MainTank:Cast(FlashHeal);
                return;
            elseif MainTank and OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Spirit Flash Heal") and OffTank:CanHeal(FlashHeal) then
                OffTank:Cast(FlashHeal);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Spirit Flash Heal") and Lowest:CanHeal(FlashHeal) then
                Lowest:Cast(FlashHeal);
                return;
            end
        end

        -- Renew Cycle
        if module.IsOptionEnabled("Spirit Renew") and HealUnits then
            local BestUnit = nil;
            local BestUnitHealth = 101;
            for i = 1, #HealUnits do
                local ThisUnit = HealUnits[i]
                local ThisUnitHealth = ThisUnit:SpecialHealthPercentage()
                if ThisUnit:CanCast(Renew) and ThisUnitHealth <= module.GetOptionValue("Spirit Renew") and ThisUnit:BuffRemains(Renew) <= 3 and ThisUnitHealth < BestUnitHealth then
                    BestUnitHealth = ThisUnitHealth;
                    BestUnit = ThisUnit;
                end
            end
            if BestUnit then
                BestUnit:Cast(Renew);
                return;
            end
        end
    end


    --- Run the beta rotation's healing logic.
    function Rotation:Combat ()
        -- Find best unit to attack
        if Target:Exists() and Target:CanCast(Smite) then
            BestTarget = Target;
        elseif MainTankTarget and MainTankTarget:CanCast(Smite) then
            BestTarget = MainTankTarget;
        elseif OffTankTarget and OffTankTarget:CanCast(Smite) then
            BestTarget = OffTankTarget;
        elseif Mouseover:Exists() and Mouseover:CanCast(Smite) then
            BestTarget = Mouseover;
        else
            BestTarget = Target;
        end

        -- Refresh tables every 0.5 seconds
        if RefreshTables < module.GetTime() then
            DispelUnit = Unit.Dispel(Purify);
            HealUnits = Player:HealUnitsAround(100, 40);
            Lowest = Unit.Lowest(MainTank, OffTank);
            module.SetOutput("|cFF9A2EFELowest:", Lowest and Lowest:Name() or "");
            RefreshTanksStatus();
            -- Units Counts
            CoHUnit = CircleOfHealing:Exists() and Player:Buff(SpiritOfRedemption) and module.IsOptionEnabled("Spirit Circle Of Healing") and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Spirit Circle Of Healing"), module.GetSecondOptionValue("Spirit Circle Of Healing"), 30) or CircleOfHealing:Exists() and module.IsOptionEnabled("Circle Of Healing") and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Circle Of Healing"), module.GetSecondOptionValue("Circle Of Healing"), 30) or nil;
            DivineStarUnits = DivineStar:Exists() and module.IsOptionEnabled("Divine Star") and #Player:UnitsInFrontRectangle(24, 5, true, module.GetSecondOptionValue("Divine Star")) or 0;
            DivineHymnUnits = DivineHymn:Exists() and module.IsOptionEnabled("Divine Hymn") and #Player:HealUnitsAround(module.GetSecondOptionValue("Divine Hymn"), 40) or 0;
            HaloUnits = Halo:Exists() and module.IsOptionEnabled("Halo") and #Player:HealUnitsAround(module.GetSecondOptionValue("Halo"), 30) or 0;
            HolyNovaUnits = HolyNova:Exists() and module.IsOptionEnabled("Holy Nova") and #Player:EnemiesWithinDistance(12) or 0;
            MendingUnits = PrayerOfMending:Exists() and module.IsOptionEnabled("Prayer Of Mending") and #Player:HealUnitsAround(module.GetSecondOptionValue("Prayer Of Mending"), 40) or 0;
            PoHUnit = PrayerOfHealing:Exists() and Player:Buff(SpiritOfRedemption) and module.IsOptionEnabled("Spirit Prayer Of Healing") and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Spirit Prayer Of Healing"), module.GetSecondOptionValue("Spirit Prayer Of Healing"), 20) or PrayerOfHealing:Exists() and module.IsOptionEnabled("Prayer Of Healing") and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Prayer Of Healing"), module.GetSecondOptionValue("Prayer Of Healing"), 20) or nil;
            RacialsUnits = module.IsOptionEnabled("Use Racials") and ((Berserking:Exists() and Player:CanCast(Berserking)) or (BloodFury:Exists() and Player:CanCast(BloodFury))) and #Player:HealUnitsAround(module.GetOptionValue("Use Racials"), 40) or 0;
            Trinket1Units = module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 1"), 40) or 0;
            Trinket2Units = module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 2"), 40) or 0;
            -- Bad Debuffs Output
            CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits);
            if CurrentBadDebuffs ~= nil then
                module.SetOutput("|cFF9A2EFEBad Debuffs:", #CurrentBadDebuffs.Tanks + #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff);
            end
            RefreshTables = module.GetTime() + 0.5;
        end

        -- Dispels Handling
        Player:DispelHandler(Purify, "Purify", DispelUnit, CurrentBadDebuffs.Dispel, "High");

        -- Active Healing Heal Target handler
        if Target:CanHeal(Heal) and module.IsOptionEnabled("Heal Target") and (module.GetOptionValue("Heal Target") == 2 or (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed())) then
            HealTarget(Target);
            return;
        end

        -- Spirit Of Redemption support
        if Player:Buff(SpiritOfRedemption) then
            SpiritRotation();
            return;
        end

        -- Trinkets with specific handlers
        if module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() then
            local Option1, Option2 = module.GetOptionValue("Use Trinket 1"), module.GetSecondOptionValue("Use Trinket 1");
            if Option1 == "Always" or (Option1 == "Health" and Lowest and Lowest:SpecialHealthPercentage() <= Option2) or (Option1 == "Mana" and Player:PowerPercentage() < Option2) then
                Trinket1:UseInventory();
            end
        end
        if module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() then
            local Option1, Option2 = module.GetOptionValue("Use Trinket 2"), module.GetSecondOptionValue("Use Trinket 2");
            if Option1 == "Always" or (Option1 == "Health" and Lowest and Lowest:SpecialHealthPercentage() <= Option2) or (Option1 == "Mana" and Player:PowerPercentage() < Option2) then
                Trinket2:UseInventory();
            end
        end
    -- Cooldowns
        -- Only use DPS and Cooldowns during combat
        if Player:IsInCombat() then
            -- DPS
            if BestTarget and module.IsOptionEnabled("DPS") and Lowest:HealthPercentage() >= module.GetOptionValue("DPS") and (not MainTank or MainTank:HealthPercentage() >= module.GetOptionValue("DPS")) and (not OffTank or OffTank:HealthPercentage() >= module.GetOptionValue("DPS")) and BestTarget:IsInCombat() then
                -- Holy Fire
                if HolyFire:Exists() and module.IsOptionEnabled("Holy Fire") and BestTarget:CanCast(HolyFire) then
                    BestTarget:Cast(HolyFire);
                    return;
                end
                -- Holy Nova
                if HolyNova:Exists() and HolyNovaUnits >= module.GetOptionValue("Holy Nova") and Player:CanCast(HolyNova) then
                    Player:Cast(HolyNova);
                    return;
                end
                -- Smite
                if Smite:Exists() and module.IsOptionEnabled("Smite") and BestTarget:CanCast(Smite) then
                    BestTarget:Cast(Smite);
                    return;
                end
                -- Find New Target
                if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
                    local NewTargetUnit = Unit.AutoTarget(Smite, module.GetOptionValue("Target | Attack"));
                    if NewTargetUnit then
                        NewTargetUnit:Attack();
                        return;
                    end
                end
            end
            -- Racials with Specific Handlers
            if module.IsOptionEnabled("Use Racials") then
                if RacialsUnits >= module.GetOptionValue("Soft Cooldowns Units") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                        return;
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                        return;
                    end
                end
            end
            -- Trinkets with specific handlers
            if module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 1"), module.GetSecondOptionValue("Use Trinket 1");
                if Option1 == "Always" or (Option1 == "Health" and Trinket1Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 1")) then
                    Trinket1:UseInventory();
                end
            end
            if module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 2"), module.GetSecondOptionValue("Use Trinket 2");
                if Option1 == "Always" or (Option1 == "Health" and Trinket2Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 2")) then
                    Trinket2:UseInventory();
                end
            end
            -- Guardian Spirit - used on Tanks when they fall under life treshold.
            if GuardianSpirit:Exists() and module.IsOptionEnabled("Guardian Spirit") then
                if MainTank and MainTank:HealthPercentage() <= module.GetOptionValue("Guardian Spirit") and MainTank:CanHeal(GuardianSpirit) then
                    MainTank:Cast(GuardianSpirit);
                    return;
                elseif OffTank and OffTank:HealthPercentage() <= module.GetOptionValue("Guardian Spirit") and OffTank:CanHeal(GuardianSpirit) then
                    OffTank:Cast(GuardianSpirit);
                    return;
                end
            end
            -- Divine Hymn - Used when # of people under treshold exceed desired number of units
            if DivineHymn:Exists() and module.IsOptionEnabled("Divine Hymn") and Player:Standing() > 1 and Player:CanCast(DivineHymn) and DivineHymnUnits >= module.GetOptionValue("Divine Hymn") then
                Player:Cast(DivineHymn);
                return;
            end
        end

        -- Dispels Handling
        Player:DispelHandler(Purify, "Purify", DispelUnit, CurrentBadDebuffs.Dispel, "Normal");

        -- Angelic Feather - when we run more than choosen time
        if AngelicFeather:Exists() and module.IsOptionEnabled("Angelic Feather") and Player:Moving() > module.GetOptionValue("Angelic Feather") and not IsFalling() and Player:BuffRemains(AngelicFeatherBuff) < .5 and Player:CanCast(AngelicFeather) then
            Player:Cast(AngelicFeather);
            return;
        end
        -- Body And Mind - when we run more than choosen time
        if BodyAndMind:Exists() and module.IsOptionEnabled("Body And Mind") and Player:Moving() > module.GetOptionValue("Body And Mind") and not Player:Buff(BodyAndMind) and Player:CanCast(BodyAndMind) then
            Player:Cast(BodyAndMind);
            return;
        end
    -- High Priority Healing
        -- Light Of T'uure
        if LightOfTuure:Exists() and module.IsOptionEnabled("Light Of T'uure") then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Light Of T'uure") and not MainTank:Buff(LightOfTuure) and MainTank:CanHeal(LightOfTuure) then
                module.Bug("Light Of T'uure - MainTank");
                MainTank:Cast(LightOfTuure);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Light Of T'uure") and not OffTank:Buff(LightOfTuure) and OffTank:CanHeal(LightOfTuure) then
                module.Bug("Light Of T'uure - OffTank");
                OffTank:Cast(LightOfTuure);
                return;
            end
        end
        -- Holy Word Serenity
        if HolyWordSerenity:Exists() and module.IsOptionEnabled("Holy Word: Serenity") then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Holy Word: Serenity") and MainTank:CanHeal(HolyWordSerenity) then
                module.Bug("Holy Word Serenity - MainTank");
                MainTank:Cast(HolyWordSerenity);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Holy Word: Serenity") and OffTank:CanHeal(HolyWordSerenity) then
                module.Bug("Holy Word Serenity - OffTank");
                OffTank:Cast(HolyWordSerenity);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() < module.GetSecondOptionValue("Holy Word: Serenity") and Lowest:CanHeal(HolyWordSerenity) then
                module.Bug("Holy Word Serenity - Lowest");
                Lowest:Cast(HolyWordSerenity);
                return;
            end
        end
        -- Circle of Healing - with number of units damaged in 30 yards of best unit
        if CircleOfHealing:Exists() and CoHUnit and CoHUnit:CanCast(CircleOfHealing) then
            CoHUnit:Cast(CircleOfHealing);
            return;
        end
        -- Holy Word: Sanctify
        if HolyWordSanctify:Exists() and module.IsOptionEnabled("Holy Word: Sanctify") and Player:CanCast(HolyWordSanctify) then
            local HealthThreshold = module.GetSecondOptionValue("Holy Word: Sanctify");
            local BestHealUnits = {};
            for i = 1, #HealUnits do
                local ThisUnit = HealUnits[i]
                if ThisUnit:CanHeal(Heal) then
                    local TheseHealUnits = ThisUnit:HealUnitsAround(HealthThreshold, 10);
                    if #TheseHealUnits >= module.GetOptionValue("Holy Word: Sanctify") and #TheseHealUnits > #BestHealUnits then
                        BestHealUnits = TheseHealUnits;
                    end
                end
            end
            if #BestHealUnits >= module.GetOptionValue("Holy Word: Sanctify") then
                Player:CastGroundHeal(HolyWordSanctify, BestHealUnits);
                return;
            end
        end
        -- Prayer of Healing
        if PrayerOfHealing:Exists() and module.IsOptionEnabled("Prayer Of Healing") and PoHUnit and PoHUnit:CanCast(PrayerOfHealing) then
            PoHUnit:Cast(PrayerOfHealing);
            return;
        end
        -- Renew on Tanks
        if Renew:Exists() and module.IsOptionEnabled("Renew") then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Renew") and not MainTank:Buff(Renew) and MainTank:CanHeal(Renew) then
                module.Bug("Renew - MainTank");
                MainTank:Cast(Renew);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Renew") and not OffTank:Buff(Renew) and OffTank:CanHeal(Renew) then
                module.Bug("Renew - OffTank");
                OffTank:Cast(Renew);
                return;
            end
        end
        -- Flash Heal
        if FlashHeal:Exists() and module.IsOptionEnabled("Flash Heal") and not Player:IsMoving() then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Flash Heal") and MainTank:CanHeal(FlashHeal) then
                module.Bug("Flash Heal - MainTank");
                MainTank:Cast(FlashHeal);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Flash Heal") and OffTank:CanHeal(FlashHeal) then
                module.Bug("Flash Heal - OffTank");
                OffTank:Cast(FlashHeal);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() < module.GetSecondOptionValue("Flash Heal") and Lowest:CanHeal(FlashHeal) then
                module.Bug("Flash Heal - Lowest");
                Lowest:Cast(FlashHeal);
                return;
            end
        end
        -- Flash Heal - Surge Of Light
        if FlashHeal:Exists() and Player:Buff(SurgeOfLight) and module.IsOptionEnabled("Flash Heal Surge Of Light") and not Player:IsMoving() then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Flash Heal Surge Of Light") and MainTank:CanHeal(FlashHeal) then
                module.Bug("Flash Heal Surge Of Light - MainTank");
                MainTank:Cast(FlashHeal);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Flash Heal Surge Of Light") and OffTank:CanHeal(FlashHeal) then
                module.Bug("Flash Heal Surge Of Light - OffTank");
                OffTank:Cast(FlashHeal);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() < module.GetSecondOptionValue("Flash Heal Surge Of Light") and Lowest:CanHeal(FlashHeal) then
                module.Bug("Flash Heal Surge Of Light - Lowest");
                Lowest:Cast(FlashHeal);
                return;
            end
        end
        -- Prayer Of Mending
        if PrayerOfMending:Exists() and MendingUnits >= module.GetOptionValue("Prayer Of Mending") then
            if MainTank and MainTank:CanHeal(PrayerOfMending) and not MainTank:Buff(PrayerOfMendingBuff) then
                MainTank:Cast(PrayerOfMending)
                return;
            elseif OffTank and OffTank:CanHeal(PrayerOfMending) and not OffTank:Buff(PrayerOfMendingBuff) then
                OffTank:Cast(PrayerOfMending)
                return;
            elseif Lowest and Lowest:CanCast(PrayerOfMending) and not Lowest:Buff(PrayerOfMendingBuff) then
                Lowest:Cast(PrayerOfMending)
                return;
            end
        end
        -- Divine Star
        if DivineStar:Exists() and DivineStarUnits >= module.GetOptionValue("Divine Star") and Player:CanCast(DivineStar) then
            Player:Cast(DivineStar);
            return;
        end
        -- Halo
        if Halo:Exists() and HaloUnits >= module.GetOptionValue("Halo") and Player:CanCast(Halo) then
            Player:Cast(Halo);
            return;
        end
    -- Bad Debuffs - Tank
        if Renew:Exists() and module.IsOptionEnabled("Tank Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Tanks do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Tanks[i], CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage();
                if ThisUnit:CanHeal(Renew) and not ThisUnit:Buff(Renew) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Tank Debuffs") then
                module.Bug("Renew on " .. BestUnit:Name() .. " to heal tank debuff");
                BestUnit:Cast(Renew);
                return;
            end
        end
    -- Bad Debuffs - Debuffs
        if Renew:Exists() and module.IsOptionEnabled("Raid Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Debuff do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Debuff[i], CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage();
                if ThisUnit:CanHeal(Renew) and not ThisUnit:Buff(Renew) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Raid Debuffs") then
                module.Bug("Renew on " .. BestUnit:Name() .. " to mitigate debuff");
                BestUnit:Cast(Renew);
                return;
            end
        end
    -- Bad Debuffs - Topping
        if module.IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Top do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Top[i], CurrentBadDebuffs.Top[i]:SpecialHealthPercentage();
                if ThisUnit:CanHeal(FlashHeal) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil then
                if Renew:Exists() and BestUnitHealth <= module.GetOptionValue("Topping") and BestUnit:CanHeal(Renew) and not BestUnit:Buff(Renew) then
                    module.Bug("Renew on " .. BestUnit:Name() .. " to top it");
                    BestUnit:Cast(Renew);
                    return;
                end
                if FlashHeal:Exists() and BestUnitHealth <= module.GetOptionValue("Topping") and BestUnit:CanHeal(FlashHeal) then
                    module.Bug("Flash Heal on " .. BestUnit:Name() .. " to top it");
                    BestUnit:Cast(FlashHeal);
                    return;
                end
            end
        end
    -- Low Priority Healing
        -- Binding Heal
        if BindingHeal:Exists() and module.IsOptionEnabled("Binding Heal") and Player:SpecialHealthPercentage() < 95 then
            if MainTank and MainTank:HealthPercentage() <= module.GetOptionValue("Binding Heal") and MainTank:CanHeal(BindingHeal) then
                MainTank:Cast(BindingHeal);
                return;
            elseif OffTank and OffTank:HealthPercentage() <= module.GetOptionValue("Binding Heal") and MainTank:CanHeal(BindingHeal) then
                OffTank:Cast(BindingHeal);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetOptionValue("Binding Heal") and Lowest:CanHeal(BindingHeal) and not Lowest:Equals(Player) then
                Lowest:Cast(BindingHeal);
                return;
            end
        end
        -- Renew Cycle
        if Renew:Exists() and module.IsOptionEnabled("Renew") then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #HealUnits do
                local ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage();
                if ThisUnitHealth <= BestUnitHealth and ThisUnit:CanHeal(Renew) and ThisUnit:BuffRemains(Renew) < 3 then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit and BestUnitHealth <= module.GetSecondOptionValue("Renew") then
                module.Bug("Renew - Cycle");
                BestUnit:Cast(Renew);
                return;
            end
        end
        -- Heal Tanks/Lowest
        if Heal:Exists() and module.IsOptionEnabled("Heal") then
            if MainTank and MainTank:CanHeal(Heal) and MainTank:SpecialHealthPercentage() <= module.GetSecondOptionValue("Heal") then
                MainTank:Cast(Heal);
                return;
            end
            if OffTank and OffTank:CanHeal(Heal) and OffTank:SpecialHealthPercentage() <= module.GetSecondOptionValue("Heal") then
                OffTank:Cast(Heal);
                return;
            end
            if Lowest and Lowest:CanHeal(Heal) and Lowest:SpecialHealthPercentage() <= module.GetOptionValue("Heal") then
                Lowest:Cast(Heal);
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Resurrect Deads
        if module.IsOptionEnabled("Resurrection") and Unit.ResurrectCycle(Resurrection) then
            return;
        end
        -- Angelic Feather - when we run more than choosen time
        if module.IsOptionEnabled("Angelic Feather") and AngelicFeather:Exists() and Player:Moving() > module.GetOptionValue("Angelic Feather") and not IsFalling() and Player:BuffRemains(AngelicFeatherBuff) < .5 and Player:CanCast(AngelicFeather) then
            Player:Cast(AngelicFeather);
            return;
        end
        -- Body And Mind - when we run more than choosen time
        if module.IsOptionEnabled("Body And Mind") and BodyAndMind:Exists() and Player:Moving() > module.GetOptionValue("Body And Mind") and not Player:Buff(BodyAndMind) and Player:CanCast(BodyAndMind) then
            Player:Cast(BodyAndMind);
            return;
        end
        if module.IsOptionEnabled("Out Of Combat Healing") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Shadow Priest
    local Rotation = {};
    module.SetRotation(258, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local TargetEnemies_10y, NumEnemies, Enemies, DeathThreshold, DeathUnit = {}, 0, {}, 20, nil;
    local CurrentInsanityDrain, GCDMax, Insanity;

    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicIntellect = Item(109218, false, false, true);
        DraenicIntellectBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);
        GiftOfTheNaaru = Spell(59544, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        BodyAndSoul = Spell(64129);
        BodyAndSoulBuff = Spell(65081);
        Death = Spell(32379, true, true, true);
        DeathReaper = Spell(199911, true, true, true);
        Dispersion = Spell(47585, false, false, true);
        Fade = Spell(586, false, false, true);
        LegacyOfTheVoid = Spell(193225);
        Mindbender = Spell(200174, true, true, true);
        MindBlast = Spell(8092, true, true, false);
        MindFlay = Spell(15407, true, true, false);
        MindSear = Spell(48045, true, true, false);
        MindSpike = Spell(73510, true, true, false);
        Pain = Spell(589, false, true, true);
        PowerInfusion = Spell(10060, false, false, true);
        PurifyDisease = Spell(213634, false, false, true);
        ReaperOfSouls = Spell(199853);
        Resurrection = Spell(2006, false, false, false, true);
        ShadowCrash = Spell(205385, false, true, true);
        ShadowMend = Spell(186263, false, false, false);
        Shadowfiend = Spell(34433, true, true, true);
        Shield = Spell(17, false, false, true);
        Silence = Spell(15487, true, true, true);
        SurrenderToMadness = Spell(193223, false, false, true);
        VampiricEmbrace = Spell(15286, false, false, true);
        VampiricTouch = Spell(34914, false, true, false);
        Void = Spell(205351, true, true, false);
        VoidBolt = Spell(205448, true, true, true);
        VoidEruptionDamage = Spell(228260, true, true, true);
        VoidEruption = Spell(228260, false, false, true);
        VoidForm = Spell(194249, false, false, true);
        VoidRay = Spell(205371);
        VoidRayBuff = Spell(205372);
        VoidTorrent = Spell(205065, true, true, false);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, { 4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest" }, { 2, "Disabled", "Enabled" }, "|cffFF0044Target (Left Box)|r \nAutomatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode. \n|cFF0088FFClosest:|r Target the closest enemy. \n|cFF0088FFLeast HP:|r Target the enemy with the least health remaining. \n|cFF0088FFMost HP:|r Target the enemy with the most health remaining. \n|cFF0088FFTarget Closest:|r Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining. \n\n|cffFF0044Attack (Right Box)|r \nUse /startattack when you changes target. Good for melee classes.");
        module.AddOption("General Settings", "Cooldowns Only On Bosses", false, "Only cast CD's on boss targets.");
        module.AddSection("General Settings", "Utility", "Green");
        --module.AddNewOption("General Settings", "Purify Disease", 220, true, {0.2, 0, 1, 0.1}, nil, "Use Purify to remove debuffs."..C.TOOLTIP_VALUE.."Wait up to 1 second before Purify to look more human");
        module.AddNewOption("General Settings", "Resurrection", 210, true, nil, nil, "Resurrect dead Target with Resurrection while out of combat.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Body And Soul", 220, true, {1.5, 0, 10, 0.1}, nil, "Use Power Word: Shield on player for Body and Soul."..C.TOOLTIP_VALUE.."Time to wait when you start moving to use it.(In seconds)");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Silence to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Mind Blast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Mindbender", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Mindbender with >= 10 Void Form stacks. On cooldown if we have T18 2 pieces."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Power Infusion", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Power Infusion."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Shadowfiend", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Shadowfiend with >= 15 Void Form stacks."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Void Torrent", 232, true, {2, "Always", "Cooldown Only"}, {35, 1, 100, 1}, "Use Void Torrent."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Used when Insanity fall under this threshold.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Dispersion", 210, true, nil, nil, "Use Dispersion during Void Form.");
        module.AddNewOption("Offensive Settings", "Mind Sear", 220, true, {2, 1, 25, 1}, nil, "Use Mind Sear."..C.TOOLTIP_VALUE.."Amount of enemies that must be in 10 yards around our target to use.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Shadow Word: Pain", 222, true, {6, 1, 10, 1}, {3, 0, 25, 0.1}, "Multi-Dot Shadow Word: Pain Cycle."..C.TOOLTIP_VALUE_1.."Amount of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Vampiric Touch", 222, true, {3, 1, 10, 1}, {3, 0, 25, 0.1}, "Multi-Dot Vampiric Touch Cycle."..C.TOOLTIP_VALUE_1.."Amount of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Void Bolt", 210, true, nil, nil, "Multi-Dot Void Bolt Cycle. This will try to maintain dots on as many target as possible.");
        module.AddNewOption("Offensive Settings", "Shadow Crash", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {2, 1, 25, 1}, "Use Shadow Crash."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Target").."Always use on the current target."..C.TOOLTIP_SUBVALUE("Target Standing").."Always use on the current target. Target must be standing still."..C.TOOLTIP_SUBVALUE("Centered").."Use centered on a cluster of enemies."..C.TOOLTIP_SUBVALUE("Centered Standing").."Use centered on a cluster of enemies. Enemies must be standing still."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Shadow Word: Death Any", 210, true, nil, nil, "Enable Shadow Word: Death on any targets that are availabe."..C.TOOLTIP_HINT("Will still use on target if unchecked."));
        module.AddNewOption("Offensive Settings", "Void Eruption", 122, true, {85, 70, 100, 1}, {0, 0, 1.25, 0.05}, "Void Eruption and Void Bolt options."..C.TOOLTIP_VALUE_1.."How much Insanity should we pool before using Void Eruption."..C.TOOLTIP_VALUE_2.."How long should we wait for Void Bolt if it is almost ready.");
        module.AddNewOption("Offensive Settings", "Void Ray", 210, true, nil, nil, "Maintain Void Ray as much as possible.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Defensive Dispersion", 220, true, {30, 1, 100, 1}, nil, "Use Dispersion."..C.TOOLTIP_VALUE.."Health threshold."..C.TOOLTIP_HINT("Never used during Surrender To Madness."));
        module.AddNewOption("Defensive Settings", "Fade", 220, true, {70, 1, 100, 1}, nil, "Use Fade."..C.TOOLTIP_VALUE.."Health threshold."..C.TOOLTIP_HINT("Will only be used if we have high threat situation. Never used during Surrender To Madness."));
        module.AddNewOption("Defensive Settings", "Power Word: Shield", 220, true, {50, 1, 100, 1}, nil, "Use Power Word: Shield on ourself."..C.TOOLTIP_VALUE.."Health threshold."..C.TOOLTIP_HINT("Never used during Surrender To Madness."));
        module.AddNewOption("Defensive Settings", "Shadow Mend", 222, true, {25, 1, 100, 1}, {85, 1, 100, 1}, "Use Shadow Mend on ouself."..C.TOOLTIP_VALUE_1.."In Combat health threshold."..C.TOOLTIP_VALUE_2.."Out of Combat health threshold."..C.TOOLTIP_HINT("Never used during Surrender To Madness."));
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {40, 1, 100, 1}, nil, "Use Gift Of The Naaru on self."..C.TOOLTIP_VALUE.."Health threshold.");
        end

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [VampiricTouch:ID()] = "Vampiric Touch",
            [Void:ID()] = "Shadow Word: Void"
        };
    end

    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Channeling(VoidTorrent) then
            return;
        end

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end
        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        -- Potion
        if module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + MindBlast:CastTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) and Player:IsWithinCastRange(Target, MindBlast) then
            if Player:Potion("Intellect", Potion) then module.Bug("Pre-Pull - Intellect Potion"); Potion = true; end
        end
        -- Mind Blast
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + MindBlast:CastTime() and Target:CanCast(MindBlast) then
            module.Bug("Pre-Pull - MindBlast");
            Target:Cast(MindBlast);
            return;
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Silence, ArcaneTorrent);
    end


    function Rotation:OffGCDAbilities ()

    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        if not Player:Buff(SurrenderToMadness) then
            -- Dispersion
            if Dispersion:Exists() and module.IsOptionEnabled("Defensive Dispersion") and Player:HealthPercentage() <= module.GetOptionValue("Defensive Dispersion") and Player:CanCast(Dispersion) then
                SpellStopCasting();
                Player:Cast(Dispersion);
                return;
            end
            -- Fade
            if Fade:Exists() and module.IsOptionEnabled("Fade") and Target:Exists() and Player:ThreatSituation() == 3 and Player:HealthPercentage() <= module.GetOptionValue("Fade") and Player:CanCast(Fade) then
                Player:Cast(Fade);
                return;
            end
            -- ShadowMend
            if ShadowMend:Exists() and module.IsOptionEnabled("Shadow Mend") and Player:HealthPercentage() <= module.GetOptionValue("Shadow Mend") and Player:CanCast(ShadowMend) then
                Player:Cast(ShadowMend);
                return;
            end
            -- Shield
            if Shield:Exists() and module.IsOptionEnabled("Power Word: Shield") and not Player:BuffAny(Shield) and Player:HealthPercentage() <= module.GetOptionValue("Power Word: Shield") and Player:CanCast(Shield) then
                Player:Cast(Shield);
                return;
            end
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    local function MindFillers ()
        if MindSear:Exists() and not Player:IsMoving() and module.IsOptionEnabled("Mind Sear") and NumEnemies >= module.GetOptionValue("Mind Sear") and not Player:Channeling(MindSear) and Target:CanCast(MindSear) then
            Target:Cast(MindSear);
            return;
        elseif not (MindSear:Exists() and module.IsOptionEnabled("Mind Sear") and NumEnemies >= module.GetOptionValue("Mind Sear") and not Player:IsMoving() and Player:Channeling(MindSear)) then
            if not MindSpike:Exists() then
                -- Mind Flay
                if not Player:Channeling(MindFlay) and Target:CanCast(MindFlay) then
                    Target:Cast(MindFlay);
                    return;
                end
            else
                -- Mind Spike
                if Target:CanCast(MindSpike) then
                    Target:Cast(MindSpike);
                    return;
                end
            end
        end
    end

    local function ShadowWordDeath ()
        if Target:HealthPercentage() <= DeathThreshold and Target:CanCast(Death) then
            Target:Cast(Death);
            return;
        end
        if module.IsOptionEnabled("Shadow Word: Death Any") then
            if DeathUnit and DeathUnit:CanCast(Death, true, true) then
                DeathUnit:Cast(Death);
                return;
            end
        end
    end

    local function VoidBoltCycle ()
        if module.IsOptionEnabled("Multi-Dot Void Bolt") then
            local ThisUnit, BestUnit, BestUnitPainDuration, BestUnitHasVamp = nil, nil, 14, nil;
            for i = 1, #Enemies do
                ThisUnit = Enemies[i];
                if Player:IsFacing(ThisUnit) and ThisUnit:Debuff(Pain) and ThisUnit:DebuffRemains(Pain) > 1.5 and ThisUnit:CanCast(VoidBolt) then
                    if BestUnit == nil or (BestUnitHasVamp == nil and ThisUnit:Debuff(VampiricTouch)) or BestUnitPainDuration > ThisUnit:DebuffRemains(Pain) then
                        BestUnit, BestUnitPainDuration, BestUnitHasVamp = ThisUnit, ThisUnit:DebuffRemains(Pain), ThisUnit:Debuff(VampiricTouch);
                    end
                end
            end
            if BestUnit then
                BestUnit:Cast(VoidEruptionDamage);
                return;
            end
        end
    end

    function Rotation:Combat ()
        -- Common values for SimC Calculations
        CurrentInsanityDrain, GCDMax, Insanity = Player:Buff(VoidForm) and 7.5 + Player:BuffCount(VoidForm)*0.5 or 0, Player:GCD(), Player:Insanity();
        if Target:Exists() and Player:CanAttack(Target) then
            -- Body And Soul
            if not Player:Buff(SurrenderToMadness) and BodyAndSoul:Exists() and module.IsOptionEnabled("Body And Soul") and Player:Moving() > module.GetOptionValue("Body And Soul") and not Player:Buff(BodyAndSoulBuff) and Player:CanCast(Shield) then
                Player:Cast(Shield);
                return;
            end

            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                Enemies = Player:EnemiesWithinDistance(40); -- 40 yards for Dots.
                Enemies_10y = Target:EnemiesWithinDistance(10); -- 10 yards for Mind Sear.
                NumEnemies = #Enemies_10y;
                PainUnit = Unit.DotCycle(Enemies, Pain, Pain, 14, "Multi-Dot Shadow Word: Pain");
                VampUnit = Unit.DotCycle(Enemies, VampiricTouch, VampiricTouch, 18, "Multi-Dot Vampiric Touch");
                DeathThreshold = ReaperOfSouls:Exists() and 35 or 20;
                DeathUnit = Unit.LightEnemyAvailableForSpellHP(Enemies, Death, DeathThreshold);
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- actions=call_action_list,name=s2m,if=buff.voidform.up&buff.surrender_to_madness.up
            if Player:Buff(VoidForm) and Player:Buff(SurrenderToMadness) then
                if Player:IsWithinCastRange(Target, MindBlast) and Insanity >= 40 then
                    Player:UseTrinkets();
                end
                -- actions.s2m=shadow_crash,if=talent.shadow_crash.enabled
                if ShadowCrash:Exists() and module.IsOptionEnabled("Shadow Crash") and Target:CanCast(ShadowCrash) then
                    if Target:CastGroundSpell(ShadowCrash, "Shadow Crash", 8) then return; end
                end
                -- actions.s2m+=/mindbender,if=talent.mindbender.enabled
                if Mindbender:Exists() and module.IsOptionEnabled("Mindbender") and (module.CooldownsAllowed() or module.GetOptionValue("Mindbender") == "Always") and Target:CanCast(Mindbender) then
                    Target:Cast(Mindbender);
                    return;
                end
                -- actions.s2m+=/dispersion,if=!buff.power_infusion.up&!buff.berserking.up&!buff.bloodlust.up
                if Dispersion:Exists() and module.IsOptionEnabled("Dispersion") and not Player:Buff(PowerInfusion) and not Player:Buff(Berserking) and not Player:HasHero() and Player:CanCast(Dispersion) then
                    Player:Cast(Dispersion);
                    return;
                end
                -- actions.s2m+=/power_infusion,if=buff.voidform.stack>=10
                if PowerInfusion:Exists() and module.IsOptionEnabled("Power Infusion") and (module.CooldownsAllowed() or module.GetOptionValue("Power Infusion") == "Always") and Player:BuffCount(VoidForm) >= 10 and Player:CanCast(PowerInfusion) then
                    Player:Cast(PowerInfusion);
                end
                -- actions.s2m+=/berserking,if=buff.voidform.stack>=10
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:BuffCount(VoidForm) >= 10 then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                end
                -- actions.s2m+=/void_bolt,if=dot.shadow_word_pain.remains<3.5*gcd,cycle_targets=1
                VoidBoltCycle();
                -- actions.s2m+=/void_bolt
                if Target:CanCast(VoidBolt) then
                    Target:Cast(VoidEruptionDamage);
                    return;
                end
                -- actions.s2m+=/void_torrent
                if VoidTorrent:Exists() and module.IsOptionEnabled("Void Torrent") and (module.CooldownsAllowed() or module.GetOptionValue("Void Torrent") == "Always") and Insanity < module.GetSecondOptionValue("Void Torrent")and Target:CanCast(VoidTorrent) then
                    Target:Cast(VoidTorrent);
                    return;
                end
                -- actions.s2m+=/shadow_word_death,if=!talent.reaper_of_souls.enabled&current_insanity_drain*gcd.max>insanity&(insanity-(current_insanity_drain*gcd.max)+30)<100
                if Death:Exists() and not ReaperOfSouls:Exists() and CurrentInsanityDrain * GCDMax > Insanity and (Insanity - (CurrentInsanityDrain * GCDMax) + 30) < 100 then
                    ShadowWordDeath();
                end
                -- actions.s2m+=/shadow_word_death,if=talent.reaper_of_souls.enabled&current_insanity_drain*gcd.max>insanity&(insanity-(current_insanity_drain*gcd.max)+90)<100
                if Death:Exists() and ReaperOfSouls:Exists() and CurrentInsanityDrain * GCDMax > Insanity and (Insanity - (CurrentInsanityDrain * GCDMax) + 75) < 100 then
                    ShadowWordDeath();
                end
                -- actions.s2m+=/mind_blast
                if MindBlast:Exists() and Target:CanCast(MindBlast) then
                    Target:Cast(MindBlast);
                    return;
                end
                -- actions.s2m+=/shadow_word_death,if=cooldown.shadow_word_death.charges=2
                if Death:Exists() and (Death:Charges() == 2 or (Death:Charges() == 1 and Death:Recharge() < 3)) then
                    ShadowWordDeath();
                end
                -- actions.s2m+=/shadowfiend,if=!talent.mindbender.enabled,if=buff.voidform.stack>15
                if Shadowfiend:Exists() and module.IsOptionEnabled("Shadowfiend") and (module.CooldownsAllowed() or module.GetOptionValue("Shadowfiend") == "Always") and Player:BuffCount(VoidForm) >= 15 and Target:CanCast(Shadowfiend) then
                    Target:Cast(Shadowfiend);
                    return;
                end
                -- actions.s2m+=/shadow_word_void,if=(insanity-(current_insanity_drain*gcd.max)+75)<100
                if Void:Exists() and (Insanity - (CurrentInsanityDrain * GCDMax) + 75) < 100 and Target:CanCast(Void) then
                    Target:Cast(Void);
                    return;
                end
                -- actions.s2m+=/shadow_word_pain,if=!ticking,cycle_targets=1
                if Pain:Exists() and module.IsOptionEnabled("Multi-Dot Shadow Word: Pain") and PainUnit then
                    PainUnit:Cast(Pain);
                    return;
                end
                -- actions.s2m+=/vampiric_touch,if=!ticking,cycle_targets=1
                if VampiricTouch:Exists() and module.IsOptionEnabled("Multi-Dot Vampiric Touch") and VampUnit then
                    VampUnit:Cast(VampiricTouch);
                    return;
                end
                -- actions.s2m+=/wait,sec=cooldown.void_bolt.remains,if=cooldown.void_bolt.remains<(gcd.max*0.75)
                if VoidBolt:Cooldown() < module.GetSecondOptionValue("Void Eruption") then
                    module.Bug("Erruption in " .. VoidBolt:Cooldown());
                    return;
                end
                -- actions.s2m+=/mind_flay,if=!talent.mind_spike.enabled,interrupt=1,chain=1
                -- actions.s2m+=/mind_spike,if=talent.mind_spike.enabled
                MindFillers();
                -- actions.s2m+=/shadow_word_pain


            -- actions+=/call_action_list,name=vf,if=buff.voidform.up
            elseif Player:Buff(VoidForm) then
                if Player:IsWithinCastRange(Target, MindBlast) and Insanity >= 40 then
                    Player:UseTrinkets();
                end
                -- actions.vf=surrender_to_madness,if=talent.surrender_to_madness.enabled&insanity>=25&(cooldown.void_bolt.up|cooldown.void_torrent.up|cooldown.shadow_word_death.up|buff.shadowy_insight.up)&target.time_to_die<=90+((raw_haste_pct*100)*2)-buff.insanity_drain_stacks.stack
                -- actions.vf+=/shadow_crash,if=talent.shadow_crash.enabled
                if ShadowCrash:Exists() and module.IsOptionEnabled("Shadow Crash") and Target:CanCast(ShadowCrash) then
                    if Target:CastGroundSpell(ShadowCrash, "Shadow Crash", 8) then return; end
                end
                -- actions.vf+=/mindbender,if=talent.mindbender.enabled
                if Mindbender:Exists() and module.IsOptionEnabled("Mindbender") and (module.CooldownsAllowed() or module.GetOptionValue("Mindbender") == "Always") and Target:CanCast(Mindbender) then
                    Target:Cast(Mindbender);
                    return;
                end
                -- actions.vf+=/dispersion,if=!buff.power_infusion.up&!buff.berserking.up&!buff.bloodlust.up
                if Dispersion:Exists() and module.IsOptionEnabled("Dispersion") and not Player:Buff(PowerInfusion) and not Player:Buff(Berserking) and not Player:HasHero() and Player:CanCast(Dispersion) then
                    Player:Cast(Dispersion);
                    return;
                end
                -- actions.vf+=/power_infusion,if=buff.voidform.stack>=10&buff.insanity_drain_stacks.stack<=30
                if PowerInfusion:Exists() and module.IsOptionEnabled("Power Infusion") and (module.CooldownsAllowed() or module.GetOptionValue("Power Infusion") == "Always") and Player:BuffCount(VoidForm) >= 10 and Player:CanCast(PowerInfusion) then
                    Player:Cast(PowerInfusion);
                end
                -- actions.vf+=/berserking,if=buff.voidform.stack>=10&buff.insanity_drain_stacks.stack<=20
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:BuffCount(VoidForm) >= 10 then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                end
                -- actions.vf+=/void_bolt,if=dot.shadow_word_pain.remains<3.5*gcd,cycle_targets=1
                VoidBoltCycle();
                -- actions.vf+=/void_bolt
                if Target:CanCast(VoidBolt) then
                    Target:Cast(VoidEruptionDamage);
                    return;
                end
                -- actions.vf+=/void_torrent
                if VoidTorrent:Exists() and module.IsOptionEnabled("Void Torrent") and (module.CooldownsAllowed() or module.GetOptionValue("Void Torrent") == "Always") and Insanity < module.GetSecondOptionValue("Void Torrent")and Target:CanCast(VoidTorrent) then
                    Target:Cast(VoidTorrent);
                    return;
                end
                -- actions.vf+=/shadow_word_death,if=!talent.reaper_of_souls.enabled&current_insanity_drain*gcd.max>insanity&(insanity-(current_insanity_drain*gcd.max)+10)<100
                if Death:Exists() and not ReaperOfSouls:Exists() and CurrentInsanityDrain * GCDMax > Insanity  and (Insanity - (CurrentInsanityDrain * GCDMax) + 10) < 100 then
                    ShadowWordDeath();
                end
                -- actions.vf+=/shadow_word_death,if=talent.reaper_of_souls.enabled&current_insanity_drain*gcd.max>insanity&(insanity-(current_insanity_drain*gcd.max)+30)<100
                if Death:Exists() and ReaperOfSouls:Exists() and CurrentInsanityDrain * GCDMax > Insanity  and (Insanity - (CurrentInsanityDrain * GCDMax) + 30) < 100 then
                    ShadowWordDeath();
                end
                -- actions.vf+=/mind_blast
                if MindBlast:Exists() and Target:CanCast(MindBlast) then
                    Target:Cast(MindBlast);
                    return;
                end
                -- actions.vf+=/shadow_word_death,if=cooldown.shadow_word_death.charges=2
                if Death:Exists() and (Death:Charges() == 2 or (Death:Charges() == 1 and Death:Recharge() < 3)) then
                    ShadowWordDeath();
                end
                -- actions.vf+=/shadowfiend,if=!talent.mindbender.enabled,if=buff.voidform.stack>15
                if Shadowfiend:Exists() and module.IsOptionEnabled("Shadowfiend") and (module.CooldownsAllowed() or module.GetOptionValue("Shadowfiend") == "Always") and Player:BuffCount(VoidForm) >= 15 and Target:CanCast(Shadowfiend) then
                    Target:Cast(Shadowfiend);
                    return;
                end
                -- actions.vf+=/shadow_word_void,if=(insanity-(current_insanity_drain*gcd.max)+25)<100
                if Void:Exists() and (Insanity - (CurrentInsanityDrain * GCDMax) + 25) < 100 and Target:CanCast(Void) then
                    Target:Cast(Void);
                    return;
                end
                -- actions.vf+=/shadow_word_pain,if=!ticking,cycle_targets=1
                if Pain:Exists() and module.IsOptionEnabled("Multi-Dot Shadow Word: Pain") and PainUnit then
                    PainUnit:Cast(Pain);
                    return;
                end
                -- actions.vf+=/vampiric_touch,if=!ticking,cycle_targets=1
                if VampiricTouch:Exists() and module.IsOptionEnabled("Multi-Dot Vampiric Touch") and VampUnit then
                    VampUnit:Cast(VampiricTouch);
                    return;
                end
                -- actions.vf+=/wait,sec=cooldown.void_bolt.remains,if=cooldown.void_bolt.remains<(gcd.max*0.75)
                if VoidBolt:Cooldown() < module.GetSecondOptionValue("Void Eruption") then
                    module.Bug("Erruption in " .. VoidBolt:Cooldown());
                    return;
                end
                -- actions.vf+=/mind_flay,if=!talent.mind_spike.enabled,interrupt=1,chain=1
                -- actions.vf+=/mind_spike,if=talent.mind_spike.enabled
                MindFillers();
                -- actions.vf+=/shadow_word_pain


            -- actions+=/call_action_list,name=main
            else
                -- actions.main=surrender_to_madness,if=talent.surrender_to_madness.enabled&target.time_to_die<=90+((raw_haste_pct*100)*2)
                -- actions.main+=/mindbender,if=talent.mindbender.enabled
                if Mindbender:Exists() and module.IsOptionEnabled("Mindbender") and (module.CooldownsAllowed() or module.GetOptionValue("Mindbender") == "Always") and Target:CanCast(Mindbender) then
                    Target:Cast(Mindbender);
                    return;
                end
                -- actions.main+=/shadow_word_pain,if=dot.shadow_word_pain.remains<(3+(4%3))*gcd
                if Pain:Exists() and Target:DebuffRemains(Pain) < 4.2 and Target:CanCast(Pain) then
                    Target:Cast(Pain);
                    return;
                end
                -- actions.main+=/vampiric_touch,if=dot.vampiric_touch.remains<(4+(4%3))*gcd
                if VampiricTouch:Exists() and Target:DebuffRemains(VampiricTouch) < 5.4 and not VampiricTouch:WasLastCastOnUnit(Target) and Target:CanCast(VampiricTouch) then
                    Target:Cast(VampiricTouch);
                    return;
                end
                -- actions.main+=/void_eruption,if=insanity>=85|(talent.auspicious_spirits.enabled&insanity>=(80-shadowy_apparitions_in_flight*4))
                if VoidEruption:Exists() and Insanity >= module.GetOptionValue("Void Eruption") and Player:CanCast(VoidEruption) then
                    Player:Cast(VoidEruption);
                    return;
                end
                -- actions.main+=/shadow_crash,if=talent.shadow_crash.enabled
                if ShadowCrash:Exists() and module.IsOptionEnabled("Shadow Crash") and Target:CanCast(ShadowCrash) then
                    if Target:CastGroundSpell(ShadowCrash, "Shadow Crash", 8) then return; end
                end
                -- actions.main+=/mindbender,if=talent.mindbender.enabled&set_bonus.tier18_2pc
                if Mindbender:Exists() and module.IsOptionEnabled("Mindbender") and (module.CooldownsAllowed() or module.GetOptionValue("Mindbender") == "Always") and module.HasT18_2Pc and Target:CanCast(Mindbender) then
                    Target:Cast(Mindbender);
                    return;
                end
                -- actions.main+=/shadow_word_pain,if=!ticking&talent.legacy_of_the_void.enabled&insanity>=70,cycle_targets=1
                if Pain:Exists() and not LegacyOfTheVoid:Exists() and module.IsOptionEnabled("Multi-Dot Shadow Word: Pain") and PainUnit then
                    PainUnit:Cast(Pain);
                    return;
                end
                -- actions.main+=/vampiric_touch,if=!ticking&talent.legacy_of_the_void.enabled&insanity>=70,cycle_targets=1
                if VampiricTouch:Exists() and not LegacyOfTheVoid:Exists() and module.IsOptionEnabled("Multi-Dot Vampiric Touch") and VampUnit then
                    VampUnit:Cast(VampiricTouch);
                    return;
                end
                -- actions.main+=/shadow_word_death,if=!talent.reaper_of_souls.enabled&cooldown.shadow_word_death.charges=2&insanity<=90
                if Death:Exists() and not ReaperOfSouls:Exists() and Death:Charges() >= 2 and Insanity < 90 then
                    ShadowWordDeath();
                end
                -- actions.main+=/shadow_word_death,if=talent.reaper_of_souls.enabled&cooldown.shadow_word_death.charges=2&insanity<=70
                if Death:Exists() and ReaperOfSouls:Exists() and Death:Charges() >= 2 and Insanity < 70 then
                    ShadowWordDeath();
                end
                -- actions.main+=/mind_blast,if=talent.legacy_of_the_void.enabled&(insanity<=81|(insanity<=75.2&talent.fortress_of_the_mind.enabled))
                if MindBlast:Exists() and LegacyOfTheVoid:Exists() and (Insanity <= 81 or (Insanity <= 75.2 and FortressOfTheMind:Exists())) and Target:CanCast(MindBlast) then
                    Target:Cast(MindBlast);
                    return;
                end
                -- actions.main+=/mind_blast,if=!talent.legacy_of_the_void.enabled|(insanity<=96|(insanity<=95.2&talent.fortress_of_the_mind.enabled))
                if MindBlast:Exists() and not LegacyOfTheVoid:Exists() and (Insanity <= 96 or (Insanity <= 95.2 and FortressOfTheMind:Exists())) and Target:CanCast(MindBlast) then
                    Target:Cast(MindBlast);
                    return;
                end
                -- actions.main+=/shadow_word_pain,if=!ticking,cycle_targets=1
                if Pain:Exists() and module.IsOptionEnabled("Multi-Dot Shadow Word: Pain") and PainUnit then
                    PainUnit:Cast(Pain);
                    return;
                end
                -- actions.main+=/vampiric_touch,if=!ticking,cycle_targets=1
                if VampiricTouch:Exists() and module.IsOptionEnabled("Multi-Dot Vampiric Touch") and VampUnit then
                    VampUnit:Cast(VampiricTouch);
                    return;
                end
                -- actions.main+=/shadow_word_void,if=(insanity<=70&talent.legacy_of_the_void.enabled)|(insanity<=85&!talent.legacy_of_the_void.enabled)
                if Void:Exists() and ((Insanity <= 70 and LegacyOfTheVoid:Exists()) or (Insanity <= 85 and not LegacyOfTheVoid:Exists())) and Target:CanCast(Void) then
                    Target:Cast(Void);
                    return;
                end
                -- actions.main+=/mind_flay,if=!talent.mind_spike.enabled,interrupt=1,chain=1
                -- actions.main+=/mind_spike,if=talent.mind_spike.enabled
                MindFillers();
                -- actions.main+=/shadow_word_pain
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(MindBlast, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Resurrect Deads
        if Resurrection:Exists() and module.IsOptionEnabled("Resurrection") and Unit.ResurrectCycle(Resurrection) then
            return;
        end
        -- ShadowMend
        if ShadowMend:Exists() and module.IsOptionEnabled("Shadow Mend") and Player:HealthPercentage() <= module.GetSecondOptionValue("Shadow Mend") and Player:CanCast(ShadowMend) then
            Player:Cast(ShadowMend);
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() -- Assassination Rogue Rotation
    local Rotation = {};
    module.SetRotation(259, Rotation);

    --- Localization
    -- Core
    local Enemies_10y, Enemies_5y, NumEnemies = {}, {}, 1; -- Enemies
    local SpamPrevention, TPSTime = 0, 0.1; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local StealthAllowed, CombatStealthAllowed = false, true; -- Stealth Handler
    local MaxComboPoint, DurationThreshold = 5, 12.6; -- Combo Points Variables
    local PoisonLethal, PoisonNonLethal, PoisonMinDuration, PoisonCastTime = nil, nil, nil, nil; -- Poison Handler
    local Rupt = {BestUnit, BestUnitTTD}; -- Rupture Cycling Variables
    local Muti = {BestUnit, BestUnit2, BestUnit3, BestUnit4}; -- Mutilate Cycling Variables
    local Hemo = {BestUnit, BestUnitTTD}; -- Hemorrhage Cycling Variables

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        --- Spells
        -- (ID, RequiresFacing, Hostile, Instant)
        -- Racials
        ArcaneTorrent = Spell(25046, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);
        -- Items
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Abilities
        Anticipation = Spell(114015, false, false, true);
        CheapShot = Spell(1833, true, true, true);
        DeathFromAbove = Spell(152150, true, true, true);
        DeeperStrategem = Spell(193531, false, false, true);
        ElaboratePlanning = Spell(193640, false, false, false);
        ElaboratePlanningBuff = Spell(193641, false, false, false);
        Envenom = Spell(32645, true, true, true);
        Exsanguinate = Spell(200806, true, true, true);
        FanOfKnives = Spell(51723, false, false, true);
        Garrote = Spell(703, true, true, true);
        Hemorrhage = Spell(16511, true, true, true);
        Kick = Spell(1766, true, true, true);
        KidneyShot = Spell(408, true, true, true);
        MarkedForDeath = Spell(137619, false, true, true);
        Mutilate = Spell(1329, true, true, true);
        PickPocket = Spell(921, true, true, true);
        PoisonedKnife = Spell(185565, true, true, true);
        Rupture = Spell(1943, true, true, true);
        ShadowFocus = Spell(108209, false, false, true);
        Subterfuge = Spell(108208, false, false, true);
        Stealth = Spell(1784, false, false, true);
        TricksoftheTrade = Spell(57934, false, false, true);
        Vanish = Spell(1856, false, false, true);
        -- Offensive Cooldowns
        Kingsbane = Spell(192759, true, true, true);
        Vendetta = Spell(79140, true, true, true);
        -- Defensive Cooldowns
        CloakofShadows = Spell(31224, false, false, true);
        CrimsonVial = Spell(185311, false, false, true);
        Feint = Spell(1966, false, false, true);
        Evasion = Spell(5277, false, false, true);
        -- Poisons
        AgonizingPoison = Spell(200802, false, false, false);
        AgonizingPoisonDebuff = Spell(200803, false, true, false);
        CripplingPoison = Spell(3408, false, false, false);
        DeadlyPoison = Spell(2823, false, false, false);
        DeadlyPoisonDebuff = Spell(2818, false, true, true);
        LeechingPoison = Spell(108211, false, false, false);
        WoundPoison = Spell(8679, false, false, false);

        --- GUI Frame
        -- Pages
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Kick to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddNewOption("General Settings", "Tricks of the Trade on Focus", 230, false, {2, "Always", "On Aggro"}, nil, "Will use Tricks of the Trade on your focus if he's allied."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Everytime it is available."..C.TOOLTIP_SUBVALUE("On Aggro").."Only if you have the aggro of something.");
        module.AddSection("General Settings", "Poisons", "Green");
        module.AddNewOption("General Settings", "Lethal | Non-Lethal", 233, true, {1, "Agonizing", "Deadly", "Wound"}, {1, "Leeching", "Crippling"}, "Choose your Poisons"..C.TOOLTIP_VALUE_1.."Choose your Lethal Poison."..C.TOOLTIP_VALUE_2.."Choose your Non-Lethal Poison. "..C.TOOLTIP_HINT("If you choose Agonizing and/or Leeching but you don't have the talent it will put Deadly and/or Crippling."));
        module.AddNewOption("General Settings", "Min Duration Poison", 120, true, {15, 0, 60, 1}, nil, "Set the minimun duration to have on Poisons in minutes before starting the combat.");
        module.AddSection("General Settings", "Solo", "Green");
        module.AddNewOption("General Settings", "Kidney Shot", 210, false, nil, nil, "Enable for the automatic usage of Kidney Shot."..C.TOOLTIP_HINT("Useful if you're having hard time while soloing."));
        module.AddNewOption("General Settings", "Cheap Shot", 210, false, nil, nil, "Enable for the automatic usage of Cheap Shot."..C.TOOLTIP_HINT("Useful if you're having hard time while soloing."));
        module.AddNewOption("General Settings", "Pick Pocket", 210, false, nil, nil, "Will PickPocket your target before engaging it."..C.TOOLTIP_HINT("Enabling Pick Pocket will turn on Auto-Loot."));

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddNewOption("Offensive Settings", "Stealth", 230, true, {1, "Always", "Near Target"}, nil, "Enable for the automatic usage of Stealth."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Everytime it is available."..C.TOOLTIP_SUBVALUE("Near Target").."When approaching your target.");
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Exsanguinate", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Exsanguinate."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Marked For Death", 233, true, {2, "Target", "Adds"}, {1, "Always", "Cooldown Only"}, "Enable for the automatic usage of Marked for Death."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Target", true).."Only on your target with 1 or less CP."..C.TOOLTIP_SUBVALUE("Adds").."On every units available."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Vanish", 233, true, {1, "Always", "Not Tanking"}, {2, "Always", "Cooldown Only"}, "Enable for the automatic usage of Vanish."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will 'Always' use Vanish no matter if you're tanking or not."..C.TOOLTIP_SUBVALUE("Not Tanking").."Will only use Vanish if you're 'Not Tanking' the target (Mostly for Solo)."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Kingsbane", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Kingsbane."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Vendetta", 210, true, nil, nil, "Enable for the automatic usage of Vendetta.");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Arcane Torrent, Berserking, Bloodfury are supported."));
        end
        module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Disabled", "Enabled"}, {2, "Disabled", "Enabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Poisoned Knife", 220, true, {75, 40, 150, 1}, nil, "Enable to auto use Throw while not being in melee range and not being stealthed."..C.TOOLTIP_VALUE.."Set the minimum energy to start using it.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Health Percentage to use Healing Belt / Healing Pot / Healthstone.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Crimson Vial", 220, true, {65, 1, 100, 1}, nil, "Health Percentage to use Crimson Vial.");
        module.AddNewOption("Defensive Settings", "Feint", 220, false, {55, 1, 100, 1}, nil, "Health Percentage to use Feint."..C.TOOLTIP_HINT("Put 100 to maintain 100% uptime."));
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, false, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Evasion", 220, true, {25, 1, 100, 1}, nil, "Health Percentage to use Evasion.");
        module.AddNewOption("Defensive Settings", "Cloak of Shadows", 220, true, {45, 1, 100, 1}, nil, "Health Percentage to use Cloak of Shadows.");
        module.AddNewOption("Defensive Settings", "Vanish Defensive", 220, false, {10, 1, 100, 1}, nil, "Health Percentage to use Vanish defensively.");

        --- Misc
        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated
        Player:SetCommonMeleeStatus();
        -- Reset the target for the Auto Re-Target Option
        Target = module.Unit.Target;
        -- Combo Points Variables
        MaxComboPoint = Anticipation:Exists() and 8 or DeeperStrategem:Exists() and 6 or 5;
        DurationThreshold = DeeperStrategem:Exists() and 8.4 or 7.2;
        -- Stealth Handler
        CombatStealthAllowed = Vanish:TimeSinceCast() > 0.5;
        Stealth = Subterfuge:Exists() and Spell(115191, false, false, true) or Spell(1784, false, false, true); -- w/ or w/o Subterfuge Talent

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Vanish Defensive") and VanishAllowed and not Player:IsStealthed(true) and Player:HealthPercentage() <= module.GetOptionValue("Vanish Defensive") and Shadowmeld:TimeSinceCast() > 0.5 and Player:CanCast(Vanish) then
            Player:Cast(Vanish);
            Vanish.LastCastTime = module.GetTime();
            return;
        end
        if module.IsOptionEnabled("Evasion") and not Player:Buff(Evasion) and Player:HealthPercentage() <= module.GetOptionValue("Evasion") and Player:CanCast(Evasion) then
            Player:Cast(Evasion);
        end
        if module.IsOptionEnabled("Cloak of Shadows") and Player:HealthPercentage() <= module.GetOptionValue("Cloak of Shadows") and Player:CanCast(CloakofShadows) then
            Player:Cast(CloakofShadows);
        end
        -- Defensive Abilities
        if module.IsOptionEnabled("Feint") and Player:HealthPercentage() <= module.GetOptionValue("Feint") and not Player:Buff(Feint) and Player:CanCast(Feint) then
            Player:Cast(Feint);
            return;
        end
        if module.IsOptionEnabled("Crimson Vial") and Player:HealthPercentage() <= module.GetOptionValue("Crimson Vial") and Player:CanCast(CrimsonVial) then
            Player:Cast(CrimsonVial);
            return;
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Kick, ArcaneTorrent);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Tricks of the Trade on Focus
        if module.IsOptionEnabled("Tricks of the Trade on Focus") and (module.GetOptionValue("Tricks of the Trade on Focus") == "Always" or (Player:ThreatSituation() and Player:ThreatSituation() >= 1)) and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
            Focus:Cast(TricksoftheTrade);
        end
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Marked for Death Handler for Adds
        if Player:UseMarkedForDeath(MarkedForDeath, Player:ComboPointsDeficit()) then
            return;
        end
        -- Auto Target
        Target = Player:ReTarget(Mutilate, false) or Unit.Target;
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Enemies Check
            if module.UseAOE() then
                Enemies_10y = Player:EnemiesWithinDistance(10, true); -- Using 10y (real range) for Fan of Knives and true as they are PlayerCenteredAoE Spells.
                Enemies_5y = Player:FilterEnemiesByDistance(Enemies_10y, 5, false); -- This table is used for Melee Range Cycling Abilities (like Rupture, Hemorrhage, ...).
                NumEnemies = #Enemies_10y;
            else
                NumEnemies = 1;
            end
            -- Cooldowns
            if Player:IsWithinCastRange(Target, Mutilate) then
                if module.CooldownsAllowed() then
                    -- potion,name=draenic_agility,if=buff.bloodlust.react|target.time_to_die<30|cooldown.vendetta.remains<10
                    -- TODO

                    -- vendetta,if=((!artifact.urge_to_kill.enabled&dot.rupture.ticking)|(energy%energy.max)<0.4)&(time<10|cooldown.exsanguinate.remains<5)
                    -- TODO Add Urge to Kill
                    if module.IsOptionEnabled("Vendetta") and not Target:Debuff(Vendetta) and (Target:Debuff(Rupture) or (Player:Energy()/Player:EnergyMax() < 0.4 and (CombatTime() < 10 or not Exsanguinate:Exists() or Exsanguinate:Cooldown() < 5))) and Target:CanCast(Vendetta) then
                        Target:Cast(Vendetta);
                    end
                    -- use_item,slot=x,if=buff.bloodlust.react|target.time_to_die<20|debuff.vendetta.up
                    if Player:HasHero() or Target:TimeToDie() < 20 or Target:Debuff(Vendetta) then
                        Player:UseTrinkets();
                    end
                end
                if (BloodFury:Exists() or Berserking:Exists() or ArcaneTorrent:Exists()) and module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:IsWithinCastRange(Target, Mutilate) and Target:Debuff(Vendetta) then
                    -- blood_fury,if=debuff.vendetta.up
                    if Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- berserking,if=debuff.vendetta.up
                    if Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                    -- arcane_torrent,if=debuff.vendetta.up&energy.deficit>50
                    if Player:CanCast(ArcaneTorrent) and Player:EnergyDeficit() > 50 then
                        Player:Cast(ArcaneTorrent);
                    end
                end
                -- exsanguinate,if=prev_gcd.rupture&dot.rupture.remains>20
                if module.IsOptionEnabled("Exsanguinate") and (module.CooldownsAllowed() or module.GetOptionValue("Exsanguinate") == "Always") and Exsanguinate:Exists() and Target:DebuffRemains(Rupture) > 20 and Target:CanCast(Exsanguinate) then
                    Target:Cast(Exsanguinate);
                    return;
                end
                if not Player:IsStealthed(true, true) and CombatStealthAllowed then
                    -- vanish,if=cooldown.exsanguinate.remains<2&combo_points>4+talent.deeper_stratagem.enabled
                    if module.IsOptionEnabled("Vanish") and (module.CooldownsAllowed() or module.GetSecondOptionValue("Vanish") == "Always") and (not Player:IsTanking(Target) or module.GetOptionValue("Vanish") == "Always") and (Exsanguinate:Cooldown() < 2 or not Exsanguinate:Exists()) and Player:ComboPoints() > 4+(DeeperStrategem:Exists() and 1 or 0) and Player:CanCast(Vanish) then
                        Player:Cast(Vanish);
                        Vanish.LastCastTime = module.GetTime();
                        return;
                    end
                end
            end
            -- Kidney Shot
            if module.IsOptionEnabled("Kidney Shot") and not Target:IsBoss() and Target:DebuffRemains(CheapShot) < 1 and Target:CanCast(KidneyShot) then
                Target:Cast(KidneyShot);
                return;
            end
            -- rupture,if=(combo_points>4+talent.deeper_stratagem.enabled&(cooldown.exsanguinate.remains<1|!exsanguinated&refreshable))|(time<4&dot.hemorrhage.remains>10&dot.garrote.remains>8)
            if ((Player:ComboPoints() > 4+(DeeperStrategem:Exists() and 1 or 0) and (Exsanguinate:Cooldown() < 1 or (not module.Exsanguinated(Target, "Rupture") and Target:DebuffRefreshable(Rupture)))) or (CombatTime() < 4 and Target:DebuffRemains(Hemorrhage) > 10 and Target:DebuffRemains(Garrote) > 8)) and Target:CanCast(Rupture) then
                Target:Cast(Rupture);
                return;
            end
            -- rupture,if=spell_targets.fan_of_knives>1&!ticking&combo_points>4
            if NumEnemies > 1 and Player:ComboPoints() > 4+(DeeperStrategem:Exists() and 1 or 0) and not Target:Debuff(Rupture) and Target:CanCast(Rupture) then
                Target:Cast(Rupture);
                return;
            end
            -- rupture,cycle_targets=1,target_if=max:target.time_to_die,max_cycle_targets=6,if=spell_targets.fan_of_knives>1&!ticking&combo_points>4
            if NumEnemies > 1 and Player:ComboPoints() > 4+(DeeperStrategem:Exists() and 1 or 0) then
                local Count = 0;
                local ThisUnit;
                for i = 1, #Enemies_5y do
                    ThisUnit = Enemies_5y[i];
                    if ThisUnit:Debuff(Rupture) then
                        Count = Count + 1;
                    end
                end
                if Count <= 6 then
                    Rupt.BestUnit, Rupt.BestUnitTTD = nil, 4;
                    -- TTD Units Handler.
                    local ThisUnitTTD;
                    for i = 1, #Enemies_5y do
                        ThisUnit = Enemies_5y[i];
                        ThisUnitTTD = ThisUnit:TimeToDie(10);
                        if ThisUnitTTD < 5000 and not ThisUnit:Debuff(Rupture) and ThisUnitTTD > Rupt.BestUnitTTD and ThisUnit:CanCast(Rupture) then
                            Rupt.BestUnit, Rupt.BestUnitTTD = ThisUnit, ThisUnitTTD;
                        end
                    end
                    -- Cast Rupture if we got an unit.
                    if Rupt.BestUnit then
                        Rupt.BestUnit:Cast(Rupture);
                        return;
                    end
                end
            end
            -- death_from_above,if=combo_points>4
            if DeathFromAbove:Exists() and Player:ComboPoints() > 4 and Target:CanCast(DeathFromAbove) then
                Target:Cast(DeathFromAbove);
                return;
            end
            -- envenom,if=combo_points>3+talent.deeper_stratagem.enabled&(energy.deficit<40|dot.rupture.exsanguinated)&buff.envenom.remains<(1+combo_points)*0.3&buff.elaborate_planning.remains<2
            if Player:ComboPoints() > 3+(DeeperStrategem:Exists() and 1 or 0) and (Player:EnergyDeficit() < 40 or module.Exsanguinated(Target, "Rupture")) and Player:BuffRemains(Envenom) < (1+Player:ComboPoints())*0.3 and Player:BuffRemains(ElaboratePlanningBuff) < 2 and Target:CanCast(Envenom) then
                Target:Cast(Envenom);
                return;
            end
            -- marked_for_death,cycle_targets=1,target_if=min:target.time_to_die,if=combo_points.deficit>=4+talent.deeper_stratagem.enabled
            if module.IsOptionEnabled("Marked For Death") and module.GetOptionValue("Marked For Death") == "Target" and (module.CooldownsAllowed() or module.GetSecondOptionValue("Marked For Death") == "Always") and MarkedForDeath:Exists() and Player:ComboPointsDeficit() >= 4+(DeeperStrategem:Exists() and 1 or 0) and Target:CanCast(MarkedForDeath) then
                Target:Cast(MarkedForDeath);
                return;
            end
            -- rupture,cycle_targets=1,target_if=max:target.time_to_die,max_cycle_targets=6,if=combo_points>4&refreshable&spell_targets.fan_of_knives>1
            if NumEnemies > 1 and Player:ComboPoints() > 4 and Target:DebuffRefreshable(Rupture) and Target:CanCast(Rupture) then
                Target:Cast(Rupture);
                return;
            end
            if NumEnemies > 1 and Player:ComboPoints() > 4+(DeeperStrategem:Exists() and 1 or 0) then
                local Count = 0;
                local ThisUnit;
                for i = 1, #Enemies_5y do
                    ThisUnit = Enemies_5y[i];
                    if ThisUnit:Debuff(Rupture) then
                        Count = Count + 1;
                    end
                end
                if Count <= 6 then
                    Rupt.BestUnit, Rupt.BestUnitTTD = nil, 4;
                    -- TTD Units Handler.
                    local ThisUnitTTD;
                    for i = 1, #Enemies_5y do
                        ThisUnit = Enemies_5y[i];
                        ThisUnitTTD = ThisUnit:TimeToDie(10);
                        if ThisUnitTTD < 5000 and ThisUnit:DebuffRemains(Rupture) <= DurationThreshold and ThisUnitTTD > Rupt.BestUnitTTD and ThisUnit:CanCast(Rupture) then
                            Rupt.BestUnit, Rupt.BestUnitTTD = ThisUnit, ThisUnitTTD;
                        end
                    end
                    -- Cast Rupture if we got an unit.
                    if Rupt.BestUnit then
                        Rupt.BestUnit:Cast(Rupture);
                        return;
                    end
                end
            end
            -- mutilate,if=prev_gcd.exsanguinate
            if Exsanguinate:Exists() and Exsanguinate:Cooldown() > 43.5 and Target:CanCast(Mutilate) then
                Target:Cast(Mutilate);
                return;
            end
            -- kingsbane,if=time>6
            if module.IsOptionEnabled("Kingsbane") and (module.CooldownsAllowed() or module.GetOptionValue("Kingsbane") == "Always") and Kingsbane:Exists() and CombatTime() > 6 and Target:CanCast(Kingsbane) then
                Target:Cast(Kingsbane);
                return;
            end
            if not AgonizingPoison:Exists() and NumEnemies > 1 and NumEnemies < 3 then
                -- mutilate,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4
                if Target:DebuffRemains(DeadlyPoisonDebuff) < 4 and Target:CanCast(Mutilate) then
                    Target:Cast(Mutilate);
                    return;
                end
                -- mutilate,cycle_targets=1,target_if=min:dot.deadly_poison_dot.remains,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4&dot.rupture.ticking&dot.garrote.ticking
                -- mutilate,cycle_targets=1,target_if=min:dot.deadly_poison_dot.remains,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4&dot.rupture.ticking
                -- mutilate,cycle_targets=1,target_if=min:dot.deadly_poison_dot.remains,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4&dot.garrote.ticking
                -- mutilate,cycle_targets=1,target_if=min:dot.deadly_poison_dot.remains,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4
                Muti.BestUnit, Muti.BestUnit2, Muti.BestUnit3, Muti.BestUnit4 = nil, nil, nil, nil;
                -- TTD Units Handler.
                local ThisUnit;
                for i = 1, #Enemies_5y do
                    ThisUnit = Enemies_5y[i];
                    if ThisUnit:DebuffRemains(DeadlyPoisonDebuff) < 4 and ThisUnit:CanCast(Mutilate) then
                        if ThisUnit:Debuff(Rupture) and ThisUnit:Debuff(Garrote) then
                            Muti.BestUnit = ThisUnit;
                        end
                        if ThisUnit:Debuff(Rupture) then
                            Muti.BestUnit2 = ThisUnit;
                        end
                        if ThisUnit:Debuff(Garrote) then
                            Muti.BestUnit3 = ThisUnit;
                        end
                        Muti.BestUnit4 = ThisUnit;
                    end
                end
                -- Cast Rupture if we got an unit.
                if Muti.BestUnit then
                    Muti.BestUnit:Cast(Mutilate);
                    return;
                elseif Muti.BestUnit2 then
                    Muti.BestUnit2:Cast(Mutilate);
                    return;
                elseif Muti.BestUnit3 then
                    Muti.BestUnit3:Cast(Mutilate);
                    return;
                elseif Muti.BestUnit4 then
                    Muti.BestUnit4:Cast(Mutilate);
                    return;
                end
            end
            -- hemorrhage,cycle_targets=1,target_if=max:target.time_to_die,max_cycle_targets=3,if=combo_points.deficit>=1&spell_targets.fan_of_knives>1&!ticking&dot.rupture.remains>6
            if Hemorrhage:Exists() and NumEnemies > 1 and Player:ComboPointsDeficit() >= 1 then
                if not Target:Debuff(Hemorrhage) and Target:DebuffRemains(Rupture) > 6 and Target:CanCast(Hemorrhage) then
                    Target:Cast(Hemorrhage);
                    return;
                end
                if module.UseAOE() then
                    local Count = 0;
                    local ThisUnit;
                    for i = 1, #Enemies_5y do
                        ThisUnit = Enemies_5y[i];
                        if ThisUnit:Debuff(Hemorrhage) then
                            Count = Count + 1;
                        end
                    end
                    if Count <= 3 then
                        Hemo.BestUnit, Hemo.BestUnitTTD = nil, 4;
                        -- TTD Units Handler.
                        local ThisUnit, ThisUnitTTD;
                        for i = 1, #Enemies_5y do
                            ThisUnit = Enemies_5y[i];
                            ThisUnitTTD = ThisUnit:TimeToDie(10);
                            if ThisUnitTTD < 5000 and ThisUnitTTD > Hemo.BestUnitTTD and not ThisUnit:Debuff(Hemorrhage) and ThisUnit:DebuffRemains(Rupture) >= 6 and ThisUnit:CanCast(Hemorrhage) then
                                Hemo.BestUnit, Hemo.BestUnitTTD = ThisUnit, ThisUnitTTD;
                            end
                        end
                        -- Cast Hemorrhage if we got an unit.
                        if Hemo.BestUnit then
                            Hemo.BestUnit:Cast(Hemorrhage);
                            return;
                        end
                    end
                end
            end
            -- fan_of_knives,if=combo_points.deficit>=1&(spell_targets>3|(poisoned_enemies<3&spell_targets>2))
            if Player:ComboPointsDeficit() >= 1 and Player:CanCast(FanOfKnives) then
                local Count = 0;
                local ThisUnit;
                for i = 1, #Enemies_5y do
                    ThisUnit = Enemies_5y[i];
                    if ThisUnit:Debuff(AgonizingPoisonDebuff) or ThisUnit:Debuff(DeadlyPoisonDebuff) then
                        Count = Count + 1;
                    end
                end
                if NumEnemies > 3 or (Count < 3 and NumEnemies > 2) then
                    Player:Cast(FanOfKnives);
                    return;
                end
            end
            -- mutilate,if=(combo_points.deficit>=2&cooldown.garrote.remains>1&(!dot.hemorrhage.refreshable|!talent.hemorrhage.enabled))
            if Player:ComboPointsDeficit() >= 2 and Garrote:Cooldown() > 1 and (not Target:DebuffRefreshable(Hemorrhage) or not Hemorrhage:Exists()) and Target:CanCast(Mutilate) then
                Target:Cast(Mutilate);
                return;
            end
            -- garrote,if=combo_points.deficit>=1&refreshable&!dot.garrote.exsanguinated
            if Player:ComboPointsDeficit() >= 1 and Target:DebuffRefreshable(Garrote) and not module.Exsanguinated(Target, "Garrote") and Target:CanCast(Garrote) then
                Target:Cast(Garrote);
                return;
            end
            -- hemorrhage,if=combo_points.deficit>=1&(refreshable|(cooldown.exsanguinate.remains<2|dot.rupture.refreshable))
            if Hemorrhage:Exists() and Player:ComboPointsDeficit() >= 1 and (Target:DebuffRefreshable(Hemorrhage) or (Exsanguinate:Exists() and Exsanguinate:Cooldown() < 2) or Target:DebuffRefreshable(Rupture)) and Target:CanCast(Hemorrhage) then
                Target:Cast(Hemorrhage);
                return;
            end
            -- Poisoned Knife Out of Range
            if module.IsOptionEnabled("Poisoned Knife") and not Player:IsWithinCastRange(Target, Mutilate) and not Player:IsStealthed(true) and Player:Energy() > module.GetOptionValue("Poisoned Knife") and (Player:ComboPoints() < MaxComboPoint or Player:PowerTimeToMax() <= 1.5) and Target:CanCast(PoisonedKnife) then
                Target:Cast(PoisonedKnife);
                return;
            end
            return;
        end
        -- potion,name=draenic_agility,if=buff.bloodlust.react|target.time_to_die<30|cooldown.vendetta.remains<10
        -- use_item,slot=finger1,if=buff.bloodlust.react|target.time_to_die<20|debuff.vendetta.up
        -- blood_fury,if=debuff.vendetta.up
        -- berserking,if=debuff.vendetta.up
        -- arcane_torrent,if=debuff.vendetta.up&energy.deficit>50
        -- vendetta,if=((!artifact.urge_to_kill.enabled&dot.rupture.ticking)|(energy%energy.max)<0.4)&(time<10|cooldown.exsanguinate.remains<5)
        -- exsanguinate,if=prev_gcd.rupture&dot.rupture.remains>20
        -- vanish,if=cooldown.exsanguinate.remains<2&combo_points>4+talent.deeper_stratagem.enabled
        -- rupture,if=(combo_points>4+talent.deeper_stratagem.enabled&(cooldown.exsanguinate.remains<1|!exsanguinated&refreshable))|(time<4&dot.hemorrhage.remains>10&dot.garrote.remains>8)
        -- rupture,if=spell_targets.fan_of_knives>1&!ticking&combo_points>4
        -- rupture,cycle_targets=1,target_if=max:target.time_to_die,max_cycle_targets=6,if=spell_targets.fan_of_knives>1&!ticking&combo_points>4
        -- death_from_above,if=combo_points>4
        -- envenom,if=combo_points>3+talent.deeper_stratagem.enabled&(energy.deficit<40|dot.rupture.exsanguinated)&buff.envenom.remains<(1+combo_points)*0.3&buff.elaborate_planning.remains<2
        -- marked_for_death,cycle_targets=1,target_if=min:target.time_to_die,if=combo_points.deficit>=4+talent.deeper_stratagem.enabled
        -- rupture,cycle_targets=1,target_if=max:target.time_to_die,max_cycle_targets=6,if=combo_points>4&refreshable&spell_targets.fan_of_knives>1
        -- mutilate,if=prev_gcd.exsanguinate
        -- kingsbane,if=time>6
        -- mutilate,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4
        -- mutilate,cycle_targets=1,target_if=min:dot.deadly_poison_dot.remains,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4&dot.rupture.ticking&dot.garrote.ticking
        -- mutilate,cycle_targets=1,target_if=min:dot.deadly_poison_dot.remains,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4&dot.rupture.ticking
        -- mutilate,cycle_targets=1,target_if=min:dot.deadly_poison_dot.remains,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4&dot.garrote.ticking
        -- mutilate,cycle_targets=1,target_if=min:dot.deadly_poison_dot.remains,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4
        -- hemorrhage,cycle_targets=1,target_if=max:target.time_to_die,max_cycle_targets=3,if=combo_points.deficit>=1&spell_targets.fan_of_knives>1&!ticking&dot.rupture.remains>6
        -- fan_of_knives,if=combo_points.deficit>=1&(spell_targets>3|(poisoned_enemies<3&spell_targets>2))
        -- mutilate,if=(combo_points.deficit>=2&cooldown.garrote.remains>1&(!dot.hemorrhage.refreshable|!talent.hemorrhage.enabled))
        -- garrote,if=combo_points.deficit>=1&refreshable&!dot.garrote.exsanguinated
        -- hemorrhage,if=combo_points.deficit>=1&(refreshable|(cooldown.exsanguinate.remains<2|dot.rupture.refreshable))
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Disable Stealth if the Loot Window is open, we are interacting with an NPC or combat has just ended. (Also used for PickPocket)
        StealthAllowed = GetNumLootItems() == 0 and not UnitExists("npc") and OutOfCombatTime() > 1 and true or false;
        -- PickPocket Handler Init
        if module.IsOptionEnabled("Pick Pocket") and not module.PickPocketInitialized then
            Player:PickPocketInit();
        end
        -- Poisons
        if not Player:IsMoving() and module.IsOptionEnabled("Lethal | Non-Lethal") then
            PoisonLethal = module.GetOptionValue("Lethal | Non-Lethal");
            PoisonNonLethal = module.GetSecondOptionValue("Lethal | Non-Lethal");
            PoisonMinDuration = module.GetOptionValue("Min Duration Poison")*60;
            PoisonCastTime = 3.3; -- Changing from 1.5s to 3s each 2 patches so I keep this variable for now.
            -- Lethal Poison
            if ((not AgonizingPoison:Exists() and PoisonLethal == "Agonizing") or PoisonLethal == "Deadly") and Player:BuffRemains(DeadlyPoison) <= PoisonMinDuration and DeadlyPoison:TimeSinceCast() > PoisonCastTime and Player:CanCast(DeadlyPoison) then
                Player:Cast(DeadlyPoison);
                DeadlyPoison.LastCastTime = module.GetTime();
                return;
            elseif PoisonLethal == "Wound" and Player:BuffRemains(WoundPoison) <= PoisonMinDuration and WoundPoison:TimeSinceCast() > PoisonCastTime and Player:CanCast(WoundPoison) then
                Player:Cast(WoundPoison);
                WoundPoison.LastCastTime = module.GetTime();
                return;
            elseif PoisonLethal == "Agonizing" and AgonizingPoison:Exists() and Player:BuffRemains(AgonizingPoison) <= PoisonMinDuration and AgonizingPoison:TimeSinceCast() > PoisonCastTime and Player:CanCast(AgonizingPoison) then
                Player:Cast(AgonizingPoison);
                AgonizingPoison.LastCastTime = module.GetTime();
                return;
            end
            -- Non-Lethal Poison
            if (not LeechingPoison:Exists() or PoisonNonLethal == "Crippling") and Player:BuffRemains(CripplingPoison) <= PoisonMinDuration and CripplingPoison:TimeSinceCast() > PoisonCastTime and Player:CanCast(CripplingPoison) then
                Player:Cast(CripplingPoison);
                CripplingPoison.LastCastTime = module.GetTime();
                return;
            elseif PoisonNonLethal == "Leeching" and LeechingPoison:Exists() and Player:BuffRemains(LeechingPoison) <= PoisonMinDuration and LeechingPoison:TimeSinceCast() > PoisonCastTime and Player:CanCast(LeechingPoison) then
                Player:Cast(LeechingPoison);
                LeechingPoison.LastCastTime = module.GetTime();
                return;
            end
        end
        -- Stealth
        if module.IsOptionEnabled("Stealth") and module.GetOptionValue("Stealth") == "Always" and StealthAllowed and not Player:IsStealthed(true) and Stealth:TimeSinceCast() > 0.4 and Player:CanCast(Stealth) then
            Player:Cast(Stealth);
            Stealth.LastCastTime = module.GetTime();
            return;
        end
        -- Crimson Vial
        if module.IsOptionEnabled("Crimson Vial") and Player:HealthPercentage() <= module.GetOptionValue("Crimson Vial") and Player:CanCast(CrimsonVial) then
            Player:Cast(CrimsonVial);
            return;
        end
        -- Pre Trick of the Trade
        if module.IsOptionEnabled("Tricks of the Trade on Focus") and BMPullTime() <= 1.5 and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
            Focus:Cast(TricksoftheTrade);
        end
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Stealth
            if module.IsOptionEnabled("Stealth") and Player:DistanceTo(Target) < 25 and StealthAllowed and not Player:IsStealthed(true) and Stealth:TimeSinceCast() > 0.4 and Player:CanCast(Stealth) then
                Player:Cast(Stealth);
                Stealth.LastCastTime = module.GetTime();
                return;
            end
            if Player:IsStealthed(true) and Player:HealthPercentage() > module.GetOptionValue("Vanish Defensive") then
                if module.IsOptionEnabled("Tricks of the Trade on Focus") and Player:DistanceTo(Target) < 10 and BMPullTime() == 60 and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
                    Focus:Cast(TricksoftheTrade);
                end
                if module.IsOptionEnabled("Pick Pocket") and not module.PickPocketed[Target:GUID()] then
                    if Target:CanCast(PickPocket) then
                        Target:Cast(PickPocket);
                        module.PickPocketTarget = Target:GUID();
                        module.PickPocketAttempt = module.GetTime();
                    end
                    return;
                end
                if module.IsOptionEnabled("Cheap Shot") and not Target:IsBoss() and Target:CanCast(CheapShot) then
                    Target:Cast(CheapShot);
                    return;
                end
                if Target:CanCast(Mutilate) then
                    Target:Cast(Mutilate);
                    return;
                end
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Outlaw Rogue Rotation
    local Rotation = {};
    module.SetRotation(260, Rotation);

    --- Localization
    -- Core
    local Enemies_8y, NumEnemies = {}, 1; -- Enemies
    local SpamPrevention, TPSTime = 0, 0.1; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local StealthAllowed, CombatStealthAllowed = false, true; -- Stealth Handler
    local MaxComboPoint, CPDiff, DurationThreshold = 5, 0, 12.6; -- Combo Points Variables
    local ShadowmeldStanding = 0.7; -- Time to Stand before casting Shadowmeld (because movements cancel it)
    local EnemiesTimer, EnemiesReset = 0, nil; -- Blade Flurry Handler

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        --- Spells
        -- (ID, RequiresFacing, Hostile, Instant)
        -- Racials
        ArcaneTorrent = Spell(25046, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);
        Shadowmeld = Spell(58984, false, false, true);
        -- Items
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Abilities
        Ambush = Spell(8676, true, true, true);
        Anticipation = Spell(114015, false, false, true);
        BetweentheEyes = Spell(199804, true, true, true);
        BladeFlurry = Spell(13877, false, false, true);
        CannonballBarrage = Spell(185767, false, true, true);
        CheapShot = Spell(1833, true, true, true);
        DeathFromAbove = Spell(152150, true, true, true);
        DeeperStrategem = Spell(193531, false, false, true);
        GhostlyStrike = Spell(196937, true, true, true);
        Kick = Spell(1766, true, true, true);
        KillingSpree = Spell(51690, false, true, true);
        MarkedForDeath = Spell(137619, false, true, true);
        Opportunity = Spell(195627, false, false, true);
        PickPocket = Spell(921, true, true, true);
        PistolShot = Spell(185763, true, true, true);
        QuickDraw = Spell(196938, false, false, true);
        RolltheBones = Spell(193316, false, false, true);
        RunThrough = Spell(2098, true, true, true);
        SaberSlash = Spell(193315, true, true, true);
        SliceAndDice = Spell(5171, false, false, true);
        Sprint = Spell(2983, false, false, true);
        Stealth = Spell(1784, false, false, true);
        TricksoftheTrade = Spell(57934, false, false, true);
        Vanish = Spell(1856, false, false, true);
        -- Offensive Cooldowns
        AdrenalineRush = Spell(13750, false, false, true);
        CurseoftheDreadblades = Spell(202665, false, false, true);
        -- Defensive Cooldowns
        CloakofShadows = Spell(31224, false, false, true);
        CrimsonVial = Spell(185311, false, false, true);
        Feint = Spell(1966, false, false, true);
        Riposte = Spell(199754, false, false, true);
        -- Roll the Bones
        JollyRoger = Spell(199603, false, false, true); -- Heal
        TrueBearing = Spell(193359, false, false, true); -- Reduc CD
        SharkInfestedWaters = Spell(193357, false, false, true); -- 40% Crit
        BuriedTreasure = Spell(199600, false, false, true); -- Energy Regen
        GrandMelee = Spell(193358, false, false, true); -- Attacks Faster
        Broadsides = Spell(193356, false, false, true); -- Attacks Faster

        --- GUI Frame
        -- Pages
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Kick to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddNewOption("General Settings", "Tricks of the Trade on Focus", 230, false, {2, "Always", "On Aggro"}, nil, "Will use Tricks of the Trade on your focus if he's allied."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Everytime it is available."..C.TOOLTIP_SUBVALUE("On Aggro").."Only if you have the aggro of something.");
        module.AddSection("General Settings", "Solo", "Green");
        module.AddNewOption("General Settings", "Cheap Shot", 210, false, nil, nil, "Enable for the automatic usage of Cheap Shot."..C.TOOLTIP_HINT("Useful if you're having hard time while soloing."));
        module.AddNewOption("General Settings", "Pick Pocket", 210, false, nil, nil, "Will PickPocket your target before engaging it."..C.TOOLTIP_HINT("Enabling Pick Pocket will turn on Auto-Loot."));

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddNewOption("Offensive Settings", "Stealth", 230, true, {1, "Always", "Near Target"}, nil, "Enable for the automatic usage of Stealth."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Everytime it is available."..C.TOOLTIP_SUBVALUE("Near Target").."When approaching your target.");
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Marked For Death", 233, true, {2, "Target", "Adds"}, {1, "Always", "Cooldown Only"}, "Enable for the automatic usage of Marked for Death."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Target", true).."Only on your target with 1 or less CP."..C.TOOLTIP_SUBVALUE("Adds").."On every units available."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Vanish", 233, true, {1, "Always", "Not Tanking"}, {2, "Always", "Cooldown Only"}, "Enable for the automatic usage of Vanish."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will 'Always' use Vanish no matter if you're tanking or not."..C.TOOLTIP_SUBVALUE("Not Tanking").."Will only use Vanish if you're 'Not Tanking' the target (Mostly for Solo)."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Curse of the Dreadblades", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Curse of the Dreadblades."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "CB | KS", 223, true, {1, 1, 3, 1}, {2, "Always", "Cooldown Only"}, "Enable for the automatic usage of Cannonball Barrage | Killing Spree."..C.TOOLTIP_VALUE_1.."Set the number of unit around you required in order to use Cannonball Barrage."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Adrenaline Rush", 210, true, nil, nil, "Enable for the automatic usage of Adrenaline Rush.");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() or Shadowmeld:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Arcane Torrent, Berserking, Bloodfury and Shadowmeld are supported."));
        end
        module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Disabled", "Enabled"}, {2, "Disabled", "Enabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Reroll Jolly Roger", 210, true, nil, nil, "Enable to cast again Roll the Bones if it only gives Jolly Roger as buff."..C.TOOLTIP_HINT("You may want to disable this for Solo Content."));
        module.AddNewOption("Offensive Settings", "Blade Flurry", 220, true, {1, 0, 9, 1}, nil, "Enable for the automatic usage of Blade Flurry."..C.TOOLTIP_VALUE.."Set the timer to keep the Blade Flurry active after having only 1 enemy."..C.TOOLTIP_HINT("Useful on fight where units jump in and out."));
        module.AddNewOption("Offensive Settings", "Pistol Shot OOR", 220, true, {75, 40, 150, 1}, nil, "Enable to auto use Pistol Shot while not being in melee range and not being stealthed."..C.TOOLTIP_VALUE.."Set the minimum energy to start using it.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Health Percentage to use Healing Belt / Healing Pot / Healthstone.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Crimson Vial", 220, true, {65, 1, 100, 1}, nil, "Health Percentage to use Crimson Vial.");
        module.AddNewOption("Defensive Settings", "Feint", 220, false, {55, 1, 100, 1}, nil, "Health Percentage to use Feint."..C.TOOLTIP_HINT("Put 100 to maintain 100% uptime."));
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, false, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Riposte", 220, true, {25, 1, 100, 1}, nil, "Health Percentage to use Riposte.");
        module.AddNewOption("Defensive Settings", "Cloak of Shadows", 220, true, {45, 1, 100, 1}, nil, "Health Percentage to use Cloak of Shadows.");
        module.AddNewOption("Defensive Settings", "Cloak of Shadows w/ Killing Spree", 210, false, nil, nil, "Enable for the automatic usage of Cloak of Shadows if not in CD before using Kiling Spree.");
        module.AddNewOption("Defensive Settings", "Vanish Defensive", 220, false, {10, 1, 100, 1}, nil, "Health Percentage to use Vanish defensively.");

        --- Misc
        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated
        Player:SetCommonMeleeStatus();
        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;
        -- Combo Points Variables
        MaxComboPoint = Anticipation:Exists() and 8 or DeeperStrategem:Exists() and 6 or 5;
        CPDiff = MaxComboPoint-Player:ComboPoints();
        DurationThreshold = DeeperStrategem:Exists() and 12.6 or 10.8;
        -- Stealth Handler
        CombatStealthAllowed = Vanish:TimeSinceCast() > 0.5 and Shadowmeld:TimeSinceCast() > 0.5;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Vanish Defensive") and not Player:IsStealthed(true) and CombatStealthAllowed and Player:HealthPercentage() <= module.GetOptionValue("Vanish Defensive") and Player:CanCast(Vanish) then
            Player:Cast(Vanish);
            Vanish.LastCastTime = module.GetTime();
            return;
        end
        if module.IsOptionEnabled("Riposte") and not Player:Buff(Riposte) and Player:HealthPercentage() <= module.GetOptionValue("Riposte") and Player:CanCast(Riposte) then
            Player:Cast(Riposte);
        end
        if module.IsOptionEnabled("Cloak of Shadows") and Player:HealthPercentage() <= module.GetOptionValue("Cloak of Shadows") and Player:CanCast(CloakofShadows) then
            Player:Cast(CloakofShadows);
        end
        -- Defensive Abilities
        if module.IsOptionEnabled("Feint") and Player:HealthPercentage() <= module.GetOptionValue("Feint") and not Player:Buff(Feint) and Player:CanCast(Feint) then
            Player:Cast(Feint);
            return;
        end
        if module.IsOptionEnabled("Crimson Vial") and Player:HealthPercentage() <= module.GetOptionValue("Crimson Vial") and Player:CanCast(CrimsonVial) then
            Player:Cast(CrimsonVial);
            return;
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Kick, ArcaneTorrent);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Tricks of the Trade on Focus
        if module.IsOptionEnabled("Tricks of the Trade on Focus") and (module.GetOptionValue("Tricks of the Trade on Focus") == "Always" or (Player:ThreatSituation() and Player:ThreatSituation() >= 1)) and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
            Focus:Cast(TricksoftheTrade);
        end
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Marked for Death Handler for Adds
        if Player:UseMarkedForDeath(MarkedForDeath, CPDiff) then
            return;
        end
        -- Auto Target
        Target = Player:ReTarget(SaberSlash, false) or Unit.Target;
    end

    -- Run the rotation's beta combat logic.
    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Enemies Check
            if module.UseAOE() then
                Enemies_8y = Player:EnemiesWithinDistance(6.5, true); -- Using 6.5y (real range, not 8y) for Blade Flurry and true as they are PlayerCenteredAoE Spells.
                NumEnemies = #Enemies_8y;
            else
                NumEnemies = 1;
            end
            if NumEnemies == 1 and EnemiesReset then EnemiesTimer, EnemiesReset = module.GetTime() + module.GetOptionValue("Blade Flurry"), false; elseif NumEnemies > 1 then EnemiesReset = true; end

            -- Blade Flurry
            if module.IsOptionEnabled("Blade Flurry") and ((NumEnemies >= 2 and not Player:Buff(BladeFlurry) and Player:CanCast(BladeFlurry)) or (NumEnemies < 2 and Player:Buff(BladeFlurry) and module.GetTime() > EnemiesTimer)) then
                Player:Cast(BladeFlurry);
            end
            -- Cooldowns
            if Player:IsWithinCastRange(Target, SaberSlash) then
                if module.CooldownsAllowed() then
                    -- Adrenaline Rush
                    if module.IsOptionEnabled("Adrenaline Rush") and not Player:Buff(AdrenalineRush) and Player:CanCast(AdrenalineRush) then
                        Player:Cast(AdrenalineRush);
                        AdrenalineRush.LastCastTime = module.GetTime();
                    end
                    -- Trinkets
                    if Trinket1:IsUsableInventory() and module.GetOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket1:UseInventory();
                    end
                    if Trinket2:IsUsableInventory() and module.GetSecondOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket2:UseInventory();
                    end
                end
                -- Racials
                if (BloodFury:Exists() or Berserking:Exists() or ArcaneTorrent:Exists()) and module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:IsWithinCastRange(Target, SaberSlash) then
                    -- Blood Fury
                    if Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                    -- Arcane Torrent
                    if Player:CanCast(ArcaneTorrent) and Player:Power() < 60 then
                        Player:Cast(ArcaneTorrent);
                    end
                end
                -- Curse of the Dreadblades
                if module.IsOptionEnabled("Curse of the Dreadblades") and CurseoftheDreadblades:Exists() and (module.CooldownsAllowed() or module.GetOptionValue("Curse of the Dreadblades") == "Always") and not Player:Debuff(CurseoftheDreadblades) and Player:CanCast(CurseoftheDreadblades) then
                    Player:Cast(CurseoftheDreadblades);
                    return;
                end
            end
            if Player:IsWithinCastRange(Target, SaberSlash) and CombatStealthAllowed and not Player:IsStealthed(true) and (not Player:IsTanking(Target) or module.GetOptionValue("Vanish") == "Always") then
                -- Vanish
                if module.IsOptionEnabled("Vanish") and (module.CooldownsAllowed() or module.GetSecondOptionValue("Vanish") == "Always") and CPDiff >= 2 and Player:CanCast(Vanish) then
                    if Player:Power() < 60 then
                        return;
                    end
                    if Player:Power() >= 60 then
                        Player:Cast(Vanish);
                        Vanish.LastCastTime = module.GetTime();
                        return;
                    end
                end
                -- Shadowmeld
                if Shadowmeld:Exists() and module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:Standing() >= ShadowmeldStanding and CPDiff >= 2 and Player:CanCast(Shadowmeld) then
                    if Player:Power() < 60 then
                        return;
                    end
                    if Player:Power() >= 60 then
                        Player:Cast(Shadowmeld);
                        Shadowmeld.LastCastTime = module.GetTime();
                        return;
                    end
                end
            end
            -- Ambush
            if Player:IsStealthed(true) or not CombatStealthAllowed then
                if not Ambush:IsUsable() then
                    return;
                end
                if Target:CanCast(Ambush) then
                    Target:Cast(Ambush);
                    return;
                end
            end
            if SliceAndDice:Exists() then
                -- Slice and Dice
                if ((Player:BuffRemains(SliceAndDice) < DurationThreshold and Player:ComboPoints() >= 5+(DeeperStrategem:Exists() and 1 or 0)) or Player:BuffRemains(SliceAndDice) < 6) and Player:BuffRemains(SliceAndDice) < Target:TimeToDie() and Player:CanCast(SliceAndDice) then
                    Player:Cast(SliceAndDice);
                    return;
                end
            else
                -- Roll the Bones
                if Player:ComboPoints() >= 5+(DeeperStrategem:Exists() and 1 or 0) and (module.IsOptionEnabled("Reroll Jolly Roger") or Player:BuffRemains(JollyRoger) < DurationThreshold) and Player:BuffRemains(TrueBearing) < DurationThreshold and Player:BuffRemains(SharkInfestedWaters) < DurationThreshold and Player:BuffRemains(BuriedTreasure) < DurationThreshold and Player:BuffRemains(GrandMelee) < DurationThreshold and Player:BuffRemains(Broadsides) < DurationThreshold and Player:CanCast(RolltheBones) then
                    Player:Cast(RolltheBones);
                    return;
                end
            end
            if module.IsOptionEnabled("CB | KS") and (module.CooldownsAllowed() or module.GetSecondOptionValue("CB | KS") == "Always") then
                -- Killing Spree
                if KillingSpree:Exists() and AdrenalineRush:TimeSinceCast() > 2 and Player:PowerTimeToMax() > 5 and Target:CanCast(KillingSpree) then
                    if module.IsOptionEnabled("Cloak of Shadows w/ Killing Spree") and Player:CanCast(CloakofShadows) then
                        Player:Cast(CloakofShadows);
                    end
                    Target:Cast(KillingSpree);
                    return;
                end
                -- Cannonball Barrage
                if CannonballBarrage:Exists() and NumEnemies >= module.GetOptionValue("CB | KS") and Target:CanCast(CannonballBarrage) and Player:CastGround(CannonballBarrage, 2, 6, 30, true) then
                    return;
                end
            end
            -- Marked for Death Single Target
            if module.IsOptionEnabled("Marked For Death") and module.GetOptionValue("Marked For Death") == "Target" and (module.CooldownsAllowed() or module.GetSecondOptionValue("Marked For Death") == "Always") and MarkedForDeath:Exists() and CPDiff >= 4 and Target:CanCast(MarkedForDeath) then
                Target:Cast(MarkedForDeath);
                return;
            end
            -- Finisher
            if Player:ComboPoints() >= 5+(DeeperStrategem:Exists() and 1 or 0) then
                -- Death From Above
                if DeathFromAbove:Exists() and Target:CanCast(DeathFromAbove) then
                    Target:Cast(DeathFromAbove);
                    return;
                end
                -- Between the Eyes
                if Target:CanCast(BetweentheEyes) and Player:ComboPoints() >= 5+(DeeperStrategem:Exists() and 1 or 0) then
                    Target:Cast(BetweentheEyes);
                    return;
                end
                -- Run Through
                if (not DeathFromAbove:Exists() or DeathFromAbove:IsOnCooldown()) and Target:CanCast(RunThrough) then
                    Target:Cast(RunThrough);
                    return;
                end
                return;
            end
            -- Generator
            if Player:ComboPoints() < 5+(DeeperStrategem:Exists() and 1 or 0) then
                -- Ghostly Strike
                if GhostlyStrike:Exists() and Target:DebuffRemains(GhostlyStrike) < 4.5 and Target:CanCast(GhostlyStrike) then
                    Target:Cast(GhostlyStrike);
                    return;
                end
                -- Pistol Shot Free Proc
                if Player:Buff(Opportunity) and Target:CanCast(PistolShot) then
                    Target:Cast(PistolShot);
                    return;
                end
                -- Saber Slash
                if Target:CanCast(SaberSlash) then
                    Target:Cast(SaberSlash);
                    return;
                end
            end
            -- Pistol Shot Out of Range
            if module.IsOptionEnabled("Pistol Shot OOR") and not Player:IsWithinCastRange(Target, SaberSlash) and not Player:IsStealthed(true) and Player:Power() > module.GetOptionValue("Pistol Shot OOR") and (Player:ComboPoints() < MaxComboPoint or Player:PowerTimeToMax() <= 1.5) and Target:CanCast(PistolShot) then
                Target:Cast(PistolShot);
                return;
            end
            return;
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Disable Stealth if the Loot Window is open, we are interacting with an NPC or combat has just ended. (Also used for PickPocket)
        StealthAllowed = GetNumLootItems() == 0 and not UnitExists("npc") and OutOfCombatTime() > 1 and true or false;
        -- PickPocket Handler Init
        if module.IsOptionEnabled("Pick Pocket") and not module.PickPocketInitialized then
            Player:PickPocketInit();
        end
        -- Stealth
        if module.IsOptionEnabled("Stealth") and module.GetOptionValue("Stealth") == "Always" and StealthAllowed and not Player:IsStealthed(true) and Stealth:TimeSinceCast() > 0.4 and Player:CanCast(Stealth) then
            Player:Cast(Stealth);
            Stealth.LastCastTime = module.GetTime();
            return;
        end
        -- Crimson Vial
        if module.IsOptionEnabled("Crimson Vial") and Player:HealthPercentage() <= module.GetOptionValue("Crimson Vial") and Player:CanCast(CrimsonVial) then
            Player:Cast(CrimsonVial);
            return;
        end
        -- Pre Trick of the Trade
        if module.IsOptionEnabled("Tricks of the Trade on Focus") and BMPullTime() <= 1.5 and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
            Focus:Cast(TricksoftheTrade);
        end
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Stealth
            if module.IsOptionEnabled("Stealth") and Player:DistanceTo(Target) < 25 and StealthAllowed and not Player:IsStealthed(true) and Stealth:TimeSinceCast() > 0.4 and Player:CanCast(Stealth) then
                Player:Cast(Stealth);
                Stealth.LastCastTime = module.GetTime();
                return;
            end
            if Player:IsStealthed(true) and Player:HealthPercentage() > module.GetOptionValue("Vanish Defensive") then
                if module.IsOptionEnabled("Tricks of the Trade on Focus") and Player:DistanceTo(Target) < 10 and BMPullTime() == 60 and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
                    Focus:Cast(TricksoftheTrade);
                end
                if module.IsOptionEnabled("Pick Pocket") and not module.PickPocketed[Target:GUID()] then
                    if Target:CanCast(PickPocket) then
                        Target:Cast(PickPocket);
                        module.PickPocketTarget = Target:GUID();
                        module.PickPocketAttempt = module.GetTime();
                    end
                    return;
                end
                if module.IsOptionEnabled("Cheap Shot") and not Target:IsBoss() and Target:CanCast(CheapShot) then
                    Target:Cast(CheapShot);
                    return;
                end
                if Target:CanCast(Ambush) then
                    Target:Cast(Ambush);
                    return;
                end
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Subtlety Rogue Rotation
    local Rotation = {};
    module.SetRotation(261, Rotation);

    --- Localization
    -- Core
    local Enemies_10y, Enemies_8y, Enemies_5y, NumEnemies = {}, {}, {}, 1; -- Enemies
    local SpamPrevention, TPSTime = 0, 0.1; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local StealthAllowed, CombatStealthAllowed = false, true; -- Stealth Handler
    local DurationThreshold = 12.6; -- Combo Points Variables
    local ShadowmeldStanding = 0.7; -- Time to Stand before casting Shadowmeld (because movements cancel it)

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        --- Spells
        -- (ID, RequiresFacing, Hostile, Instant, Resurrect)
        -- Racials
        ArcaneTorrent = Spell(25046, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);
        Shadowmeld = Spell(58984, false, false, true);
        -- Items
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Abilities
        Anticipation = Spell(114015, false, false, true);
        Backstab = Spell(53, true, true, true);
        CheapShot = Spell(1833, true, true, true);
        Death = Spell(227151, false, false, false);
        DeathFromAbove = Spell(152150, true, true, true);
        DeeperStrategem = Spell(193531, false, false, true);
        EnvelopingShadows = Spell(206237, false, false, true);
        Eviscerate = Spell(196819, true, true, true);
        Gloomblade = Spell(200758, true, true, true);
        Kick = Spell(1766, true, true, true);
        KidneyShot = Spell(408, true, true, true);
        MarkedForDeath = Spell(137619, false, true, true);
        MasterofShadows = Spell(196976, false, false, true);
        MasterOfSubtlety = Spell(31223, false, false, true);
        MasterOfSubtletyBuff = Spell(31665, false, false, false);
        Nightblade = Spell(195452, true, true, true);
        PickPocket = Spell(921, true, true, true);
        Premeditation = Spell(196979, false, false, false);
        PrecisionStrike = Spell(197235, false, false, false);
        ShadowFocus = Spell(108209, false, false, true);
        Shadowstrike = Spell(185438, false, true, true);
        ShurikenStorm = Spell(197835, false, false, true);
        ShurikenToss = Spell(114014, true, true, true);
        Sprint = Spell(2983, false, false, true);
        Stealth = Spell(1784, false, false, true);
        Subterfuge = Spell(108208, false, false, true);
        SymbolsofDeath = Spell(212283, false, false, true);
        TricksoftheTrade = Spell(57934, false, false, true);
        Vanish = Spell(1856, false, false, true);
        -- Offensive Cooldowns
        ShadowBlades = Spell(121471, false, false, true);
        ShadowDance = Spell(185313, false, false, true);
        GoremawsBite = Spell(209782, false, true, true);
        -- Defensive Cooldowns
        CloakofShadows = Spell(31224, false, false, true);
        CrimsonVial = Spell(185311, false, false, true);
        Feint = Spell(1966, false, false, true);
        Evasion = Spell(5277, false, false, true);

        --- GUI Frame
        -- Pages
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Kick to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddNewOption("General Settings", "Tricks of the Trade on Focus", 230, false, {2, "Always", "On Aggro"}, nil, "Will use Tricks of the Trade on your focus if he's allied."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Everytime it is available."..C.TOOLTIP_SUBVALUE("On Aggro").."Only if you have the aggro of something.");
        module.AddSection("General Settings", "Solo", "Green");
        module.AddNewOption("General Settings", "Kidney Shot", 210, false, nil, nil, "Enable for the automatic usage of Kidney Shot."..C.TOOLTIP_HINT("Useful if you're having hard time while soloing."));
        module.AddNewOption("General Settings", "Cheap Shot", 210, false, nil, nil, "Enable for the automatic usage of Cheap Shot."..C.TOOLTIP_HINT("Useful if you're having hard time while soloing."));
        module.AddNewOption("General Settings", "Pick Pocket", 210, false, nil, nil, "Will PickPocket your target before engaging it."..C.TOOLTIP_HINT("Enabling Pick Pocket will turn on Auto-Loot."));

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddNewOption("Offensive Settings", "Stealth", 230, true, {1, "Always", "Near Target"}, nil, "Enable for the automatic usage of Stealth."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Everytime it is available."..C.TOOLTIP_SUBVALUE("Near Target").."When approaching your target.");
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Marked For Death", 233, true, {2, "Target", "Adds"}, {1, "Always", "Cooldown Only"}, "Enable for the automatic usage of Marked for Death."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Target", true).."Only on your target with 1 or less CP."..C.TOOLTIP_SUBVALUE("Adds").."On every units available."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Vanish", 233, true, {1, "Always", "Not Tanking"}, {2, "Always", "Cooldown Only"}, "Enable for the automatic usage of Vanish."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will 'Always' use Vanish no matter if you're tanking or not."..C.TOOLTIP_SUBVALUE("Not Tanking").."Will only use Vanish if you're 'Not Tanking' the target (Mostly for Solo)."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Goremaw's Bite", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Goremaw's Bite."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Shadow Dance", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Shadow Dance."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Shadow Blades", 210, true, nil, nil, "Enable for the automatic usage of Shadow Blades.");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() or Shadowmeld:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Arcane Torrent, Berserking, Bloodfury are supported.\nAs of Build 21531 Shadowstrike doesn't work with Shadowmeld."));
        end
        module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Disabled", "Enabled"}, {2, "Disabled", "Enabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Nightblade Cycling", 220, false, {12, 6, 24, 1}, nil, "Cycle Nightblade on available units and set the minimum TTD."..C.TOOLTIP_HINT("It will always cast on the unit available with the Highest TTD."));
        module.AddNewOption("Offensive Settings", "Shadowstrike Range", 122, true, {10, 5, 25, 1}, {10, 5, 25, 1}, "Set the range from the target to use Shadowstrike."..C.TOOLTIP_VALUE_1.."While being In Combat."..C.TOOLTIP_VALUE_2.."While being Out of Combat.");
        module.AddNewOption("Offensive Settings", "Shuriken Toss", 220, true, {75, 40, 150, 1}, nil, "Enable to auto use Throw while not being in melee range and not being stealthed."..C.TOOLTIP_VALUE.."Set the minimum energy to start using it.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Health Percentage to use Healing Belt / Healing Pot / Healthstone.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Crimson Vial", 220, true, {65, 1, 100, 1}, nil, "Health Percentage to use Crimson Vial.");
        module.AddNewOption("Defensive Settings", "Feint", 220, false, {55, 1, 100, 1}, nil, "Health Percentage to use Feint."..C.TOOLTIP_HINT("Put 100 to maintain 100% uptime."));
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, false, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Evasion", 220, true, {25, 1, 100, 1}, nil, "Health Percentage to use Evasion.");
        module.AddNewOption("Defensive Settings", "Cloak of Shadows", 220, true, {45, 1, 100, 1}, nil, "Health Percentage to use Cloak of Shadows.");
        module.AddNewOption("Defensive Settings", "Vanish Defensive", 220, false, {10, 1, 100, 1}, nil, "Health Percentage to use Vanish defensively.");

        --- Misc
        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Combat's Local Functions
    local function Finisher ()
        -- kidney_shot
        if module.IsOptionEnabled("Kidney Shot") and not Target:IsBoss() and Target:DebuffRemains(CheapShot) < 1 and Target:CanCast(KidneyShot) then
            Target:Cast(KidneyShot);
            return;
        end
        -- death_from_above,if=spell_targets.death_from_above>=10
        if DeathFromAbove:Exists() and #Enemies_8y >= 10 and Target:CanCast(DeathFromAbove) then
            Target:Cast(DeathFromAbove);
            return;
        end
        -- nightblade,if=!dot.nightblade.ticking|dot.nightblade.remains<(6+(2*combo_points))*0.3
        if Target:DebuffRemains(Nightblade) <= (6+(2*Player:ComboPoints()))*0.3 and Target:TimeToDie(10) > 6 and Target:CanCast(Nightblade) then
            Target:Cast(Nightblade);
            return;
        end
        -- nightblade,cycle_targets=1,target_if=max:target.time_to_die,if=active_dot.nightblade<6&target.time_to_die>6&(!dot.nightblade.ticking|dot.nightblade.remains<(6+(2*combo_points))*0.3)
        if module.IsOptionEnabled("Nightblade Cycling") and module.UseAOE() then
            -- TTD Units Handler.
            local BestUnit, BestUnitTTD = nil, module.GetOptionValue("Nightblade Cycling");
            local ThisUnit, ThisUnitTTD;
            for i = 1, #Enemies_5y do
                ThisUnit = Enemies_5y[i];
                ThisUnitTTD = ThisUnit:TimeToDie(20);
                if ThisUnitTTD > 6 and ThisUnitTTD < 5000 and ThisUnitTTD > BestUnitTTD and ThisUnit:DebuffRemains(Nightblade) <= (6+(2*Player:ComboPoints()))*0.3 and ThisUnit:CanCast(Nightblade) then
                    BestUnit, BestUnitTTD = ThisUnit, ThisUnitTTD;
                end
            end
            -- Cast Nightblade if we got an unit.
            if BestUnit then
                BestUnit:Cast(Nightblade);
                return;
            end
        end
        -- death_from_above
        if DeathFromAbove:Exists() and Target:CanCast(DeathFromAbove) then
            Target:Cast(DeathFromAbove);
            return;
        end
        -- eviscerate
        if Target:CanCast(Eviscerate) then
            Target:Cast(Eviscerate);
            return;
        end
        return;
    end
    local function Generator ()
        -- shuriken_storm,if=spell_targets.shuriken_storm>=2
        if NumEnemies >= 2 and Player:CanCast(ShurikenStorm) then
            Player:Cast(ShurikenStorm);
            return;
        end
        if Gloomblade:Exists() then
            -- gloomblade,if=energy.time_to_max<2.5
            if Player:EnergyTimeToMax() < 2.5 and Target:CanCast(Gloomblade) then
                Target:Cast(Gloomblade);
                return;
            end
        else
            -- backstab,if=energy.time_to_max<2.5
            if Player:EnergyTimeToMax() < 2.5 and Target:CanCast(Backstab) then
                Target:Cast(Backstab);
                return;
            end
        end
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated
        Player:SetCommonMeleeStatus();
        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;
        -- Combo Points Variables
        DurationThreshold = DeeperStrategem:Exists() and 12.6 or 10.8;
        -- Stealth Handler
        CombatStealthAllowed = ShadowDance:TimeSinceCast() > 0.5 and Vanish:TimeSinceCast() > 0.5 and Shadowmeld:TimeSinceCast() > 0.5;
        Stealth = Subterfuge:Exists() and Spell(115191, false, false, true) or Spell(1784, false, false, true); -- w/ or w/o Subterfuge Talent

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Vanish Defensive") and VanishAllowed and not Player:IsStealthed(true) and Player:HealthPercentage() <= module.GetOptionValue("Vanish Defensive") and Shadowmeld:TimeSinceCast() > 0.5 and Player:CanCast(Vanish) then
            Player:Cast(Vanish);
            Vanish.LastCastTime = module.GetTime();
            return;
        end
        if module.IsOptionEnabled("Evasion") and not Player:Buff(Evasion) and Player:HealthPercentage() <= module.GetOptionValue("Evasion") and Player:CanCast(Evasion) then
            Player:Cast(Evasion);
        end
        if module.IsOptionEnabled("Cloak of Shadows") and Player:HealthPercentage() <= module.GetOptionValue("Cloak of Shadows") and Player:CanCast(CloakofShadows) then
            Player:Cast(CloakofShadows);
        end
        -- Defensive Abilities
        if module.IsOptionEnabled("Feint") and Player:HealthPercentage() <= module.GetOptionValue("Feint") and not Player:Buff(Feint) and Player:CanCast(Feint) then
            Player:Cast(Feint);
            return;
        end
        if module.IsOptionEnabled("Crimson Vial") and Player:HealthPercentage() <= module.GetOptionValue("Crimson Vial") and Player:CanCast(CrimsonVial) then
            Player:Cast(CrimsonVial);
            return;
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Kick, ArcaneTorrent);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Tricks of the Trade on Focus
        if module.IsOptionEnabled("Tricks of the Trade on Focus") and (module.GetOptionValue("Tricks of the Trade on Focus") == "Always" or (Player:ThreatSituation() and Player:ThreatSituation() >= 1)) and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
            Focus:Cast(TricksoftheTrade);
        end
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Marked for Death Handler for Adds
        if Player:UseMarkedForDeath(MarkedForDeath, Player:ComboPointsDeficit()) then
            return;
        end
        -- Auto Target
        Target = Player:ReTarget(Backstab, false) or Unit.Target;
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Enemies Check
            if module.UseAOE() then
                Enemies_10y = Player:EnemiesWithinDistance(10, true); -- Using 10y (real range) for Shuriken Storm and true as it is a PlayerCenteredAoE Spell.
                Enemies_8y = Player:FilterEnemiesByDistance(Enemies_10y, 8, true); -- Using 8y (real range) for Death from Above and true as it is a PlayerCenteredAoE Spell.
                Enemies_5y = Player:FilterEnemiesByDistance(Enemies_8y, 5, false); -- This table is used for Melee Range Cycling Abilities (like Nightblade).
                NumEnemies = #Enemies_10y;
            else
                NumEnemies = 1;
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, Backstab) then
                if module.CooldownsAllowed() then
                    -- shadow_blades,if=!buff.shadow_blades.up&energy.deficit<20&(buff.shadow_dance.up|buff.vanish.up)
                    if module.IsOptionEnabled("Shadow Blades") and not Player:Buff(ShadowBlades) and Player:EnergyMax()-Player:Energy() < 20 and Player:IsStealthed(true) and Player:CanCast(ShadowBlades) then
                        Player:Cast(ShadowBlades);
                    end
                    -- Trinkets
                    if Trinket1:IsUsableInventory() and module.GetOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket1:UseInventory();
                    end
                    if Trinket2:IsUsableInventory() and module.GetSecondOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket2:UseInventory();
                    end
                end
                -- Racials
                if (BloodFury:Exists() or Berserking:Exists() or ArcaneTorrent:Exists()) and module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:IsWithinCastRange(Target, Backstab) then
                    if Player:Buff(ShadowDance) then
                        -- blood_fury,if=buff.shadow_dance.up
                        if Player:CanCast(BloodFury) then
                            Player:Cast(BloodFury);
                        end
                        -- berserking,if=buff.shadow_dance.up
                        if Player:CanCast(Berserking) then
                            CastSpellByID(26297, "player")
                        end
                    end
                    -- arcane_torrent,if=energy.deficit>15&(buff.shadow_dance.up|buff.vanish.up)
                    if Player:CanCast(ArcaneTorrent) and Player:EnergyDeficit() > 15 and Player:IsStealthed(true) then
                        Player:Cast(ArcaneTorrent);
                    end
                end
                -- goremaws_bite,if=(combo_points.max-combo_points>=2&energy.deficit>55&time<10)|(combo_points.max-combo_points>=4&energy.deficit>45)|target.time_to_die<8
                if module.IsOptionEnabled("Goremaw's Bite") and (module.CooldownsAllowed() or module.GetSecondOptionValue("Goremaw's Bite") == "Always") and ((Player:ComboPointsDeficit() >= 2 and Player:EnergyMax()-Player:Energy() > 55 and CombatTime() < 10) or (Player:ComboPointsDeficit() >= 4 and Player:EnergyMax()-Player:Energy() > 45) or Target:TimeToDie() < 8) and Target:CanCast(GoremawsBite) then
                    Target:Cast(GoremawsBite);
                    return;
                end
            end
            if Player:IsStealthed(true) or not CombatStealthAllowed then
                -- symbols_of_death,if=buff.symbols_of_death.remains<target.time_to_die-4&buff.symbols_of_death.remains<=10.5
                if Player:BuffRemains(SymbolsofDeath) < Target:TimeToDie() and Player:BuffRemains(SymbolsofDeath) <= 10.5 then
                    if not SymbolsofDeath:IsUsable() then
                        return;
                    end
                    if Player:CanCast(SymbolsofDeath) then
                        Player:Cast(SymbolsofDeath);
                    end
                end
                -- shuriken_storm,if=buff.stealth.up&talent.premeditation.enabled&artifact.precision_strike.rank<=3&combo_points.max-combo_points>=3&spell_targets.shuriken_storm>=7
                if Premeditation:Exists() and NumEnemies >= 7 and Player:ComboPointsDeficit() >= 3 and PrecisionStrike:ArtifactRank() <= 3 and Player:CanCast(ShurikenStorm) then
                    Player:Cast(ShurikenStorm);
                    return;
                end
                -- shuriken_storm,if=buff.stealth.up&!buff.death.up&combo_points.max-combo_points>=2&((!talent.premeditation.enabled&((artifact.precision_strike.rank<=3&spell_targets.shuriken_storm>=4)|spell_targets.shuriken_storm>=5))|spell_targets.shuriken_storm>=8)
                if not Player:Buff(Death) and Player:ComboPointsDeficit() >= 2 and (NumEnemies >= 8 or (not Premeditation:Exists() and (NumEnemies >= 4 or (PrecisionStrike:ArtifactRank() <= 3 and NumEnemies >= 3)))) and Player:CanCast(ShurikenStorm) then
                    Player:Cast(ShurikenStorm);
                    return;
                end
                -- shadowstrike,if=combo_points.max-combo_points>=2
                if Player:ComboPointsDeficit() >= 2 and Player:DistanceTo(Target) < module.GetOptionValue("Shadowstrike Range") and Target:CanCast(Shadowstrike) then
                    Target:Cast(Shadowstrike);
                    return;
                end
            end
            if not Player:IsStealthed(true) and CombatStealthAllowed and Player:IsWithinCastRange(Target, Backstab) then
                -- pool_resource,for_next=1,extra_amount=energy.max-talent.master_of_shadows.enabled*30
                -- vanish,if=energy.deficit<talent.master_of_shadows.enabled*30&combo_points.max-combo_points>=3&cooldown.shadow_dance.charges<2|target.time_to_die<8
                if module.IsOptionEnabled("Vanish") and (module.CooldownsAllowed() or module.GetSecondOptionValue("Vanish") == "Always") and (not Player:IsTanking(Target) or module.GetOptionValue("Vanish") == "Always") and Player:ComboPointsDeficit() >= 3 and ShadowDance:Charges() < 2 and Player:CanCast(Vanish) then
                    if Player:Energy() < Player:EnergyMax()-5-(MasterofShadows:Exists() and 30 or 0) then
                        return;
                    end
                    if Player:Energy() >= Player:EnergyMax()-5-(MasterofShadows:Exists() and 30 or 0) then
                        Player:Cast(Vanish);
                        Vanish.LastCastTime = module.GetTime();
                        return;
                    end
                end
                -- pool_resource,for_next=1,extra_amount=energy.max-talent.master_of_shadows.enabled*30
                -- shadow_dance,if=combo_points.max-combo_points>=2&((cooldown.vanish.remains&buff.symbols_of_death.remains<=10.5&energy.deficit<talent.master_of_shadows.enabled*30)|cooldown.shadow_dance.charges>=2|target.time_to_die<25)
                if module.IsOptionEnabled("Shadow Dance") and (module.CooldownsAllowed() or module.GetOptionValue("Shadow Dance") == "Always") and (((not Vanish:Exists() or Vanish:IsOnCooldown() or not module.IsOptionEnabled("Vanish") or (Player:IsTanking(Target) and module.GetOptionValue("Vanish") == "Not Tanking")) and Player:BuffRemains(SymbolsofDeath) <= 10.5 and Player:EnergyMax()-Player:Energy() < (MasterofShadows:Exists() and 30 or 0)) or ShadowDance:Charges() >= 2 or Target:TimeToDie() < 25) and Player:ComboPointsDeficit() >= 2 and Player:CanCast(ShadowDance) then
                    if Player:Energy() < Player:EnergyMax()-5-(MasterofShadows:Exists() and 30 or 0) then
                        return;
                    else
                        Player:Cast(ShadowDance);
                        ShadowDance.LastCastTime = module.GetTime();
                        return;
                    end
                end
            end
            -- enveloping_shadows,if=buff.enveloping_shadows.remains<target.time_to_die&((buff.enveloping_shadows.remains<=10.8+talent.deeper_strategem.enabled*1.8&combo_points>=5+talent.deeper_strategem.enabled)|buff.enveloping_shadows.remains<=6)
            if EnvelopingShadows:Exists() and ((Player:BuffRemains(EnvelopingShadows) < DurationThreshold and Player:ComboPoints() >= 5+(DeeperStrategem:Exists() and 1 or 0)) or Player:BuffRemains(EnvelopingShadows) < 6) and Player:BuffRemains(EnvelopingShadows) < Target:TimeToDie() and Player:CanCast(EnvelopingShadows) then
                Player:Cast(EnvelopingShadows);
                return;
            end
            -- marked_for_death,cycle_targets=1,target_if=min:target.time_to_die,if=combo_points.max-combo_points>=4
            if module.IsOptionEnabled("Marked For Death") and module.GetOptionValue("Marked For Death") == "Target" and (module.CooldownsAllowed() or module.GetSecondOptionValue("Marked For Death") == "Always") and MarkedForDeath:Exists() and Player:ComboPointsDeficit() >= 4 and Target:CanCast(MarkedForDeath) then
                Target:Cast(MarkedForDeath);
                return;
            end
            -- run_action_list,name=finisher,if=combo_points>=5
            if Player:ComboPoints() >= 5 then
                Finisher();
            end
            -- run_action_list,name=generator,if=combo_points<5
            if Player:ComboPoints() < 5 then
                Generator();
            end
            -- Shuriken Toss Out of Range
            if module.IsOptionEnabled("Shuriken Toss") and not Player:IsWithinCastRange(Target, Backstab) and not Player:IsStealthed(true) and Player:Energy() > module.GetOptionValue("Shuriken Toss") and (Player:ComboPoints() < Player:ComboPointsMax() or Player:EnergyTimeToMax() <= 1.5) and Target:CanCast(ShurikenToss) then
                Target:Cast(ShurikenToss);
                return;
            end
            return;
        end
        -- potion,name=draenic_agility,if=buff.bloodlust.react|target.time_to_die<40
        -- blood_fury,if=buff.shadow_dance.up
        -- berserking,if=buff.shadow_dance.up
        -- arcane_torrent,if=energy.deficit>15&(buff.shadow_dance.up|buff.vanish.up)
        -- shadow_blades,if=!buff.shadow_blades.up&energy.deficit<20&(buff.shadow_dance.up|buff.vanish.up)
        -- goremaws_bite,if=(combo_points.max-combo_points>=2&energy.deficit>55&time<10)|(combo_points.max-combo_points>=4&energy.deficit>45)|target.time_to_die<8
        -- symbols_of_death,if=buff.symbols_of_death.remains<target.time_to_die-4&buff.symbols_of_death.remains<=10.5
        -- shuriken_storm,if=buff.stealth.up&talent.premeditation.enabled&artifact.precision_strike.rank<=3&combo_points.max-combo_points>=3&spell_targets.shuriken_storm>=7
        -- shuriken_storm,if=buff.stealth.up&!buff.death.up&combo_points.max-combo_points>=2&((!talent.premeditation.enabled&((artifact.precision_strike.rank<=3&spell_targets.shuriken_storm>=4)|spell_targets.shuriken_storm>=5))|spell_targets.shuriken_storm>=8)
        -- shadowstrike,if=combo_points.max-combo_points>=2
        -- pool_resource,for_next=1,extra_amount=energy.max-talent.master_of_shadows.enabled*30
        -- vanish,if=energy.deficit<talent.master_of_shadows.enabled*30&combo_points.max-combo_points>=3&cooldown.shadow_dance.charges<2|target.time_to_die<8
        -- pool_resource,for_next=1,extra_amount=energy.max-talent.master_of_shadows.enabled*30
        -- shadow_dance,if=combo_points.max-combo_points>=2&((cooldown.vanish.remains&buff.symbols_of_death.remains<=10.5&energy.deficit<talent.master_of_shadows.enabled*30)|cooldown.shadow_dance.charges>=2|target.time_to_die<25)
        -- enveloping_shadows,if=buff.enveloping_shadows.remains<target.time_to_die&((buff.enveloping_shadows.remains<=10.8+talent.deeper_strategem.enabled*1.8&combo_points>=5+talent.deeper_strategem.enabled)|buff.enveloping_shadows.remains<=6)
        -- marked_for_death,cycle_targets=1,target_if=min:target.time_to_die,if=combo_points.max-combo_points>=4
        -- run_action_list,name=finisher,if=combo_points>=5
        -- run_action_list,name=generator,if=combo_points<5

        -- death_from_above,if=spell_targets.death_from_above>=10
        -- nightblade,if=!dot.nightblade.ticking|dot.nightblade.remains<(6+(2*combo_points))*0.3
        -- nightblade,cycle_targets=1,target_if=max:target.time_to_die,if=active_dot.nightblade<6&target.time_to_die>6&(!dot.nightblade.ticking|dot.nightblade.remains<(6+(2*combo_points))*0.3)
        -- death_from_above
        -- eviscerate

        -- shuriken_storm,if=spell_targets.shuriken_storm>=2
        -- gloomblade,if=energy.time_to_max<2.5
        -- backstab,if=energy.time_to_max<2.5
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Disable Stealth if the Loot Window is open, we are interacting with an NPC or combat has just ended. (Also used for PickPocket)
        StealthAllowed = GetNumLootItems() == 0 and not UnitExists("npc") and OutOfCombatTime() > 1 and true or false;
        -- PickPocket Handler Init
        if module.IsOptionEnabled("Pick Pocket") and not module.PickPocketInitialized then
            Player:PickPocketInit();
        end
        -- Stealth
        if module.IsOptionEnabled("Stealth") and module.GetOptionValue("Stealth") == "Always" and StealthAllowed and not Player:IsStealthed(true) and Stealth:TimeSinceCast() > 0.4 and Player:CanCast(Stealth) then
            Player:Cast(Stealth);
            Stealth.LastCastTime = module.GetTime();
            return;
        end
        -- Crimson Vial
        if module.IsOptionEnabled("Crimson Vial") and Player:HealthPercentage() <= module.GetOptionValue("Crimson Vial") and Player:CanCast(CrimsonVial) then
            Player:Cast(CrimsonVial);
            return;
        end
        -- Pre Trick of the Trade
        if module.IsOptionEnabled("Tricks of the Trade on Focus") and BMPullTime() <= 1.5 and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
            Focus:Cast(TricksoftheTrade);
        end
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        -- Symbols of Death
        if SymbolsofDeath:TimeSinceCast() > 0.5 and Player:CanCast(SymbolsofDeath) then
            Player:Cast(SymbolsofDeath);
            SymbolsofDeath.LastCastTime = module.GetTime();
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Stealth
            if module.IsOptionEnabled("Stealth") and Player:DistanceTo(Target) < 25 and StealthAllowed and not Player:IsStealthed(true) and Stealth:TimeSinceCast() > 0.4 and Player:CanCast(Stealth) then
                Player:Cast(Stealth);
                Stealth.LastCastTime = module.GetTime();
                return;
            end
            if Player:IsStealthed(true) and Player:HealthPercentage() > module.GetOptionValue("Vanish Defensive") then
                if module.IsOptionEnabled("Tricks of the Trade on Focus") and Player:DistanceTo(Target) < module.GetSecondOptionValue("Shadowstrike Range")+5 and BMPullTime() == 60 and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
                    Focus:Cast(TricksoftheTrade);
                end
                if module.IsOptionEnabled("Pick Pocket") and not module.PickPocketed[Target:GUID()] then
                    if Target:CanCast(PickPocket) then
                        Target:Cast(PickPocket);
                        module.PickPocketTarget = Target:GUID();
                        module.PickPocketAttempt = module.GetTime();
                    end
                    return;
                end
                if module.IsOptionEnabled("Cheap Shot") and not Target:IsBoss() and Target:CanCast(CheapShot) then
                    Target:Cast(CheapShot);
                    return;
                end
                if Player:DistanceTo(Target) < module.GetSecondOptionValue("Shadowstrike Range") and Target:CanCast(Shadowstrike) then
                    Target:Cast(Shadowstrike);
                    return;
                end
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Elemental Shaman
    local Rotation = {};
    module.SetRotation(262, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local Enemies, NumEnemies, TargetEnemies_10y = {}, 0, {};

    -- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicIntellect = Item(109218, false, false, true);
        DraenicIntellectBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);
        GiftOfTheNaaru = Spell(59548, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        AncestralGuidance = Spell(108281, false, false, true);
        AncestralSwiftness = Spell(192087, false, false, true);
        Ascendance = Spell(114050, false, false, true);
        AstralShift = Spell(108271, false, false, true);
        ChainLightning = Spell(188443, true, true, true);
        EchoOfTheElements = Spell(108283);
        EarthElemental = Spell(198103, false, false, true);
        EarthquakeTotem = Spell(61882, false, true, true);
        EarthShock = Spell(8042, true, true, true);
        ElementalBlast = Spell(117014, true, true, false);
        ElementalFusion = Spell(192235);
        ElementalMastery = Spell(16166, false, false, true);
        EmberTotem = Spell(210658);
        FlameShock = Spell(188389, true, true, true);
        FrostShock = Spell(196840, true, true, true);
        FireElemental = Spell(198067, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);
        HealingSurge = Spell(8004, false, false, false);
        IceFury = Spell(210714, true, true, false);
        LavaBeam = Spell(114074, true, true, true);
        LavaBurst = Spell(51505, true, true, true);
        LightningBolt = Spell(188196, true, true, true);
        LiquidMagma = Spell(192222, false, true, true);
        PrimalElementalist = Spell(117013);
        StormElemental = Spell(192249, false, false, true);
        StormKeeper = Spell(205495, false, false, true);
        Thunderstorm = Spell(51490, false, false, true);
        TotemMastery = Spell(210643, false, false, true);
        WindShear = Spell(57994, true, true, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, { 4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest" }, { 2, "Disabled", "Enabled" }, "|cffFF0044Target (Left Box)|r \nAutomatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode. \n|cFF0088FFClosest:|r Target the closest enemy. \n|cFF0088FFLeast HP:|r Target the enemy with the least health remaining. \n|cFF0088FFMost HP:|r Target the enemy with the most health remaining. \n|cFF0088FFTarget Closest:|r Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining. \n\n|cffFF0044Attack (Right Box)|r \nUse /startattack when you changes target. Good for melee classes.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Only cast CD's on boss targets.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Ancestral Spirit", 210, true, nil, nil, "Resurrect dead Target with Ancestral Spirit while out of combat");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Wind Shear to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Ascendance", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Ascendance."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Earth Elemental", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Earth Elemental."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Elemental Mastery", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Elemental Mastery."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Fire Elemental", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Fire Elemental."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Storm Elemental", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Storm Elemental."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Chain Lightning", 220, true, {2, 1, 5, 1}, nil, "Use Chain Lightning."..C.TOOLTIP_VALUE.."Define minimum number of units that needs to be in 10 yards around the target.");
        module.AddNewOption("Offensive Settings", "Earthquake Totem", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {2, 1, 25, 1}, "Use Earthquake Totem."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Target").."Always use on the current target."..C.TOOLTIP_SUBVALUE("Target Standing").."Always use on the current target. Target must be standing still."..C.TOOLTIP_SUBVALUE("Centered").."Use centered on a cluster of enemies."..C.TOOLTIP_SUBVALUE("Centered Standing").."Use centered on a cluster of enemies. Enemies must be standing still."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Lava Beam", 220, true, {2, 1, 5, 1}, nil, "Use Lava Beam."..C.TOOLTIP_VALUE.."Define minimum number of units that needs to be in 10 yards around the target.");
        module.AddNewOption("Offensive Settings", "Liquid Magma Totem", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {2, 1, 25, 1}, "Use Liquid Magma Totem."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Target").."Always use on the current target."..C.TOOLTIP_SUBVALUE("Target Standing").."Always use on the current target. Target must be standing still."..C.TOOLTIP_SUBVALUE("Centered").."Use centered on a cluster of enemies."..C.TOOLTIP_SUBVALUE("Centered Standing").."Use centered on a cluster of enemies. Enemies must be standing still."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the spell effect to use.");


        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Astral Shift", 220, true, {50, 1, 100, 1}, nil, "Use Astral Shift."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Ancestral Guidance", 220, true, {40, 1, 100, 1}, nil, "Use Ancestral Guidance."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {40, 1, 100, 1}, nil, "Use Gift Of The Naaru on self."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Healing Surge", 222, true, { 20, 0, 95, 5 }, { 90, 0, 95, 5 }, "Use Healing Surge."..C.TOOLTIP_VALUE_1.."Health threshold while in combat."..C.TOOLTIP_VALUE_2.."Health threshold while out of combat.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end
        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        local OpenerSpell = ElementalBlast:Exists() and ElementalBlast or LightningBolt;
        -- Potion
        if module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) and Player:IsWithinCastRange(Target, OpenerSpell) then
            if Player:Potion("Intellect", Potion) then module.Bug("Pre-Pull - Intellect Potion"); Potion = true; end
        end
        -- Totem Mastery
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + 1.5 and TotemMastery:Exists() and (not Player:Buff(EmberTotem) or TotemMastery:TotemDuration() < 10) and Player:CanCast(TotemMastery) then
            Player:Cast(TotemMastery);
            return;
        end
        -- Opener Spell
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() and Target:CanCast(OpenerSpell) then
            Target:Cast(OpenerSpell);
            return;
        end
        -- Flame Shock
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") and not Target:Debuff(FlameShock) and Target:CanCast(FlameShock) then
            Target:Cast(FlameShock);
            return;
        end
    end

    function Rotation:Interrupts ()
        Player:UseInterrupt(WindShear);
    end

    function Rotation:OffGCDAbilities ()

    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Cooldowns
        if module.IsOptionEnabled("Shamanistic Rage") and Player:CanCast(ShamanisticRage) and module.Player:HealthPercentage() <= module.GetOptionValue("Shamanistic Rage") then
            Player:Cast(ShamanisticRage);
        end
        -- Ancestral Guidance
        if AncestralGuidance:Exists() and module.IsOptionEnabled("Ancestral Guidance") and Player:CanCast(AncestralGuidance) and Player:HealthPercentage() <= module.GetOptionValue("Ancestral Guidance") then
            Player:Cast(AncestralGuidance);
        end
        -- Astral Shift
        if AstralShift:Exists() and module.IsOptionEnabled("Astral Shift") and Player:CanCast(AstralShift) and Player:HealthPercentage() <= module.GetOptionValue("Astral Shift") then
            Player:Cast(AstralShift);
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    function Rotation:Combat ()
        -- Healing Surge on ourself
        if module.IsOptionEnabled("Healing Surge") and not Player:IsMoving() and Player:CanCast(HealingSurge) and Player:HealthPercentage() <= module.GetOptionValue("Healing Surge") then
            Player:Cast(HealingSurge);
            return;
        end
        if Target:Exists() and Player:CanAttack(Target) then

            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                Enemies = module.UseAOE() and Player:EnemiesWithinDistance(40) or {}; -- 40 yards.
                TargetEnemies_10y = module.UseAOE() and Target:EnemiesWithinDistance(10) or {}; -- 10 yards of Target for Chain Lightning.
                NumEnemies = #TargetEnemies_10y;
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, LightningBolt) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Ascendance
                if Ascendance:Exists() and module.IsOptionEnabled("Ascendance") and (module.CooldownsAllowed() or module.GetOptionValue("Ascendance") == "Always") and not Player:Buff(Ascendance) and Player:CanCast(Ascendance) then
                    Player:Cast(Ascendance);
                    return;
                end
                -- Storm Elemental Totem
                if StormElemental:Exists() and module.IsOptionEnabled("Storm Elemental") and (module.CooldownsAllowed() or module.GetOptionValue("Storm Elemental") == "Always") and Player:CanCast(StormElemental) then
                    Player:Cast(StormElemental);
                    return;
                end
                -- Fire Elemental Totem
                if not StormElemental:Exists() and FireElemental:Exists() and module.IsOptionEnabled("Fire Elemental") and (module.CooldownsAllowed() or module.GetOptionValue("Fire Elemental") == "Always") and Player:CanCast(FireElemental) then
                    Player:Cast(FireElemental);
                    return;
                end
                -- Earth Elemental Totem
                if EarthElemental:Exists() and module.IsOptionEnabled("Earth Elemental") and (module.CooldownsAllowed() or module.GetOptionValue("Earth Elemental") == "Always") and Player:CanCast(EarthElemental) then
                    Player:Cast(EarthElemental);
                    return;
                end
                -- ElementalMastery
                if ElementalMastery:Exists() and module.IsOptionEnabled("Elemental Mastery") and (module.CooldownsAllowed() or module.GetOptionValue("Elemental Mastery") == "Always") and Player:CanCast(ElementalMastery) then
                    Player:Cast(ElementalMastery);
                    return;
                end
            end
            -- Rotation
            -- Liquid Magma Totem
            if module.UseAOE() and LiquidMagma:Exists() and module.IsOptionEnabled("Liquid Magma Totem") and Target:CanCast(LiquidMagma) then
                if Target:CastGroundSpell(LiquidMagma, "Liquid Magma Totem", 8) then return; end
            end
            -- Totem Mastery
            if TotemMastery:Exists() and TotemMastery:TimeSinceCast() > 5 and (not Player:Buff(EmberTotem) or TotemMastery:TotemDuration() < 3) and Player:CanCast(TotemMastery) then
                TotemMastery.LastCastTime = module.GetTime();
                Player:Cast(TotemMastery);
                return;
            end
            -- Flame Shock
            if FlameShock:Exists() and (Player:Maelstrom() >= 20 or Target:DebuffRemains(FlameShock) < LavaBurst:CastTime()) and Target:DebuffRemains(FlameShock) < 3 and Target:CanCast(FlameShock) then
                Target:Cast(FlameShock);
                return;
            end
            -- Earthquake Totem
            if module.UseAOE() and EarthquakeTotem:TimeSinceCast() >= 9 and EarthquakeTotem:Exists() and module.IsOptionEnabled("Earthquake Totem") and Target:CanCast(EarthquakeTotem) then
                if Target:CastGroundSpell(EarthquakeTotem, "Earthquake Totem", 8) then
                    EarthquakeTotem.LastCastTime = module.GetTime();
                    module.Bug("Earthquake Totem");
                    return;
                end
            end
            if Player:Maelstrom() >= 90 then
                -- Earth Shock
                if EarthShock:Exists() and Target:CanCast(EarthShock) then
                    Target:Cast(EarthShock);
                    return;
                end
            end
            -- Lava Beam
            if module.UseAOE() and Player:Buff(Ascendance) and ChainLightning:Exists() and NumEnemies >= module.GetOptionValue("Lava Beam") and Target:CanCast(ChainLightning) then
                Target:Cast(ChainLightning);
                return;
            end
            -- Lava Burst
            if LavaBurst:Exists() and Target:Debuff(FlameShock) and Target:CanCast(LavaBurst) then
                Target:Cast(LavaBurst);
                return;
            end
            -- Ice Fury
            if IceFury:Exists() and Target:CanCast(IceFury) then
                Target:Cast(IceFury);
                return;
            end
            -- Frost Shock
            if IceFury:Exists() and Player:Buff(IceFury) and Player:Maelstrom() >= 20 and Target:CanCast(FrostShock) then
                Target:Cast(FrostShock);
                return;
            end
            -- Earth Shock
            if EarthShock:Exists() and Player:Maelstrom() >= 70 and Target:CanCast(EarthShock) then
                Target:Cast(EarthShock);
                return;
            end
            -- Earthquake Totem
            if module.UseAOE() and EarthquakeTotem:TimeSinceCast() >= 9 and EarthquakeTotem:Exists() and module.IsOptionEnabled("Earthquake Totem") and Target:CanCast(EarthquakeTotem) then
                if Target:CastGroundSpell(EarthquakeTotem, "Earthquake Totem", 8) then
                    EarthquakeTotem.LastCastTime = module.GetTime();
                    module.Bug("Earthquake Totem");
                    return;
                end
            end
            -- Elemental Blast
            if ElementalBlast:Exists() and Target:CanCast(ElementalBlast) then
                Target:Cast(ElementalBlast);
                return;
            end
            -- Totem Mastery
            if TotemMastery:Exists() and TotemMastery:TimeSinceCast() > 5 and TotemMastery:TotemDuration() < 10 and Player:CanCast(TotemMastery) then
                TotemMastery.LastCastTime = module.GetTime();
                Player:Cast(TotemMastery);
                return;
            end
            -- Storm Keeper
            if StormKeeper:Exists() and Player:CanCast(StormKeeper) then
                Player:Cast(StormKeeper);
                return;
            end
            -- Chain Lightning
            if module.UseAOE() and ChainLightning:Exists() and NumEnemies >= module.GetOptionValue("Chain Lightning") and Target:CanCast(ChainLightning) then
                Target:Cast(ChainLightning);
                return;
            end
            -- Lightning Bolt
            if LightningBolt:Exists() and Target:CanCast(LightningBolt) then
                Target:Cast(LightningBolt);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(LightningBolt, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end
    function Rotation:OutOfCombat ()
        -- Healing Surge on ourself
        if module.IsOptionEnabled("Healing Surge") and not Player:IsMoving() and Player:CanCast(HealingSurge) and Player:HealthPercentage() <= module.GetSecondOptionValue("Healing Surge") then
            Player:Cast(HealingSurge);
            return;
        end
        -- AncestralSpirit
        if module.IsOptionEnabled("Ancestral Spirit") and Unit.ResurrectCycle(AncestralSpirit) then
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Enhancement Shaman
    local Rotation = {};
    module.SetRotation(263, Rotation);

    --- Localization
    -- Core
    local Enemies_30y = {};
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local CrashEnemies, SunderingEnemies, NumEnemies, HealUnits = {}, {}, 1, {}; -- Enemies


    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);
        --Racials
        BloodFury = Spell(33697, false, false, true);
        Berserking = Spell(26297, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        AncestralSpirit = Spell(2008, false, false, false, true);
        Ascendance = Spell(114051, false, false, true);
        AstralShift = Spell(108271, false, false, true);
        Boulderfist = Spell(201897, true, true, true);
        BoulderfistBuff = Spell(218825, false, false, true);
        CrashingStorm = Spell(192246);
        CrashLightning = Spell(187874, true, true, true);
        CrashLightningBuff = Spell(187878, false, false, true);
        DoomWinds = Spell(204945, true, true, true);
        EarthenSpike = Spell(188089, true, true, true);
        FeralLunge = Spell(196884, true, true, true);
        FeralSpirit = Spell(51533, false, false, true);
        FeralSpiritArtifact = Spell(198506, false, false, true);
        Flametongue = Spell(193796, true, true, true);
        FlametongueBuff = Spell(194084, false, false, true);
        Frostbrand = Spell(196834, true, true, true);
        FrostbrandBuff = Spell(196834, false, false, true);
        FuryOfAir = Spell(197211, false, false, true);
        GhostWolf = Spell(2645, false, false, true);
        HealingSurge = Spell(188070, false, false, true);
        HotHand = Spell(215785, false, false, true);
        LavaLash = Spell(60103, true, true, true);
        LightningBolt = Spell(187837, true, true, false);
        LightningShield = Spell(192106, false, false, true);
        Overcharge = Spell(210727, false, false, true);
        Purge = Spell(370, true, true, true);
        Rainfall = Spell(215864, false, false, true);
        Rockbiter = Spell(193786, true, true, true);
        Stormstrike = Spell(17364, true, true, true);
        Sundering = Spell(197214, false, false, true);
        WindShear = Spell(57994, true, true, true);
        Windsong = Spell(201898, false, true, true);
        Windstrike = Spell(115356, true, true, true);

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        -- Add options to pages
        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {1, "Disabled", "Enabled"}, "|cffFF0044Target (Left Box)|r\nAutomatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\n|cFF0088FFClosest:|r Target the closest enemy.\n|cFF0088FFLeast HP:|r Target the enemy with the least health remaining.\n|cFF0088FFMost HP:|r Target the enemy with the most health remaining.\n|cFF0088FFTarget Closest:|r Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining.\n\n|cffFF0044Attack (Right Box)|r\nUse /startattack when you changes target. Good for melee classes.");
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range.\n\n|cffFF0044Mode (Left Box)|r\n|cFF0088FFKeep:|r Cast on the new unit but keep your target the same.\n|cFF0088FFSwitch:|r Cast on the new unit and change your target to this unit.\n\n|cffFF0044Range (Right Box)|r\nSet the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Feral Lunge", 133, true, {1, "Disabled", "Enabled"}, {1, "Disabled", "Enabled"}, "Use Feral Lunge to close the gap between you and your target. \n\n|cFF0088FFValue 1:|r In Combat. \n\n|cFF0088FFValue 2:|r Out of Combat.");
        module.AddNewOption("General Settings", "Purge", 230, false, { 1, "Any Target", "Target" }, nil, "Remove known magic buffs from the Target or Any Target.");
        module.AddNewOption("General Settings", "Ancestral Spirit", 210, true, nil, nil, "Resurrect dead Target with Ancestral Spirit while out of combat");
        module.AddNewOption("General Settings", "Lightning Shield", 210, true, nil, nil, "Maintain Lightning Shield on us.");
        module.AddNewOption("General Settings", "Ghost Wolf", 210, true, nil, nil, "Use Ghost Wolf while out of combat.");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {40, 20, 90, 5, 20}, {60}, "Will use Wind Shear to interrupt the target when its cast time meets this % range.");
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range.\n(Works only if Interrupt between % is enabled).");
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Will use Potion when the BossMod (Support DBM & BW) timer will met the timer set.");
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions (only if your target is a Boss).");
        module.AddNewOption("Offensive Settings", "Ascendance", 230, true, {2, "Always", "With Cooldowns"}, nil, "Use Ascendance. \n\n|cFF0088FFValue:|r Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Doom Winds", 230, true, {2, "Always", "With Cooldowns"}, nil, "Use Doom Winds. \n\n|cFF0088FFValue:|r Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Feral Spirit", 230, true, {2, "Always", "With Cooldowns"}, nil, "Use Feral Spirit. \n\n|cFF0088FFValue:|r Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Windsong", 230, true, {2, "Always", "With Cooldowns"}, nil, "Use Windsong. \n\n|cFF0088FFValue:|r Define if you want to always use the ability or only with cooldowns.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Crash Lightning", 220, true, {2, 1, 5, 1}, nil, "Use Crash Lightning. \n\n|cFF0088FFValue:|r Units needed to be in Crash Lightning effect zone to use it. (Recommanded 2)");
        module.AddNewOption("Offensive Settings", "Fury Of Air", 220, true, {2, 1, 5, 1}, nil, "Use Fury of Air. \n\n|cFF0088FFValue 1:|r Minimum units in 8 yards around the player to active it. Fury of Air will be triggered off when ther are less than the units count.");
        module.AddNewOption("Offensive Settings", "Lightning Shield", 210, true, nil, nil, "Maintain Lightning Shield on us.");
        module.AddNewOption("Offensive Settings", "Sundering", 220, true, {1, 1, 10, 1}, nil, "Use Sundering. \n\n|cFF0088FFValue:|r Units needed to be in Sundering effect zone to use it.");
        module.AddNewOption("Offensive Settings", "Weapon Imbue", 230, true, {2, "Both", "Flametongue", "Frostbrand", "None"}, nil, "Use Weapon imbue. \n\n|cFF0088FFValue:|r Which weapon imbue(s) should we use.");


        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Health Percentage to use Healing Belt / Healing Pot / Healthstone.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Healing Surge", 222, true, {25, 0, 100, 1}, {85, 0, 100, 1}, "Use Healing Surge. \n\n|cFF0088FFValue 1:|r In Combat health threshold. \n\n|cFF0088FFValue 2:|r Out of Combat health threshold.");
        module.AddNewOption("Defensive Settings", "Rainfall", 222, true, { 3, 1, 10, 1 }, { 70, 0, 100, 1 }, "Use Rainfall. \n\n|cFF0088FFValue 1:|r Number of units that needs to be under threshold.\n\n|cFF0088FFValue 2:|r Threshold health under which the units must be.");
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Astral Shift", 220, true, {30, 0, 100, 1}, nil, "Use Astral Shift.");
        module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 0, 100, 1}, nil, "Use Gift Of The Naaru on ourself.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- Status Frame
        Player:AddCommonMeleeStatus();
        FuryOfAirName = GetSpellInfo(197211);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        -- Put the Outputs here that we wait to keep updated
        Player:SetCommonMeleeStatus();
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end
        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end


    function Rotation:Defensives ()
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Healing Item") and Player:HealthPercentage() <= module.GetOptionValue("Healing Item") then
            if HealingTonic:IsUsable() then
                Healthstone:Use(Player);
            elseif Healthstone:IsUsable() then
                HealingTonic:Use(Player);
            end
        end
        -- Astral Shift
        if AstralShift:Exists() and module.IsOptionEnabled("Astral Shift") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Astral Shift") and Player:CanCast(AstralShift) then
            Player:Cast(AstralShift);
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    function Rotation:Interrupts ()
        Player:UseInterrupt(WindShear);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(Stormstrike, false) or Unit.Target;
    end

    -- Remove Enrages
    local function PurgeCycle ()
        if module.GetOptionValue("Purge") == "Any Target" then
            for i = 1, #Enemies_30y do
                local ThisUnit = Enemies_30y[i];
                if ThisUnit:IsMagicBuffed() and ThisUnit:CanCast(Purge) then
                    module.Bug("Purge - Any on " .. ThisUnit:Name());
                    ThisUnit:Cast(Purge);
                    return;
                end
            end
        else
            if Target:IsMagicBuffed() and Target:CanCast(Purge) then
                module.Bug("Purge - Target");
                Target:Cast(Purge);
                return;
            end
        end
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()

        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and Player:IsFacing(Target) then
            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                HealUnits = Player:HealUnitsAround(100, 12);
                Enemies_30y = Player:EnemiesWithinDistance(30, true, false); -- Enemies in 30 yards for Purge
                Enemies_8y = Player:FilterEnemiesByDistance(Enemies_30y, 8, true); -- Enemies in 8 yards for Fury of Air
                CrashEnemies = Player:UnitsInFrontConeAroundUnit(Target, 5, 100);
                SunderingEnemies = Sundering:Exists() and Player:UnitsInFrontRectangle(10, 5) or {};
                NumEnemies = #CrashEnemies;
                RefreshEnemies = module.GetTime() + 0.2;
            end
            -- Lightning Shield
            if LightningShield:Exists() and module.IsOptionEnabled("Lightning Shield") and Player:BuffRemains(LightningShield) < 900 and Player:CanCast(LightningShield) then
                Player:Cast(LightningShield);
                return;
            end
            -- Purge
            if Purge:Exists() and module.IsOptionEnabled("Purge") and not Purge:IsOnCooldown() then
                PurgeCycle();
            end
            -- Healing Surge
            if HealingSurge:Exists() and module.IsOptionEnabled("Healing Surge") and Player:CanCast(HealingSurge, true) and Player:HealthPercentage() <= module.GetOptionValue("Healing Surge") then
                if Player:Maelstrom() >= 20 then
                    Player:Cast(HealingSurge);
                    return;
                elseif not Player:IsMoving() then
                    Player:Cast(HealingSurge);
                    return;
                end
            end
            if not Player:Buff(GhostWolf) and Target:InCastRange(LightningBolt) then

                -- Cooldowns
                if Player:IsWithinCastRange(Target, Stormstrike) then
                    Player:UseTrinkets();
                    if module.CooldownsAllowed() then
                        -- Racials
                        if module.IsOptionEnabled("Offensive Racials") then
                            -- Blood Fury
                            if BloodFury:Exists() and Player:CanCast(BloodFury) then
                                Player:Cast(BloodFury);
                            end
                            -- Berserking
                            if Berserking:Exists() and Player:CanCast(Berserking) then
                                CastSpellByID(26297, "player")
                            end
                        end
                    end
                    -- Feral Spirit
                    if FeralSpirit:Exists() and module.IsOptionEnabled("Feral Spirit") and (module.CooldownsAllowed() or module.GetOptionValue("Feral Spirit") == "Always") and Target:TimeToDie() >= 20 then
                        if not FeralSpiritArtifact:IsOnCooldown() and not FeralSpirit:IsOnCooldown() and Player:CanCast(FeralSpirit) then
                            Player:Cast(FeralSpirit);
                            return;
                        end
                    end
                    -- Ascendance
                    if Ascendance:Exists() and module.IsOptionEnabled("Ascendance") and (module.CooldownsAllowed() or module.GetOptionValue("Ascendance") == "Always") and Target:TimeToDie() >= 20 and Player:CanCast(Ascendance) then
                        Player:Cast(Ascendance);
                        return;
                    end
                    -- Windsong
                    if Windsong:Exists() and module.IsOptionEnabled("Windsong") and (module.CooldownsAllowed() or module.GetOptionValue("Windsong") == "Always") and Target:TimeToDie() >= 10 and Target:CanCast(Windsong) then
                        Target:Cast(Windsong);
                        return;
                    end
                else
                    -- Feral Lunge
                    if FeralLunge:Exists() and module.GetOptionValue("Feral Lunge") == "Enabled" and Player:DistanceTo(Target) >= 9 and Player:DistanceTo(Target) <= 24 and Target:CanCast(FeralLunge) then
                        Target:Cast(FeralLunge);
                        return;
                    end
                end


                -- Rotation
                if DoomWinds:Exists() and module.IsOptionEnabled("Doom Winds") and (module.CooldownsAllowed() or module.GetOptionValue("Doom Winds") == "Always") and Target:CanCast(DoomWinds) then
                    Target:Cast(DoomWinds);
                    return;
                end
                -- Earthen Spike
                if EarthenSpike:Exists() and Target:CanCast(EarthenSpike) then
                    Target:Cast(EarthenSpike);
                    return;
                end
                -- Boulderfist buff/dump
                if Boulderfist:Exists() and (Boulderfist:Charges() >= 2 or not Player:Buff(BoulderfistBuff)) and Target:CanCast(Boulderfist) then
                    Target:Cast(Boulderfist);
                    return;
                end
                -- Fury of Air
                if FuryOfAir:Exists() and module.IsOptionEnabled("Fury Of Air") then
                    if #Enemies_8y >= module.GetOptionValue("Fury Of Air") and not Player:Buff(FuryOfAir) and Player:CanCast(FuryOfAir) then
                        Player:Cast(FuryOfAir);
                        return;
                    end
                    if #Enemies_8y < module.GetOptionValue("Fury Of Air") and Player:Buff(FuryOfAir) then
                        RunMacroText("/cancelaura " .. FuryOfAirName);
                    end
                end
                -- Crash Lightning buffer
                if CrashLightning:Exists() and (CrashingStorm:Exists() or not Player:Buff(CrashLightningBuff)) and module.IsOptionEnabled("Crash Lightning") and #CrashEnemies >= module.GetOptionValue("Crash Lightning") and Target:CanCast(CrashLightning) then
                    Target:Cast(CrashLightning);
                    return;
                end
                if module.IsOptionEnabled("Weapon Imbue") then
                    -- Flametonge
                    if Flametongue:Exists() and (module.GetOptionValue("Weapon Imbue") == "Flametongue" or module.GetOptionValue("Weapon Imbue") == "Both") and Player:BuffRemains(FlametongueBuff) <= 2 and Target:CanCast(Flametongue) then
                        Target:Cast(Flametongue);
                        return;
                    end
                    -- Frostbrand
                    if Frostbrand:Exists() and (module.GetOptionValue("Weapon Imbue") == "Frostbrand" or module.GetOptionValue("Weapon Imbue") == "Both") and Player:BuffRemains(FrostbrandBuff) <= 2 and Target:CanCast(Frostbrand) then
                        Target:Cast(Frostbrand);
                        return;
                    end
                end
                -- Lava Lash - Hot Hand
                if LavaLash:Exists() and Player:Buff(HotHand) and Target:CanCast(LavaLash) then
                    Target:Cast(LavaLash);
                    return;
                end
                -- Sundering
                if Sundering:Exists() and module.IsOptionEnabled("Sundering") and #SunderingEnemies >= module.GetOptionValue("Sundering") and Player:CanCast(Sundering) then
                    Player:Cast(Sundering);
                    return;
                end
                -- Stormstrike/Windstrike
                if Stormstrike:Exists() and Target:CanCast(Stormstrike) then
                    Target:Cast(Stormstrike);
                    return;
                end
                -- Lightning Bolt Overcharge
                if Overcharge:Exists() and LightningBolt:Exists() and Player:Maelstrom() >= 50 and Target:CanCast(LightningBolt) then
                    Target:Cast(LightningBolt);
                    return;
                end
                -- Crash Lightning filler
                if CrashLightning:Exists() and not Player:Buff(CrashLightningBuff) and module.IsOptionEnabled("Crash Lightning") and #CrashEnemies >= module.GetOptionValue("Crash Lightning") and Target:CanCast(CrashLightning) then
                    Target:Cast(CrashLightning);
                    return;
                end
                -- Boulderfist filler
                if Boulderfist:Exists() and (Boulderfist:Charges() >= 2 or not Player:Buff(BoulderfistBuff) or Player:Maelstrom() < 70) and Target:CanCast(Boulderfist) then
                    Target:Cast(Boulderfist);
                    return;
                end
                -- Lava Lash
                if LavaLash:Exists() and Player:Maelstrom() >= 70 and Target:CanCast(LavaLash) then
                    Target:Cast(LavaLash);
                    return;
                end
                -- Rainfall
                if module.IsOptionEnabled("Rainfall") and Player:CanCast(Rainfall) then
                    local HealthThreashold = module.GetSecondOptionValue("Rainfall");
                    local BestHealUnits = {};
                    for i = 1, #HealUnits do
                        local ThisUnit = HealUnits[i]
                        if ThisUnit:CanHeal(HealingSurge) and not ThisUnit:IsMoving() then
                            TheseHealUnits = ThisUnit:HealUnitsAround(HealthThreashold, 12);
                            if #TheseHealUnits >= module.GetOptionValue("Rainfall") and #TheseHealUnits > #BestHealUnits then
                                BestHealUnits = TheseHealUnits;
                            end
                        end
                    end

                    if #BestHealUnits >= module.GetOptionValue("Rainfall") then
                        Player:CastGroundHeal(Rainfall, BestHealUnits);
                        return;
                    end
                end
                -- Rockbiter
                if Rockbiter:Exists() and Target:CanCast(Rockbiter) then
                    Target:Cast(Rockbiter);
                    return;
                end
                -- Lightning Bolt
                if LightningBolt:Exists() and not Player:IsWithinCastRange(Target, Stormstrike) and Target:CanCast(LightningBolt) then
                    Target:Cast(LightningBolt);
                    return;
                end
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Stormstrike, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        -- Healing Surge
        if HealingSurge:Exists() and module.IsOptionEnabled("Healing Surge") and Player:CanCast(HealingSurge, true) and Player:HealthPercentage() <= module.GetSecondOptionValue("Healing Surge") then
            if Player:Maelstrom() > 20 then
                Player:Cast(HealingSurge);
                return;
            elseif not Player:IsMoving() then
                Player:Cast(HealingSurge);
                return;
            end
        end
        -- Lightning Shield
        if LightningShield:Exists() and module.IsOptionEnabled("Lightning Shield") and Player:BuffRemains(LightningShield) < 900 and Player:CanCast(LightningShield) then
            Player:Cast(LightningShield);
            return;
        end
        -- AncestralSpirit
        if AncestralSpirit:Exists() and module.IsOptionEnabled("Ancestral Spirit") and Unit.ResurrectCycle(AncestralSpirit) then
            return;
        end
        -- Feral Lunge
        if FeralLunge:Exists() and module.GetSecondOptionValue("Feral Lunge") == "Enabled" and Player:DistanceTo(Target) >= 9 and Player:DistanceTo(Target) <= 24 and Target:CanCast(FeralLunge) then
            Target:Cast(FeralLunge);
            return;
        end
        -- Ghost Wolf
        if GhostWolf:Exists() and module.IsOptionEnabled("Ghost Wolf") and not Player:Buff(GhostWolf) and Player:CanCast(GhostWolf) then
            if not module.ShouldGhost then
                module.ShouldGhost = module.GetTime() + math.random(2, 3);
            elseif module.ShouldGhost < module.GetTime() then
                module.ShouldGhost = nil;
                Player:Cast(GhostWolf);
                return;
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Restoration Shaman
    local Rotation = {};
    module.SetRotation(264, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshTables = 0, 0.1, 0; -- Combat Module Throttle
    -- Healers Specific
    local MainTank, MainTankTarget, OffTank, OffTankTarget, HealUnits, Lowest, CurrentBadDebuffs, BestTarget, DispelUnit;
    local Trinket1Units, Trinket2Units, RacialsUnits;
    -- Profile Specific
    local GiftOfTheQueenCount, GiftOfTheQueenUnits = 0, {};
    local HealingRainCount, HealingRainUnits = 0, {};
    local SpiritLinkRaidCount,SpiritLinkRaidUnits = 0, {};
    local AscendanceCount, AncestralGuidanceCount, ChainHealUnit = 0, 0, nil;
    local CloudBurstTotemCount, HealingStreamTotemCount, HealingTideTotemCount, WellspringCount = 0, 0, 0, 0;

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        LukewarmYakRoastBroth = Item(120293, false, false, true);
        DraenicChanneledManaPotion = Spell(156432, false, false, false);
        --Racials
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33697, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        AncestralGuidance = Spell(108281, false, false, true);
        AncestralProtectionTotem = Spell(207399, false, false, true);
        AncestralSpirit = Spell(2008, false, false, false);
        AncestralVision = Spell(212048, false, false, false);
        Ascendance = Spell(114052, false, false, true);
        AstralShift = Spell(108271, false, false, true);
        ChainHeal = Spell(1064, false, false, false);
        ChainLightning = Spell(421, true, true, false);
        CloudBurstTotem = Spell(157153, false, false, true);
        EchoOfTheElements = Spell(108283);
        EarthenShieldTotem = Spell(198838, false, false, true);
        FlameShock = Spell(188838, true, true, true);
        GhostWolf = Spell(2645, false, false, true);
        GiftOfTheQueen = Spell(207778, false, false, true);
        HealingRain = Spell(73920, false, false, false);
        HealingStreamTotem = Spell(5394, false, false, true);
        HealingSurge = Spell(8004, false, false, false);
        HealingTideTotem = Spell(108280, false, false, true);
        HealingWave = Spell(77472, false, false, false);
        LavaBurst = Spell(51505, true, true, false);
        LightningBolt = Spell(403, true, true, false);
        Purge = Spell(370, true, true, true);
        PurifySpirit = Spell(77130, false, false, true);
        Riptide = Spell(61295, false, false, true);
        SpiritLinkTotem = Spell(98008, false, false, true);
        SpiritwalkersGrace = Spell(79206, false, false, true);
        TidalWave = Spell(53390);
        UnleashLife = Spell(73685, false, false, true);
        Wellspring = Spell(197995, false, false, false);
        WindShear = Spell(57994, true, true, true);

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Healing Settings");
        module.AddPage("Cooldowns Settings");
        module.AddPage("Offensive/Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Focus Assignation", 230, true, {2, "Main Tank", "Off Tank"}, nil, "Select which Tank slot should be given to the focussed unit.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Purify Spirit", 232, false, {1, "Auto", "High", "Normal"}, {0.2, 0, 1, 0.1}, "Use Purify Spirit to Dispel bad debuffs on allied units."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Auto").."Dispel Active Dispel Raid debuffs as High Priority and other not listed debuffs as Normal Priority."..C.TOOLTIP_SUBVALUE("High").."Dispel all debuffs as High Priority even before urgent cooldowns."..C.TOOLTIP_SUBVALUE("Normal").."Dispel all debuffs as Normal Priority after urgent cooldowns."..C.TOOLTIP_VALUE_2.."Define how long you want to wait before dispelling to look more human. This does not apply to Active Dispels Raid debuffs which will always be as soon as Global Cooldown ends."..C.TOOLTIP_HINT("Active Raid Dispels are based on an hardcoded list. Please report of any dispels you may encounter that requires specific strategies so that they can be properly added to the list."));
        module.AddNewOption("General Settings", "Ancestral Spirit", 210, true, nil, nil, "Resurrect dead Target with Ancestral Spirit while out of combat.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Ghost Wolf", 232, true, {3, "Always", "In Combat", "Out Of Combat"}, {2.5, 0, 10, 0.1}, "Use Ghost Wolf on player."..C.TOOLTIP_VALUE_1.."When should we use Ghost Wolf."..C.TOOLTIP_VALUE_2.."Select desired time to wait when you start moving to use it.(seconds)");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Wind Shear to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Healing Settings", "Common Healing Thresholds", "Green");
        module.AddNewOption("Healing Settings", "Chain Heal", 222, true, {3, 1, 5, 1}, {70, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Gift Of The Queen", 222, true, {1, 1, 5, 1}, {95, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Healing Rain", 222, true, {3, 1, 5, 1}, {70, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Healing Surge", 222, true, {70, 0, 100, 1}, {35, 0, 100, 1}, "Use Healing Surge."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Healing Wave", 222, true, {90, 0, 100, 1}, {80, 0, 100, 1}, "Use Healing Wave."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Riptide", 222, true, {95, 0, 100, 1}, {92, 0, 100, 1}, "Use Riptide."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Unleash Life", 222, true, {70, 0, 100, 1}, {35, 0, 100, 1}, "Use Riptide."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Wellspring", 222, true, {3, 1, 5, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Out Of Combat Healing", 210, true, nil, nil, "Allow Healing while Out of Combat.");
        module.AddSection("Healing Settings", "Active Healing", "Green");
        module.AddNewOption("Healing Settings", "Heal Target", 230, true, {1, "Known Unit", "Any Unit"}, nil, "Heal our current target if it is listed to be healed."..C.TOOLTIP_VALUE.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Known Unit").."Allow Heal Target to be used only when we are targetting a unit listed for it."..C.TOOLTIP_SUBVALUE("Any Unit").."Allow Heal Target to be used on any unit.");
        module.AddNewOption("Healing Settings", "Raid Debuffs", 220, true, {40, 0, 100, 1}, nil, "Use Renew on Debuffed units."..C.TOOLTIP_VALUE.."Helath threshold.");
        module.AddNewOption("Healing Settings", "Tank Debuffs", 220, true, {50, 0, 100, 1}, nil, "Use Renew on Debuffed tanks."..C.TOOLTIP_VALUE.."Helath threshold.");
        module.AddNewOption("Healing Settings", "Topping", 220, true, {100, 0, 100, 1}, nil, "Use Renew/Flash Heal on units to be topped."..C.TOOLTIP_VALUE.."Helath threshold.");

        module.AddSection("Cooldowns Settings", "Cooldowns", "Green");
        module.AddNewOption("Cooldowns Settings", "Ancestral Protection", 220, true, {15, 0, 100, 1}, nil, "Use on a dieing Tank."..C.TOOLTIP_VALUE.."Tank Health threshold."..C.TOOLTIP_HINT("The spell will normally always be used on as many units as possible around the Tank."));
        module.AddNewOption("Cooldowns Settings", "Ancestral Guidance", 222, true, {3, 1, 25, 1}, {60, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Ascendance", 222, true, {3, 1, 25, 1}, {60, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Cloud Burst Totem", 222, true, {1, 1, 25, 1}, {65, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Earthen Shield Totem", 220, true, {15, 0, 100, 1}, nil, "Use on a dieing Tank."..C.TOOLTIP_VALUE.."Tank Health threshold."..C.TOOLTIP_HINT("The spell will normally always be used on as many units as possible around the Tank."));
        module.AddNewOption("Cooldowns Settings", "Healing Stream Totem", 222, true, {2, 1, 25, 1}, {90, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Healing Tide Totem", 222, true, {3, 1, 25, 1}, {70, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Spirit Link Emergency", 222, true, {3, 1, 25, 1}, {25, 0, 100, 1}, "Use when selected number of units are around a dieing Tank."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Tank Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Spirit Link Raid", 222, true, {3, 1, 25, 1}, {50, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddSection("Cooldowns Settings", "Trinkets And Racials", "Green");
        module.AddNewOption("Cooldowns Settings", "Soft Cooldowns Units", 120, true, {3, 1, 25, 1}, nil, "Number of units that needs to be under thresholds to use Racials and Trinkets with Health.");
        module.AddNewOption("Cooldowns Settings", "Use Racials", 220, true, {80, 0, 100, 1}, nil, "Use Racials."..C.TOOLTIP_VALUE.."Use when number of units under threshold is greater or equal to Soft Cooldowns Units value.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 1", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 1 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always") .." Use Always."..C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 2", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 2 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always") .." Use Always."..C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");

        module.AddSection("Offensive/Defensive Settings", "DPS Offensive", "Green");
        module.AddPresetOption("TargetAttack");
        module.AddNewOption("Offensive/Defensive Settings", "DPS", 220, true, {95, 0, 100, 1}, nil, "Enables DPS options."..C.TOOLTIP_VALUE.."Will only DPS if the Lowest unit is above DPS health treshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Chain Lightning", 220, true, {3, 1, 10, 1}, nil, "Use Chain Lightning in the DPS rotation."..C.TOOLTIP_VALUE.."Amount of units required to be in 12 yards of Player to use."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Flame Shock", 210, true, nil, nil, "Use Flame Shock in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Lava Burst", 210, true, nil, nil, "Use Lava Burst in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Lightning Bolt", 210, true, nil, nil, "Use Lightning Bolt in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddSection("Offensive/Defensive Settings", "Defensive", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Astral Shift", 220, true, {30, 1, 100, 1}, nil, "Use Astral Shift."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Offensive/Defensive Settings", "Gift Of The Naaru", 222, true, {65, 0, 100, 1}, {55, 0, 100, 1}, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        end

        -- Healers Specific
        module.AddOutput("|cFF9A2EFEMain Tank:");
        module.AddOutput("|cFF9A2EFEOff Tank:");
        module.AddOutput("|cFF9A2EFELowest:");
        module.AddOutput("|cFF9A2EFEBad Debuffs:");
        module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- New Improved Spell Casting Logic
        module.ISCL = {
            [HealingSurge:ID()] = "Healing Surge",
            [HealingWave:ID()] = "Healing Wave",
            [ChainHeal:ID()] = "Chain Heal"
        };
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Define Main Tanks
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(WindShear);
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Astral Shift
        if AstralShift:Exists() and module.IsOptionEnabled("Astral Shift") and Player:HealthPercentage() <= module.GetOptionValue("Astral Shift") and Player:CanCast(AstralShift) then
            Player:Cast(AstralShift);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and MainTank:CanCast(GiftOfTheNaaru) then
                MainTank:Cast(GiftOfTheNaaru);
                return;
            elseif MainTank and OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and OffTank:CanCast(GiftOfTheNaaru) then
                OffTank:Cast(GiftOfTheNaaru);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Gift Of The Naaru") and Lowest:CanCast(GiftOfTheNaaru) then
                Lowest:Cast(GiftOfTheNaaru);
                return;
            end
        end
    end

    -- Get Tanks Status
    local TanksStatus, MainTankTanking, OffTankTanking = {Main = {IsTanking = module.GetTime()},Off = {IsTanking = module.GetTime()}};
    local function RefreshTanksStatus ()
        TanksStatus = {
            Main = {IsTanking = MainTank and MainTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Main.IsTanking},
            Off = {IsTanking = OffTank and OffTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Off.IsTanking}
        };
        MainTankTanking = module.GetTime() - TanksStatus.Main.IsTanking < 3 or false;
        OffTankTanking = module.GetTime() - TanksStatus.Off.IsTanking < 3 or false;
    end

    -- Active Healing Heal Target handler
    local function HealTarget (ThisUnit)
        -- Riptide
        if ThisUnit:CanCast(Riptide) and ThisUnit:BuffRemains(Riptide) < 2 then
            ThisUnit:Cast(Riptide);
            return;
        end
        if not Player:IsMoving() and ThisUnit:CanCast(HealingSurge) then
            -- Healing Surge
            if ThisUnit:CanCast(HealingSurge) and ThisUnit:SpecialHealthPercentage() < 100 then
                ThisUnit:Cast(HealingSurge);
                return;
            end
            -- Healing Wave
            if ThisUnit:CanCast(HealingWave) then
                ThisUnit:Cast(HealingWave);
                return;
            end
        end
    end

    --- Run the beta rotation's healing logic.
    function Rotation:Combat ()
        -- Find best unit to attack
        if Target:Exists() and Target:CanCast(LightningBolt) then
            BestTarget = Target;
        elseif MainTankTarget and MainTankTarget:CanCast(LightningBolt) then
            BestTarget = MainTankTarget;
        elseif OffTankTarget and OffTankTarget:CanCast(LightningBolt) then
            BestTarget = OffTankTarget;
        elseif Mouseover:Exists() and Mouseover:CanCast(LightningBolt) then
            BestTarget = Mouseover;
        else
            BestTarget = Target;
        end

        -- Refresh tables every 0.5 seconds
        if RefreshTables < module.GetTime() then
            DispelUnit = Unit.Dispel(PurifySpirit);
            HealUnits = Player:HealUnitsAround(100, 40);
            Lowest = Unit.Lowest(MainTank, OffTank);
            module.SetOutput("|cFF9A2EFELowest:", Lowest and Lowest:Name() or "");
            RefreshTanksStatus();
            TargetEnemies_10y = module.UseAOE() and BestTarget:Exists() and BestTarget:EnemiesWithinDistance(10) or {}; -- 10 yards of Target for Chain Lightning.
            AscendanceCount = Ascendance:Exists() and #Player:HealUnitsAround(module.GetSecondOptionValue("Ascendance"), 40) or 0;
            AncestralGuidanceCount = AncestralGuidance:Exists() and #Player:HealUnitsAround(module.GetSecondOptionValue("Ancestral Guidance"), 40) or 0;
            ChainHealUnit = ChainHeal:Exists() and module.IsOptionEnabled("Chain Heal") and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Chain Heal"), module.GetSecondOptionValue("Chain Heal"), 20) or nil;
            CloudBurstTotemCount = CloudBurstTotem:Exists() and module.IsOptionEnabled("Cloud Burst Totem") and #Player:HealUnitsAround(module.GetSecondOptionValue("Cloud Burst Totem"), 40) or 0;
            HealingStreamTotemCount = HealingStreamTotem:Exists() and module.IsOptionEnabled("Healing Stream Totem") and #Player:HealUnitsAround(module.GetSecondOptionValue("Healing Stream Totem"), 40) or 0;
            HealingTideTotemCount = HealingTideTotem:Exists() and module.IsOptionEnabled("Healing Tide Totem") and #Player:HealUnitsAround(module.GetSecondOptionValue("Healing Tide Totem"), 40) or 0;
            RacialsUnits = module.IsOptionEnabled("Use Racials") and ((Berserking:Exists() and Player:CanCast(Berserking)) or (BloodFury:Exists() and Player:CanCast(BloodFury))) and #Player:HealUnitsAround(module.GetOptionValue("Use Racials"), 40) or 0;
            Trinket1Units = module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 1"), 40) or 0;
            Trinket2Units = module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 2"), 40) or 0;
            WellspringCount = Wellspring:Exists() and #Player:UnitsInFrontCone(30, 160, true, module.GetSecondOptionValue("Wellspring")) or 0;
            if GiftOfTheQueen:Exists() and module.IsOptionEnabled("Gift Of The Queen") and not GiftOfTheQueen:IsOnCooldown() then
                GiftOfTheQueenCount, GiftOfTheQueenUnits = Player:BestGroundHealUnits(HealUnits, module.GetSecondOptionValue("Gift Of The Queen"), 12);
            else
                GiftOfTheQueenCount, GiftOfTheQueenUnits = 0, {};
            end
            if HealingRain:Exists() and module.IsOptionEnabled("Healing Rain") and not HealingRain:IsOnCooldown() then
                HealingRainCount, HealingRainUnits = Player:BestGroundHealUnits(HealUnits, module.GetSecondOptionValue("Healing Rain"), 10)
            else
                HealingRainCount, HealingRainUnits = 0, {};
            end
            if SpiritLinkTotem:Exists() and module.IsOptionEnabled("Spirit Link Raid") and not SpiritLinkTotem:IsOnCooldown() then
                SpiritLinkRaidCount, SpiritLinkRaidUnits = Player:BestGroundHealUnits(HealUnits, module.GetSecondOptionValue("Spirit Link Raid"), 10)
            else
                SpiritLinkRaidCount, SpiritLinkRaidUnits = 0, {};
            end
            -- Bad Debuffs Output
            CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits);
            if CurrentBadDebuffs ~= nil then
                module.SetOutput("|cFF9A2EFEBad Debuffs:", #CurrentBadDebuffs.Tanks + #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff);
            end
            RefreshTables = module.GetTime() + 0.5;
        end

        -- Dispels Handling
        Player:DispelHandler(PurifySpirit, "Purify Spirit", DispelUnit, CurrentBadDebuffs.Dispel, "High");

        -- Active Healing Heal Target handler
        if Target:CanCast(HealingWave) and module.IsOptionEnabled("Heal Target") and (module.GetOptionValue("Heal Target") == 2 or (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed())) then
            HealTarget(Target);
            return;
        end

    -- Cooldowns
        -- Only use DPS and Cooldowns during combat
        if Player:IsInCombat() then
            -- DPS
            if module.IsOptionEnabled("DPS") and BestTarget and (not Lowest or Lowest:HealthPercentage() >= module.GetOptionValue("DPS")) and (not MainTank or MainTank:HealthPercentage() >= module.GetOptionValue("DPS")) and (not OffTank or OffTank:HealthPercentage() >= module.GetOptionValue("DPS")) and BestTarget:IsInCombat() then
                -- Flame Shock
                if FlameShock:Exists() and module.IsOptionEnabled("Flame Shock") and BestTarget:DebuffRemains(FlameShock) < 3 and BestTarget:CanCast(FlameShock) then
                    BestTarget:Cast(FlameShock);
                    return;
                end
                -- Lava Burst
                if LavaBurst:Exists() and BestTarget:Debuff(FlameShock) and BestTarget:CanCast(LavaBurst) then
                    BestTarget:Cast(LavaBurst);
                    return;
                end
                -- Chain Lightning
                if ChainLightning:Exists() and #TargetEnemies_10y >= module.GetOptionValue("Chain Lightning") and BestTarget:CanCast(ChainLightning) then
                    BestTarget:Cast(ChainLightning);
                    return;
                end
                -- Lightning Bolt
                if LightningBolt:Exists() and module.IsOptionEnabled("Lightning Bolt") and BestTarget:CanCast(LightningBolt) then
                    BestTarget:Cast(LightningBolt);
                    return;
                end
                -- Find New Target
                if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
                    local NewTargetUnit = Unit.AutoTarget(LightningBolt, module.GetOptionValue("Target | Attack"));
                    if NewTargetUnit then
                        NewTargetUnit:Attack();
                        return;
                    end
                end
            end
            -- Spirit Link Totem
            if SpiritLinkTotem:Exists() and Player:CanCast(SpiritLinkTotem) then
                -- MainTank Emergency
                if MainTank and module.IsOptionEnabled("Spirit Link Emergency") and not MainTank:IsMoving() and MainTank:SpecialHealthPercentage() < module.GetSecondOptionValue("Spirit Link Emergency") and MainTank:CanCast(HealingWave) then
                    local TheseHealUnits = MainTank:HealUnitsAround(100, 10);
                    if #TheseHealUnits >= module.GetOptionValue("Spirit Link Emergency") then
                        module.Bug("Spirit Link Emergency on Main Tank.");
                        Player:CastGroundHeal(SpiritLinkTotem, TheseHealUnits);
                        return;
                    end
                end
                -- OffTank Emergency
                if OffTank and module.IsOptionEnabled("Spirit Link Emergency") and not OffTank:IsMoving() and OffTank:SpecialHealthPercentage() < module.GetSecondOptionValue("Spirit Link Emergency") and OffTank:CanCast(HealingWave) then
                    local TheseHealUnits = OffTank:HealUnitsAround(100, 10);
                    if #TheseHealUnits >= module.GetOptionValue("Spirit Link Emergency") then
                        module.Bug("Spirit Link Emergency on Off Tank.");
                        Player:CastGroundHeal(SpiritLinkTotem, TheseHealUnits);
                        return;
                    end
                end
                -- Raid
                if SpiritLinkRaidCount >= module.GetOptionValue("Spirit Link Raid") then
                    module.Bug("Spirit Link Raid " .. " Count:" .. SpiritLinkRaidCount .. " Units:" .. #SpiritLinkRaidUnits);
                    module.Bug("Spirit Link Raid");
                    Player:CastGroundHeal(SpiritLinkTotem, SpiritLinkRaidUnits);
                    return;
                end
            end
            -- Ancestral Protection Totem
            if AncestralProtectionTotem:Exists() and Player:CanCast(AncestralProtectionTotem) then
                -- MainTank Emergency
                if MainTank and module.IsOptionEnabled("Ancestral Protection") and not MainTank:IsMoving() and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Ancestral Protection") and MainTank:CanCast(AncestralProtection) then
                    local TheseHealUnits = MainTank:HealUnitsAround(100, 10);
                    module.Bug("Ancestral Protection on Main Tank.");
                    Player:CastGroundHeal(AncestralProtectionTotem, TheseHealUnits);
                    return;
                end
                -- OffTank Emergency
                if OffTank and module.IsOptionEnabled("Ancestral Protection") and not OffTank:IsMoving() and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Ancestral Protection") and OffTank:CanCast(AncestralProtection) then
                    local TheseHealUnits = OffTank:HealUnitsAround(100, 10);
                    module.Bug("Ancestral Protection on Off Tank.");
                    Player:CastGroundHeal(AncestralProtectionTotem, TheseHealUnits);
                    return;
                end
            end
            -- Earthen Shield Totem
            if EarthenShieldTotem:Exists() and Player:CanCast(EarthenShieldTotem) then
                -- MainTank Emergency
                if MainTank and module.IsOptionEnabled("Ancestral Protection") and not MainTank:IsMoving() and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Earthen Shield Totem") and MainTank:CanCast(EarthenShieldTotem) then
                    local TheseHealUnits = MainTank:HealUnitsAround(100, 10);
                    module.Bug("Earthen Shield Totem on Main Tank.");
                    Player:CastGroundHeal(EarthenShieldTotem, TheseHealUnits);
                    return;
                end
                -- OffTank Emergency
                if OffTank and module.IsOptionEnabled("Ancestral Protection") and not OffTank:IsMoving() and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Earthen Shield Totem") and OffTank:CanCast(EarthenShieldTotem) then
                    local TheseHealUnits = OffTank:HealUnitsAround(100, 10);
                    module.Bug("Earthen Shield Totem on Off Tank.");
                    Player:CastGroundHeal(EarthenShieldTotem, TheseHealUnits);
                    return;
                end
            end
            -- Healing Tide - Used when # of people under treshold exceed desired number of units
            if HealingTideTotem:Exists() and module.IsOptionEnabled("Healing Tide Totem") and HealingTideTotemCount >= module.GetOptionValue("Healing Tide Totem") and Player:CanCast(HealingTideTotem) then
                Player:Cast(HealingTideTotem);
                return;
            end
            -- Healing Stream - Used when # of people under treshold exceed desired number of units
            if HealingStreamTotem:Exists() and module.IsOptionEnabled("Healing Stream Totem") and HealingStreamTotem:TimeSinceCast() >= 12 and HealingStreamTotemCount >= module.GetOptionValue("Healing Stream Totem") and Player:CanCast(HealingStreamTotem) then
                Player:Cast(HealingStreamTotem);
                HealingStreamTotem.LastCastTime = module.GetTime();
                return;
            end
            -- Cloud Burst - Used when # of people under treshold exceed desired number of units
            if CloudBurstTotem:Exists() and module.IsOptionEnabled("Cloud Burst Totem") and CloudBurstTotemCount >= module.GetOptionValue("Cloud Burst Totem") and Player:CanCast(CloudBurstTotem) then
                Player:Cast(CloudBurstTotem);
                return;
            end
            -- Racials with Specific Handlers
            if module.IsOptionEnabled("Use Racials") then
                if RacialsUnits >= module.GetOptionValue("Soft Cooldowns Units") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                        return;
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                        return;
                    end
                end
            end
            -- Trinkets with specific handlers
            if module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 1"), module.GetSecondOptionValue("Use Trinket 1");
                if Option1 == "Always" or (Option1 == "Health" and Trinket1Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 1")) then
                    Trinket1:UseInventory();
                end
            end
            if module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 2"), module.GetSecondOptionValue("Use Trinket 2");
                if Option1 == "Always" or (Option1 == "Health" and Trinket2Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 2")) then
                    Trinket2:UseInventory();
                end
            end
            -- Ascendance
            if Ascendance:Exists() and module.IsOptionEnabled("Ascendance") and AscendanceCount >= module.GetOptionValue("Ascendance") and Player:CanCast(Ascendance) then
                Player:Cast(Ascendance);
                return;
            end
            -- Ancestral Guidance
            if AncestralGuidance:Exists() and module.IsOptionEnabled("Ancestral Guidance") and AncestralGuidanceCount >= module.GetOptionValue("Ancestral Guidance") and Player:CanCast(AncestralGuidance) then
                Player:Cast(AncestralGuidance);
                return;
            end
        end
        -- Dispels Handling
        Player:DispelHandler(PurifySpirit, "Purify Spirit", DispelUnit, CurrentBadDebuffs.Dispel, "Normal");
    -- High Priority Healing
        -- Wellspring
        if Wellspring:Exists() and module.IsOptionEnabled("Wellspring") and WellspringCount >= module.GetOptionValue("Wellspring") and Player:CanCast(Wellspring) then
            Player:Cast(Wellspring);
            return;
        end
        -- Gift Of The Queen
        if GiftOfTheQueen:Exists() and GiftOfTheQueenCount >= module.GetOptionValue("Gift Of The Queen") and Player:CanCast(GiftOfTheQueen) then
            -- module.Bug("Gift Of The Queen " .. " Count:" .. GiftOfTheQueenCount .. " Units:" .. #GiftOfTheQueenUnits);
            Player:CastGroundHeal(GiftOfTheQueen, GiftOfTheQueenUnits);
            return;
        end
        -- Healing Rain
        if HealingRain:Exists() and HealingRainCount >= module.GetOptionValue("Healing Rain") and Player:CanCast(HealingRain) then
            -- module.Bug("Healing Rain " .. " Count:" .. HealingRainCount .. " Units:" .. #HealingRainUnits);
            Player:CastGroundHeal(HealingRain, HealingRainUnits);
            return;
        end
        -- Unleash Life
        if UnleashLife:Exists() and module.IsOptionEnabled("Unleash Life") then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Unleash Life") and MainTank:CanCast(UnleashLife) then
                MainTank:Cast(UnleashLife);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Unleash Life") and OffTank:CanCast(UnleashLife) then
                OffTank:Cast(UnleashLife);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Unleash Life") and Lowest:CanCast(UnleashLife) then
                Lowest:Cast(UnleashLife);
                return;
            end
        end
        -- Riptide on Tanks
        if Riptide:Exists() and module.IsOptionEnabled("Riptide") then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Riptide") and (MainTank:BuffRemains(Riptide) <= 5 or MainTank:SpecialHealthPercentage() < 30) and MainTank:CanCast(Riptide) then
                MainTank:Cast(Riptide);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Riptide") and (OffTank:BuffRemains(Riptide) <= 5 or MainTank:SpecialHealthPercentage() < 30) and OffTank:CanCast(Riptide) then
                OffTank:Cast(Riptide);
                return;
            end
        end
        -- Riptide Cycle
        if Player:IsInCombat() and Riptide:Exists() and module.IsOptionEnabled("Riptide") and (not EchoOfTheElements:Exists() or Riptide:Charges() >= 2 or (Riptide:Charges() >= 1 and Riptide:Recharge() < 2)) and (Player:BuffRemains(TidalWave) < 3 or Player:BuffCount(TidalWave) < 2) then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #HealUnits do
                local ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage();
                if ThisUnitHealth <= BestUnitHealth and ThisUnit:CanCast(Riptide) and ThisUnit:BuffRemains(Riptide) < 3 then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit then
                BestUnit:Cast(Riptide);
                return;
            end
        end
        -- Healing Surge - Tanks
        if HealingSurge:Exists() and module.IsOptionEnabled("Healing Surge") and not Player:IsMoving() then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Healing Surge") and MainTank:CanCast(HealingSurge) then
                MainTank:Cast(HealingSurge);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Healing Surge") and OffTank:CanCast(HealingSurge) then
                OffTank:Cast(HealingSurge);
                return;
            end
        end
        -- Chain Heal
        if module.IsOptionEnabled("Chain Heal") and ChainHealUnit and ChainHealUnit:CanCast(ChainHeal) then
            ChainHealUnit:Cast(ChainHeal);
            return;
        end
        -- Healing Surge - Raid
        if HealingSurge:Exists() and module.IsOptionEnabled("Healing Surge") and not Player:IsMoving() then
            if Lowest and Lowest:SpecialHealthPercentage() < module.GetSecondOptionValue("Healing Surge") and Lowest:CanCast(HealingSurge) then
                Lowest:Cast(HealingSurge);
                return;
            end
        end
    -- Bad Debuffs - Tank
        if Riptide:Exists() and module.IsOptionEnabled("Tank Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Tanks do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Tanks[i], CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Riptide) and not ThisUnit:Buff(Riptide) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Tank Debuffs") then
                module.Bug("Riptide on " .. BestUnit:Name() .. " to heal tank debuff");
                BestUnit:Cast(Riptide);
                return;
            end
        end
    -- Bad Debuffs - Debuffs
        if Riptide:Exists() and module.IsOptionEnabled("Raid Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Debuff do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Debuff[i], CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Riptide) and not ThisUnit:Buff(Riptide) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Raid Debuffs") then
                module.Bug("Riptide on " .. BestUnit:Name() .. " to mitigate debuff");
                BestUnit:Cast(Riptide);
                return;
            end
        end
    -- Bad Debuffs - Topping
        if module.IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Top do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Top[i], CurrentBadDebuffs.Top[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(HealingSurge) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil then
                if Riptide:Exists() and BestUnitHealth <= module.GetOptionValue("Topping") and BestUnit:CanCast(Riptide) and not BestUnit:Buff(Riptide) then
                    module.Bug("Riptide on " .. BestUnit:Name() .. " to top it");
                    BestUnit:Cast(Riptide);
                    return;
                end
                if HealingSurge:Exists() and BestUnitHealth <= module.GetOptionValue("Topping") and BestUnit:CanCast(HealingSurge) then
                    module.Bug("Healing Surge on " .. BestUnit:Name() .. " to top it");
                    BestUnit:Cast(HealingSurge);
                    return;
                end
            end
        end
    -- Low Priority Healing
        -- Healing Wave Tanks/Lowest
        if HealingWave:Exists() and module.IsOptionEnabled("Healing Wave") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Healing Wave") and MainTank:CanCast(HealingWave) then
                MainTank:Cast(HealingWave);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Healing Wave") and OffTank:CanCast(HealingWave) then
                OffTank:Cast(HealingWave);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Healing Wave") and Lowest:CanCast(HealingWave) then
                Lowest:Cast(HealingWave);
                return;
            end
        end
        -- Ghost Wolf - when we run more than choosen time
        if GhostWolf:Exists() and module.IsOptionEnabled("Ghost Wolf") and (module.GetOptionValue("Ghost Wolf") == "Always" or (module.GetOptionValue("Ghost Wolf") == "In Combat" and Player:IsInCombat()) or (module.GetOptionValue("Ghost Wolf") == "Out Of Combat" and not Player:IsInCombat())) and Player:Moving() > module.GetSecondOptionValue("Ghost Wolf") and not IsFalling() and not Player:Buff(GhostWolf) and Player:CanCast(GhostWolf) then
            Player:Cast(GhostWolf);
            return;
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Resurrect Deads
        if module.IsOptionEnabled("Ancestral Spirit") and Unit.ResurrectCycle(AncestralSpirit) then
            return;
        end
        if module.IsOptionEnabled("Out Of Combat Healing") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Affliction Warlock
    local Rotation = {};
    module.SetRotation(265, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local MainTank, OffTank, MainTankResDelay, OffTankResDelay = nil, nil, nil, nil; -- Battle Resurection timers
    local Enemies_40y, TargetEnemies_10y, NumEnemies = {}, {}, 0; -- Enemies Table
    local AgonyUnit, CorruptionUnit, SiphonLifeUnit, UnstableAfflictionUnit; -- Dots units
    -- Pet Manager
    local PetTimer, SacrificeRandomDelay = 0, nil;
    -- Effigy Handling
    local CurrentTarget, PreviousTarget

    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicIntellect = Item(109218, false, false, true);
        DraenicIntellectBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, resurrect)
        AbsoluteCorruption = Spell(196103);
        Agony = Spell(980, false, true, true);
        Corruption = Spell(172, false, true, true);
        CorruptionDebuff = Spell(146739);
        CreateHealthstone = Spell(6201, false, false, false);
        DarkPact = Spell(108416, false, false, true);
        DeadwindHarvester = Spell(216708);
        DrainLife = Spell(689, true, true, false);
        DrainSoul = Spell(198590, true, true, false);
        GuardianDoomguard = Spell(18540, false, true, true);
        GuardianInfernal = Spell(1122, false, true, true);
        GrimoreOfSacrifice = Spell(108503, false, false, true);
        GrimoreOfSacrificeBuff = Spell(196099);
        GrimoreOfService = Spell(108501, false, false, true);
        GrimoreOfSupremacy = Spell(152107, false, true, true);
        GrimoreOfImp = Spell(111859, false, true, true);
        GrimoreOfVoid = Spell(111895, false, true, true);
        GrimoreOfSuccubus = Spell(111896, false, true, true);
        GrimoreOfFelHunter = Spell(111897, false, true, true);
        Haunt = Spell(48181, true, true, false);
        HealthFunnel = Spell(755, false, false, false);
        LifeTap = Spell(1454, false, false, true);
        ManaTap = Spell(196104, false, false, true);
        MortalCoil = Spell(6789, false, true, true);
        PhantomSingularity = Spell(205179, false, true, true);
        ReapSouls = Spell(216698, false, false, true);
        SeedOfCorruption = Spell(27243, false, true, false);
        ShadowLock = Spell(171138, true, true, true);
        SiphonLife = Spell(63106, false, true, true);
        SoulEffigy = Spell(205178, false, true, true);
        SoulHarvest = Spell(196098, false, false, true);
        Soulstone = Spell(20707, false, false, false, true);
        SowTheSeeds = Spell(196226);
        SpellLock = Spell(19647, false, true, true);
        SummonDoomguard = Spell(157757, false, false, false);
        SummonFelhunter = Spell(691, false, false, false);
        SummonImp = Spell(688, false, false, false);
        SummonInfernal = Spell(157898, false, false, false);
        SummonSuccubus = Spell(712, false, false, false);
        SummonVoidwalker = Spell(697, false, false, false);
        TormentedSouls = Spell(216695);
        UnendingBreath = Spell(5697, false, false, true);
        UnendingResolve = Spell(104773, false, false, true);
        UnstableAffliction = Spell(30108, false, true, false);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddPresetOption("TargetAttack");
        module.AddPresetOption("BossCD");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Shadow Lock/Spell Lock to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddSection("General Settings", "Demons Management", "Green");
        module.AddNewOption("General Settings", "Demon Manager", 230, true, {3, "Doomguard", "Felhunter", "Imp", "Infernal", "Succubus", "Voidwalker"}, nil, "Enable pet management."..C.TOOLTIP_VALUE.."Choose demon to use.")
        module.AddNewOption("General Settings", "Health Funnel", 220, true, {25, 1, 100, 5}, nil, "Use Health Funnel to heal our demon."..C.TOOLTIP_VALUE.."Health threshold.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Doomguard", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Doomguard."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Grimoire Of Service", 233, true, {1, "Always", "Cooldown Only"}, {2, "Felhunter", "Imp", "Succubus", "Voidwalker"}, "Enable Grimoire of Service."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Choose demon to use.")
        module.AddNewOption("Offensive Settings", "Grimoire Of Sacrifice", 210, true, nil, nil, "Automatic Grimoire Of Sacrifice usage.");
        module.AddNewOption("Offensive Settings", "Infernal", 230, false, {2, "Always", "Cooldown Only"}, nil, "Use Infernal."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Mana Tap", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Mana Tap."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Soul Harvest", 232, true, {1, "Always", "Cooldown Only"}, {1, 0, 3, 1}, "Use Soul Harvest."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Phantom Singularity", 232, true, {1, "Always", "Cooldown Only"}, {1, 0, 3, 1}, "Use Phantom Singularity."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.AddPresetOption("Trinket");
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "SoC AoE", 220, true, {4, 1, 10, 1}, nil, "Use AoE rotation. Apply Dots to current target and spam Seed of Corruption."..C.TOOLTIP_VALUE.."Amount of units needed within 10 yards around our target.");
        module.AddNewOption("Offensive Settings", "Soul Effigy", 232, true, {1, "Auto", "Agony + Corruption"}, {3, 0, 25, 0.1}, "Use Soul Effigy on the current target."..C.TOOLTIP_VALUE.."Minimum health our target must have to use Soul Effigy.")
        module.AddSection("Offensive Settings", "Multi-Dots", "Green");
        module.AddNewOption("Offensive Settings", "Multi-Dot Agony", 222, true, {6, 1, 10, 1}, {3, 0, 25, 0.1}, "Multi-Dot Agony Cycle."..C.TOOLTIP_VALUE_1.."Amount of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Corruption", 222, true, {6, 1, 10, 1}, {3, 0, 25, 0.1}, "Multi-Dot Corruption Cycle."..C.TOOLTIP_VALUE_1.."Amount of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Siphon Life", 222, false, {6, 1, 10, 1}, {3, 0, 25, 0.1}, "Multi-Dot Siphon Life Cycle."..C.TOOLTIP_VALUE_1.."Amount of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Multi-Dot UA", 222, false, {3, 1, 10, 1}, {3, 0, 25, 0.1}, "Multi-Dot Unstable Affliction Cycle."..C.TOOLTIP_VALUE_1.."Amount of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply."..C.TOOLTIP_HINT("Multi-Dot Unstable Affliction will only be used if we have at least 4 Soul Shards."));

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Create Healthstones", 210, true, nil, nil, "Will create you a new healthstone if you have none in your bags and are out of combat.");
        module.AddPresetOption("HealingItem");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Dark Pact", 220, true, {40, 1, 100, 1}, nil, "Use Dark Bargain."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Drain Life", 220, true, {20, 1, 75, 1}, nil, "Use Drain Life."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Mortal Coil", 220, true, {50, 1, 100, 1}, nil, "Use Mortal Coil."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Unending Resolve", 220, true, {40, 1, 100, 1}, nil, "Use Dark Unending Resolve."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [UnstableAffliction:ID()] = "Unstable Affliction"
        };
    end
    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end
        DrainFiller = not Player:Channeling(DrainSpell) and false or DrainFiller;

        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end
        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        local OpenerSpell = not GrimoreOfSupremacy:Exists() and module.IsOptionEnabled("Doomguard") and GuardianDoomguard:Cooldown() == 0 and GuardianDoomguard or UnstableAffliction;
        -- 2) Potion
        if module.IsOptionEnabled("Pre-Pull BossMod") and not Potion and module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and Player:IsWithinCastRange(Target, UnstableAffliction) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + OpenerSpell:TravelTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) then
            if Player:Potion("Intellect", Potion) then Potion = true; end
        end
        -- 3) Doomguard/Shadowbolt/Demonbolt
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + OpenerSpell:TravelTime() and Target:CanCast(OpenerSpell) then
            Target:Cast(OpenerSpell);
            return;
        end
    end

    function Rotation:Interrupts ()
        local PetInterrupt = (SpellLock:PetKnown() and SpellLock) or (ShadowLock:PetKnown() and ShadowLock) or nil;
        if PetInterrupt then
            Player:UseInterrupt(PetInterrupt, ArcaneTorrent, true);
        end
    end

    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(Corruption, true) or Unit.Target;
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Mortal Coil
        if MortalCoil:Exists() and module.IsOptionEnabled("Mortal Coil") and Target:Exists() and Target:CanCast(MortalCoil) and Player:HealthPercentage() <= module.GetOptionValue("Mortal Coil") then
            Target:Cast(MortalCoil);
        end
        -- Dark Pact
        if DarkPact:Exists() and module.IsOptionEnabled("Dark Pact") and Player:CanCast(DarkPact) and Player:HealthPercentage() <= module.GetOptionValue("Dark Pact") then
            Player:Cast(DarkPact);
            return;
        end
        -- Unending Resolve
        if UnendingResolve:Exists() and module.IsOptionEnabled("Unending Resolve") and Player:CanCast(UnendingResolve) and Player:HealthPercentage() <= module.GetOptionValue("Unending Resolve") then
            Player:Cast(UnendingResolve);
            return;
        end
        -- Drain Life
        if module.IsOptionEnabled("Drain Life") and not Player:IsMoving() and not DrainFiller then
            DrainSpell = DrainSoul:Exists() and DrainSoul or DrainLife:Exists() and DrainLife;
            if Player:Channeling(DrainSpell) and Player:HealthPercentage() > module.GetOptionValue("Drain Life") + 15 then
                module.Bug("Stop Chanelling Drain Life as Health threshold was reach.")
                SpellStopCasting();
            end
            if Player:Channeling(DrainSpell) then
                return;
            end
            if Player:HealthPercentage() < module.GetOptionValue("Drain Life") and Target:CanCast(DrainSpell) then
                Target:Cast(DrainSpell);
                return;
            end
        end
    end

    local function PetsManager ()
        -- Grimoire of Sacrifice with random delay
        if module.IsOptionEnabled("Grimoire Of Sacrifice") and GrimoreOfSacrifice:Exists() and not Player:Buff(GrimoreOfSacrificeBuff) then
            if UnitExists("PlayerPet") and Player:CanCast(GrimoreOfSacrifice) then
                if SacrificeRandomDelay then
                    if SacrificeRandomDelay < module.GetTime() then
                        Player:Cast(GrimoreOfSacrifice);
                        module.PetTimer = module.GetTime() + 4;
                        SacrificeRandomDelay = nil;
                        return;
                    end
                else
                    SacrificeRandomDelay = module.GetTime() + math.random(2, 6);
                end
            end
        end
        if not (GrimoreOfSacrifice:Exists() and Player:Buff(GrimoreOfSacrificeBuff)) then
            -- Resurrect Pet
            if not Player:IsMoving() and module.IsOptionEnabled("Demon Manager") and (not PlayerPet:Exists() or PlayerPet:IsDeadOrGhost()) and Player:SoulShards() >= 1 then
                local SelectedPet = module.GetOptionValue("Demon Manager");
                local SelectedPetSpell = SelectedPet == "Doomguard" and GrimoreOfSupremacy:Exists() and SummonDoomguard or SelectedPet == "Felhunter" and SummonFelhunter:Exists() and SummonFelhunter or SelectedPet == "Infernal" and GrimoreOfService:Exists() and SummonInfernal or SelectedPet == "Succubus" and SummonSuccubus:Exists() and SummonSuccubus or SelectedPet == "Voidwalker" and SummonVoidwalker:Exists() and SummonVoidwalker or SummonImp;
                if module.GetTime() - PetTimer >= 1 and Player:CanCast(SelectedPetSpell) then
                    Player:Cast(SelectedPetSpell);
                    PetTimer = module.GetTime() + 2.5;
                end
            end
            -- Health Funnel
            if module.IsOptionEnabled("Health Funnel") and PlayerPet:Exists() and not PlayerPet:IsDeadOrGhost() and Player:Standing() > 0.25 and PlayerPet:HealthPercentage() < module.GetOptionValue("Health Funnel") and Player:CanCast(HealthFunnel) then
                Player:Cast(HealthFunnel);
                return;
            end
        end
    end

    local function ServicePet ()
        local SelectedGrimoire = module.GetSecondOptionValue("Grimoire Of Service");
        local SelectedGrimoireSpell = SelectedGrimoire == "Felhunter" and GrimoreOfFelHunter or SelectedGrimoire == "Imp" and GrimoreOfImp or SelectedGrimoire == "Succubus" and GrimoreOfSuccubus or SelectedGrimoire == "Voidwalker" and GrimoreOfVoid;
        if Target:CanCast(SelectedGrimoireSpell) then
            Target:Cast(SelectedGrimoireSpell);
            return;
        end
    end

    function Rotation:Combat ()
        -- Combat Res Tanks
        MainTank = Unit.MainTank();
        OffTank = Unit.OffTank();
        if MainTank and MainTank:Exists() and not MainTank:IsDeadOrGhost() then MainTankResDelay = nil; end
        if OffTank and OffTank:Exists() and not OffTank:IsDeadOrGhost() then OffTankResDelay = nil; end
        if module.IsOptionEnabled("Instant Soulstone Tank") then
            if MainTank and MainTank:Exists() and MainTank:IsDeadOrGhost() and MainTank:IsPlayer() and MainTank:CanCast(Soulstone) then
                if not MainTankResDelay then MainTankResDelay = module.GetTime(); end
                if module.GetTime()-MainTankResDelay >= module.GetOptionValue("Instant Soulstone Tank") then
                    MainTankResDelay = nil;
                    MainTank:Cast(Soulstone);
                    return;
                end
            elseif OffTank and OffTank:Exists() and OffTank:IsDeadOrGhost() and OffTank:IsPlayer() and OffTank:CanCast(Soulstone) then
                if not OffTankResDelay then OffTankResDelay = module.GetTime(); end
                if module.GetTime()-OffTankResDelay >= module.GetOptionValue("Instant Soulstone Tank") then
                    OffTankResDelay = nil;
                    OffTank:Cast(Soulstone);
                    return;
                end
            end
        end
        if module.IsOptionEnabled("Soulstone") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and Target:IsPlayer() and Target:CanCast(Soulstone) then
            Target:Cast(Soulstone);
            return;
        end

        PetsManager();

        if Target:Exists() and Player:CanAttack(Target) then
            if module.IsOptionEnabled("Soul Effigy") then
                -- Keep tracking of previous target for the Soul Effigy
                if Target:GUID() ~= CurrentTarget then
                    PreviousTarget = CurrentTarget;
                    CurrentTarget = Target:GUID();
                end
                -- When we target the Soul Effigy, we focus it then we swap back to target
                if Target:CreatureID() == 103679 then
                    RunMacroText("/focus");
                    for i = 1, #module.EnemyUnits do
                        local ThisEnemy = module.EnemyUnits[i];
                        if ThisEnemy.UnitID == PreviousTarget then
                            ThisFocusUnit = ThisEnemy;
                            break;
                        end
                    end
                    ThisFocusUnit:Attack();
                end
            end
            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                Enemies_40y = Player:EnemiesWithinDistance(40);
                TargetEnemies_10y = Target:EnemiesWithinDistance(10, true);
                NumEnemies = #TargetEnemies_10y;
                AgonyUnit = Unit.DotCycle(Enemies_40y, Agony, Agony, 18, "Multi-Dot Agony");
                CorruptionUnit = Unit.DotCycle(Enemies_40y, Corruption, CorruptionDebuff, 18, "Multi-Dot Corruption", false, AbsoluteCorruption:Exists());
                SiphonLifeUnit = Unit.DotCycle(Enemies_40y, SiphonLife, SiphonLife, 15, "Multi-Dot Siphon Life");
                UnstableAfflictionUnit = Unit.DotCycle(Enemies_40y, UnstableAffliction, UnstableAffliction, 8, "Multi-Dot UA");
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, Corruption) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Grimoire Of Service
                if GrimoreOfService:Exists() and module.IsOptionEnabled("Grimoire Of Service") and (module.CooldownsAllowed() or module.GetOptionValue("Grimoire Of Service") == "Always") and Target:CanCast(GrimoreOfImp) then
                    ServicePet();
                end
                -- Doomguard
                if not GrimoreOfSupremacy:Exists() and GuardianDoomguard:Exists() and module.IsOptionEnabled("Doomguard") and (module.CooldownsAllowed() or module.GetOptionValue("Doomguard") == "Always") and Target:CanCast(GuardianDoomguard) then
                    Target:Cast(GuardianDoomguard);
                    return;
                end
                -- Infernal
                if not GrimoreOfSupremacy:Exists() and GuardianInfernal:Exists() and module.IsOptionEnabled("Infernal") and (module.CooldownsAllowed() or module.GetOptionValue("Infernal") == "Always") and Target:CanCast(GuardianInfernal) then
                    Target:Cast(GuardianInfernal);
                    return;
                end
                -- Mana Tap
                if ManaTap:Exists() and module.IsOptionEnabled("Mana Tap") and (module.CooldownsAllowed() or module.GetOptionValue("Mana Tap") == "Always") and Player:BuffRemains(ManaTap) < 3 and Player:CanCast(ManaTap) then
                    Player:Cast(ManaTap);
                    return;
                end
            end
            -- Rotation
            -- Reap Souls
            if ReapSouls:Exists() and Player:BuffCount(TormentedSouls) >= 3 and Player:BuffRemains(DeadwindHarvester) < 2 and Player:CanCast(ReapSouls) then
                Player:Cast(ReapSouls);
                return;
            end
            if module.UseAOE() and NumEnemies >= module.GetOptionValue("SoC AoE") then
                -- Unstable Affliction - Target
                if not SowTheSeeds:Exists() and UnstableAffliction:Exists() and Target:DebuffRemains(UnstableAffliction) < 3 and Target:CanCast(UnstableAffliction) then
                    Target:Cast(UnstableAffliction);
                    return;
                end
                -- Agony - Target
                if Agony:Exists() and Target:DebuffRemains(Agony) < 3 and Target:CanCast(Agony) then
                    Target:Cast(Agony);
                    return;
                end
                -- Haunt
                if Haunt:Exists() and Target:CanCast(Haunt) then
                    Target:Cast(Haunt);
                    return;
                end
                -- Agony
                if Agony:Exists() and module.IsOptionEnabled("Multi-Dot Agony") and AgonyUnit and AgonyUnit:DebuffRemains(Agony) < 4 then
                    AgonyUnit:Cast(Agony);
                    return;
                end
                -- Life Tap
                if LifeTap:Exists() and Player:PowerPercentage() <= 40 and Player:HealthPercentage() >= 60 and Player:CanCast(LifeTap) then
                    Player:Cast(LifeTap);
                    return;
                end
                if Player:IsWithinCastRange(Target, Corruption) then
                    -- Soul Harvest
                    if SoulHarvest:Exists() and module.IsOptionEnabled("Soul Harvest") and (module.CooldownsAllowed() or module.GetOptionValue("Soul Harvest") == "Always") and Player:CanCast(SoulHarvest) then
                        Player:Cast(SoulHarvest);
                        return;
                    end
                    -- Phantom Singularity
                    if PhantomSingularity:Exists() and module.IsOptionEnabled("Phantom Singularity") and (module.CooldownsAllowed() or module.GetOptionValue("Phantom Singularity") == "Always") and Target:CanCast(PhantomSingularity) then
                        Target:Cast(PhantomSingularity);
                        return;
                    end
                end
                -- Seed of Corruption - Target
                if SeedOfCorruption:Exists() and Target:CanCast(SeedOfCorruption) then
                    Target:Cast(SeedOfCorruption);
                    return;
                end
                return;
            end
            -- Agony - Target
            if Agony:Exists() and Target:DebuffRemains(Agony) < 3 and Target:CanCast(Agony) then
                Target:Cast(Agony);
                return;
            end
            -- Haunt
            if Haunt:Exists() and Target:CanCast(Haunt) then
                Target:Cast(Haunt);
                return;
            end
            -- Soul Effigy
            if SoulEffigy:Exists() and (not Focus:Exists() or not Target:Debuff(SoulEffigy) or not Player:IsWithinCastRange(Focus, Corruption)) and module.IsOptionEnabled("Soul Effigy") and SoulEffigy:TimeSinceCast() > 5 and Target:Health() >= module.GetSecondOptionValue("Soul Effigy")*1000000 and Target:CanCast(SoulEffigy) then
                SoulEffigy.LastCastTime = module.GetTime();
                Target:Cast(SoulEffigy);
                return;
            end
            -- Agony - Focus
            if Agony:Exists() and module.IsOptionEnabled("Soul Effigy") and Focus:Exists() and Focus:DebuffRemains(Agony) < 3 and Focus:CanCast(Agony) then
                Focus:Cast(Agony);
                return;
            end
            -- Agony
            if Agony:Exists() and module.IsOptionEnabled("Multi-Dot Agony") and AgonyUnit and AgonyUnit:DebuffRemains(Agony) < 4 then
                AgonyUnit:Cast(Agony);
                return;
            end
            if Player:IsWithinCastRange(Target, Corruption) then
                -- Soul Harvest
                if SoulHarvest:Exists() and module.IsOptionEnabled("Soul Harvest") and (module.CooldownsAllowed() or module.GetOptionValue("Soul Harvest") == "Always") and Player:CanCast(SoulHarvest) then
                    Player:Cast(SoulHarvest);
                    return;
                end
                -- Phantom Singularity
                if PhantomSingularity:Exists() and module.IsOptionEnabled("Phantom Singularity") and (module.CooldownsAllowed() or module.GetOptionValue("Phantom Singularity") == "Always") and Target:CanCast(PhantomSingularity) then
                    Target:Cast(PhantomSingularity);
                    return;
                end
            end
            -- Unstable Affliction - Target
            if UnstableAffliction:Exists() and Target:DebuffRemains(UnstableAffliction) < 3 and Target:CanCast(UnstableAffliction) then
                Target:Cast(UnstableAffliction);
                return;
            end
            -- Life Tap
            if LifeTap:Exists() and Player:PowerPercentage() <= 40 and Player:HealthPercentage() >= 60 and Player:CanCast(LifeTap) then
                Player:Cast(LifeTap);
                return;
            end
            -- Corruption - Target
            if Corruption:Exists() and ((AbsoluteCorruption:Exists() and not Target:Debuff(CorruptionDebuff)) or (not AbsoluteCorruption:Exists() and Target:DebuffRemains(CorruptionDebuff) < 3)) and Target:CanCast(Corruption) then
                Target:Cast(Corruption);
                return;
            end
            -- Unstable Affliction - Focus
            if UnstableAffliction:Exists() and Focus:Exists() and module.IsOptionEnabled("Soul Effigy") and module.GetOptionValue("Soul Effigy") == "Auto" and Player:SoulShards() >= 4 and Focus:DebuffRemains(UnstableAffliction) < 3 and Focus:CanCast(UnstableAffliction) then
                Focus:Cast(UnstableAffliction);
                return;
            end
            -- Corruption - Focus
            if Corruption:Exists() and module.IsOptionEnabled("Soul Effigy") and Focus:Exists() and ((AbsoluteCorruption:Exists() and not Focus:Debuff(CorruptionDebuff)) or (not AbsoluteCorruption:Exists() and Focus:DebuffRemains(CorruptionDebuff) < 3)) and Focus:CanCast(Corruption) then
                Focus:Cast(Corruption);
                return;
            end
            -- Unstable Affliction - Cycle
            if UnstableAffliction:Exists() and module.IsOptionEnabled("Multi-Dot UA") and Player:SoulShards() >= 4 and UnstableAfflictionUnit and UnstableAfflictionUnit:DebuffRemains(UnstableAffliction) < 8*0.3 and UnstableAfflictionUnit:CanCast(UnstableAffliction) then
                UnstableAfflictionUnit:Cast(UnstableAffliction);
                return;
            end
            -- Corruption - Cycle
            if Corruption:Exists() and module.IsOptionEnabled("Multi-Dot Corruption") and CorruptionUnit and CorruptionUnit:DebuffRemains(Corruption) < 14*0.3 and CorruptionUnit:CanCast(Corruption) then
                CorruptionUnit:Cast(Corruption);
                return;
            end
            -- Life Tap
            if LifeTap:Exists() and Player:PowerPercentage() <= 65 and Player:HealthPercentage() >= 60 and Player:CanCast(LifeTap) then
                Player:Cast(LifeTap);
                return;
            end
            -- Siphon Life - Target
            if SiphonLife:Exists() and Target:DebuffRemains(SiphonLife) < 3 and Target:CanCast(SiphonLife) then
                Target:Cast(SiphonLife);
                return;
            end
            -- Siphon Life - Focus
            if SiphonLife:Exists() and module.IsOptionEnabled("Soul Effigy") and Focus:Exists() and Focus:DebuffRemains(SiphonLife) < 3 and Focus:CanCast(SiphonLife) then
                Focus:Cast(SiphonLife);
                return;
            end
            -- Siphon Life - Cycle
            if SiphonLife:Exists() and module.IsOptionEnabled("Multi-Dot Siphon Life") and SiphonLifeUnit and SiphonLifeUnit:DebuffRemains(SiphonLife) < 15*0.3 and SiphonLifeUnit:CanCast(SiphonLife) then
                SiphonLifeUnit:Cast(SiphonLife);
                return;
            end
            -- Drain Life
            DrainSpell = DrainSoul:Exists() and DrainSoul or DrainLife:Exists() and DrainLife;
            if Player:Channeling(DrainSpell) then
                return;
            end
            if not Player:IsMoving() and Target:CanCast(DrainSpell) then
                DrainFiller = true;
                Target:Cast(DrainSpell);
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        PetsManager();
        -- Create Healthstones
        if module.IsOptionEnabled("Create Healthstones") and Player:Standing() > 0.25 then
            if not Healthstone:InStock() and CreateHealthstone:TimeSinceCast() >= module.GetTime() + 5 and Player:CanCast(CreateHealthstone) then
                Player:Cast(CreateHealthstone);
                CreateHealthstone.LastCastTime = module.GetTime();
                return;
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Demonology Warlock
    local Rotation = {};
    module.SetRotation(266, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local MainTank, OffTank, MainTankResDelay, OffTankResDelay = nil, nil, nil, nil; -- Battle Resurection timers
    local Enemies = {};
    -- Pet Manager
    local PetTimer = 0;
    local DemonicEmpowermentSwitch, InstantShadowboltSwitch;

    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicIntellect = Item(109218, false, false, true);
        DraenicIntellectBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, resurrect)
        CallDreadstalkers = Spell(104316, false, true, false);
        ChaosWave = Spell(129346, false, true, true);
        CreateHealthstone = Spell(6201, false, false, false);
        DarkPact = Spell(108416, false, false, true);
        Demonwrath = Spell(193440, false, false, true);
        DrainLife = Spell(689, false, true, false);
        Demonbolt = Spell(157695, false, true, false);
        DemonboltInstant = Spell(157695, false, true, true);
        DemonicCalling = Spell(205146);
        DemonicEmpowerment = Spell(193396, false, false, false);
        Doom = Spell(603, false, true, true);
        Felstorm = Spell(89751, false, true, true);
        GuardianDoomguard = Spell(18540, false, true, true);
        GuardianInfernal = Spell(157898, false, true, true);
        GrimoreOfService = Spell(108501, false, false, true);
        GrimoreOfSupremacy = Spell(152107, false, true, true);
        GrimoreOfSynergy = Spell(171975, false, true, true);
        GrimoreOfImp = Spell(111859, false, true, true);
        GrimoreOfVoid = Spell(111895, false, true, true);
        GrimoreOfSuccubus = Spell(111896, false, true, true);
        GrimoreOfFelHunter = Spell(111897, false, true, true);
        GrimoreOfFelguard = Spell(111898, false, true, true);
        HandOfGuldan = Spell(105174, false, true, false);
        HealthFunnel = Spell(755, false, false, false);
        Implosion = Spell(196277, false, true, true);
        LifeTap = Spell(1454, false, false, true);
        MortalCoil = Spell(6789, false, true, true);
        ShadowBolt = Spell(686, true, true, false);
        ShadowBoltInstant = Spell(686, true, true, true);
        Shadowflame = Spell(205181, false, true, true);
        ShadowLock = Spell(171138, false, true, true);
        ShadowyInspiration = Spell(196606);
        SoulHarvest = Spell(196098, false, false, true);
        Soulstone = Spell(20707, false, false, false, true);
        SpellLock = Spell(19647, false, true, true);
        SummonDarkGlare = Spell(205180, false, false, true);
        SummonDoomguard = Spell(157757, false, false, false);
        SummonFelguard = Spell(30146, false, false, false);
        SummonFelhunter = Spell(691, false, false, false);
        SummonImp = Spell(688, false, false, false);
        SummonInfernal = Spell(157898, false, false, false);
        SummonSuccubus = Spell(712, false, false, false);
        SummonVoidwalker = Spell(697, false, false, false);
        ThalkielsConsumption = Spell(211714, false, true, true);
        UnendingBreath = Spell(5697, false, false, true);
        UnendingResolve = Spell(104773, false, false, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddPresetOption("TargetAttack");
        module.AddPresetOption("BossCD");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Shadow Lock/Spell Lock to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddSection("General Settings", "Demons Management", "Green");
        module.AddNewOption("General Settings", "Demon Manager", 230, true, {2, "Doomguard", "Felguard", "Felhunter", "Imp", "Infernal", "Succubus", "Voidwalker"}, nil, "Enable pet management."..C.TOOLTIP_VALUE.."Choose demon to use.")
        module.AddNewOption("General Settings", "Health Funnel", 220, true, {35, 1, 100, 5}, nil, "Use Health Funnel to heal our demon."..C.TOOLTIP_VALUE.."Health threshold.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Dark Glare", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Dark Glare."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Doomguard", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Doomguard."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Grimoire Of Service", 233, true, {1, "Always", "Cooldown Only"}, {2, "Felguard", "Felhunter", "Imp", "Succubus", "Voidwalker"}, "Enable Grimoire of Service."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Choose demon to use.")
        module.AddNewOption("Offensive Settings", "Infernal", 230, false, {2, "Always", "Cooldown Only"}, nil, "Use Infernal."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Soul Harvest", 232, true, {1, "Always", "Cooldown Only"}, {1, 0, 3, 1}, "Use Soul Harvest."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Only use when we have this amount of Soul Shards or less.");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.AddPresetOption("Trinket");
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Call Dreadstalkers", 210, true, nil, nil, "Use Call Dreadstalkers.");
        module.AddNewOption("Offensive Settings", "Demonwrath", 232, true, {1, "Always", "While Moving"}, {6, 1, 12, 1}, "Use Demonwrath."..C.TOOLTIP_VALUE.."Amount of demons needed to use.");
        module.AddNewOption("Offensive Settings", "Felstorm", 232, true, {1, "Always", "Cooldown Only"}, {1, 1, 5, 1}, "Use Felstorm."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be in range to use.");
        module.AddNewOption("Offensive Settings", "Hand Of Gul'dan", 220, true, {3, 1, 4, 1}, nil, "Use Hand Of Gul'dan."..C.TOOLTIP_VALUE.."How many Soul Shard we want to have before using.");
        module.AddNewOption("Offensive Settings", "Implosion", 222, true, {3, 1, 10, 1}, {8, 1, 10, 1}, "Use Implosion."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be in range of the target to use before Imps disappear."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be in range of the target to use anytime as soon as there are imps.");
        module.AddNewOption("Offensive Settings", "Thal'kiel's Consumption", 220, true, {6, 1, 12, 1}, nil, "Use Thal'kiel's Consumption."..C.TOOLTIP_VALUE.."Amount of demons needed to use.");
        module.AddSection("Offensive Settings", "Multi-Dots", "Green");
        module.AddNewOption("Offensive Settings", "Doom", 222, false, { 6, 1, 10, 1 }, { 5, 0, 25, 0.1 }, "Multi-Dot Doom Cycle. \n\n|cFF0088FFValue 1:|r Number of dots to apply. \n\n|cFF0088FFValue 2:|r Minimum health (in million) to apply.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Create Healthstones", 210, true, nil, nil, "Will create you a new healthstone if you have none in your bags and are out of combat.");
        module.AddPresetOption("HealingItem");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Dark Pact", 220, true, {40, 1, 100, 1}, nil, "Use Dark Bargain."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Drain Life", 220, true, {20, 1, 75, 1}, nil, "Use Drain Life."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Mortal Coil", 220, true, {50, 1, 100, 1}, nil, "Use Mortal Coil."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Unending Resolve", 220, true, {40, 1, 100, 1}, nil, "Use Dark Unending Resolve."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        module.AddOutput("Dreadstalkers / Imps:");
        module.SetOutput("Dreadstalkers / Imps:", "0 / 0");
        function Player:DemonsCount()
            return module.TotalDreadStalkers + module.TotalImps;
        end
        function Player:ImpsCount()
            return module.TotalImps;
        end

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [CallDreadstalkers:ID()] = "Call Dreadstalkers",
            [Demonbolt:ID()] = "Demonbolt",
            [DemonicEmpowerment:ID()] = "Demonic Empowerment",
            [HandOfGuldan:ID()] = "Hand of Gul'dan",
            [ShadowBolt:ID()] = "Shadow Bolt"
        };
    end
    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end
        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        local OpenerSpell = not GrimoreOfSupremacy:Exists() and module.IsOptionEnabled("Doomguard") and GuardianDoomguard:Cooldown() == 0 and GuardianDoomguard or Demonbolt:Exists() and Demonbolt or ShadowBolt;
        -- 2) Potion
        if module.IsOptionEnabled("Pre-Pull BossMod") and not Potion and module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and Player:IsWithinCastRange(Target, ShadowBolt) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + OpenerSpell:TravelTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) then
            if Player:Potion("Intellect", Potion) then Potion = true; end
        end
        -- 3) Doomguard/Shadowbolt/Demonbolt
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + OpenerSpell:TravelTime() and Target:CanCast(OpenerSpell) then
            Target:Cast(OpenerSpell);
            return;
        end
        -- 1) Demonic Empowerment
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + OpenerSpell:TravelTime() + DemonicEmpowerment:CastTime() and Player:CanCast(DemonicEmpowerment) then
            Player:Cast(DemonicEmpowerment);
            return;
        end
    end

    function Rotation:Interrupts ()
        local PetInterrupt = (SpellLock:PetKnown() and SpellLock) or (ShadowLock:PetKnown() and ShadowLock) or nil;
        if PetInterrupt then
            Player:UseInterrupt(PetInterrupt, ArcaneTorrent, true);
        end
    end

    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(HandOfGuldan, true) or Unit.Target;
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Mortal Coil
        if MortalCoil:Exists() and module.IsOptionEnabled("Mortal Coil") and Target:Exists() and Target:CanCast(MortalCoil) and Player:HealthPercentage() <= module.GetOptionValue("Mortal Coil") then
            Target:Cast(MortalCoil);
        end
        -- Dark Pact
        if DarkPact:Exists() and module.IsOptionEnabled("Dark Pact") and Player:CanCast(DarkPact) and Player:HealthPercentage() <= module.GetOptionValue("Dark Pact") then
            Player:Cast(DarkPact);
            return;
        end
        -- Unending Resolve
        if UnendingResolve:Exists() and module.IsOptionEnabled("Unending Resolve") and Player:CanCast(UnendingResolve) and Player:HealthPercentage() <= module.GetOptionValue("Unending Resolve") then
            Player:Cast(UnendingResolve);
            return;
        end
        -- Drain Life
        if DrainLife:Exists() and module.IsOptionEnabled("Drain Life") then
            if Player:HealthPercentage() < module.GetOptionValue("Drain Life") and Target:CanCast(DrainLife) then
                Target:Cast(DrainLife);
                return;
            end
            if Player:Channeling(DrainLife) and Player:HealthPercentage() > module.GetOptionValue("Drain Life") + 15 then
                module.Bug("Stop Chanelling Drain Life as Health threshold was reach.")
                SpellStopCasting();
            end
            if Player:Channeling(DrainLife) then
                return;
            end
        end
    end

    local function PetsManager ()
        -- Resurrect Pet
        if not Player:IsMoving() and module.IsOptionEnabled("Demon Manager") and (not PlayerPet:Exists() or PlayerPet:IsDeadOrGhost()) and Player:SoulShards() >= 1 then
            local SelectedPet = module.GetOptionValue("Demon Manager");
            local SelectedPetSpell = SelectedPet == "Doomguard" and GrimoreOfSupremacy:Exists() and SummonDoomguard or SelectedPet == "Felhunter" and SummonFelhunter:Exists() and SummonFelhunter or SelectedPet == "Imp" and SummonImp:Exists() and SummonImp or SelectedPet == "Infernal" and GrimoreOfService:Exists() and SummonInfernal or SelectedPet == "Succubus" and SummonSuccubus:Exists() and SummonSuccubus or SelectedPet == "Voidwalker" and SummonVoidwalker:Exists() and SummonVoidwalker or SummonFelguard;
            if module.GetTime() - PetTimer >= 1 and Player:CanCast(SelectedPetSpell) then
                Player:Cast(SelectedPetSpell);
                PetTimer = module.GetTime() + 2.5;
            end
        end
        -- Health Funnel
        if module.IsOptionEnabled("Health Funnel") and PlayerPet:Exists() and not PlayerPet:IsDeadOrGhost() and Player:Standing() > 0.25 and PlayerPet:HealthPercentage() < module.GetOptionValue("Health Funnel") and Player:CanCast(HealthFunnel) then
            Player:Cast(HealthFunnel);
            return;
        end
    end

    local function ServicePet ()
        local SelectedGrimoire = module.GetSecondOptionValue("Grimoire Of Service");
        local SelectedGrimoireSpell = SelectedGrimoire == "Felguard" and GrimoreOfFelguard or SelectedGrimoire == "Felhunter" and GrimoreOfFelHunter or SelectedGrimoire == "Imp" and GrimoreOfImp or SelectedGrimoire == "Succubus" and GrimoreOfSuccubus or SelectedGrimoire == "Voidwalker" and GrimoreOfVoid;
        if Target:CanCast(SelectedGrimoireSpell) then
            Target:Cast(SelectedGrimoireSpell);
            return;
        end
    end

    function Rotation:Combat ()
        -- Combat Res Tanks
        MainTank = Unit.MainTank();
        OffTank = Unit.OffTank();
        if MainTank and MainTank:Exists() and not MainTank:IsDeadOrGhost() then MainTankResDelay = nil; end
        if OffTank and OffTank:Exists() and not OffTank:IsDeadOrGhost() then OffTankResDelay = nil; end
        if module.IsOptionEnabled("Instant Soulstone Tank") then
            if MainTank and MainTank:Exists() and MainTank:IsDeadOrGhost() and MainTank:IsPlayer() and MainTank:CanCast(Soulstone) then
                if not MainTankResDelay then MainTankResDelay = module.GetTime(); end
                if module.GetTime()-MainTankResDelay >= module.GetOptionValue("Instant Soulstone Tank") then
                    MainTankResDelay = nil;
                    MainTank:Cast(Soulstone);
                    return;
                end
            elseif OffTank and OffTank:Exists() and OffTank:IsDeadOrGhost() and OffTank:IsPlayer() and OffTank:CanCast(Soulstone) then
                if not OffTankResDelay then OffTankResDelay = module.GetTime(); end
                if module.GetTime()-OffTankResDelay >= module.GetOptionValue("Instant Soulstone Tank") then
                    OffTankResDelay = nil;
                    OffTank:Cast(Soulstone);
                    return;
                end
            end
        end
        if module.IsOptionEnabled("Soulstone") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and Target:IsPlayer() and Target:CanCast(Soulstone) then
            Target:Cast(Soulstone);
            return;
        end

        PetsManager();

        if Target:Exists() and Player:CanAttack(Target) then

            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                Enemies_40y = Player:EnemiesWithinDistance(40);
                Enemies_8y = Target:EnemiesWithinDistance(8, true);
                FelstormEnemies = module.IsOptionEnabled("Felstorm") and #PlayerPet:EnemiesWithinDistance(8, true) or 0;
                NumEnemies = #Enemies_8y;
                DoomUnit = Unit.DotCycle(Enemies_40y, Doom, Doom, 0, "Doom");
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- Shadowflame - Clip
            if Shadowflame:Exists() and Target:Debuff(Shadowflame) and (Target:DebuffRemains(Shadowflame) < 2.5 or Target:DebuffCount(Shadowflame) >= 2) and Target:CanCast(Shadowflame) then
                Target:Cast(Shadowflame);
                return;
            end

            if Player:Channeling(Demonwrath) then
                return;
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, HandOfGuldan) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Felstorm/Wrathstorm is in the Short Cooldowns Category and react with the "Felstorm/Wrathstorm" option.
                if PlayerPet:Exists() and module.IsOptionEnabled("Felstorm") and (module.CooldownsAllowed() or module.GetOptionValue("Felstorm") == "Always") and FelstormEnemies >= module.GetSecondOptionValue("Felstorm") and Target:PetCanCast(Felstorm) then
                    Target:Cast(Felstorm);
                end
                -- Grimoire Of Service
                if GrimoreOfService:Exists() and module.IsOptionEnabled("Grimoire Of Service") and (module.CooldownsAllowed() or module.GetOptionValue("Grimoire Of Service") == "Always") and Target:CanCast(GrimoreOfImp) then
                    ServicePet();
                end
                -- Dark Glare
                if SummonDarkGlare:Exists() and Player:DemonsCount() >= 4 and module.IsOptionEnabled("Dark Glare") and (module.CooldownsAllowed() or module.GetOptionValue("Dark Glare") == "Always") and Player:CanCast(SummonDarkGlare) then
                    Player:Cast(SummonDarkGlare);
                    return;
                end
                -- Doomguard
                if not GrimoreOfSupremacy:Exists() and GuardianDoomguard:Exists() and module.IsOptionEnabled("Doomguard") and (module.CooldownsAllowed() or module.GetOptionValue("Doomguard") == "Always") and Target:CanCast(GuardianDoomguard) then
                    Target:Cast(GuardianDoomguard);
                    return;
                end
                -- Infernal
                if not GrimoreOfSupremacy:Exists() and GuardianInfernal:Exists() and module.IsOptionEnabled("Infernal") and (module.CooldownsAllowed() or module.GetOptionValue("Infernal") == "Always") and Target:CanCast(GuardianInfernal) then
                    Target:Cast(GuardianInfernal);
                    return;
                end
                -- Soul Harvest
                if SoulHarvest:Exists() and module.IsOptionEnabled("Soul Harvest") and (module.CooldownsAllowed() or module.GetOptionValue("Soul Harvest") == "Always") and Player:SoulShards() <= module.GetSecondOptionValue("Soul Harvest") and Player:CanCast(SoulHarvest) then
                    Player:Cast(SoulHarvest);
                    return;
                end
            end
            -- Rotation
            -- Implosion
            if Implosion:Exists() and module.IsOptionEnabled("Implosion") and ImplosionReady and ((#Enemies_8y >= module.GetOptionValue("Implosion") and ImplosionReady < module.GetTime()) or #Enemies_8y >= module.GetSecondOptionValue("Implosion")) and Target:CanCast(Implosion) then
                Target:Cast(Implosion);
                ImplosionReady = nil;
                return;
            end
            -- Call Dreadstalkers
            if CallDreadstalkers:Exists() and module.IsOptionEnabled("Call Dreadstalkers") and (Player:SoulShards() >= 2 or Player:Buff(DemonicCalling)) and Target:CanCast(CallDreadstalkers) then
                Target:Cast(CallDreadstalkers);
                CallDreadstalkers.LastCastTime = module.GetTime();
                return;
            end
            --Hand Of Gul'Dan
            if HandOfGuldan:Exists() and not InstantShadowboltSwitch and module.IsOptionEnabled("Hand Of Gul'dan") and Player:SoulShards() >= module.GetOptionValue("Hand Of Gul'dan") and HandOfGuldan:TimeSinceCast() > 1 and Target:CanCast(HandOfGuldan) then
                Target:Cast(HandOfGuldan);
                DemonicEmpowermentSwitch = true;
                HandOfGuldan.LastCastTime = module.GetTime();
                return;
            end
            -- Demonic Empowerment
            if DemonicEmpowerment:Exists() and (Player:DemonsCount() >= 3 or DemonicEmpowermentSwitch) and (not SummonDarkGlare:Exists() or SummonDarkGlare:Cooldown() > 8) and (PlayerPet:BuffRemains(DemonicEmpowerment) < 3 or DemonicEmpowermentSwitch) and Player:CanCast(DemonicEmpowerment) then
                Player:Cast(DemonicEmpowerment);
                DemonicEmpowermentSwitch = false;
                InstantShadowboltSwitch = true;
                DemonicEmpowerment.LastCastTime = module.GetTime();
                return;
            end
            -- Thalkiels Consumption
            if ThalkielsConsumption:Exists() and module.IsOptionEnabled("Thal'kiel's Consumption") and Player:DemonsCount() >= module.GetOptionValue("Thal'kiel's Consumption") and Target:CanCast(ThalkielsConsumption, true) then
                Target:Cast(ThalkielsConsumption);
                return;
            end
            -- Shadowflame - Apply
            if Shadowflame:Exists() and (Shadowflame:Charges() == 2 or (Shadowflame:Charges() == 1 and Shadowflame:Recharge() < 1)) and Target:CanCast(Shadowflame) then
                Target:Cast(Shadowflame);
                return;
            end
            -- Doom
            if module.IsOptionEnabled("Doom") then
                if not Target:Debuff(Doom) and Target:CanCast(Doom) and Target:Health() >= module.GetSecondOptionValue("Doom")*1000000 then
                    module.Bug("Doom - Target");
                    Target:Cast(Doom);
                    return;
                end
                if DoomUnit then
                    module.Bug("Doom on " .. DoomUnit:GUID());
                    DoomUnit:Cast(Doom);
                    return;
                end
            end
            -- Demonwrath
            if Demonwrath:Exists() and module.IsOptionEnabled("Demonwrath") and (Player:IsMoving() or module.GetOptionValue("Demonwrath") == "Always") and Player:DemonsCount() >= module.GetSecondOptionValue("Demonwrath") and Player:CanCast(Demonwrath, true) then
                Player:Cast(Demonwrath);
                return;
            end
            -- Life Tap
            if Player:PowerPercentage() <= 40 and Player:HealthPercentage() >= 60 and Player:CanCast(LifeTap) then
                Player:Cast(LifeTap);
                return;
            end
            -- Player Moving, Life Tap or Demonwrath
            if Player:IsMoving() then
                -- Shadowy Inspiration
                if Player:Buff(ShadowyInspiration) then
                    -- Demonbolt
                    if Demonbolt:Exists() and Target:CanCast(DemonboltInstant) then
                        Target:Cast(DemonboltInstant);
                        return;
                    end
                    -- Shadow Bolt
                    if Target:CanCast(ShadowBoltInstant) then
                        Target:Cast(ShadowBoltInstant);
                        return;
                    end
                end
                -- Life Tap
                if Player:PowerPercentage() < 70 and Player:HealthPercentage() >= 60 and Player:CanCast(LifeTap) then
                    Player:Cast(LifeTap);
                    return;
                end
                -- Demonwrath
                if Demonwrath:Exists() and module.IsOptionEnabled("Demonwrath") and Player:DemonsCount() >= 2 and Player:CanCast(Demonwrath, true) then
                    Player:Cast(Demonwrath);
                    return;
                end
            end
            -- Demonbolt
            if Demonbolt:Exists() and Target:CanCast(Demonbolt) then
                InstantShadowboltSwitch = false;
                Target:Cast(Demonbolt);
                return;
            end
            -- Shadow Bolt
            if Target:CanCast(ShadowBolt) then
                InstantShadowboltSwitch = false;
                Target:Cast(ShadowBolt);
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        PetsManager();
        -- Create Healthstones
        if module.IsOptionEnabled("Create Healthstones") and Player:Standing() > 0.25 then
            if not Healthstone:InStock() and CreateHealthstone:TimeSinceCast() >= module.GetTime() + 5 and Player:CanCast(CreateHealthstone) then
                Player:Cast(CreateHealthstone);
                CreateHealthstone.LastCastTime = module.GetTime();
                return;
            end
        end
    end
end)();






--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Destruction Warlock
    local Rotation = {};
    module.SetRotation(267, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local MainTank, OffTank, MainTankResDelay, OffTankResDelay = nil, nil, nil, nil; -- Battle Resurection timers
    local Enemies_40y, TargetEnemies_10y, NumEnemies, ImmolateUnit = {}, {}, 0, nil; -- Enemies Table
    -- Havoc Cycling
    local BestUnit, BestUnitHealth, ThisUnit, ThisUnitHealth;
    local HavocUnit, HavocTime = nil, 0;
    -- Pet Manager
    local PetTimer, SacrificeRandomDelay = 0, nil;


    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicIntellect = Item(109218, false, false, true);
        DraenicIntellectBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, resurrect)
        BackDraft = Spell(196406);
        BackDraftBuff = Spell(117828);
        Cataclysm = Spell(152108, false, true, true);
        ChaosBolt = Spell(116858, true, true, false);
        ChannelDemonfire = Spell(196447, true, true, false);
        Conflagrate = Spell(17962, true, true, true);
        CreateHealthstone = Spell(6201, false, false, false);
        DarkPact = Spell(108416, false, false, true);
        DimensionalRift = Spell(196586, false, true, true);
        DrainLife = Spell(689, true, true, false);
        Eradication = Spell(196412);
        EradicationDebuff = Spell(196414);
        GuardianDoomguard = Spell(18540, false, true, true);
        GuardianInfernal = Spell(1122, false, true, true);
        GrimoreOfSacrifice = Spell(108503, false, false, true);
        GrimoreOfSacrificeBuff = Spell(196099);
        GrimoreOfService = Spell(108501, false, false, true);
        GrimoreOfSupremacy = Spell(152107, false, true, true);
        GrimoreOfImp = Spell(111859, false, true, true);
        GrimoreOfVoid = Spell(111895, false, true, true);
        GrimoreOfSuccubus = Spell(111896, false, true, true);
        GrimoreOfFelHunter = Spell(111897, false, true, true);
        Havoc = Spell(80240, false, true, true);
        HealthFunnel = Spell(755, false, false, false);
        Immolate = Spell(348, true, true, true);
        ImmolateDebuff = Spell(157736);
        Incinerate = Spell(29722, true, true, true);
        LifeTap = Spell(1454, false, false, true);
        ManaTap = Spell(196104, false, false, true);
        MortalCoil = Spell(6789, false, true, true);
        RainOfFire = Spell(5740, false, true, false);
        RoaringBlaze = Spell(205184);
        Shadowburn = Spell(17877, true, true, true);
        ShadowLock = Spell(171138, true, true, true);
        SoulHarvest = Spell(196098, false, false, true);
        Soulstone = Spell(20707, false, false, false, true);
        SpellLock = Spell(19647, false, true, true);
        SummonDoomguard = Spell(157757, false, false, false);
        SummonFelhunter = Spell(691, false, false, false);
        SummonImp = Spell(688, false, false, false);
        SummonInfernal = Spell(157898, false, false, false);
        SummonSuccubus = Spell(712, false, false, false);
        SummonVoidwalker = Spell(697, false, false, false);
        UnendingBreath = Spell(5697, false, false, true);
        UnendingResolve = Spell(104773, false, false, true);
        WreakHavoc = Spell(196410);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddPresetOption("TargetAttack");
        module.AddPresetOption("BossCD");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Shadow Lock/Spell Lock to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddSection("General Settings", "Demons Management", "Green");
        module.AddNewOption("General Settings", "Demon Manager", 230, true, {3, "Doomguard", "Felhunter", "Imp", "Infernal", "Succubus", "Voidwalker"}, nil, "Enable pet management."..C.TOOLTIP_VALUE.."Choose demon to use.")
        module.AddNewOption("General Settings", "Health Funnel", 220, true, {25, 1, 100, 5}, nil, "Use Health Funnel to heal our demon."..C.TOOLTIP_VALUE.."Health threshold.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Dimensional Rift", 232, true, {2, "Always", "Cooldown Only"}, {2, 1, 3, 1}, "Use Dimensional Rift."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."How many charges should we keep to use with the Cooldowns."..C.TOOLTIP_HINT("Set it to Cooldowns Only with charges at 2 to always keep the third charge recharging."));
        module.AddNewOption("Offensive Settings", "Doomguard", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Doomguard."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Grimoire Of Service", 233, true, {1, "Always", "Cooldown Only"}, {2, "Felhunter", "Imp", "Succubus", "Voidwalker"}, "Enable Grimoire of Service."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Choose demon to use.")
        module.AddNewOption("Offensive Settings", "Grimoire Of Sacrifice", 210, true, nil, nil, "Automatic Grimoire Of Sacrifice usage.");
        module.AddNewOption("Offensive Settings", "Infernal", 230, false, {2, "Always", "Cooldown Only"}, nil, "Use Infernal."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Mana Tap", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Mana Tap."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Soul Harvest", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Soul Harvest."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.AddPresetOption("Trinket");
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Cataclysm", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {1, 1, 10, 1}, "Use Cataclysm." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Havoc", 232, true, {1, "Auto", "Focus"}, {3, 0, 25, 0.1}, "Use Havoc."..C.TOOLTIP_VALUE_1.."On which unit should we apply Havoc."..C.TOOLTIP_SUBVALUE("Auto", true).."Use on the unit with the most health."..C.TOOLTIP_SUBVALUE("Focus", true).."Use on the Focus unit or the unit with the most health."..C.TOOLTIP_SUBVALUE("Target", true).."Use on the Target."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Rain Of Fire", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {6, 1, 10, 1}, "Use Rain Of Fire." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Shadowburn Filler", 210, true, nil, nil, "Use Shadowburn as Low Priority while moving.");
        module.AddNewOption("Offensive Settings", "Shadowburn Sniping", 210, true, nil, nil, "Attempt to get Shadowburn on adds that will die in the next 5 seconds to get back Soul Shards.");
        module.AddSection("Offensive Settings", "Multi-Dots", "Green");
        module.AddNewOption("Offensive Settings", "Multi-Dot Immolate", 222, true, {6, 1, 10, 1}, {3, 0, 25, 0.1}, "Multi-Dot Immolate Cycle."..C.TOOLTIP_VALUE_1.."Amount of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Create Healthstones", 210, true, nil, nil, "Will create you a new healthstone if you have none in your bags and are out of combat.");
        module.AddPresetOption("HealingItem");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Dark Pact", 220, true, {40, 1, 100, 1}, nil, "Use Dark Bargain."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Drain Life", 220, true, {20, 1, 75, 1}, nil, "Use Drain Life."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Mortal Coil", 220, true, {50, 1, 100, 1}, nil, "Use Mortal Coil."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Unending Resolve", 220, true, {40, 1, 100, 1}, nil, "Use Dark Unending Resolve."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [ChaosBolt:ID()] = "Chaos Bolt",
            [Immolate:ID()] = "Immolate"
        };
    end
    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Channeling(ChannelDemonfire) then
            return;
        end

        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            if Player:Channeling(DrainLife) then
                return;
            end
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        local OpenerSpell = not GrimoreOfSupremacy:Exists() and module.IsOptionEnabled("Doomguard") and GuardianDoomguard:Cooldown() == 0 and GuardianDoomguard or Immolate;
        -- 2) Potion
        if module.IsOptionEnabled("Pre-Pull BossMod") and not Potion and module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and Player:IsWithinCastRange(Target, Immolate) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + OpenerSpell:TravelTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) then
            if Player:Potion("Intellect", Potion) then Potion = true; end
        end
        -- 3) Doomguard/Immolate
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + OpenerSpell:TravelTime() and Target:CanCast(OpenerSpell) then
            Target:Cast(OpenerSpell);
            return;
        end
    end

    function Rotation:Interrupts ()
        local PetInterrupt = (SpellLock:PetKnown() and SpellLock) or (ShadowLock:PetKnown() and ShadowLock) or nil;
        if PetInterrupt then
            Player:UseInterrupt(PetInterrupt, ArcaneTorrent, true);
        end
    end

    function Rotation:OffGCDAbilities ()
        -- Enemies Check
        if RefreshEnemies < module.GetTime() then
            Enemies_40y = Player:EnemiesWithinDistance(40);
        end

        -- Find Best Target
        if HavocUnit and HavocTime > module.GetTime() and HavocUnit:Exists() and HavocUnit:GUID() == Target:GUID() then
            BestUnit, BestUnitHealth, BestTarget = nil, 0, nil;
            for i = 1, #Enemies_40y do
                ThisUnit, ThisUnitHealth = Enemies_40y[i], Enemies_40y[i]:Health();
                if not ThisUnit:Debuff(Havoc) and ThisUnitHealth > BestUnitHealth and ThisUnit:CanCast(Incinerate) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit then
                BestTarget = BestUnit;
            end
        end
        -- Auto Target
        Target = Player:ReTarget(Immolate, true) or Unit.Target;
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Mortal Coil
        if MortalCoil:Exists() and module.IsOptionEnabled("Mortal Coil") and Target:Exists() and Target:CanCast(MortalCoil) and Player:HealthPercentage() <= module.GetOptionValue("Mortal Coil") then
            Target:Cast(MortalCoil);
        end
        -- Dark Pact
        if DarkPact:Exists() and module.IsOptionEnabled("Dark Pact") and Player:CanCast(DarkPact) and Player:HealthPercentage() <= module.GetOptionValue("Dark Pact") then
            Player:Cast(DarkPact);
            return;
        end
        -- Unending Resolve
        if UnendingResolve:Exists() and module.IsOptionEnabled("Unending Resolve") and Player:CanCast(UnendingResolve) and Player:HealthPercentage() <= module.GetOptionValue("Unending Resolve") then
            Player:Cast(UnendingResolve);
            return;
        end
        -- Drain Life
        if DrainLife:Exists() and module.IsOptionEnabled("Drain Life") then
            if Player:Channeling(DrainLife) and Player:HealthPercentage() > module.GetOptionValue("Drain Life") + 15 then
                module.Bug("Stop Chanelling Drain Life as Health threshold was reach.")
                SpellStopCasting();
            end
            if not Player:Channeling(DrainLife) and Player:HealthPercentage() < module.GetOptionValue("Drain Life") and Target:CanCast(DrainLife) then
                Target:Cast(DrainLife);
                return;
            end
        end
    end

    -- Havoc
    local function HavocHandler (HavocMode)
        if HavocMode ~= "Wreak Havoc" or WreakHavoc:Exists() then
            if Havoc:Exists() and module.IsOptionEnabled("Havoc") and #Enemies_40y >= 2 and not (HavocUnit and HavocTime > module.GetTime() and HavocUnit:Exists()) then
                HavocThreshold = module.GetSecondOptionValue("Havoc")*1000000;
                if module.GetOptionValue("Havoc") == "Focus" and Focus:Exists() and Focus:Health() >= HavocThreshold and Focus:CanCast(Havoc) then
                    HavocUnit, HavocTime = Focus, WreakHavoc:Exists() and module.GetTime() + 20 or module.GetTime() + 8;
                    Focus:Cast(Havoc);
                    return;
                else
                    BestUnit, BestUnitHealth = nil, 0;
                    for i = 1, #Enemies_40y do
                        ThisUnit, ThisUnitHealth = Enemies_40y[i], Enemies_40y[i]:Health();
                        if ThisUnitHealth >= HavocThreshold and ThisUnitHealth > BestUnitHealth and ThisUnit:CanCast(Havoc) then
                            BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                        end
                    end
                    if BestUnit then
                        HavocUnit, HavocTime = BestUnit, WreakHavoc:Exists() and module.GetTime() + 20 - ChaosBolt:CastTime() or module.GetTime() + 8;
                        BestUnit:Cast(Havoc);
                    end
                end
            end
        end
    end

    local function PetsManager ()
        -- Grimoire of Sacrifice with random delay
        if module.IsOptionEnabled("Grimoire Of Sacrifice") and GrimoreOfSacrifice:Exists() and not Player:Buff(GrimoreOfSacrificeBuff) then
            if UnitExists("PlayerPet") and Player:CanCast(GrimoreOfSacrifice) then
                if SacrificeRandomDelay then
                    if SacrificeRandomDelay < module.GetTime() then
                        Player:Cast(GrimoreOfSacrifice);
                        module.PetTimer = module.GetTime() + 4;
                        SacrificeRandomDelay = nil;
                        return;
                    end
                else
                    SacrificeRandomDelay = module.GetTime() + math.random(2, 6);
                end
            end
        end
        if not (GrimoreOfSacrifice:Exists() and Player:Buff(GrimoreOfSacrificeBuff)) then
            -- Resurrect Pet
            if not Player:IsMoving() and module.IsOptionEnabled("Demon Manager") and (not PlayerPet:Exists() or PlayerPet:IsDeadOrGhost()) and Player:SoulShards() >= 1 then
                local SelectedPet = module.GetOptionValue("Demon Manager");
                local SelectedPetSpell = SelectedPet == "Doomguard" and GrimoreOfSupremacy:Exists() and SummonDoomguard or SelectedPet == "Felhunter" and SummonFelhunter:Exists() and SummonFelhunter or SelectedPet == "Infernal" and GrimoreOfService:Exists() and SummonInfernal or SelectedPet == "Succubus" and SummonSuccubus:Exists() and SummonSuccubus or SelectedPet == "Voidwalker" and SummonVoidwalker:Exists() and SummonVoidwalker or SummonImp;
                if module.GetTime() - PetTimer >= 1 and Player:CanCast(SelectedPetSpell) then
                    Player:Cast(SelectedPetSpell);
                    PetTimer = module.GetTime() + 2.5;
                end
            end
            -- Health Funnel
            if module.IsOptionEnabled("Health Funnel") and PlayerPet:Exists() and not PlayerPet:IsDeadOrGhost() and Player:Standing() > 0.25 and PlayerPet:HealthPercentage() < module.GetOptionValue("Health Funnel") and Player:CanCast(HealthFunnel) then
                Player:Cast(HealthFunnel);
                return;
            end
        end
    end

    local function ServicePet ()
        local SelectedGrimoire = module.GetSecondOptionValue("Grimoire Of Service");
        local SelectedGrimoireSpell = SelectedGrimoire == "Felhunter" and GrimoreOfFelHunter or SelectedGrimoire == "Imp" and GrimoreOfImp or SelectedGrimoire == "Succubus" and GrimoreOfSuccubus or SelectedGrimoire == "Voidwalker" and GrimoreOfVoid;
        if Target:CanCast(SelectedGrimoireSpell) then
            Target:Cast(SelectedGrimoireSpell);
            return;
        end
    end

    function Rotation:Combat ()
        -- Prevent Early Chaos Bolt recasts but allow to have Havoc during Chaos Bolt.
        if Player:Casting(ChaosBolt) then
            return;
        end
        -- Combat Res Tanks
        MainTank = Unit.MainTank();
        OffTank = Unit.OffTank();
        if MainTank and MainTank:Exists() and not MainTank:IsDeadOrGhost() then MainTankResDelay = nil; end
        if OffTank and OffTank:Exists() and not OffTank:IsDeadOrGhost() then OffTankResDelay = nil; end
        if module.IsOptionEnabled("Instant Soulstone Tank") then
            if MainTank and MainTank:Exists() and MainTank:IsDeadOrGhost() and MainTank:IsPlayer() and MainTank:CanCast(Soulstone) then
                if not MainTankResDelay then MainTankResDelay = module.GetTime(); end
                if module.GetTime()-MainTankResDelay >= module.GetOptionValue("Instant Soulstone Tank") then
                    MainTankResDelay = nil;
                    MainTank:Cast(Soulstone);
                    return;
                end
            elseif OffTank and OffTank:Exists() and OffTank:IsDeadOrGhost() and OffTank:IsPlayer() and OffTank:CanCast(Soulstone) then
                if not OffTankResDelay then OffTankResDelay = module.GetTime(); end
                if module.GetTime()-OffTankResDelay >= module.GetOptionValue("Instant Soulstone Tank") then
                    OffTankResDelay = nil;
                    OffTank:Cast(Soulstone);
                    return;
                end
            end
        end
        if module.IsOptionEnabled("Soulstone") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and Target:IsPlayer() and Target:CanCast(Soulstone) then
            Target:Cast(Soulstone);
            return;
        end

        PetsManager();

        if Target:Exists() and Player:CanAttack(Target) then

            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                TargetEnemies_10y = Target:EnemiesWithinDistance(10, true);
                NumEnemies = #TargetEnemies_10y;
                ImmolateUnit = Unit.DotCycle(Enemies_40y, Immolate, ImmolateDebuff, 18, "Multi-Dot Immolate");
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- Shadowburn Sniping
            if Shadowburn:Exists() and module.IsOptionEnabled("Shadowburn Sniping") and Player:SoulShards() >= 1 and Player:SoulShards() < 4 then
                for i = 1, #Enemies_40y do
                    ThisUnit = Enemies_40y[i];
                    if not ThisUnit:Debuff(Shadowburn) and ThisUnit:HealthPercentage() < 20 and ThisUnit:CanCast(Shadowburn, true, true) and (ThisUnit:TimeToDie() < 5 or ThisUnit:IsDummy()) then
                        module.Bug("Cancel Cast and Snipe Shadowburn on " .. ThisUnit:Name());
                        SpellStopCasting();
                        ThisUnit:Cast(Shadowburn);
                        return;
                    end
                end
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, Immolate) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Grimoire Of Service
                if GrimoreOfService:Exists() and module.IsOptionEnabled("Grimoire Of Service") and (module.CooldownsAllowed() or module.GetOptionValue("Grimoire Of Service") == "Always") and Target:CanCast(GrimoreOfImp) then
                    ServicePet();
                end
                -- Doomguard
                if not GrimoreOfSupremacy:Exists() and GuardianDoomguard:Exists() and module.IsOptionEnabled("Doomguard") and (module.CooldownsAllowed() or module.GetOptionValue("Doomguard") == "Always") and Target:CanCast(GuardianDoomguard) then
                    Target:Cast(GuardianDoomguard);
                    return;
                end
                -- Infernal
                if not GrimoreOfSupremacy:Exists() and GuardianInfernal:Exists() and module.IsOptionEnabled("Infernal") and (module.CooldownsAllowed() or module.GetOptionValue("Infernal") == "Always") and Target:CanCast(GuardianInfernal) then
                    Target:Cast(GuardianInfernal);
                    return;
                end
                -- Mana Tap
                if ManaTap:Exists() and module.IsOptionEnabled("Mana Tap") and (module.CooldownsAllowed() or module.GetOptionValue("Mana Tap") == "Always") and Player:BuffRemains(ManaTap) < 3 and Player:CanCast(ManaTap) then
                    Player:Cast(ManaTap);
                    return;
                end
            end
            -- Havoc Rotation
            if not WreakHavoc:Exists() and BestTarget and BestTarget:Exists() and HavocTime > module.GetTime() then
                -- Chaos Bolt
                if Player:SoulShards() >= 2 and HavocTime > module.GetTime() + ChaosBolt:CastTime() and BestTarget:CanCast(ChaosBolt) then
                    BestTarget:Cast(ChaosBolt);
                    return;
                end
                -- Conflagrate
                if HavocTime > module.GetTime() + 0.2 and BestTarget:CanCast(Conflagrate) and (not BackDraft:Exists() or not Player:Buff(BackDraftBuff)) then
                    BestTarget:Cast(Conflagrate);
                    return;
                end
                -- Incinerate
                if HavocTime > module.GetTime() + Incinerate:CastTime() and BestTarget:CanCast(Incinerate) then
                    BestTarget:Cast(Incinerate);
                    return;
                end
            end
            -- Rotation
            if WreakHavoc:Exists() and BestTarget and BestTarget:Exists() and HavocTime > module.GetTime() then
                Target = BestTarget;
            end
            -- Dimensional Rift
            if DimensionalRift:Exists() and module.IsOptionEnabled("Dimensional Rift") and DimensionalRift:Charges() == 3 and (DimensionalRift:Charges() > module.GetSecondOptionValue("Dimensional Rift") or (module.CooldownsAllowed() or module.GetOptionValue("Mana Tap") == "Dimensional Rift")) and Target:CanCast(DimensionalRift) then
                Target:Cast(DimensionalRift);
                return;
            end
            -- Wreak Havoc
            HavocHandler("Wreak Havoc");
            -- Roaring Blaze Conflagrate
            if Conflagrate:Exists() and RoaringBlaze:Exists() and Target:DebuffRemains(ImmolateDebuff) >= 12 and Conflagrate:TimeSinceCast() >= 6 and Target:CanCast(Conflagrate) then
                Conflagrate.LastCastTime = module.GetTime();
                Target:Cast(Conflagrate);
                return;
            end
            -- Rain Of Fire
            if RainOfFire:Exists() and Player:SoulShards() >= 3 and module.IsOptionEnabled("Rain Of Fire") and Target:CanCast(RainOfFire) then
                if Target:CastGroundSpell(RainOfFire, "Rain Of Fire", 8) then return; end
            end
            -- Chaos Bolt
            if ChaosBolt:Exists() and Player:SoulShards() >= 4 and Target:CanCast(ChaosBolt) then
                HavocHandler();
                Target:Cast(ChaosBolt);
                return;
            end
            -- Life Tap
            if LifeTap:Exists() and Player:PowerPercentage() <= 40 and Player:HealthPercentage() >= 60 and Player:CanCast(LifeTap) then
                Player:Cast(LifeTap);
                return;
            end
            -- Cataclysm
            if Cataclysm:Exists() and module.IsOptionEnabled("Cataclysm") and Target:CanCast(Cataclysm) then
                if Target:CastGroundSpell(Cataclysm, "Cataclysm", 8) then return; end
            end
            -- Immolate - Target
            if Immolate:Exists() and Target:DebuffRemains(ImmolateDebuff) < 3 and Target:CanCast(Immolate) then
                Target:Cast(Immolate);
                return;
            end
            -- Immolate - Cycle
            if Immolate:Exists() and module.IsOptionEnabled("Multi-Dot Immolate") and ImmolateUnit and ImmolateUnit:CanCast(Immolate) then
                ImmolateUnit:Cast(Immolate);
                return;
            end
            -- Life Tap
            if LifeTap:Exists() and Player:PowerPercentage() <= 65 and Player:HealthPercentage() >= 60 and Player:CanCast(LifeTap) then
                Player:Cast(LifeTap);
                return;
            end
            -- Soul Harvest
            if SoulHarvest:Exists() and module.IsOptionEnabled("Soul Harvest") and Player:IsWithinCastRange(Target, Immolate) and (module.CooldownsAllowed() or module.GetOptionValue("Soul Harvest") == "Always") and Player:CanCast(SoulHarvest) then
                Player:Cast(SoulHarvest);
                return;
            end
            -- Conflagrate
            if Conflagrate:Exists() and not RoaringBlaze:Exists() and (not BackDraft:Exists() or not Player:Buff(BackDraftBuff)) and Target:CanCast(Conflagrate) then
                Conflagrate.LastCastTime = module.GetTime();
                Target:Cast(Conflagrate);
                return;
            end
            -- Dimensional Rift
            if DimensionalRift:Exists() and module.IsOptionEnabled("Dimensional Rift") and (DimensionalRift:Charges() > module.GetSecondOptionValue("Dimensional Rift") or (module.CooldownsAllowed() or module.GetOptionValue("Mana Tap") == "Dimensional Rift")) and Target:CanCast(DimensionalRift) then
                Target:Cast(DimensionalRift);
                return;
            end
            -- Life Tap
            if LifeTap:Exists() and Player:PowerPercentage() <= 40 and Player:CanCast(LifeTap) then
                Player:Cast(LifeTap);
                return;
            end
            -- Channel Demonfire
            if ChannelDemonfire:Exists() and Target:CanCast(ChannelDemonfire) then
                Target:Cast(ChannelDemonfire);
                return;
            end
            -- Chaos Bolt
            if ChaosBolt:Exists() and Player:SoulShards() >= 3 and (Player:SoulShards() >= 4 or not Eradication:Exists() or ChaosBolt:TimeSinceCast() + ChaosBolt:CastTime() >= 6) and Target:CanCast(ChaosBolt) then
                HavocHandler();
                Target:Cast(ChaosBolt);
                return;
            end
            -- Incinerate
            if Incinerate:Exists() and Target:CanCast(Incinerate) then
                Target:Cast(Incinerate);
                return;
            end
            -- Shadowburn while moving
            if Shadowburn:Exists() and module.IsOptionEnabled("Shadowburn Filler") and Player:IsMoving() and Target:CanCast(Shadowburn) then
                Target:Cast(Shadowburn);
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        PetsManager();
        -- Create Healthstones
        if module.IsOptionEnabled("Create Healthstones") and Player:Standing() > 0.25 then
            if not Healthstone:InStock() and CreateHealthstone:TimeSinceCast() >= module.GetTime() + 5 and Player:CanCast(CreateHealthstone) then
                Player:Cast(CreateHealthstone);
                CreateHealthstone.LastCastTime = module.GetTime();
                return;
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Arms Warrior
    local Rotation = {};
    module.SetRotation(71, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local CleaveCount, Enemies_8y, Enemies_5y, ExecuteUnit, ShockwaveCount, NumEnemies = 0, {}, {}, nil, 0, 0; -- Enemies
    local ShouldDump, RendUnit;
    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicStrength = Item(109219, false, false, true);
        DraenicStrengthBuff = Spell(156428, false, false, true);

        --Racials
        ArcaneTorrent = Spell(69179, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        Avatar = Spell(107574, false, false, true);
        BattleCry = Spell(1719, false, false, true);
        BerserkerRage = Spell(18499, false, false, true);
        Bladestorm = Spell(227847, false, false, true);
        Charge = Spell(100, true, true, true);
        Cleave = Spell(845, true, false, true);
        CleaveBuff = Spell(188923);
        ColossusSmash = Spell(167105, true, true, true);
        ColossusSmashDebuff = Spell(208086);
        CommandingShout = Spell(97462, false, false, true);
        DeadlyCalm = Spell(227266);
        DefensiveStance = Spell(197690, false, false, true); -- Battle = DefensiveStance:Icon() == 132349
        DieByTheSword = Spell(118038, false, false, true);
        Execute = Spell(163201, true, true, true);
        FervorOfBattle = Spell(202316);
        FocusedRage = Spell(207982, false, false, true);
        Hamstring = Spell(1715, true, true, true);
        HeroicThrow = Spell(57755, true, true, true);
        InForTheKill = Spell(215550);
        MortalStrike = Spell(12294, true, true, true);
        Overpower = Spell(7384, true, true, true);
        OverpowerBuff = Spell(60503);
        PreciseStrikes = Spell(209492);
        Pummel = Spell(6552, true, true, true);
        Ravager = Spell(152277, false, true, true);
        Rend = Spell(772, true, true, true);
        Slam = Spell(1464, true, true, true);
        ShatteredDefenses = Spell(209706);
        Shockwave = Spell(46968, true, false, true);
        StoneHeart = Spell(225947); -- Legendary Ring Proc - Free Execute
        StormBolt = Spell(107570, true, true, true);
        VictoryRush = Spell(34428, true, true, true);
        VictoryRushBuff = Spell(32216);
        Warbreaker = Spell(209577, false, false, true);
        Whirlwind = Spell(1680, false, false, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Pummel to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Auto Charge Combat", 220, false, {15, 6.5, 22, 0.5}, nil, "Distance away from the target to auto use charge while in combat");
        module.AddNewOption("General Settings", "Auto Charge Out Of Combat", 220, false, {15, 6.5, 22, 0.5}, nil, "Distance away from the target to auto use charge while not in combat");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 232, true, {1, "Boss Only", "Always", "Never"}, {0.2, 0, 3, 0.1}, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Avatar", 233, true, {2, "Always", "Cooldown Only"}, {2, "Always", "With Bladestorm"}, "Use Avatar."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Use on cooldown."..C.TOOLTIP_SUBVALUE("With Bladestorm", true).."Pair with Bladestorm.");
        module.AddNewOption("Offensive Settings", "Battle Cry", 233, true, {1, "Always", "Cooldown Only"}, {2, "Always", "With Bladestorm"}, "Use Battle Cry."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Use on cooldown."..C.TOOLTIP_SUBVALUE("With Bladestorm", true).."Pair with Bladestorm.");
        module.AddNewOption("Offensive Settings", "Berserker Rage", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Berserker Rage."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Bladestorm", 232, true, {1, "Always", "Cooldown Only"}, {2, 1, 10, 1}, "Use Bladestorm."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be in range to use."..C.TOOLTIP_HINT("Only usable without the Ravager talent."));
        module.AddNewOption("Offensive Settings", "Execute", 230, true, {1, "Target Only", "Any Unit"}, nil, "Use Execute on low health Targets."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Target Only", true).."Only use Execute on current Target."..C.TOOLTIP_SUBVALUE("Any Unit", true).."Use Execute on any available unit that is in range.");
        module.AddNewOption("Offensive Settings", "Colossus Smash", 232, true, {1, "Always", "Without Debuff"}, {45, 1, 100, 1}, "Use Colossus Smash"..C.TOOLTIP_VALUE_1.."Choose when you want to use Colossus Smash."..C.TOOLTIP_SUBVALUE("Always").."Use Colossus Smash whenever it is ready."..C.TOOLTIP_SUBVALUE("Without Debuff").."Only use Colossus Smash to apply Colossus Smash debuff on the target."..C.TOOLTIP_VALUE_2.."Minimum Rage to use Colossus Smash.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Rend", 222, false, { 5, 1, 10, 1 }, { 3, 0, 25, 0.1 }, "Multi-Dot Rend Cycle."..C.TOOLTIP_VALUE_1.."Number of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Ravager", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {1, 1, 10, 1}, "Use Death and Decay." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Shockwave", 220, true, {2, 1, 10, 1}, nil, "Use Shockwave."..C.TOOLTIP_VALUE_1.."Define number of units needed in front of us to use Shockwave.");
        module.AddNewOption("Offensive Settings", "Storm Bolt", 210, true, nil, nil, "Use Storm Bolt as filler.");
        module.AddNewOption("Offensive Settings", "Warbreaker", 220, true, {2, 1, 10, 1}, nil, "Use Warbreaker."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range to use.");
        module.AddNewOption("Offensive Settings", "Whirlwind", 222, true, {2, 1, 10, 1}, {3, 1, 10, 1}, "Use Whirlwind."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be in range to use."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be in range to use as high priority."..C.TOOLTIP_HINT("High Priority rotation will be only using Warbreaker + Bladestorm + Cleave + Whirlwind. Cleave will always be used to empower Whirlwind. The unit Count is frontal as it requires Cleave to be efficient."));

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Defensive Stance", 220, true, {20, 1, 100, 1}, nil, "Use Defensive Stance."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Die By The Sword", 220, true, {30, 1, 100, 1}, nil, "Use Die By The Sword."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Victory Rush", 220, true, {50, 1, 100, 1}, nil, "Use Victory Rush."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Buff(Bladestorm) then
            return;
        end

        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Pummel, ArcaneTorrent);
    end


    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Victory Rush
        if VictoryRush:Exists() and Player:Buff(VictoryRushBuff) and module.IsOptionEnabled("Victory Rush") and Player:HealthPercentage() <= module.GetOptionValue("Victory Rush") and Target:CanCast(VictoryRush) then
            Target:Cast(VictoryRush);
            return;
        end
        -- Defensive Items
        Player:UseHealingItem();
        -- Die By The Sword
        if DieByTheSword:Exists() and module.IsOptionEnabled("Die By The Sword") and Player:HealthPercentage() <= module.GetOptionValue("Die By The Sword") and Player:CanCast(DieByTheSword) then
            Player:Cast(DieByTheSword);
        end
        -- Defensive Stance
        if DefensiveStance:Exists() then
            if module.IsOptionEnabled("Defensive Stance") and Player:HealthPercentage() <= module.GetOptionValue("Defensive Stance") and not Player:Buff(DefensiveStance) and Player:CanCast(DefensiveStance) then
                Player:Cast(DefensiveStance);
            end
            if (not module.IsOptionEnabled("Defensive Stance") or Player:HealthPercentage() > module.GetOptionValue("Defensive Stance")) and Player:Buff(DefensiveStance) and Player:CanCast(DefensiveStance) then
                Player:Cast(DefensiveStance);
            end
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end


    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(MortalStrike, false) or Unit.Target;
        -- actions+=/hamstring,if=talent.deadly_calm.enabled&buff.battle_cry.up
        if Target:Exists() and Hamstring:Exists() and DeadlyCalm:Exists() and Player:Buff(BattleCry) and Target:CanCast(Hamstring) then
            Target:Cast(Hamstring);
            return;
        end
        -- actions+=/focused_rage,if=talent.deadly_calm.enabled&buff.battle_cry.up
        if FocusedRage:Exists() and DeadlyCalm:Exists() and Player:Buff(BattleCry) and Player:BuffCount(FocusedRage) < 3 and Player:CanCast(FocusedRage) then
            Player:Cast(FocusedRage);
            return;
        end
        -- Focused Rage tweak
        if FocusedRage:Exists() and (Player:BuffCount(FocusedRage) < 3 or Player:BuffRemains(FocusedRage) < 5) and (not Target:Exists() or (not Target:Debuff(ColossusSmashDebuff) and Target:HealthPercentage() >= 20)) and Player:RageDeficit() < 30 and Player:CanCast(FocusedRage) then
            Player:Cast(FocusedRage);
            return;
        end
    end

    function Rotation:Opening ()
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicStrengthBuff) and DraenicStrength:InStock() and not DraenicStrength:IsOnCooldown() then
            if Player:Potion("Strength", Potion) then Potion = true; end
        end
    end

    local function ExecuteHandler ()
        if Target:HealthPercentage() < 20 and Target:CanCast(Execute) then
            Target:Cast(Execute);
            return;
        end
        if module.GetOptionValue("Execute") == "Any Unit" then
            if ExecuteUnit and ExecuteUnit:CanCast(Execute, true, true) then
                ExecuteUnit:Cast(Execute);
                return;
            end
        end
    end

    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Combat Charge
            if module.IsOptionEnabled("Auto Charge Combat") and Target:CanCast(Charge) and Player:DistanceTo(Target) >= 6.5 and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Charge Combat") and Player:IsFacing(Target) then
                Target:Cast(Charge);
                return;
            end
            -- Enemies Check
            if module.UseAOE() then
                CleaveCount = #Player:UnitsInFrontConeAroundUnit(Target, 7, 180);
                Enemies_8y = Player:EnemiesWithinDistance(8, true);
                Enemies_5y = Player:FilterEnemiesByDistance(Enemies_8y, 5, false);
                ExecuteUnit = Execute:Exists() and module.IsOptionEnabled("Execute") and module.GetOptionValue("Execute") == "Any Unit" and Unit.LightEnemyAvailableForSpellHP(Enemies_8y, Execute, 20) or nil;
                RendUnit = Rend:Exists() and Unit.DotCycle(Enemies_5y, Rend, Rend, 4.5, "Multi-Dot Rend") or nil; -- Rend DoT Cycle
                ShockwaveCount = Shockwave:Exists() and #Player:UnitsInFrontCone(10, 140) or 0;
                NumEnemies = #Enemies_8y;
            else
                CleaveCount, Enemies_8y, Enemies_5y, ExecuteUnit, RendUnit, ShockwaveCount, NumEnemies = 0, {}, {}, nil, nil, 0, 1;
            end

            if Player:IsWithinCastRange(Target, MortalStrike) then
                --- Cooldowns ---
                if module.CooldownsAllowed() then
                    Player:UseTrinkets();
                    -- Racials
                    if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                        -- Blood Fury
                        if BloodFury:Exists() and Player:CanCast(BloodFury) and Player:Buff(BattleCry) then
                            Player:Cast(BloodFury);
                        end
                        -- Berserking
                        if Berserking:Exists() and Player:CanCast(Berserking) and Player:Buff(BattleCry) then
                            Player:Cast(Berserking);
                        end
                        -- Arcane Torrent
                        if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Rage() < Player:RageMax() - 40 then
                            Player:Cast(ArcaneTorrent);
                        end
                    end
                end
                -- Berserker Rage
                if BerserkerRage:Exists() and module.IsOptionEnabled("Berserker Rage") and (module.CooldownsAllowed() or module.GetOptionValue("Berserker Rage") == "Always") and Player:CanCast(BerserkerRage) then
                    Player:Cast(BerserkerRage);
                end
                -- Battle Cry
                if BattleCry:Exists() and module.IsOptionEnabled("Battle Cry") and (module.CooldownsAllowed() or module.GetOptionValue("Battle Cry") == "Always") and (Target:DebuffRemains(ColossusSmashDebuff) > 5 or (Target:Debuff(ColossusSmashDebuff) and not ColossusSmash:IsOnCooldown())) and Player:CanCast(BattleCry) then
                    Player:Cast(BattleCry);
                end
                -- Avatar
                if Avatar:Exists() and module.IsOptionEnabled("Avatar") and (module.CooldownsAllowed() or module.GetOptionValue("Avatar") == "Always") and Player:Buff(BattleCry) and Player:CanCast(Avatar) then
                    Player:Cast(Avatar);
                    return;
                end
            end

            -- Bladestorm
            if Bladestorm:Exists() and not Ravager:Exists() and module.IsOptionEnabled("Bladestorm") and NumEnemies >= module.GetSecondOptionValue("Bladestorm") and Player:CanCast(Bladestorm) then
                -- Avatar
                if Avatar:Exists() and module.IsOptionEnabled("Avatar") and (module.CooldownsAllowed() or module.GetOptionValue("Avatar") == "Always") and module.GetSecondOptionValue("Avatar") == "With Bladestorm" and Player:CanCast(Avatar) then
                    Player:Cast(Avatar);
                end
                -- Battle Cry
                if BattleCry:Exists() and module.IsOptionEnabled("Battle Cry") and (module.CooldownsAllowed() or module.GetOptionValue("Battle Cry") == "Always") and module.GetSecondOptionValue("Battle Cry") == "With Bladestorm" and Player:CanCast(BattleCry) then
                    Player:Cast(BattleCry);
                end
                Player:Cast(Bladestorm);
                return;
            end

            -- Execute - Stone Heart
            if Execute:Exists() and Player:Buff(StoneHeart) and Target:CanCast(Execute) then
                Target:Cast(Execute);
                return;
            end
            -- actions+=/rend,if=remains<gcd
            if Rend:Exists() and Player:Rage() >= 15 and Target:DebuffRemains(Rend) < Player:GCD() and Target:CanCast(Rend) then
                Target:Cast(Rend);
                return;
            end
            -- actions+=/colossus_smash,if=debuff.colossus_smash.down
            if ColossusSmash:Exists() and not Target:Debuff(ColossusSmashDebuff) and Target:CanCast(ColossusSmash) then
                Target:Cast(ColossusSmash);
                return;
            end
            -- actions+=/warbreaker,if=debuff.colossus_smash.down
            if Warbreaker:Exists() and Player:IsWithinCastRange(Target, MortalStrike) and module.IsOptionEnabled("Warbreaker") and NumEnemies >= module.GetOptionValue("Warbreaker") and not Target:Debuff(ColossusSmashDebuff) and Player:CanCast(Warbreaker) then
                Player:Cast(Warbreaker);
                return;
            end
            -- actions+=/ravager
            if Ravager:Exists() and module.IsOptionEnabled("Ravager") and Target:CanCast(Ravager) then
                if Player:CastGroundSpell(Ravager, "Ravager", 10) then return; end
            end
            -- actions+=/overpower
            if Overpower:Exists()  and Player:Rage() >= 10 and Player:Buff(OverpowerBuff) and Target:CanCast(Overpower) then
                Target:Cast(Overpower);
                return;
            end

            -- actions+=/run_action_list,name=execute,if=target.health.pct<20
            if Target:HealthPercentage() < 20 then
                -- actions.execute=mortal_strike,if=buff.shattered_defenses.up&buff.focused_rage.stack=3
                if MortalStrike:Exists() and Player:Buff(ShatteredDefenses) and Player:BuffCount(FocusedRage) == 3 and Target:CanCast(MortalStrike) then
                    Target:Cast(MortalStrike);
                    return;
                end
                -- actions.execute+=/execute,if=debuff.colossus_smash.up&(buff.shattered_defenses.up|rage>100|talent.deadly_calm.enabled&buff.battle_cry.up)
                if Execute:Exists() and module.IsOptionEnabled("Execute") and Target:Debuff(ColossusSmashDebuff) and (Player:Buff(ShatteredDefenses) or Player:Rage() > 100 or (DeadlyCalm:Exists() and Player:Buff(BattleCry))) and Target:CanCast(Execute) then
                    Target:Cast(Execute);
                    return;
                end
                -- actions.execute+=/mortal_strike,if=talent.in_for_the_kill.enabled&buff.shattered_defenses.down
                if MortalStrike:Exists() and InForTheKill:Exists() and not Player:Buff(ShatteredDefenses) and Target:CanCast(MortalStrike) then
                    Target:Cast(MortalStrike);
                    return;
                end
                -- actions.execute+=/colossus_smash,if=buff.shattered_defenses.down&buff.precise_strikes.down
                if ColossusSmash:Exists() and Warbreaker:Exists() and not Player:Buff(ShatteredDefenses) and not Player:Buff(PreciseStrikes) and Target:CanCast(ColossusSmash) then
                    Target:Cast(ColossusSmash);
                    return;
                end
                -- actions.execute+=/warbreaker,if=buff.shattered_defenses.down
                if Warbreaker:Exists() and Player:IsWithinCastRange(Target, MortalStrike) and module.IsOptionEnabled("Warbreaker") and NumEnemies >= module.GetOptionValue("Warbreaker") and Player:Buff(ShatteredDefenses) and Player:CanCast(Warbreaker) then
                    Player:Cast(Warbreaker);
                    return;
                end
                -- actions.execute+=/mortal_strike
                if MortalStrike:Exists() and Target:CanCast(MortalStrike) then
                    Target:Cast(MortalStrike);
                    return;
                end
                -- actions.execute+=/execute,if=debuff.colossus_smash.up|rage>=100
                if Execute:Exists() and module.IsOptionEnabled("Execute") and (Target:Debuff(ColossusSmashDebuff) or Player:Rage() >= 100) and Target:CanCast(Execute) then
                    Target:Cast(Execute);
                    return;
                end
                -- actions.execute+=/rend,if=remains<=duration*0.3
                if Rend:Exists() and Player:Rage() >= 15 and Target:DebuffRemains(Rend) < 4.5 and Target:CanCast(Rend) then
                    Target:Cast(Rend);
                    return;
                end
                -- actions.execute+=/heroic_charge
                -- actions.execute+=/shockwave
                if Shockwave:Exists() and module.IsOptionEnabled("Shockwave") and ShockwaveCount >= module.GetOptionValue("Shockwave") and Player:CanCast(Shockwave) then
                    Player:Cast(Shockwave);
                    return;
                end
                -- actions.execute+=/storm_bolt
                if StormBolt:Exists() and module.IsOptionEnabled("Storm Bolt") and Target:CanCast(StormBolt) then
                    Target:Cast(StormBolt);
                    return;
                end
                return;
            end

            -- actions+=/run_action_list,name=single,if=target.health.pct>=20
            -- actions.single=mortal_strike
            if MortalStrike:Exists() and Target:CanCast(MortalStrike) then
                Target:Cast(MortalStrike);
                return;
            end
            -- actions.single+=/colossus_smash,if=buff.shattered_defenses.down&buff.precise_strikes.down
            if ColossusSmash:Exists() and Warbreaker:Exists() and not Player:Buff(ShatteredDefenses) and not Player:Buff(PreciseStrikes) and Target:CanCast(ColossusSmash) then
                Target:Cast(ColossusSmash);
                return;
            end
            -- actions.single+=/warbreaker,if=buff.shattered_defenses.down
            if Warbreaker:Exists() and Player:IsWithinCastRange(Target, MortalStrike) and module.IsOptionEnabled("Warbreaker") and NumEnemies >= module.GetOptionValue("Warbreaker") and Player:Buff(ShatteredDefenses) and Player:CanCast(Warbreaker) then
                Player:Cast(Warbreaker);
                return;
            end
            -- actions.single+=/whirlwind,if=talent.fervor_of_battle.enabled&(debuff.colossus_smash.up|rage.deficit<50)&!talent.focused_rage.enabled|talent.deadly_calm.enabled&buff.battle_cry.up|buff.cleave.up
            if Whirlwind:Exists() and module.IsOptionEnabled("Whirlwind") and CleaveCount >= module.GetSecondOptionValue("Whirlwind") then
                -- Whirlwind
                if (FervorOfBattle:Exists() and (Target:Debuff(ColossusSmash) or Player:RageDeficit() < 50) and not FocusedRage:Exists()) or (DeadlyCalm:Exists() and Player:Buff(BattleCry)) or Player:Buff(CleaveBuff) then
                    if Player:CanCast(Whirlwind) then
                        Player:Cast(Whirlwind);
                        return;
                    end
                end
                -- Cleave for Whirlwind
                if Cleave:Exists() and Player:Rage() >= 35 and not Player:Buff(CleaveBuff) and Player:CanCast(Cleave) then
                    Player:Cast(Cleave);
                    return;
                end
            end
            -- actions.single+=/slam,if=!talent.fervor_of_battle.enabled&(debuff.colossus_smash.up|rage.deficit<40)&!talent.focused_rage.enabled|talent.deadly_calm.enabled&buff.battle_cry.up
            if Slam:Exists() and not FervorOfBattle:Exists() and (Target:Debuff(ColossusSmash) or Player:RageDeficit() < 40) and (not FocusedRage:Exists() or (DeadlyCalm:Exists() and Player:Buff(BattleCry))) and Target:CanCast(Slam) then
                Target:Cast(Slam);
                return;
            end
            -- actions.single+=/rend,if=remains<=duration*0.3
            if Rend:Exists() and Player:Rage() >= 15 and Target:DebuffRemains(Rend) < 4.5 and Target:CanCast(Rend) then
                Target:Cast(Rend);
                return;
            end
            -- actions.single+=/heroic_charge
            -- actions.single+=/whirlwind,if=talent.fervor_of_battle.enabled&(!talent.focused_rage.enabled|rage>100|buff.focused_rage.stack=3)
            if Whirlwind:Exists() and module.IsOptionEnabled("Whirlwind") and CleaveCount >= module.GetSecondOptionValue("Whirlwind") then
                if FervorOfBattle:Exists() and (not FocusedRage:Exists() or Player:Rage() > 100 or Player:BuffCount(FocusedRage) == 3) then
                    if Player:CanCast(Whirlwind) then
                        Player:Cast(Whirlwind);
                        return;
                    end
                end
            end
            -- actions.single+=/slam,if=!talent.fervor_of_battle.enabled&(!talent.focused_rage.enabled|rage>100|buff.focused_rage.stack=3)
            if Slam:Exists() and (not FocusedRage:Exists() or Player:Rage() > 100 or Player:BuffCount(FocusedRage) == 3) and Target:CanCast(Slam) then
                Target:Cast(Slam);
                return;
            end
            -- actions.single+=/execute
            if Execute:Exists() and module.IsOptionEnabled("Execute") and Target:CanCast(Execute) then
                Target:Cast(Execute);
                return;
            end
            -- actions.single+=/shockwave
            if Shockwave:Exists() and module.IsOptionEnabled("Shockwave") and ShockwaveCount >= module.GetOptionValue("Shockwave") and Player:CanCast(Shockwave) then
                Player:Cast(Shockwave);
                return;
            end
            -- actions.single+=/storm_bolt
            if StormBolt:Exists() and module.IsOptionEnabled("Storm Bolt") and Target:CanCast(StormBolt) then
                Target:Cast(StormBolt);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(MortalStrike, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Out Of Combat Charge
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and module.IsOptionEnabled("Auto Charge Out Of Combat") and Player:DistanceTo(Target) >= 6.5 and ((BMPullTime() == 60 and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Charge Out Of Combat")) or BMPullTime() <= module.GetSecondOptionValue("Pre-Pot BossMod")) and Player:IsFacing(Target) and Target:CanCast(Charge) then
            Target:Cast(Charge);
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Fury Warrior
    local Rotation = {};
    module.SetRotation(72, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local Enemies_20y, Enemies_8y, ExecuteUnit, ShockwaveCount, NumEnemies = {}, {}, nil, 0, 0; -- Enemies
    local BattleCryEnabled, CanExecute;

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicStrength = Item(109219, false, false, true);
        DraenicStrengthBuff = Spell(156428, false, false, true);

        --Racials
        ArcaneTorrent = Spell(69179, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        Avatar = Spell(107574, false, false, true);
        BattleCry = Spell(1719, false, false, true);
        BerserkerRage = Spell(18499, false, false, true);
        Bladestorm = Spell(46924, false, false, true);
        Bloodbath = Spell(12292, false, false, true);
        Bloodthirst = Spell(23881, true, true, true);
        Carnage = Spell(202922);
        Charge = Spell(100, true, true, true);
        CommandingShout = Spell(97462, false, false, true);
        DragonRoar = Spell(118000, false, false, true);
        Enrage = Spell(184362);
        EnragedRegeneration = Spell(184364, false, false, true);
        Execute = Spell(5308, true, true, true);
        Frenzy = Spell(206313);
        FrenzyBuff = Spell(202539);
        FuriousSlash = Spell(100130, true, true, true);
        HeroicThrow = Spell(57755, true, true, true);
        InnerRage = Spell(215573);
        Juggernaut = Spell(201009);
        Massacre = Spell(206316);
        MeatCleaver = Spell(85739);
        OdynsFury = Spell(205545, false, false, true);
        Pummel = Spell(6552, true, true, true);
        RagingBlow = Spell(85288, true, true, true);
        Rampage = Spell(184367, true, true, true);
        SenseForDeath = Spell(200979);
        Shockwave = Spell(46968, true, false, true);
        StoneHeart = Spell(225947); -- Legendary Ring Proc - Free Execute
        StormBolt = Spell(107570, true, true, true);
        Whirlwind = Spell(190411, false, false, true);
        WreckingBall = Spell(215570);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Pummel to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Auto Charge Combat", 220, false, {15, 6.5, 22, 0.5}, nil, "Distance away from the target to auto use charge while in combat");
        module.AddNewOption("General Settings", "Auto Charge Out Of Combat", 220, false, {15, 6.5, 22, 0.5}, nil, "Distance away from the target to auto use charge while not in combat");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 232, true, {1, "Boss Only", "Always", "Never"}, {0.2, 0, 3, 0.1}, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Avatar", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Avatar."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Battle Cry", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Battle Cry."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Berserker Rage", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Berserker Rage."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Bladestorm", 232, true, {1, "Always", "Cooldown Only"}, {2, 1, 10, 1}, "Use Bladestorm."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be in range to use.");
        module.AddNewOption("Offensive Settings", "Bloodbath", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Blood Bath."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Dragon Roar", 232, true, {2, "Always", "Cooldown Only"}, {1, 1, 10, 1}, "Use Dragon Roar."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be in range to use.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Execute", 230, true, {2, "Target Only", "Any Unit"}, nil, "Use Execute on low health Targets."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Target Only", true).."Only use Execute on current Target."..C.TOOLTIP_SUBVALUE("Any Unit", true).."Use Execute on any available unit that is in range.");
        module.AddNewOption("Offensive Settings", "Odyn's Fury", 220, true, {2, 1, 10, 1}, nil, "Use Odyn's Fury."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range to use.");
        module.AddNewOption("Offensive Settings", "Shockwave", 220, false, {3, 1, 10, 1}, nil, "Use Shockwave."..C.TOOLTIP_VALUE.."Define number of units needed in front of us to use Shockwave.");
        module.AddSection("Offensive Settings", "Rotations", "Green");
        module.AddNewOption("Offensive Settings", "AoE Rotation", 220, true, {4, 4, 4, 0}, nil, "Use AoE Rotation. (4+ Targets)"..C.TOOLTIP_VALUE.."Amount of units that needs to be in Whirlwind Radius to use the AoE Rotation.");
        module.AddNewOption("Offensive Settings", "Cleave Rotation", 220, true, {2, 2, 2, 0}, nil, "Use Cleave Rotation. (2-3 Targets)"..C.TOOLTIP_VALUE.."Amount of units that needs to be in Whirlwind Radius to use the Cleave Rotation.");
        -- module.AddNewOption("Offensive Settings", "Whirlwind", 222, true, {2, 1, 10, 1}, {1, 1, 10, 1}, "Use Whirlwind."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be in range to use."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be in range to use when we have the Wrecking Ball buff.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Enraged Regeneration", 220, true, {30, 1, 100, 1}, nil, "Use Enraged Regeneration."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        module.AddOutput("|cFFE30000Rotation:");
        module.SetOutput("|cFFE30000Rotation:", "|cFFE30000Single Target");
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Pummel, ArcaneTorrent);
    end


    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Enraged Regeneration
        if EnragedRegeneration:Exists() and module.IsOptionEnabled("Enraged Regeneration") and Player:HealthPercentage() <= module.GetOptionValue("Enraged Regeneration") and Player:CanCast(EnragedRegeneration) then
            Player:Cast(EnragedRegeneration);
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end


    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(Bloodthirst, false) or Unit.Target;
    end

    function Rotation:Opening ()
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicStrengthBuff) and DraenicStrength:InStock() and not DraenicStrength:IsOnCooldown() then
            if Player:Potion("Strength", Potion) then Potion = true; end
        end
    end

    local function ExecuteHandler ()
        if Target:HealthPercentage() < 20 and Target:CanCast(Execute) then
            Target:Cast(Execute);
            return;
        end
        if module.GetOptionValue("Execute") == "Any Unit" then
            if ExecuteUnit and ExecuteUnit:CanCast(Execute, true, true) then
                ExecuteUnit:Cast(Execute);
                return;
            end
        end
    end

    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Combat Charge
            if module.IsOptionEnabled("Auto Charge Combat") and Target:CanCast(Charge) and Player:DistanceTo(Target) >= 6.5 and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Charge Combat") and Player:IsFacing(Target) then
                Target:Cast(Charge);
                return;
            end
            -- Enemies Check
            if module.UseAOE() then
                Enemies_20y = Player:EnemiesWithinDistance(20, true);
                Enemies_8y = Player:FilterEnemiesByDistance(Enemies_20y, 8, true);
                ExecuteUnit = Execute:Exists() and module.IsOptionEnabled("Execute") and module.GetOptionValue("Execute") == "Any Unit" and Unit.LightEnemyAvailableForSpellHP(Enemies_8y, Execute, 20) or nil;
                ShockwaveCount = Shockwave:Exists() and #Player:UnitsInFrontCone(10, 140) or 0;
                NumEnemies = #Enemies_8y;
            else
                NumEnemies = 1;
            end

            -- Shockwave
            if Shockwave:Exists() and module.IsOptionEnabled("Shockwave") and ShockwaveCount >= module.GetOptionValue("Shockwave") and Player:CanCast(Shockwave) then
                Player:Cast(Shockwave);
                return;
            end

            if Player:IsWithinCastRange(Target, Bloodthirst) then
                --- Cooldowns ---
                if module.CooldownsAllowed() then
                    Player:UseTrinkets();

                end
                BattleCryEnabled = module.IsOptionEnabled("Battle Cry") and (module.CooldownsAllowed() or module.GetOptionValue("Battle Cry") == "Always") or false;
                DragonRoarEnabled = DragonRoar:Exists() and (module.CooldownsAllowed() or module.GetOptionValue("Avatar") == "Always") and module.IsOptionEnabled("Dragon Roar") and NumEnemies >= module.GetSecondOptionValue("Dragon Roar") or false;
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    if ((BattleCryEnabled and BattleCry:Cooldown() < Player:GCD()) or not BattleCryEnabled) then
                        -- Blood Fury
                        if BloodFury:Exists() and Player:CanCast(BloodFury) then
                            Player:Cast(BloodFury);
                        end
                        -- Berserking
                        if Berserking:Exists() and Player:CanCast(Berserking) then
                            CastSpellByID(26297, "player")
                        end
                    end
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Rage() < Player:RageMax() - 40 then
                        Player:Cast(ArcaneTorrent);
                    end
                end
                -- DragonRoar
                if DragonRoar:Exists() and module.IsOptionEnabled("Dragon Roar") and (module.CooldownsAllowed() or module.GetOptionValue("Dragon Roar") == "Always") and NumEnemies >= module.GetSecondOptionValue("Dragon Roar") and ((BattleCryEnabled and BattleCry:Cooldown() < Player:GCD()) or not BattleCryEnabled or BattleCry:Cooldown() > 23) and Player:CanCast(DragonRoar) then
                    Player:Cast(DragonRoar);
                    return;
                end
                -- Avatar
                if Avatar:Exists() and module.IsOptionEnabled("Avatar") and (module.CooldownsAllowed() or module.GetOptionValue("Avatar") == "Always") and ((BattleCryEnabled and BattleCry:Cooldown() < 10) or not BattleCryEnabled) and Player:CanCast(Avatar) then
                    Player:Cast(Avatar);
                    return;
                end
                -- Bloodbath
                if Bloodbath:Exists() and module.IsOptionEnabled("Bloodbath") and (module.CooldownsAllowed() or module.GetOptionValue("Bloodbath") == "Always") and ((BattleCryEnabled and (Player:Buff(BattleCry) or BattleCry:Cooldown() > 28)) or not BattleCryEnabled) and Player:CanCast(Bloodbath) then
                    Player:Cast(Bloodbath);
                    return;
                end
                -- Berserker Rage
                if BerserkerRage:Exists() and not Player:Buff(Enrage) and not (DragonRoarEnabled and not Player:Buff(DragonRoar)) and module.IsOptionEnabled("Berserker Rage") and (module.CooldownsAllowed() or module.GetOptionValue("Berserker Rage") == "Always") and Player:CanCast(BerserkerRage) then
                    Player:Cast(BerserkerRage);
                end
                -- Battle Cry
                if BattleCry:Exists() and not (DragonRoarEnabled and not Player:Buff(DragonRoar)) and BattleCryEnabled and Player:CanCast(BattleCry) then
                    Player:Cast(BattleCry);
                    return;
                end
            end

            -- actions+=/call_action_list,name=aoe,if=spell_targets.whirlwind>3
            if module.UseAOE() and module.IsOptionEnabled("AoE Rotation") and NumEnemies >= 4 then
                module.SetOutput("|cFFE30000Rotation:", "|cFFE30000AoE");
                -- actions.aoe=bloodthirst,if=buff.enrage.down|rage<50
                if Bloodthirst:Exists() and (not Player:Buff(Enrage) or Player:Rage() < 50) and Target:CanCast(Bloodthirst) then
                    Target:Cast(Bloodthirst);
                    return;
                end
                -- actions.bladestorm+=/bladestorm,if=buff.enrage.remains>2&(raid_event.adds.in>90|!raid_event.adds.exists|spell_targets.bladestorm_mh>desired_targets)
                if Bladestorm:Exists() and Player:BuffRemains(Enrage) > 2 and module.IsOptionEnabled("Bladestorm") and NumEnemies >= module.GetSecondOptionValue("Bladestorm") and Player:CanCast(Bladestorm) then
                    Player:Cast(Bladestorm);
                    return;
                end
                -- actions.aoe+=/whirlwind
                if Whirlwind:Exists() and Player:IsWithinCastRange(Target, Bloodthirst) and Player:CanCast(Whirlwind) then
                    Player:Cast(Whirlwind);
                    return;
                end
                -- actions.aoe+=/dragon_roar
                -- actions.aoe+=/bloodthirst
                if Bloodthirst:Exists() and Target:CanCast(Bloodthirst) then
                    Target:Cast(Bloodthirst);
                    return;
                end

            -- actions+=/call_action_list,name=two_targets,if=spell_targets.whirlwind=2|spell_targets.whirlwind=3
            elseif module.UseAOE() and module.IsOptionEnabled("Cleave Rotation") and NumEnemies >= 2 then
                module.SetOutput("|cFFE30000Rotation:", "|cFFE30000Cleave");
                -- actions.two_targets=whirlwind,if=buff.meat_cleaver.down
                if Whirlwind:Exists() and Player:IsWithinCastRange(Target, Bloodthirst) and not Player:Buff(MeatCleaver) and Player:CanCast(Whirlwind) then
                    Player:Cast(Whirlwind);
                    return;
                end
                -- actions.two_targets+=/rampage,if=buff.enrage.down|(rage=100&buff.juggernaut.down)|buff.massacre.up
                if Rampage:Exists() and (not Player:Buff(Enrage) or (Player:Rage() == 100 and not Player:Buff(Juggernaut)) or Player:Buff(Massacre)) and Target:CanCast(Rampage) then
                    Target:Cast(Rampage);
                    return;
                end
                -- actions.two_targets+=/bloodthirst,if=buff.enrage.down
                if Bloodthirst:Exists() and not Player:Buff(Enrage) and Target:CanCast(Bloodthirst) then
                    Target:Cast(Bloodthirst);
                    return;
                end
                -- actions.two_targets+=/raging_blow,if=talent.inner_rage.enabled&spell_targets.whirlwind=2
                if RagingBlow:Exists() and InnerRage:Exists() and NumEnemies == 2 and Target:CanCast(RagingBlow) then
                    Target:Cast(RagingBlow);
                    return;
                end
                -- actions.two_targets+=/whirlwind,if=spell_targets.whirlwind>2
                if Whirlwind:Exists() and Player:IsWithinCastRange(Target, Bloodthirst) and NumEnemies == 3 and Player:CanCast(Whirlwind) then
                    Player:Cast(Whirlwind);
                    return;
                end
                -- actions.two_targets+=/dragon_roar
                -- actions.two_targets+=/bloodthirst
                if Bloodthirst:Exists() and Target:CanCast(Bloodthirst) then
                    Target:Cast(Bloodthirst);
                    return;
                end
            end

            -- actions+=/call_action_list,name=single_target
            module.SetOutput("|cFFE30000Rotation:", "|cFFE30000Single Target");
            -- actions.single_target=odyns_fury
            if OdynsFury:Exists() and (Player:Buff(BattleCry) or BattleCry:Cooldown() > 35 or not (module.IsOptionEnabled("Battle Cry") and (module.CooldownsAllowed() or module.GetOptionValue("Battle Cry") == "Always"))) and module.IsOptionEnabled("Odyn's Fury") and #Enemies_20y >= module.GetOptionValue("Odyn's Fury") and Player:CanCast(OdynsFury) then
                Player:Cast(OdynsFury);
                return;
            end
            -- Juggernaut Support
            if Execute:Exists() and Player:Rage() >= 25 and (Player:BuffRemains(Juggernaut) < 1.8 or Player:Buff(BattleCry) or (DragonRoarEnabled and DragonRoar:Cooldown() < 2 and Player:BuffRemains(Juggernaut) < 3.5)) and module.IsOptionEnabled("Execute") then
                ExecuteHandler();
            end
            -- Stone Hearth & Sens for Death Proc
            if Execute:Exists() and (Player:Buff(StoneHeart) or (Player:Buff(BattleCry) and Player:Buff(SenseForDeath) and Target:HealthPercentage() < 20)) and Target:CanCast(Execute) then
                ExecuteHandler();
            end
            -- actions.single_target+=/rampage,if=rage=100|buff.massacre.up
            if Rampage:Exists() and (Player:Rage() >= 100 or Player:Buff(Massacre)) and Target:CanCast(Rampage) then
                Target:Cast(Rampage);
                return;
            end
            -- actions.single_target+=/rampage,if=buff.enrage.down
            if Rampage:Exists() and not Player:Buff(Enrage) and Target:CanCast(Rampage) then
                Target:Cast(Rampage);
                return;
            end
            -- actions.single_target+=/furious_slash,if=talent.frenzy.enabled&(buff.frenzy.down|buff.frenzy.remains<=3)
            if FuriousSlash:Exists() and Frenzy:Exists() and (not Player:Buff(FrenzyBuff) or (Player:Buff(FrenzyBuff) and Player:BuffRemains(FrenzyBuff) <= 3)) and Target:CanCast(FuriousSlash) then
                Target:Cast(FuriousSlash);
                return;
            end
            -- actions.single_target+=/execute,if=buff.enrage.up&(!talent.massacre.enabled&!talent.inner_rage.enabled)|talent.massacre.enabled&buff.enrage.down|buff.enrage.up&(talent.massacre.enabled&!talent.inner_rage.enabled)
            if Execute:Exists() and Player:Rage() >= 25 and module.IsOptionEnabled("Execute") and ((Player:Buff(Enrage) and (not Massacre:Exists() and not InnerRage:Exists())) or (Massacre:Exists() and not Player:Buff(Enrage)) or (Player:Buff(Enrage) and (Massacre:Exists() and not InnerRage:Exists()))) then
                ExecuteHandler();
            end
            -- actions.single_target+=/bloodthirst,if=!talent.inner_rage.enabled
            if Bloodthirst:Exists() and not InnerRage:Exists() and Target:CanCast(Bloodthirst) then
                Target:Cast(Bloodthirst);
                return;
            end
            -- actions.single_target+=/whirlwind,if=!talent.inner_rage.enabled&buff.wrecking_ball.react
            if Whirlwind:Exists() and Player:IsWithinCastRange(Target, Bloodthirst) and not InnerRage:Exists() and Player:Buff(WreckingBall) and Player:CanCast(Whirlwind) then
                Player:Cast(Whirlwind);
                return;
            end
            -- actions.single_target+=/raging_blow,if=buff.enrage.up
            if RagingBlow:Exists() and Player:Buff(Enrage) and Target:CanCast(RagingBlow) then
                Target:Cast(RagingBlow);
                return;
            end
            -- actions.single_target+=/whirlwind,if=buff.wrecking_ball.react&buff.enrage.up
            if Whirlwind:Exists() and Player:IsWithinCastRange(Target, Bloodthirst) and Player:Buff(WreckingBall) and Player:CanCast(Whirlwind) then
                Player:Cast(Whirlwind);
                return;
            end
            -- actions.single_target+=/execute,if=buff.enrage.up&!talent.frenzy.enabled|talent.frenzy.enabled|talent.massacre.enabled
            if Execute:Exists() and Player:Rage() >= 25 and module.IsOptionEnabled("Execute") and ((Player:Buff(Enrage) and not Frenzy:Exists()) or not Frenzy:Exists() or not Massacre:Exists()) then
                ExecuteHandler();
            end
            -- actions.single_target+=/bloodthirst,if=buff.enrage.down
            if Bloodthirst:Exists() and not Player:Buff(Enrage) and Target:CanCast(Bloodthirst) then
                Target:Cast(Bloodthirst);
                return;
            end
            -- actions.single_target+=/raging_blow
            if RagingBlow:Exists() and (Player:Buff(Enrage) or InnerRage:Exists()) and Target:CanCast(RagingBlow) then
                Target:Cast(RagingBlow);
                return;
            end
            -- actions.single_target+=/bloodthirst
            if Bloodthirst:Exists() and Target:CanCast(Bloodthirst) then
                Target:Cast(Bloodthirst);
                return;
            end
            -- actions.single_target+=/furious_slash
            if FuriousSlash:Exists() and Target:CanCast(FuriousSlash) then
                Target:Cast(FuriousSlash);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Bloodthirst, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Out Of Combat Charge
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and module.IsOptionEnabled("Auto Charge Out Of Combat") and Player:DistanceTo(Target) >= 6.5 and ((BMPullTime() == 60 and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Charge Out Of Combat")) or BMPullTime() <= module.GetSecondOptionValue("Pre-Pot BossMod")) and Player:IsFacing(Target) and Target:CanCast(Charge) then
            Target:Cast(Charge);
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Protection Warrior
    local Rotation = {};
    module.SetRotation(73, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local Enemies_30y, Enemies_15y, Enemies_8y, ShockwaveUnits, NumEnemies = {}, {}, {}, 0, 0; -- Enemies

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicArmor = Item(109220, false, false, true);
        DraenicArmorBuff = Spell(156430, false, false, true);

        --Racials
        ArcaneTorrent = Spell(69179, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(28880, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        Avatar = Spell(107574, false, false, true);
        BattleCry = Spell(1719, false, false, true);
        BerserkerRage = Spell(18499, false, false, true);
        CracklingThunder = Spell(203201);
        DeepWounds = Spell(115767);
        DemoralizingShout = Spell(1160, false, false, true);
        Devastate = Spell(20243, true, true,  true);
        FocusedRage = Spell(204488, false, false, true);
        HeroicThrow = Spell(57755, true, true, true);
        IgnorePain = Spell(190456, false, false, true);
        ImpendingVictory = Spell(202168, true, true, true);
        Intercept = Spell(198304, true, true, true);
        LastStand = Spell(12975, false, false, true);
        NeltharionsFury = Spell(203524, false, false, true);
        Pummel = Spell(6552, true, true, true);
        -- Ravager = Spell(152277, true, true, true);
        Revenge = Spell(6572, false, false, true);
        ShieldBlock = Spell(2565, false, false, true);
        ShieldBlockBuff = Spell(132404);
        ShieldSlam = Spell(23922, true, true, true);
        ShieldWall = Spell(871, false, false, true);
        Shockwave = Spell(46968, true, false, true);
        SpellReflection = Spell(23920, false, false, true);
        StormBolt = Spell(107570, true, true, true);
        Taunt = Spell(355, false, true, true);
        ThunderClap = Spell(6343, false, false, true);
        Ultimatum = Spell(122510);
        Victorious = Spell(32216);
        VictoryRush = Spell(34428, true, true, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {6, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest", "Untanked"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_SUBVALUE("Untanked").."Integrate tanking logic that will priorise the untaked units."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.TauntManagerOptions("Taunt");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Pummel to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Auto Intercept Combat", 220, false, {15, 6.5, 22, 0.5}, nil, "Distance away from the target to auto use charge while in combat");
        module.AddNewOption("General Settings", "Auto Intercept Out Of Combat", 220, false, {15, 6.5, 22, 0.5}, nil, "Distance away from the target to auto use charge while not in combat");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 232, true, {1, "Boss Only", "Always", "Never"}, {0.2, 0, 3, 0.1}, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Avatar", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Avatar."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Battle Cry", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Battle Cry."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Berserker Rage", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Berserker Rage."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be in range to use.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Heroic Throw", 210, true, nil, nil, "Use Heroic Throw while we are out of range.");
        module.AddNewOption("Offensive Settings", "Neltharion's Fury", 220, true, {2, 1, 10, 1}, nil, "Use Neltharion's Fury."..C.TOOLTIP_VALUE.."Amount of units needed in front of us to use.");
        -- module.AddNewOption("Offensive Settings", "Ravager", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {1, 1, 10, 1}, "Use Ravager." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Shockwave", 220, true, {2, 1, 10, 1}, nil, "Use Shockwave."..C.TOOLTIP_VALUE.."Amount of units needed in front of us to use.");
        module.AddNewOption("Offensive Settings", "Storm Bolt", 210, true, nil, nil, "Use Storm Bolt.");
        module.AddNewOption("Offensive Settings", "Thunder Clap", 220, true, {2, 1, 10, 1}, nil, "Use Thunder Clap."..C.TOOLTIP_VALUE.."Amount of units needed within 8 yards around player to use.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Ignore Pain", 222, true, {40, 1, 100, 1}, {90, 20, 101, 1}, "Use Ignore Pain."..C.TOOLTIP_VALUE_1.."Health threshold."..C.TOOLTIP_VALUE_2.."Rage threshold to use Ignore Pain to dump exceeding Rage."..C.TOOLTIP_HINT("You can set it to 101 to completely avoid using it for Rage dumping."));
        module.AddNewOption("Defensive Settings", "Shield Block", 221, true, {50, 1, 100, 1, 0}, {100}, "Use Shield Block."..C.TOOLTIP_VALUE_1.."Health threshold to use with one or two charges."..C.TOOLTIP_VALUE_2.."Health threshold to use with two charges.");
        module.AddNewOption("Defensive Settings", "Victory Rush, Impending Victory", 220, true, {80, 1, 100, 1}, nil, "Use Victory Rush."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Demoralizing Shout", 222, true, {1, 1, 10, 1}, {70, 1, 100, 1}, "Use Demoralizing Shout."..C.TOOLTIP_VALUE_1.."Amount of units needed within 15 yards around player to use."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Last Stand", 220, true, {20, 1, 100, 1}, nil, "Use Last Stand."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Shield Wall", 220, true, {30, 1, 100, 1}, nil, "Use Shield Wall."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Pummel, ArcaneTorrent);
    end


    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        if Player:IsWithinCastRange(Target, Devastate) then
            if not Player:Buff(ShieldBlockBuff) then
                -- Shield Block
                if ShieldBlock:Exists() and module.IsOptionEnabled("Shield Block") and Player:HealthPercentage() <= module.GetOptionValue("Shield Block") and Player:CanCast(ShieldBlock) then
                    Player:Cast(ShieldBlock);
                    return;
                end
                -- Shield Block - 2 Charges
                if ShieldBlock:Exists() and (ShieldBlock:Charges() >= 2 or (ShieldBlock:Charges() == 1 and ShieldBlock:Recharge() < 2)) and module.IsOptionEnabled("Shield Block") and Player:HealthPercentage() <= module.GetSecondOptionValue("Shield Block") and Player:CanCast(ShieldBlock) then
                    Player:Cast(ShieldBlock);
                    return;
                end
            end
            -- Shield Wall
            if ShieldWall:Exists() and module.IsOptionEnabled("Shield Wall") and Player:HealthPercentage() <= module.GetOptionValue("Shield Wall") and Player:CanCast(ShieldWall) then
                Player:Cast(ShieldWall);
                return;
            end
            -- Ignore Pain
            if IgnorePain:Exists() and module.IsOptionEnabled("Ignore Pain") and (Player:HealthPercentage() <= module.GetOptionValue("Ignore Pain") or Player:Rage() >= module.GetSecondOptionValue("Ignore Pain")) and Player:CanCast(IgnorePain) then
                Player:Cast(IgnorePain);
                return;
            end
            -- Last Stand
            if LastStand:Exists() and module.IsOptionEnabled("Last Stand") and Player:HealthPercentage() <= module.GetOptionValue("Last Stand") and Player:CanCast(LastStand) then
                Player:Cast(LastStand);
                return;
            end
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
        -- Victory Rush/Impending Victory
        if module.IsOptionEnabled("Victory Rush, Impending Victory") and Player:HealthPercentage() <= module.GetOptionValue("Victory Rush, Impending Victory") then
            if not ImpendingVictory:Exists() and Player:Buff(Victorious) and Target:CanCast(VictoryRush) then
                Target:Cast(VictoryRush);
                return;
            elseif ImpendingVictory:Exists() and Target:CanCast(ImpendingVictory) then
                Target:Cast(ImpendingVictory);
                return;
            end
        end
    end


    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target or Intercept
        if not (module.IsOptionEnabled("Auto Intercept Combat") and Intercept:Charges() >= 1 and Player:DistanceTo(Target) >= 6.5 and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Intercept Combat") and Player:IsFacing(Target)) then
            Target = Player:ReTarget(ShieldSlam, false) or Unit.Target;
        end
        -- Focused Rage
        if FocusedRage:Exists() and (Player:Rage() >= 110 or Player:Buff(Ultimatum)) and Player:CanCast(FocusedRage) then
            Player:Cast(FocusedRage);
        end
    end

    function Rotation:Opening ()
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicArmorBuff) and DraenicArmor:InStock() and not DraenicArmor:IsOnCooldown() then
            if Player:Potion("Armor", Potion) then Potion = true; end
        end
    end

    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Combat Intercept
            if module.IsOptionEnabled("Auto Intercept Combat") and Target:CanCast(Intercept) and Player:DistanceTo(Target) >= 6.5 and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Intercept Combat") and Player:IsFacing(Target) then
                Target:Cast(Intercept);
                return;
            end
            -- Enemies Check
            if module.UseAOE() then
                Enemies_30y = Player:EnemiesWithinDistance(40, false);
                Enemies_15y = Player:FilterEnemiesByDistance(Enemies_30y, 15, true); -- Demoralizing Shout
                Enemies_8y = not CracklingThunder:Exists() and Player:FilterEnemiesByDistance(Enemies_15y, 8, true) or Enemies_15y; -- Thunderclap
                ShockwaveUnits = #Player:UnitsInFrontCone(10, 140) or 0; -- Shockwave + Neltharion's Fury
                NumEnemies = #Enemies_8y;
            else
                Enemies_15y, Enemies_8y, ShockwaveUnits, NumEnemies = {}, {}, 0, 1;
            end

            -- Taunt
            if Player:TauntManager(Taunt, "Taunt", Target, Enemies_30y) then
                return;
            end

            if Player:IsWithinCastRange(Target, Devastate) then
                -- Demoralizing Shout
                if DemoralizingShout:Exists() and #Enemies_15y > module.GetOptionValue("Demoralizing Shout") and Player:HealthPercentage() <= module.GetSecondOptionValue("Demoralizing Shout") and Player:CanCast(DemoralizingShout) then
                    Player:Cast(DemoralizingShout);
                    return;
                end
                --- Cooldowns ---
                if module.CooldownsAllowed() then
                    Player:UseTrinkets();
                    -- Racials
                    if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                        -- Blood Fury
                        if BloodFury:Exists() and Player:CanCast(BloodFury) then
                            Player:Cast(BloodFury);
                        end
                        -- Berserking
                        if Berserking:Exists() and Player:CanCast(Berserking) then
                            CastSpellByID(26297, "player")
                        end
                        -- Arcane Torrent
                        if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Rage() < Player:RageMax() - 40 then
                            Player:Cast(ArcaneTorrent);
                        end
                    end
                end
                -- Avatar
                if Avatar:Exists() and module.IsOptionEnabled("Avatar") and (module.CooldownsAllowed() or module.GetOptionValue("Avatar") == "Always") and Player:CanCast(Avatar) then
                    Player:Cast(Avatar);
                    return;
                end
                -- Berserker Rage
                if BerserkerRage:Exists() and module.IsOptionEnabled("Berserker Rage") and (module.CooldownsAllowed() or module.GetOptionValue("Berserker Rage") == "Always") and Player:CanCast(BerserkerRage) then
                    Player:Cast(BerserkerRage);
                end
                -- Battle Cry
                if BattleCry:Exists() and module.IsOptionEnabled("Battle Cry") and (module.CooldownsAllowed() or module.GetOptionValue("Battle Cry") == "Always") and Player:CanCast(BattleCry) then
                    Player:Cast(BattleCry);
                end
            end
            -- Rotation
            -- Revenge
            if Revenge:Exists() and Player:IsWithinCastRange(Target, Devastate) and Player:CanCast(Revenge) then
                Player:Cast(Revenge);
                return;
            end
            -- Thunder Clap
            if ThunderClap:Exists() and module.IsOptionEnabled("Thunder Clap") and #Enemies_8y >= module.GetOptionValue("Thunder Clap") and Player:CanCast(ThunderClap) then
                Player:Cast(ThunderClap);
                return;
            end
            --  Shield Slam
            if ShieldSlam:Exists() and Target:CanCast(ShieldSlam) then
                Target:Cast(ShieldSlam);
                return;
            end
            -- -- Ravager
            -- if Ravager:Exists() and module.IsOptionEnabled("Ravager") and Target:CanCast(Ravager) then
            --  if Target:CastGroundSpell(Ravager, "Ravager", 6) then return; end
            -- end
            -- Neltharion's Fury
            if NeltharionsFury:Exists() and Player:Standing() > 0.5 and module.IsOptionEnabled("Neltharion's Fury") and ShockwaveUnits >= module.GetOptionValue("Neltharion's Fury") and Player:CanCast(NeltharionsFury) then
                Player:Cast(NeltharionsFury);
                return;
            end
            -- Revenge/Devastate - Deep Wounds
            if Player:IsWithinCastRange(Target, Devastate) and not Target:Debuff(DeepWounds) then
                if Revenge:Exists() and Player:CanCast(Revenge) then
                    Player:Cast(Revenge);
                    return;
                end
                if Devastate:Exists() and Target:CanCast(Devastate) then
                    Target:Cast(Devastate);
                    return;
                end
            end
            -- shockwave
            if Shockwave:Exists() and module.IsOptionEnabled("Shockwave") and ShockwaveUnits >= module.GetOptionValue("Shockwave") and Player:CanCast(Shockwave) then
                Player:Cast(Shockwave);
                return;
            end
            -- Storm Bolt
            if StormBolt:Exists() and module.IsOptionEnabled("Storm Bolt") and Target:CanCast(StormBolt) then
                Target:Cast(StormBolt);
                return;
            end
            -- Devastate
            if Devastate:Exists() and Target:CanCast(Devastate) then
                Target:Cast(Devastate);
                return;
            end
            -- Heroic Throw
            if HeroicThrow:Exists() and module.IsOptionEnabled("Heroic Throw") and not Player:IsWithinCastRange(Target, Devastate) and Target:CanCast(HeroicThrow) then
                Target:Cast(HeroicThrow);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(ShieldSlam, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Out Of Combat Intercept
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and module.IsOptionEnabled("Auto Intercept Out Of Combat") and Player:DistanceTo(Target) >= 6.5 and ((BMPullTime() == 60 and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Intercept Out Of Combat")) or BMPullTime() <= module.GetSecondOptionValue("Pre-Pot BossMod")) and Player:IsFacing(Target) and Target:CanCast(Intercept) then
            Target:Cast(Intercept);
            return;
        end
    end
end)();
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Unholy Deathknight
    local Rotation = {};
    module.SetRotation("_"..252, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local Enemies_40y, TargetEnemies_8y, EpidemicUnitsCount, OutbreakCount, NumEnemies = {}, {}, 0, 0, 0;
    local IsDarkTransformationEnabled, ShouldArbiter;
    local MainTankResDelay, OffTankResDelay = nil, nil;
    local RuneCount, NextRune, RunicPower = 0, 0, 0;
    module.Arbiter = 0;

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        -- Items
        DraenicStrength = Item(109217, false, false, true);
        DraenicStrengthBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Racials
        ArcaneTorrent = Spell(50613, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59545, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Spells
        Apocalypse = Spell(220143, false, true, true);
        AntiMagicShell = Spell(48707, false, false, true);
        ArmyOfTheDead =Spell(42650, false, false, true);
        BlightedRuneWeapon = Spell(194918, false, false, true);
        ClawingShadows = Spell(207311, true, true, true);
        ControlUndead = Spell(111673, true, true, true);
        CorpseShield = Spell(207319, false, false, true);
        DarkArbiter = Spell(207349, true, true, true);
        DarkCommand = Spell(56222, true, true, true);
        DarkSuccor = Spell(178819);
        DarkSuccorBuff = Spell(101568);
        DarkTransformation = Spell(63560, false, false, true);
        DeathAndDecay = Spell(43265, false, true, true);
        DeathAndDecayBuff = Spell(188290);
        DeathCoil = Spell(47541, true, true, true);
        DeathStrike = Spell(49998, true, true, true);
        Defile = Spell(152280, false, true, true);
        Epidemic = Spell(207317, false, false, true);
        FesteringStrike = Spell(85948, true, true, true);
        FesteringWound = Spell(194310);
        IceboundFortitude = Spell(48792, false, false, true);
        InfectedClaws = Spell(207272);
        MindFreeze = Spell(47528, true, true, true);
        Necrosis = Spell(207346);
        NecrosisBuff = Spell(216974);
        Outbreak = Spell(77575, false, true, true);
        RaiseAlly = Spell(61999, false, false, true, true);
        RaiseDead = Spell(46584, false, false, true);
        ScourgeStrike = Spell(55090, true, true, true);
        ShadowInfusion = Spell(198943);
        SludgeBelcher = Spell(207313);
        SoulReaper = Spell(130736, true, true, true);
        SoulReaperBuff = Spell(215711);
        SuddenDoom = Spell(81340, true, true, true);
        SummonGargoyle = Spell(49206, false, true, true);
        UnholyStrength = Spell(53365);
        VirulentPlague = Spell(191587);
        WraithWalk = Spell(212552, false, false, true);

        -- Ghoul Spells
        Claw = Spell(47468, true, true, true);
        Huddle = Spell(47484, false, false, true)
        Gnaw = Spell(47481, true, true, true);
        -- Abomination Spell
        Cleaver = Spell(212333, true, true, true);
        ProtectiveBile = Spell(212384, false, false, true);
        Smash = Spell(212336, true, true, true)


        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range.\n\n|cffFF0044Mode (Left Box)|r\n|cFF0088FFKeep:|r Cast on the new unit but keep your target the same.\n|cFF0088FFSwitch:|r Cast on the new unit and change your target to this unit.\n\n|cffFF0044Range (Right Box)|r\nSet the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Mind Freeze to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddNewOption("General Settings", "Raise Ally", 210, true, nil, nil, "Use Raise Ally on dead target.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Wraith Walk", 210, false, nil, nil, "Automatically use Wraith Walk while moving and Out of Combat.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Apocalypse", 232, true, {1, "Always", "Cooldown Only"}, {6, 1, 8, 1}, "Use Apocalypse."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("We will always ramp up Festering Wound stacks to 8 prior to using Apocalypse."));
        module.AddNewOption("Offensive Settings", "Blighted Rune Weapon", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Blighted Rune Weapon."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("We will always ramp up Festering Wound stacks to 8 prior to using Apocalypse."));
        module.AddNewOption("Offensive Settings", "Dark Arbiter", 232, true, {2, "Always", "Cooldown Only"}, {80, 1, 100, 1}, "Use Dark Arbiter."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."How much Runic Power should we pool before using Dark Arbiter?");
        module.AddNewOption("Offensive Settings", "Gargoyle", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Gargoyle."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Only usable if Dark Arbiter is not talented."));
        module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Disabled", "Enabled"}, {2, "Disabled", "Enabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Death And Decay", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {2, 1, 10, 1}, "Use Death and Decay." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use."..C.TOOLTIP_HINT("Also used for Defile."));
        module.AddNewOption("Offensive Settings", "Epidemic", 222, true, {5, 1, 10, 1}, {3, 1, 10, 1}, "Use Epidemic."..C.TOOLTIP_VALUE_1.."Amount of enemies that must have Virulent Plague to use."..C.TOOLTIP_VALUE_2.."Amount of enemies that must have Virulent Plague to use as low priority.");
        module.AddNewOption("Offensive Settings", "Pet Damage Handling", 233, true, {1, "Handle Assist", "Do Not Handle Assist"}, {1, "Handle Spells", "Do Not Handle Spells"}, "Manage Pet Casts to use power as high priority only during Dark Transformation."..C.TOOLTIP_VALUE_1.."Enable this to automatically change between assist and passive mode depending if you have a target or not."..C.TOOLTIP_VALUE_2.."Enable this to automatically disable spells the profile should be handling so that they are handled by the rotation."..C.TOOLTIP_HINT("Spells handling applies to Ghoul Claw and Gnaw or Abomination Cleaver and Smash."));

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Death Strike", 222, true, {20, 1, 100, 1}, {70, 1, 100, 1}, "Use Death Strike."..C.TOOLTIP_VALUE_1.."Health threshold to use."..C.TOOLTIP_VALUE_2.."Health threshold to use with Dark Succor buff.");
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, true, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru on self."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Anti-Magic Shell", 220, false, {50, 1, 100, 1}, nil, "Use Anti-Magic Shell."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Corpse Shield", 232, false, {2, "Do Not Use Pet Shield", "Use Pet Shield"}, {25, 1, 100, 1}, "Use Corpse Shield."..C.TOOLTIP_VALUE_1.."Set to Use Pet Shield to allow using the Pet Shield ability (Ghoul Huddle or Abomination Protective Bile)."..C.TOOLTIP_VALUE_2.."Health threshold."..C.TOOLTIP_HINT("If first option is set to Use Pet Shield, the Pet will Shield itself whenever you use Corpse Shield. Even if used manually or if the option to use Corpse Shield is disabled. To prevent Pet from Shielding itself, you need to define it to Do Not Use Pet Shield."));
        module.AddNewOption("Defensive Settings", "Icebound Fortitude", 220, true, {20, 1, 100, 1}, nil, "Use Icebound Fortitude."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we wait to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        -- Anti-Magic Shell - Absorb 33% total health in magic damage - Generate runic power
        if AntiMagicShell:Exists() and module.IsOptionEnabled("Anti-Magic Shell") and Player:HealthPercentage() <= module.GetOptionValue("Anti-Magic Shell") and Player:CanCast(AntiMagicShell) then
            Player:Cast(AntiMagicShell);
        end
        -- Icebound Fortitude
        if IceboundFortitude:Exists() and module.IsOptionEnabled("Icebound Fortitude") and Player:HealthPercentage() <= module.GetOptionValue("Icebound Fortitude") and Player:CanCast(IceboundFortitude) then
            Player:Cast(IceboundFortitude);
        end
        -- Corpse Shield
        if CorpseShield:Exists() and module.IsOptionEnabled("Corpse Shield") and Player:HealthPercentage() <= module.GetSecondOptionValue("Corpse Shield") and Player:CanCast(CorpseShield) then
            Player:Cast(CorpseShield);
        end
        if CorpseShield:Exists() and module.GetOptionValue("Corpse Shield") == "Use Pet Shield" and PlayerPet:Power() > 10 and Player:Buff(CorpseShield) then
            if SludgeBelcher:Exists() and Player:PetCanCast(ProtectiveBile) and ProtectiveBile:TimeSinceCast() > 45 then
                Player:Cast(ProtectiveBile);
                ProtectiveBile.LastCastTime = module.GetTime();
            elseif Player:PetCanCast(Huddle) and Huddle:TimeSinceCast() > 45 then
                Player:Cast(Huddle);
                Huddle.LastCastTime = module.GetTime();
            end
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
        end
    end

    function Rotation:Interrupts ()
        -- Interrupts
        -- Mind Freeze
        Player:UseInterrupt(MindFreeze, ArcaneTorrent);
    end

    -- Handling of Pet Actionbar Abilities
    local PetActionName, IsPetActionActive, PetActionID, PetAssisting;
    local function PlayerPetHandling ()
        -- Player Pet Handling
        if module.IsOptionEnabled("Pet Damage Handling") then
            if PlayerPet:Exists() then
                if module.GetSecondOptionValue("Pet Damage Handling") == "Handle Spells" then
                    -- Disable Spells
                    for i = 1, 10 do
                        PetActionName, _, _, _, _, _, IsPetActionActive, PetActionID = GetPetActionInfo(i);
                        if PetActionID == 212333 or PetActionID == 212336 or PetActionID == 47468 or PetActionID == 47481 then
                            if IsPetActionActive then
                                module.Bug("Disabling "..PetActionName);
                                DisableSpellAutocast(PetActionName);
                            end
                        end
                    end
                end
                -- Assist/Passive Mode
                if module.GetOptionValue("Pet Damage Handling") == "Handle Assist" then
                    if Target:Exists() and not PetAssisting then
                        PetAssistMode();
                        PetAssisting = true;
                    elseif not Target:Exists() and PetAssisting then
                        PetPassiveMode();
                        PetAssisting = false;
                    end
                end
                IsDarkTransformationEnabled = DarkTransformation:Exists() and module.IsOptionEnabled("Dark Transformation") and (module.CooldownsAllowed() or module.GetOptionValue("Dark Transformation") == "Always") or false;
                if SludgeBelcher:Exists() then
                    -- Cleaver
                    if PlayerPet:Buff(DarkTransformation) and Target:PetCanCast(Cleaver) then
                        Target:Cast(Cleaver);
                    elseif (not IsDarkTransformationEnabled or DarkTransformation:Cooldown() > 10 or PlayerPet:Power() >= 80) and Target:PetCanCast(Cleaver) then
                        Target:Cast(Cleaver);
                    end
                    -- Smash
                    if PlayerPet:Buff(DarkTransformation) and Target:PetCanCast(Smash) then
                        Target:Cast(Smash);
                    elseif (not IsDarkTransformationEnabled or DarkTransformation:Cooldown() > 25) and Target:PetCanCast(Smash) then
                        Target:Cast(Smash);
                    end
                else
                    -- Claw
                    if PlayerPet:Buff(DarkTransformation) and Target:PetCanCast(Claw) then
                        Target:Cast(Claw);
                    elseif (not IsDarkTransformationEnabled or DarkTransformation:Cooldown() > 10 or PlayerPet:Power() >= 80) and Target:PetCanCast(Claw) then
                        Target:Cast(Claw);
                    end
                    -- Gnaw
                    if PlayerPet:Buff(DarkTransformation) and Target:PetCanCast(Gnaw) then
                        Target:Cast(Gnaw);
                    elseif (not IsDarkTransformationEnabled or DarkTransformation:Cooldown() > 25) and Target:PetCanCast(Gnaw) then
                        Target:Cast(Gnaw);
                    end
                end
            end
        else
            if PlayerPet:Exists() then
                if module.GetSecondOptionValue("Pet Damage Handling") == "Handle Spells" then
                    -- Enable Spells
                    for i = 1, 10 do
                        PetActionName, _, _, _, _, _, IsPetActionActive, PetActionID = GetPetActionInfo(i);
                        if PetActionID == 212333 or PetActionID == 212336 or PetActionID == 47468 or PetActionID == 47481 then
                            if not IsPetActionActive then
                                module.Bug("Enabling "..PetActionName);
                                EnableSpellAutocast(PetActionName);
                            end
                        end
                    end
                end
            end
        end
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        PlayerPetHandling();
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura "..HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(FesteringStrike, false) or Unit.Target;
    end

    local function PetHandler ()
        if (UnitExists("PlayerPet") == false or UnitIsDeadOrGhost("PlayerPet")) and Player:CanCast(RaiseDead) then
            Player:Cast(RaiseDead);
            return;
        end
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        -- Raise Ally
        if RaiseAlly:Exists() and module.IsOptionEnabled("Raise Ally") and Target:Exists() and Target:IsDeadOrGhost() and Target:IsPlayer() and Target:CanCast(RaiseAlly) then
            Target:Cast(RaiseAlly);
            return;
        end
        PetHandler();
        -- Common values for SimC Calculations
        RuneCount, NextRune = Player:Runes();
        RunicPower = Player:RunicPower();
        if Target:Exists() and Player:CanAttack(Target) then
            -- Enemies Check
            if module.UseAOE() then
                if RefreshEnemies < module.GetTime() then
                    Enemies_40y = Player:EnemiesWithinDistance(40, false);
                    EpidemicUnitsCount = Epidemic:Exists() and #Player:FilterEnemiesByDebuff(Enemies_40y, VirulentPlague) or 0;
                    TargetEnemies_8y = Target:EnemiesWithinDistance(8, true);
                    OutbreakCount = #Target:FilterEnemiesByDebuff(TargetEnemies_8y, VirulentPlague) or 0;
                    NumEnemies = #TargetEnemies_8y;
                    RefreshEnemies = module.GetTime() + 0.2;
                end
            else
                Enemies_40y, TargetEnemies_8y, EpidemicUnitsCount, OutbreakCount, NumEnemies = {}, {}, 0, 0, 1;
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, FesteringStrike) then
                --- Cooldowns ---
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and RunicPower < 70 and Player:CanCast(ArcaneTorrent) then
                        Player:Cast(ArcaneTorrent);
                        return;
                    end
                end
            end

            -- actions+=/outbreak,target_if=!dot.virulent_plague.ticking
            if Outbreak:Exists() and not Target:Debuff(VirulentPlague) and Target:CanCast(Outbreak) then
                Target:Cast(Outbreak);
                return;
            end
            -- actions+=/dark_transformation
            if DarkTransformation:Exists() and Player:CanCast(DarkTransformation) then
                Player:Cast(DarkTransformation);
                return;
            end
            -- actions+=/blighted_rune_weapon
            if BlightedRuneWeapon:Exists() and module.IsOptionEnabled("Blighted Rune Weapon") and (module.CooldownsAllowed() or module.GetOptionValue("Blighted Rune Weapon") == "Always") and Player:CanCast(BlightedRuneWeapon) then
                Player:Cast(BlightedRuneWeapon);
                return;
            end

            -- actions+=/run_action_list,name=valkyr,if=talent.dark_arbiter.enabled&pet.valkyr_battlemaiden.active
            if DarkArbiter:Exists() and module.GetTime() < module.Arbiter then
                -- actions.valkyr=death_coil
                if DeathCoil:Exists() and RunicPower >= 35 and Target:CanCast(DeathCoil) then
                    Target:Cast(DeathCoil);
                    return;
                end
                -- actions.valkyr+=/call_action_list,name=aoe,if=active_enemies>=2
                if NumEnemies >= 2 then
                    -- actions.aoe=death_and_decay,if=spell_targets.death_and_decay>=2
                    if not Defile:Exists() and DeathAndDecay:Exists() and module.IsOptionEnabled("Death And Decay") and Target:CanCast(DeathAndDecay) then
                        if Target:CastGroundSpell(DeathAndDecay, "Death And Decay", 10) then return; end
                    end
                    -- actions.aoe+=/epidemic,if=spell_targets.epidemic>4
                    if Epidemic:Exists() and module.IsOptionEnabled("Epidemic") and EpidemicUnitsCount >= module.GetOptionValue("Epidemic") and Player:CanCast(Epidemic) then
                        Player:Cast(Epidemic);
                        return;
                    end
                    -- actions.aoe+=/scourge_strike,if=spell_targets.scourge_strike>=2&(dot.death_and_decay.ticking|dot.defile.ticking)
                    if ScourgeStrike:Exists() and Player:Buff(DeathAndDecay) and Target:CanCast(ScourgeStrike) then
                        Target:Cast(ScourgeStrike);
                        return;
                    end
                    -- actions.aoe+=/clawing_shadows,if=spell_targets.clawing_shadows>=2&(dot.death_and_decay.ticking|dot.defile.ticking)
                    if ClawingShadows:Exists() and Player:Buff(DeathAndDecay) and Target:CanCast(ClawingShadows) then
                        Target:Cast(ClawingShadows);
                        return;
                    end
                    -- actions.aoe+=/epidemic,if=spell_targets.epidemic>2
                    if Epidemic:Exists() and module.IsOptionEnabled("Epidemic") and EpidemicUnitsCount >= module.GetSecondOptionValue("Epidemic") and Player:CanCast(Epidemic) then
                        Player:Cast(Epidemic);
                        return;
                    end
                end
                -- actions.valkyr+=/festering_strike,if=debuff.festering_wound.stack<=6
                if FesteringStrike:Exists() and Target:DebuffCount(FesteringWound) <= 6 and Target:CanCast(FesteringStrike) then
                    Target:Cast(FesteringStrike);
                    return;
                end
                -- actions.valkyr+=/scourge_strike,if=debuff.festering_wound.up
                if ScourgeStrike:Exists() and Target:Debuff(FesteringWound) and Target:CanCast(ScourgeStrike) then
                    Target:Cast(ScourgeStrike);
                    return;
                end
                -- actions.valkyr+=/clawing_shadows,if=debuff.festering_wound.up
                if ClawingShadows:Exists() and Target:Debuff(FesteringWound) and Target:CanCast(ClawingShadows) then
                    Target:Cast(ClawingShadows);
                    return;
                end
                return;
            end

            -- actions+=/call_action_list,name=generic
            -- actions.generic=dark_arbiter,if=runic_power>80
            if DarkArbiter:Exists() and module.IsOptionEnabled("Dark Arbiter") and (module.CooldownsAllowed() or module.GetOptionValue("Dark Arbiter") == "Always") and RunicPower >= module.GetSecondOptionValue("Dark Arbiter") and Target:CanCast(DarkArbiter) then
                Target:Cast(DarkArbiter);
                return;
            end
            -- actions.generic+=/summon_gargoyle
            if not DarkArbiter:Exists() and SummonGargoyle:Exists() and module.IsOptionEnabled("Summon Gargoyle") and (module.CooldownsAllowed() or module.GetOptionValue("Summon Gargoyle") == "Always") and Target:CanCast(SummonGargoyle) then
                Target:Cast(SummonGargoyle);
                return;
            end
            -- actions.generic+=/death_coil,if=runic_power>80
            if DeathCoil:Exists() and RunicPower > 80 and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil);
                return;
            end
            -- actions.generic+=/death_coil,if=runic_power>80&cooldown.dark_arbiter.remains>5
            if DeathCoil:Exists() and RunicPower > 80 and DarkArbiter:Cooldown() > 5 and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil);
                return;
            end
            -- actions.generic+=/death_coil,if=talent.dark_arbiter.enabled&buff.sudden_doom.react&cooldown.dark_arbiter.remains>5
            if DeathCoil:Exists() and DarkArbiter:Exists() and Player:Buff(SuddenDoom) and DarkArbiter:Cooldown() > 5 and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil);
                return;
            end
            -- actions.generic+=/death_coil,if=!talent.dark_arbiter.enabled&buff.sudden_doom.react
            if DeathCoil:Exists() and not DarkArbiter:Exists() and Player:Buff(SuddenDoom) and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil);
                return;
            end
            -- actions.generic+=/soul_reaper,if=debuff.festering_wound.stack>=3
            if SoulReaper:Exists() and Target:DebuffCount(FesteringWound) >= 3 and Target:CanCast(SoulReaper) then
                Target:Cast(SoulReaper);
                return;
            end
            -- actions.generic+=/festering_strike,if=debuff.soul_reaper.up&!debuff.festering_wound.up
            if FesteringStrike:Exists() and Target:Debuff(SoulReaper) and not Target:Debuff(FesteringWound) and Target:CanCast(FesteringStrike) then
                Target:Cast(FesteringStrike);
                return;
            end
            -- actions.generic+=/scourge_strike,if=debuff.soul_reaper.up&debuff.festering_wound.stack>=1
            if ScourgeStrike:Exists() and Target:Debuff(SoulReaper) and Target:Debuff(FesteringWound) and Target:CanCast(ScourgeStrike) then
                Target:Cast(ScourgeStrike);
                return;
            end
            -- actions.generic+=/clawing_shadows,if=debuff.soul_reaper.up&debuff.festering_wound.stack>=1
            if ClawingShadows:Exists() and Target:Debuff(SoulReaper) and Target:Debuff(FesteringWound) and Target:CanCast(ClawingShadows) then
                Target:Cast(ClawingShadows);
                return;
            end
            -- actions.generic+=/defile
            if Defile:Exists() and module.IsOptionEnabled("Death And Decay") and Target:CanCast(Defile) then
                if Target:CastGroundSpell(Defile, "Death And Decay", 10) then return; end
            end
            -- actions.generic+=/call_action_list,name=aoe,if=active_enemies>=2
            if NumEnemies >= 2 then
                -- actions.aoe=death_and_decay,if=spell_targets.death_and_decay>=2
                if not Defile:Exists() and DeathAndDecay:Exists() and module.IsOptionEnabled("Death And Decay") and Target:CanCast(DeathAndDecay) then
                    if Target:CastGroundSpell(DeathAndDecay, "Death And Decay", 10) then return; end
                end
                -- actions.aoe+=/epidemic,if=spell_targets.epidemic>4
                if Epidemic:Exists() and module.IsOptionEnabled("Epidemic") and EpidemicUnitsCount >= module.GetOptionValue("Epidemic") and Player:CanCast(Epidemic) then
                    Player:Cast(Epidemic);
                    return;
                end
                -- actions.aoe+=/scourge_strike,if=spell_targets.scourge_strike>=2&(dot.death_and_decay.ticking|dot.defile.ticking)
                if ScourgeStrike:Exists() and Player:Buff(DeathAndDecay) and Target:CanCast(ScourgeStrike) then
                    Target:Cast(ScourgeStrike);
                    return;
                end
                -- actions.aoe+=/clawing_shadows,if=spell_targets.clawing_shadows>=2&(dot.death_and_decay.ticking|dot.defile.ticking)
                if ClawingShadows:Exists() and Player:Buff(DeathAndDecay) and Target:CanCast(ClawingShadows) then
                    Target:Cast(ClawingShadows);
                    return;
                end
                -- actions.aoe+=/epidemic,if=spell_targets.epidemic>2
                if Epidemic:Exists() and module.IsOptionEnabled("Epidemic") and EpidemicUnitsCount >= module.GetSecondOptionValue("Epidemic") and Player:CanCast(Epidemic) then
                    Player:Cast(Epidemic);
                    return;
                end
            end
            -- actions.generic+=/festering_strike,if=debuff.festering_wound.stack<=4
            if FesteringStrike:Exists() and Target:DebuffCount(FesteringWound) <= 4 and Target:CanCast(FesteringStrike) then
                Target:Cast(FesteringStrike);
                return;
            end
            -- actions.generic+=/scourge_strike,if=buff.necrosis.react
            if ScourgeStrike:Exists() and Player:Buff(NecrosisBuff) and Target:CanCast(ScourgeStrike) then
                Target:Cast(ScourgeStrike);
                return;
            end
            -- actions.generic+=/clawing_shadows,if=buff.necrosis.react
            if ClawingShadows:Exists() and Player:Buff(NecrosisBuff) and Target:CanCast(ClawingShadows) then
                Target:Cast(ClawingShadows);
                return;
            end
            -- actions.generic+=/scourge_strike,if=buff.unholy_strength.react
            if ScourgeStrike:Exists() and Player:Buff(UnholyStrength) and Target:CanCast(ScourgeStrike) then
                Target:Cast(ScourgeStrike);
                return;
            end
            -- actions.generic+=/clawing_shadows,if=buff.unholy_strength.react
            if ClawingShadows:Exists() and Player:Buff(UnholyStrength) and Target:CanCast(ClawingShadows) then
                Target:Cast(ClawingShadows);
                return;
            end
            -- actions.generic+=/scourge_strike,if=rune>=3
            if ScourgeStrike:Exists() and RuneCount >= 3 and Target:CanCast(ScourgeStrike) then
                Target:Cast(ScourgeStrike);
                return;
            end
            -- actions.generic+=/clawing_shadows,if=rune>=3
            if ClawingShadows:Exists() and RuneCount >= 3 and Target:CanCast(ClawingShadows) then
                Target:Cast(ClawingShadows);
                return;
            end
            -- actions.generic+=/death_coil,if=talent.shadow_infusion.enabled&talent.dark_arbiter.enabled&!buff.dark_transformation.up&cooldown.dark_arbiter.remains>15
            if DeathCoil:Exists() and ShadowInfusion:Exists() and DarkArbiter:Exists() and not PlayerPet:Buff(DarkTransformation) and DarkArbiter:Cooldown() > 15 and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil);
                return;
            end
            -- actions.generic+=/death_coil,if=talent.shadow_infusion.enabled&!talent.dark_arbiter.enabled&!buff.dark_transformation.up
            if DeathCoil:Exists() and ShadowInfusion:Exists() and not DarkArbiter:Exists() and not PlayerPet:Buff(DarkTransformation) and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil);
                return;
            end
            -- actions.generic+=/death_coil,if=talent.dark_arbiter.enabled&cooldown.dark_arbiter.remains>15
            if DeathCoil:Exists() and not ShadowInfusion:Exists() and DarkArbiter:Exists() and DarkArbiter:Cooldown() > 15 and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil);
                return;
            end
            -- actions.generic+=/death_coil,if=!talent.shadow_infusion.enabled&!talent.dark_arbiter.enabled
            if DeathCoil:Exists() and not ShadowInfusion:Exists() and not DarkArbiter:Exists() and Target:CanCast(DeathCoil) then
                Target:Cast(DeathCoil);
                return;
            end
        end
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(ScourgeStrike, module.GetOptionValue("Target | Attack"));
            if AutoAttack then
                AutoAttack:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        PetHandler();
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicStrengthBuff) and DraenicStrength:InStock() and not DraenicStrength:IsOnCooldown() then
            if Player:Potion("Strength", Potion) then Potion = true; end
        end
        -- Wraith Walk when we run more than choosen time
        if WraithWalk:Exists() and module.IsOptionEnabled("Wraith Walk") and Player:IsMoving() and Player:CanCast(WraithWalk) then
            Player:Cast(WraithWalk);
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() -- Leveling Frost Deathknight
    local Rotation = {};
    module.SetRotation("_"..251, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local Enemies_8y, FrostscytheUnits, GlacialAdvanceEnemies, SindragosasFuryEnemies, TargetEnemies_8y = {}, 0, 0, 0, {};
    local ShouldObliteration, RunesDump, ShouldBreath = false, false, false;
    local MainTankResDelay, OffTankResDelay = nil, nil;

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        -- Items
        DraenicStrength = Item(109217, false, false, true);
        DraenicStrengthBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Racials
        ArcaneTorrent = Spell(50613, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59545, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Spells
        AntiMagicShell = Spell(48707, false, false, true);
        BreathOfSindragosa = Spell(152279, false, false, true);
        ControlUndead = Spell(111673, true, true, true);
        DarkCommand = Spell(56222, true, true, true);
        DarkSuccor = Spell(178819);
        DarkSuccorBuff = Spell(101568);
        DeathStrike = Spell(49998, true, true, true);
        EmpowerRuneWeapon = Spell(47568, false, false, true);
        FrostFever = Spell(55095);
        Frostscythe =Spell(207230, false, false, true);
        FrostStrike = Spell(49143, true, true, true);
        FrozenPulse = Spell(194909);
        GlacialAdvance = Spell(194913, false, false, true);
        KillingMachine = Spell(51124);
        HornOfWinter = Spell(57330, false, false, true);
        HowlingBlast = Spell(49184, true, true, true);
        HungeringWeapon = Spell(207127, false, false, true);
        IceboundFortitude = Spell(48792, false, false, true);
        IcyTalons = Spell(194878);
        IcyTalonsBuff = Spell(194879);
        MindFreeze = Spell(47528, true, true, true);
        Obliterate = Spell(49020, true, true, true);
        Obliteration = Spell(207256);
        PillarOfFrost = Spell(51271, false, false, true);
        RaiseAlly = Spell(61999, false, false, true, true);
        RemorselessWinter = Spell(196770, false, false, true);
        Rime = Spell(59052);
        SindragosasFury = Spell(190778, false, false, true);
        WraithWalk = Spell(212552, false, false, true);

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range.\n\n|cffFF0044Mode (Left Box)|r\n|cFF0088FFKeep:|r Cast on the new unit but keep your target the same.\n|cFF0088FFSwitch:|r Cast on the new unit and change your target to this unit.\n\n|cffFF0044Range (Right Box)|r\nSet the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Mind Freeze to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddNewOption("General Settings", "Raise Ally", 210, true, nil, nil, "Use Raise Ally on dead target.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Wraith Walk", 210, false, nil, nil, "Automatically use Wraith Walk while moving and Out of Combat.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Breath Of Sindragosa", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Breath Of Sindragosa."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Empower Rune Weapon", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Empower Rune Weapon."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Include Hungering Rune Weapon talent."));
        module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Obliteration", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Obliteration."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Pillar Of Frost", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Pillar Of Frost."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Disabled", "Enabled"}, {2, "Disabled", "Enabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Frostscythe", 220, true, {2, 1, 10, 1}, nil, "Use Frostscythe."..C.TOOLTIP_VALUE.."Amount of enemies that must be in 5y in front of player to use."..C.TOOLTIP_HINT("Frostscythe will be used with as few as 1 unit when we have the Killing Machine buff."));
        module.AddNewOption("Offensive Settings", "Glacial Advance", 222, true, {2, 1, 10, 1}, {1, 1, 10, 1}, "Use Glacial Advance."..C.TOOLTIP_VALUE_1.."Amount of enemies that must be in the 20y corridor in front of player to use as high priority."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the 20y corridor in front of player to use as low priority.");
        module.AddNewOption("Offensive Settings", "Howling Blast", 220, true, {7, 1, 20, 1}, nil, "Use Howling Blast filler rather than Obliterate."..C.TOOLTIP_VALUE.."Amount of enemies that must be in 8 yards around our target to use Howling Blast instead of Obliterate when no procs and we have at least 3 Runes."..C.TOOLTIP_HINT("Lower it if you use the Freezing Fog talent."));
        module.AddNewOption("Offensive Settings", "Remorseless Winter", 222, true, {3, 1, 10, 1}, {2, 1, 10, 1}, "Use Remorseless Winter."..C.TOOLTIP_VALUE_1.."Amount of enemies that must be in 8y around player to use as high priority."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in 8y around player to use as low priority.");
        module.AddNewOption("Offensive Settings", "Sindragosa's Fury", 222, true, {2, 1, 10, 1}, {1, 1, 10, 1}, "Use Sindragosa's Fury."..C.TOOLTIP_VALUE_1.."Amount of enemies that must be in the 40y corridor in front of player to use as high priority."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the 40y corridor in front of player to use as low priority.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Death Strike", 222, true, {20, 1, 100, 1}, {70, 1, 100, 1}, "Use Death Strike."..C.TOOLTIP_VALUE_1.."Health threshold to use."..C.TOOLTIP_VALUE_2.."Health threshold to use with Dark Succor buff.");
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, true, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru on self."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Icebound Fortitude", 220, true, {30, 1, 100, 1}, nil, "Use Icebound Fortitude."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Anti-Magic Shell", 220, false, {50, 1, 100, 1}, nil, "Use Anti-Magic Shell."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we wait to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        -- Anti-Magic Shell - Absorb 33% total health in magic damage - Generate runic power
        if AntiMagicShell:Exists() and module.IsOptionEnabled("Anti-Magic Shell") and Player:HealthPercentage() <= module.GetOptionValue("Anti-Magic Shell") and Player:CanCast(AntiMagicShell) then
            Player:Cast(AntiMagicShell);
        end
        -- Icebound Fortitude
        if IceboundFortitude:Exists() and module.IsOptionEnabled("Icebound Fortitude") and Player:HealthPercentage() <= module.GetOptionValue("Icebound Fortitude") and Player:CanCast(IceboundFortitude) then
            Player:Cast(IceboundFortitude);
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
        end
    end

    function Rotation:Interrupts ()
        -- Interrupts
        -- Mind Freeze
        Player:UseInterrupt(MindFreeze, ArcaneTorrent);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura "..HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(Obliterate, false) or Unit.Target;
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        -- Raise Ally
        if RaiseAlly:Exists() and module.IsOptionEnabled("Raise Ally") and Target:Exists() and Target:IsDeadOrGhost() and Target:IsPlayer() and Target:CanCast(RaiseAlly) then
            Target:Cast(RaiseAlly);
            return;
        end
        local RuneCount, NextRune = Player:Runes();
        if Target:Exists() and Player:CanAttack(Target) then
            -- Enemies Check
            if module.UseAOE() and RefreshEnemies < module.GetTime() then
                Enemies_8y = Player:EnemiesWithinDistance(8, true); -- Remorseless Winter
                FrostscytheUnits = #Player:UnitsInFrontCone(5, 180); -- Frostscythe Cone.
                GlacialAdvanceEnemies = #Player:UnitsInFrontRectangle(20, 5); -- Glacial Advance
                SindragosasFuryEnemies = #Player:UnitsInFrontRectangle(40, 5); -- Sindragosa's Fury
                TargetEnemies_8y = Target:EnemiesWithinDistance(10); -- Howling Blast
                RefreshEnemies = module.GetTime() + 0.2;
            else
                Enemies_8y, FrostscytheUnits, GlacialAdvanceEnemies, SindragosasFuryEnemies, TargetEnemies_8y = {}, 0, 0, 0, {};
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, Obliterate) then
                --- Cooldowns ---
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Obliteration
                if Obliteration:Exists() and module.IsOptionEnabled("Obliteration") and (module.CooldownsAllowed() or module.GetOptionValue("Obliteration") == "Always") and Obliteration:Cooldown() < 6 then
                    if Player:RunicPower() >= 80 and Player:CanCast(Obliteration) then
                        Player:Cast(Obliteration);
                        ShouldObliteration = false;
                        return;
                    else
                        ShouldObliteration = true;
                    end
                else
                    ShouldObliteration = false;
                end
                -- Pillar of Frost
                if PillarOfFrost:Exists() and module.IsOptionEnabled("Pillar Of Frost") and (module.CooldownsAllowed() or module.GetOptionValue("Pillar Of Frost") == "Always") and Player:CanCast(PillarOfFrost) then
                    Player:Cast(PillarOfFrost);
                    return;
                end
                -- Empower/Hungering Rune Weapon
                if module.IsOptionEnabled("Empower Rune Weapon") and (module.CooldownsAllowed() or module.GetOptionValue("Empower Rune Weapon") == "Always") then
                    if not HungeringWeapon:Exists() and EmpowerRuneWeapon:Exists() and Player:CanCast(EmpowerRuneWeapon) then
                        if RuneCount < 1 then
                            Player:Cast(EmpowerRuneWeapon);
                            return;
                        else
                            RunesDump = true
                        end
                    end
                    if HungeringWeapon:Exists() and Player:CanCast(HungeringWeapon) then
                        if RuneCount < 3 then
                            Player:Cast(HungeringWeapon);
                            return;
                        else
                            RunesDump = true
                        end
                    end
                else
                    RunesDump = false
                end
                -- Breath Of Sindragosa
                if BreathOfSindragosa:Exists() then
                    if module.IsOptionEnabled("Breath Of Sindragosa") and (module.CooldownsAllowed() or module.GetOptionValue("Breath Of Sindragosa") == "Always") and BreathOfSindragosa:Cooldown() < 8 then
                        if Player:CanCast(BreathOfSindragosa) and Player:RunicPower() >= 80 then
                            ShouldBreath = false;
                            Player:Cast(BreathOfSindragosa);
                            return;
                        end
                        ShouldBreath = true;
                    else
                        ShouldBreath = false;
                    end
                    if Player:Buff(BreathOfSindragosa) then
                        ShouldBreath = true;
                        RunesDump = true;
                    end
                else
                    ShouldBreath = false;
                end
            end

            -- Death Strike - Healing + Dark Succor
            if DeathStrike:Exists() and (Player:HealthPercentage() <= module.GetOptionValue("Death Strike") or (Player:Buff(DarkSuccorBuff) and Player:HealthPercentage() <= module.GetSecondOptionValue("Death Strike"))) and Target:CanCast(DeathStrike) then
                Target:Cast(DeathStrike);
                return;
            end
            -- Frost Strike - Obliteration
            if FrostStrike:Exists() and Player:Buff(Obliteration) and not Player:Buff(KillingMachine) and Target:CanCast(FrostStrike) then
                Target:Cast(FrostStrike);
                return;
            end
            -- Obliterate/Frostscythe - Obliteration
            if Player:Buff(Obliteration) and RuneCount >= 2 and Player:Buff(KillingMachine) then
                if Frostscythe:Exists() and module.IsOptionEnabled("Frostscythe") and FrostscytheUnits >= 1 and Player:CanCast(Frostscythe) then
                    Player:Cast(Frostscythe);
                    return;
                end
                if Obliterate:Exists() and Target:CanCast(Obliterate) then
                    Target:Cast(Obliterate);
                    return;
                end
            end
            -- Frost Strike - Dump (80)
            if FrostStrike:Exists() and not Player:Buff(BreathOfSindragosa) and Player:RunicPower() >= 80 and Target:CanCast(FrostStrike) then
                Target:Cast(FrostStrike);
                return;
            end
            -- Frost Strike - Icy Talons
            if not ShouldBreath and not ShouldObliteration and IcyTalons:Exists() and FrostStrike:Exists() and Player:Buff(IcyTalonsBuff) and Player:BuffRemains(IcyTalonsBuff) < 2.5 and Player:RunicPower() >= 25 and Target:CanCast(FrostStrike) then
                Target:Cast(FrostStrike);
                return;
            end
            -- Howling Blast - Frost Fever
            if HowlingBlast:Exists() and not Target:Debuff(FrostFever) and Target:CanCast(HowlingBlast) then
                Target:Cast(HowlingBlast);
                return;
            end
            -- Obliterate/Frostscythe - Killing Machine
            if Player:Buff(KillingMachine) then
                if Frostscythe:Exists() and module.IsOptionEnabled("Frostscythe")and FrostscytheUnits >= 1 and Player:CanCast(Frostscythe) then
                    Player:Cast(Frostscythe);
                    return;
                end
                if Obliterate:Exists() and RuneCount >= 2 and Target:CanCast(Obliterate) then
                    Target:Cast(Obliterate);
                    return;
                end
            end
            -- Glacial Advance - High Prio
            if GlacialAdvance:Exists() and module.IsOptionEnabled("Glacial Advance") and GlacialAdvanceEnemies >= module.GetOptionValue("Glacial Advance") and Player:CanCast(GlacialAdvance) then
                Player:Cast(GlacialAdvance);
                return;
            end
            -- Sindragosa's Fury - High Prio
            if SindragosasFury:Exists() and module.IsOptionEnabled("Sindragosa's Fury") and SindragosasFuryEnemies >= module.GetOptionValue("Sindragosa's Fury") and Player:CanCast(SindragosasFury) then
                Player:Cast(SindragosasFury);
                return;
            end
            -- Remorseless Winter - High Prio
            if RemorselessWinter:Exists() and module.IsOptionEnabled("Remorseless Winter") and #Enemies_8y >= module.GetOptionValue("Remorseless Winter") and Player:CanCast(RemorselessWinter) then
                Player:Cast(RemorselessWinter);
                return;
            end
            -- Howling Blast - Rime
            if HowlingBlast:Exists() and Player:Buff(Rime) and Target:CanCast(HowlingBlast) then
                Target:Cast(HowlingBlast);
                return;
            end
            -- Glacial Advance - Low Prio
            if GlacialAdvance:Exists() and module.IsOptionEnabled("Glacial Advance") and GlacialAdvanceEnemies >= module.GetSecondOptionValue("Glacial Advance") and Player:CanCast(GlacialAdvance) then
                Player:Cast(GlacialAdvance);
                return;
            end
            -- Sindragosa's Fury - Low Prio
            if SindragosasFury:Exists() and module.IsOptionEnabled("Sindragosa's Fury") and SindragosasFuryEnemies >= module.GetSecondOptionValue("Sindragosa's Fury") and Player:CanCast(SindragosasFury) then
                Player:Cast(SindragosasFury);
                return;
            end
            -- Remorseless Winter - Low Prio
            if RemorselessWinter:Exists() and module.IsOptionEnabled("Remorseless Winter") and #Enemies_8y >= module.GetSecondOptionValue("Remorseless Winter") and Player:CanCast(RemorselessWinter) then
                Player:Cast(RemorselessWinter);
                return;
            end
            -- Frost Strike - Dump (60)
            if not ShouldBreath and not ShouldObliteration and not IcyTalons:Exists() and FrostStrike:Exists() and Player:RunicPower() >= 60 and Target:CanCast(FrostStrike) then
                Target:Cast(FrostStrike);
                return;
            end
            -- Obliterate/Howling Blast - 3+ Runes or Frozen Pulse
            if RuneCount >= 3 or (RuneCount >= 2 and NextRune < 3) or FrozenPulse:Exists() or RunesDump then
                -- Howling Blast
                if HowlingBlast:Exists() and module.IsOptionEnabled("Howling Blast") and #TargetEnemies_8y >= module.GetOptionValue("Howling Blast") and Target:CanCast(HowlingBlast) then
                    Target:Cast(HowlingBlast);
                    return;
                end
                -- Obliterate/Frostscythe
                if Frostscythe:Exists() and module.IsOptionEnabled("Frostscythe") and FrostscytheUnits >= module.GetOptionValue("Frostscythe") and Player:CanCast(Frostscythe) then
                    Player:Cast(Frostscythe);
                    return;
                end
                if Obliterate:Exists() and RuneCount >= 2 and Target:CanCast(Obliterate) then
                    Target:Cast(Obliterate);
                    return;
                end
                -- Howling Bast
                if FrozenPulse:Exists() and HowlingBlast:Exists() and not Player:Buff(KillingMachine) and ((RuneCount >= 1 and RuneCount < 2 and NextRune >= 3) or RunesDump) and Target:CanCast(HowlingBlast) then
                    module.Bug("Howling Blast - Clear Runes for Frozen Pulse");
                    Target:Cast(HowlingBlast);
                    return;
                end
            end
            -- Hown of Winter
            if HornOfWinter:Exists() and Player:CanCast(HornOfWinter) then
                Player:Cast(HornOfWinter);
                return;
            end
            -- Frost Strike - Filler
            if not ShouldBreath and not ShouldObliteration and not IcyTalons:Exists() and FrostStrike:Exists() and Player:RunicPower() >= 25 and Target:CanCast(FrostStrike) then
                Target:Cast(FrostStrike);
                return;
            end
        end
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Obliterate, module.GetOptionValue("Target | Attack"));
            if AutoAttack then
                AutoAttack:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicStrengthBuff) and DraenicStrength:InStock() and not DraenicStrength:IsOnCooldown() then
            if Player:Potion("Strength", Potion) then Potion = true; end
        end
        -- Wraith Walk when we run more than choosen time
        if WraithWalk:Exists() and module.IsOptionEnabled("Wraith Walk") and Player:IsMoving() and Player:CanCast(WraithWalk) then
            Player:Cast(WraithWalk);
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() -- Leveling Blood Deathknight
    local Rotation = {};
    module.SetRotation("_"..250, Rotation);

    --- Localization
    -- Core
    local Enemies_30y, Enemies_10y, RefreshEnemies = {}, {}, 0;
    local SpamPrevention, TPSTime = 0, 0.1; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local MainTankResDelay, OffTankResDelay = nil, nil;

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        -- Items
        DraenicArmor = Item(109220, false, false, true);
        DraenicArmorBuff = Spell(156430, false, false, true);
        DraenicStrength = Item(109217, false, false, true);
        DraenicStrengthBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Racials
        ArcaneTorrent = Spell(50613, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59545, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Spells
        AntiMagicShell = Spell(48707, false, false, true);
        Asphyxiate = Spell(221562, true, true, true);
        BloodBoil = Spell(50842, false, false, true);
        BloodDrinker = Spell(206931, true, true, true);
        BloodMirror = Spell(206977, true, true, true);
        BloodPlague = Spell(55078, false, false, true);
        BloodTap = Spell(221699, false, false, true);
        BoneShield = Spell(195181, false, false, true);
        Bonestorm = Spell(194844, false, false, true);
        Consumption = Spell(205223, true, true, true);
        ControlUndead = Spell(111673, true, true, true);
        DancingRuneWeapon = Spell(49028, false, true, true);
        DancingRuneWeaponBuff = Spell(81256, false, false, true);
        DarkCommand = Spell(56222, true, true, true);
        DeathAndDecay = Spell(43265, false, true, true);
        DeathAndDecayBuff = Spell(188290, false, false, true);
        DeathStrike = Spell(49998, true, true, true);
        DeathsCaress = Spell(195292, true, true, true);
        Exsanguinate = Spell(206931, true, true, true);
        HearthStrike = Spell(206930, true, true, true);
        MarkOfBlood = Spell(206940, true, true, true);
        MarrowRend = Spell(195182, true, true, true);
        MindFreeze = Spell(47528, true, true, true);
        RaiseAlly = Spell(61999, false, false, true, true);
        RuneTap = Spell(194679, false, false, true);
        Soulgorge = Spell(212744, false, false, true);
        Tombstone = Spell(219809, false, false, true);
        VampiricBlood = Spell(55233, false, false, true);
        WraithWalk = Spell(212552, false, false, true);

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {6, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest", "Untanked"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_SUBVALUE("Untanked").."Integrate tanking logic that will priorise the untaked units."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range.\n\n|cffFF0044Mode (Left Box)|r\n|cFF0088FFKeep:|r Cast on the new unit but keep your target the same.\n|cFF0088FFSwitch:|r Cast on the new unit and change your target to this unit.\n\n|cffFF0044Range (Right Box)|r\nSet the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.TauntManagerOptions("Dark Command");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Mind Freeze to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddNewOption("General Settings", "Raise Ally", 210, true, nil, nil, "Use Raise Ally on dead target.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Wraith Walk", 210, false, nil, nil, "Automatically use Wraith Walk while moving and Out of Combat.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Only Arcane Torrent is supported."));
        module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Disabled", "Enabled"}, {2, "Disabled", "Enabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Bonestorm", 222, true, {2, 1, 10, 1}, {90, 10, 100, 5}, "Use Bonestorm." .. C.TOOLTIP_VALUE .. "Amount of enemies that must be in melee range to use." .. C.TOOLTIP_VALUE_2 .. "Required Runic Power to use.");
        module.AddNewOption("Offensive Settings", "Death And Decay", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {1, 1, 10, 1}, "Use Death and Decay." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Death's Caress", 122, true, {3, 1, 10, 1}, {3, 0, 25, 0.1}, "Death's Caress Cycle for Soulgorge." .. C.TOOLTIP_VALUE_1 .. "Number of dots to apply." .. C.TOOLTIP_VALUE_2 .. "Minimum enemy health (in million) to apply." .. C.TOOLTIP_HINT("Only used when the Soulgorge talent is selected."));
        module.AddNewOption("Offensive Settings", "Soulgorge", 220, true, {2, 0, 20, 0.1}, nil, "Use Soulgorge." .. C.TOOLTIP_VALUE .. "Remaining seconds on the Blood Plague that will expire next to use Soulgorge." .. C.TOOLTIP_HINT("Lesser is usually better."))

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Death Strike", 222, true, {20, 1, 100, 1}, {80, 1, 100, 1}, "Use Death Strike." .. C.TOOLTIP_VALUE_1 .. "Health threshold to use as high priority." .. C.TOOLTIP_VALUE_2 .. "Health threshold to use as low priority.");
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, true, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddNewOption("Defensive Settings", "Mark Of Blood", 222, true, {100, 1, 100, 1}, {5, 0, 25, 0.1}, "Use Mark of Blood." .. C.TOOLTIP_VALUE_1 .. "Health threshold." .. C.TOOLTIP_VALUE_2 .. "Minimum enemy health (in million) to apply.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru on self." .. C.TOOLTIP_VALUE .. "Health threshold.");
        end
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Anti-Magic Shell", 220, false, {50, 1, 100, 1}, nil, "Use Anti-Magic Shell."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Blood Drinker", 220, true, {85, 1, 100, 1}, nil, "Use Blood Drinker." .. C.TOOLTIP_VALUE_1 .. "Health threshold.");
        module.AddNewOption("Defensive Settings", "Blood Mirror", 222, true, {20, 1, 100, 1}, {3, 0, 25, 0.1}, "Use Blood Mirror." .. C.TOOLTIP_VALUE_1 .. "Health threshold." .. C.TOOLTIP_VALUE_2 .. "Minimum enemy health (in million) to apply.");
        module.AddNewOption("Defensive Settings", "Dancing Rune Weapon", 220, true, {40, 1, 100, 1}, nil, "Use Dancing Rune Weapon." .. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddNewOption("Defensive Settings", "Rune Tap", 222, true, {20, 1, 100, 1}, {80, 1, 100, 1}, "Use Rune Tap." .. C.TOOLTIP_VALUE_1 .. "Health threshold to use when we have 1 charge." .. C.TOOLTIP_VALUE_2 .. "Health threshold to use when we have 2 charges.");
        module.AddNewOption("Defensive Settings", "Tombstone", 222, true, {5, 1, 10, 1}, {40, 1, 100, 1}, "Use Tombstone." .. C.TOOLTIP_VALUE_1 .. "Minimum Bone Shield stacks to use." .. C.TOOLTIP_VALUE_2 .. "Health threshold.");
        module.AddNewOption("Defensive Settings", "Vampiric Blood", 220, true, {20, 1, 100, 1}, nil, "Use Vampiric Blood." .. C.TOOLTIP_VALUE .. "Health threshold.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we wait to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        if module.CooldownsAllowed() and not Player:Buff(Tombstone) and not Player:Buff(RuneTap) and not Player:Buff(DancingRuneWeapon) and not Player:Buff(VampiricBlood) then
            local Shielded = false;
            -- Tombstone - Consume Bone Shield stacks and shield up to 3% per stack for 8 seconds
            if Tombstone:Exists() and module.IsOptionEnabled("Tombstone") and Player:BuffCount(BoneShield) >= module.GetOptionValue("Tombstone") and Player:HealthPercentage() <= module.GetSecondOptionValue("Tombstone") and Player:CanCast(Tombstone) then
                Player:Cast(Tombstone);
                Shielded = true;
            end
            -- Rune Tap - Reduce damage taken by 25% for 3 seconds
            if not Shielded and RuneTap:Exists() and module.IsOptionEnabled("Rune Tap") and ((Player:HealthPercentage() <= module.GetOptionValue("Rune Tap")) or (RuneTap:Charges() >= 2 and Player:HealthPercentage() <= module.GetSecondOptionValue("Rune Tap"))) and Player:CanCast(RuneTap) then
                Player:Cast(RuneTap);
                Shielded = true;
            end
            -- Dancing Rune Weapon - 40% parry chance
            if not Shielded and DancingRuneWeapon:Exists() and module.IsOptionEnabled("Dancing Rune Weapon") and Player:HealthPercentage() <= module.GetOptionValue("Dancing Rune Weapon") and Target:CanCast(DancingRuneWeapon) then
                Target:Cast(DancingRuneWeapon);
                Shielded = true;
            end
            -- Vampiric Blood - Increase Max Health / Increased Healing Received
            if not Shielded and VampiricBlood:Exists() and module.IsOptionEnabled("Vampiric Blood") and Player:HealthPercentage() <= module.GetOptionValue("Vampiric Blood") and Player:CanCast(VampiricBlood) then
                Player:Cast(VampiricBlood);
            end
        end
        -- Anti-Magic Shell - Absorb 33% total health in magic damage - Generate runic power
        if AntiMagicShell:Exists() and module.IsOptionEnabled("Anti-Magic Shell") and Player:HealthPercentage() <= module.GetOptionValue("Anti-Magic Shell") and Player:CanCast(AntiMagicShell) then
            Player:Cast(AntiMagicShell);
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
        end
    end

    function Rotation:Interrupts ()
        -- Interrupts
        -- Mind Freeze
        Player:UseInterrupt(MindFreeze, ArcaneTorrent);
        -- Asphyxiate
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(HearthStrike, false) or Unit.Target;
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        -- Raise Ally
        if RaiseAlly:Exists() and module.IsOptionEnabled("Raise Ally") and Target:Exists() and Target:IsDeadOrGhost() and Target:IsPlayer() and Target:CanCast(RaiseAlly) then
            Target:Cast(RaiseAlly);
            return;
        end

        -- Runes
        local RuneCount, NextRune = Player:Runes();

        if Target:Exists() and Player:CanAttack(Target) and not Target:IsDeadOrGhost() then

            -- Enemies Check
            if module.UseAOE() and RefreshEnemies < module.GetTime() then
                Enemies_30y = Player:EnemiesWithinDistance(30, false);
                Enemies_10y = Player:FilterEnemiesByDistance(Enemies_30y, 10, true);
                Enemies_5y = module.IsOptionEnabled("Bonestorm") and Player:FilterEnemiesByDistance(Enemies_10y, 6.5, true) or {};
                RefreshEnemies = module.GetTime() + 0.2;
            else
                Enemies_30y, Enemies_10y, Enemies_5y = {}, {}, {};
            end

            -- Dark Command
            if Player:TauntManager(DarkCommand, "Dark Command", Target, Enemies_30y) then
                return;
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, HearthStrike) then
                --- Cooldowns ---
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
            end
            -- Rotation
            if Consumption:Exists() and Target:CanCast(Consumption) then
                Target:Cast(Consumption);
                return;
            end
            -- MarrowRend - 2 Runes - Apply 3 BoneShield charges - Active Mitigation
            if MarrowRend:Exists() and Target:CanCast(MarrowRend) and (Player:BuffCount(BoneShield) < 2 or Player:BuffRemains(BoneShield) < 3) then
                Target:Cast(MarrowRend);
                return;
            end
            -- Death Strike - High Priority Heal
            if DeathStrike:Exists() and module.IsOptionEnabled("Death Strike") and Player:HealthPercentage() <= module.GetOptionValue("Death Strike") and Target:CanCast(DeathStrike) then
                Target:Cast(DeathStrike);
                return;
            end
            -- Blood Mirror
            if BloodMirror:Exists() and module.IsOptionEnabled("Blood Mirror") and Player:HealthPercentage() <= module.GetOptionValue("Blood Mirror") and Target:Health() >= module.GetSecondOptionValue("Blood Mirror")*1000000 and Target:CanCast(BloodMirror) then
                Target:Cast(BloodMirror);
                return;
            end
            -- Bonestorm - Dump Runic Power
            if Bonestorm:Exists() and module.IsOptionEnabled("Bonestorm") and #Enemies_5y >= module.GetOptionValue("Bonestorm") and Player:RunicPower() >= module.GetSecondOptionValue("Bonestorm") and Player:CanCast(Bonestorm) then
                Player:Cast(Bonestorm);
                return;
            end
            -- Death Strike - Dump Runic Power
            if DeathStrike:Exists() and module.IsOptionEnabled("Death Strike") and (not module.IsOptionEnabled("Bonestorm") or not Bonestorm:Exists() or Bonestorm:Cooldown() > 2 or #Enemies_5y < module.GetOptionValue("Bonestorm")) and Player:RunicPower() >= 75 and Target:CanCast(DeathStrike) then
                Target:Cast(DeathStrike);
                return;
            end
            -- If Soulgorge then we should apply blood plague via DeathsCaress (multi-dot)
            -- then when all units have dots and the first applied dot is about to fall off we Soulgorge
            if DeathsCaress:Exists() and Soulgorge:Exists() then
                local LowestUnitDuration, BestUnitToCastOn, PlaguedUnits, DeathsCaressThreshold = 24, nil, 0, module.GetSecondOptionValue("Death's Caress")*1000000;
                for i = 1, #Enemies_30y do
                    local ThisUnit = Enemies_30y[i];
                    local ThisUnitDebuffDuration = ThisUnit:DebuffRemains(BloodPlague);
                    LowestUnitDuration = ThisUnitDebuffDuration > 0 and ThisUnitDebuffDuration < LowestUnitDuration and ThisUnitDebuffDuration or LowestUnitDuration
                    if ThisUnitDebuffDuration == 0 then
                        BestUnitToCastOn = (ThisUnit:IsDummy() or ThisUnit:Health() >= DeathsCaressThreshold) and ThisUnit:CanCast(DeathsCaress) and ThisUnit:Level() < Player:Level() + 5 and not (Player:Level() < 110 and ThisUnit:Level() == -1) and ThisUnit or BestUnitToCastOn;
                    end
                end
                if LowestUnitDuration < module.GetOptionValue("Soulgorge") and Player:CanCast(Soulgorge) then
                    Player:Cast(Soulgorge);
                    return;
                end
                if PlaguedUnits < module.GetOptionValue("Death's Caress") and BestUnitToCastOn then
                    BestUnitToCastOn:Cast(DeathsCaress);
                    return;
                end
            end
            -- Blood Boil Cycle - Apply Blood Plague / DeathsCaress if > 10 yard
            if BloodBoil:Exists() and not Soulgorge:Exists() and Player:CanCast(BloodBoil) then
                for i = 1, #Enemies_10y do
                    local ThisUnit = Enemies_10y[i];
                    if ThisUnit:DebuffRemains(BloodPlague) < 3 then
                        Player:Cast(BloodBoil);
                        return;
                    end
                end
            end
            -- Blood Tap - Generate 1 rune - Cooldown reduced when Bone Shield charges are used
            if BloodTap:Exists() and RuneCount < 3 and Player:CanCast(BloodTap) then
                Player:Cast(BloodTap);
                return;
            end
            -- Death and Decay - Increase Targets hit by Hearth Strike to 3 when we are in it
            if DeathAndDecay:Exists() and module.IsOptionEnabled("Death And Decay") and Target:CanCast(DeathAndDecay) then
                if Player:CastGroundSpell(DeathAndDecay, "Death And Decay", 10) then return; end
            end
            -- Mark of Blood
            if MarkOfBlood:Exists() and module.IsOptionEnabled("Mark Of Blood") and not Target:Debuff(MarkOfBlood) and Player:HealthPercentage() <= module.GetOptionValue("Mark Of Blood") and Target:Health() >= module.GetSecondOptionValue("Mark Of Blood")*1000000 and Target:CanCast(MarkOfBlood) then
                Target:Cast(MarkOfBlood);
                return;
            end
            -- Death Strike - Low Priority Heal
            if DeathStrike:Exists() and module.IsOptionEnabled("Death Strike") and Player:HealthPercentage() <= module.GetSecondOptionValue("Death Strike") and Target:CanCast(DeathStrike) then
                Target:Cast(DeathStrike);
                return;
            end
            -- Blood Drinker
            if BloodDrinker:Exists() and module.IsOptionEnabled("Blood Drinker") and Player:HealthPercentage() <= module.GetOptionValue("Blood Drinker") and Target:CanCast(BloodDrinker) then
                Target:Cast(BloodDrinker);
                return;
            end
            if RuneCount >= 2.5 then
                if Player:DistanceTo(Target) > 10 then
                    -- Death's Caress - Out of Range
                    if DeathsCaress:Exists() and Target:CanCast(DeathsCaress) and not Target:Debuff(BloodPlague) then
                        Target:Cast(DeathsCaress);
                        return;
                    end
                else
                    -- MarrowRend - Stack up to 10 stacks
                    if MarrowRend:Exists() and Target:CanCast(MarrowRend) and Player:BuffCount(BoneShield) <= 7 then
                        Target:Cast(MarrowRend);
                        return;
                    end
                    -- Hearth Strike - 1 Rune - Generate 5 Runic Power
                    if HearthStrike:Exists() and Target:CanCast(HearthStrike) then
                        Target:Cast(HearthStrike);
                        return;
                    end
                end
            end
            -- Blood Boil - Filler
            if BloodBoil:Exists() and Player:IsWithinCastRange(Target, HearthStrike) and Player:CanCast(BloodBoil) then
                Player:Cast(BloodBoil);
                return;
            end
        end
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(HearthStrike, module.GetOptionValue("Target | Attack"));
            if AutoAttack then
                AutoAttack:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicArmorBuff) and DraenicArmor:InStock() and not DraenicArmor:IsOnCooldown() then
            if Player:Potion("Armor", Potion) then Potion = true; end
        end
        -- Deaths Advance when we run more than choosen time
        if WraithWalk:Exists() and module.IsOptionEnabled("Wraith Walk") and Player:IsMoving() and Player:CanCast(WraithWalk) then
            Player:Cast(WraithWalk);
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Havoc Demon Hunter Rotation
    local Rotation = {};
    module.SetRotation("_"..577, Rotation);

    --- Localization
    -- Core
    local Enemies_8y, EyeBeamNumEnemies, NumEnemies = {}, 1, 1; -- Enemies
    local SpamPrevention, TPSTime = 0, 0.1; -- Combat Module Throttle
    local UpdateInterruptPercentage, InterruptPercentage = 0, 1; -- Interrupt Module
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local MetamorphosisTimer, MetamorphosisCasted, MetamorphosisReset = 0, nil, nil; -- Metamorphosis Handler
    local NoPathFromEvent, NoPathFromEventPositionX, NoPathFromEventPositionY, NoPathFromEventPositionZ = nil, nil, nil, nil; -- No Path Available Handler
    local EyeBeamStanding, EyeBeamPooling = 0.7, nil; -- Time to Stand before casting Eye Beam (because movements cancel it) and EyeBeam Pooling Variable.
    local VR_FR_FB_Sync, FelBladeTarget = -1, nil; -- Variable to do Vengeful Retreat / Fel Rush / Felblade trick.

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        --- Spells
        -- (ID, RequiresFacing, Hostile, Instant)
        -- Racials
        ArcaneTorrent = Spell(202719, false, false, true);
        Shadowmeld = Spell(58984, false, false, true);
        -- Items
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Abilities
        Annihilation = Spell(201427, true, true, true);
        BladeDance = Spell(188499, false, false, true);
        ChaosNova = Spell(179057, false, false, true);
        ChaosStrike = Spell(162794, true, true, true);
        ConsumeMagic = Spell(183752, true, true, true);
        DeathSweep = Spell(210152, false, false, true);
        Demonic = Spell(213410, false, false, true);
        DemonsBite = Spell(162243, true, true, true);
        EyeBeam = Spell(198013, false, false, true);
        FelBarrage = Spell(211053, true, true, true);
        FelBlade = Spell(213241, true, true, true);
        FelEruption = Spell(211881, true, true, true);
        FelRush = Spell(195072, false, false, true);
        FirstBlood = Spell(206416, false, false, true);
        Momentum = Spell(206476, false, false, true);
        Nemesis = Spell(206491, true, true, true);
        Prepared = Spell(203551, false, false, true);
        ThrowGlaive = Spell(185123, true, true, true);
        VengefulRetreat = Spell(198793, false, false, true);
        -- Offensive Cooldowns
        ChaosBlades = Spell(211048, false, false, true);
        FuryoftheIllidari = Spell(201467, false, false, true);
        Metamorphosis = Spell(191427, false, false, true);
        MetamorphosisBuff = Spell(162264, false, false, true);
        -- Defensive Cooldowns
        Blur = Spell(198589, false, false, true);
        BlurBuff = Spell(212800, false, false, true);
        Netherwalk = Spell(196555, false, false, true);

        --- GUI Frame
        -- Pages
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Consume Magic to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "VR | FR Trick", 210, false, nil, nil, "Enable for the automatic usage of Vengeful Retreat -> Fel Rush trick to proc Momentum.\n\nYou need Prepared and Momentum talents.\n\nYou will need to get back in melee range yourself.");
        module.AddNewOption("General Settings", "VR | FR | FB Trick", 210, true, nil, nil, "Enable for the automatic usage of Vengeful Retreat -> Fel Rush -> Felblade trick to proc Momentum while staying in melee range.\n\nYou need Prepared, Felblade and Momentum talents.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Chaos Blades | Fel Barrage", 223, true, {4, 1, 5, 1}, {2, "Always", "Cooldown Only"}, "Enable for the automatic usage of Chaos Blades | Fel Barrage."..C.TOOLTIP_VALUE_1.."If you have Fel Barrage as talent, select how many charges you want to have in order to cast it."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Fury of the Illidari", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Fury of the Illidari."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Nemesis", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Nemesis."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Metamorphosis", 210, true, nil, nil, "Enable for the automatic usage of Metamorphosis.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Only Arcane Torrent is supported."));
        end
        module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Disabled", "Enabled"}, {2, "Disabled", "Enabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Eye Beam", 220, true, {1, 1, 5, 1}, {1, "Always", "Cooldown Only"}, "Enable for the automatic usage of Eye Beam."..C.TOOLTIP_VALUE_1.."Set the number of enemies required in front of you."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Chaos Nova", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Chaos Nova."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Fel Eruption", 210, true, nil, nil, "Enable for the automatic usage of Fel Eruption.");
        module.AddNewOption("Offensive Settings", "Felblade", 210, true, nil, nil, "Enable for the automatic usage of Felblade.");
        module.AddNewOption("Offensive Settings", "Throw Glaive", 210, true, nil, nil, "Enable for the automatic usage of Throw Glaive.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Health Percentage to use Healing Belt / Healing Pot / Healthstone.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, false, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Blur | Netherwalk", 220, true, {25, 1, 100, 1}, nil, "Health Percentage to use Blur or Netherwalk.");

        --- Misc
        -- Status Frame
        Player:AddCommonMeleeStatus();
        module.AddOutput("Next VR | FR Trick :");
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
        -- No Path Available Handler Event Register
        local PathFrame = CreateFrame("FRAME", "PathFrameFrame");
        PathFrame:RegisterEvent("UI_ERROR_MESSAGE");
        local function PathCheck(Self, Event, Message)
            -- Legion Alpha Message : SPELL_FAILED_NOPATH = 50;
            if Message == SPELL_FAILED_NOPATH or Message == 50 then
                NoPathFromEvent = true;
                NoPathFromEventPositionX, NoPathFromEventPositionY, NoPathFromEventPositionZ = Player:Position():Expand();
            end
        end
        PathFrame:SetScript("OnEvent", PathCheck);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Blur | Netherwalk") and Player:HealthPercentage() <= module.GetOptionValue("Blur | Netherwalk") then
            if not Netherwalk:Exists() then
                if not Player:Buff(BlurBuff)  and Player:CanCast(Blur) then
                    Player:Cast(Blur);
                end
            else
                if not Player:Buff(Netherwalk) and Player:CanCast(Netherwalk) then
                    Player:Cast(Netherwalk);
                end
            end
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(ConsumeMagic, ArcaneTorrent);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(DemonsBite, false) or Unit.Target;
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Enemies Check
            if module.UseAOE() then
                Enemies_8y = Player:EnemiesWithinDistance(8, true, false);
                NumEnemies = #Enemies_8y;
            else
                NumEnemies = 1;
            end
            -- Eye Beam Handler
            if module.IsOptionEnabled("Eye Beam") then
                EyeBeamNumEnemies = #Player:UnitsInFrontRectangle(16, 3); -- Measured on 04/18/2016 : 7.0.3.21491 (Normal Range + Pythagore for Width)
            end
            EyeBeamPooling = false; -- Reset EyeBeam Pooling
            -- No Path Available Handler (Check if we moved or not since last error)
            if NoPathFromEvent then
                local X, Y, Z = Player:Position():Expand();
                if NoPathFromEventPositionX ~= X or NoPathFromEventPositionY ~= Y or NoPathFromEventPositionZ ~= Z then
                    NoPathFromEvent = false;
                    NoPathFromEventPositionX, NoPathFromEventPositionY, NoPathFromEventPositionZ = nil, nil, nil;
                end
            end
            -- Status Update
            if Momentum:Exists() and Prepared:Exists() then
                if FelBlade:Exists() then
                    if module.IsOptionEnabled("VR | FR | FB Trick") then
                        module.SetOutput("Next VR | FR Trick :", tostring(math.floor(math.max(VengefulRetreat:Cooldown(), FelRush:Cooldown(), FelBlade:Cooldown()))).."s");
                    else
                        module.SetOutput("Next VR | FR Trick :", "Disabled");
                    end
                else
                    if module.IsOptionEnabled("VR | FR Trick") then
                        module.SetOutput("Next VR | FR Trick :", tostring(math.floor(math.max(VengefulRetreat:Cooldown(), FelRush:Cooldown()))).."s");
                    else
                        module.SetOutput("Next VR | FR Trick :", "Disabled");
                    end
                end
            else
                module.SetOutput("Next VR | FR Trick :", "Disabled");
            end
            -- Cooldowns
            if not MetamorphosisReset and module.GetTime()-MetamorphosisTimer > 2 then MetamorphosisCasted, MetamorphosisReset = false, true; module.Bug("Metamorphosis Buffer Reset"); end
            if Player:IsWithinCastRange(Target, DemonsBite) then
                if module.CooldownsAllowed() then
                    -- Metamorphosis
                    if module.IsOptionEnabled("Metamorphosis") and Metamorphosis:Exists() and (not module.IsOptionEnabled("Eye Beam") or EyeBeam:IsOnCooldown()) and not NoPathFromEvent and not Player:Buff(MetamorphosisBuff) and Player:CanCast(Metamorphosis) then
                        Player:CastGround(Metamorphosis);
                        MetamorphosisTimer, MetamorphosisCasted, MetamorphosisReset = module.GetTime(), true, false;
                        return;
                    end
                    -- Trinkets
                    if Trinket1:IsUsableInventory() and module.GetOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket1:UseInventory();
                    end
                    if Trinket2:IsUsableInventory() and module.GetSecondOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket2:UseInventory();
                    end
                end
                -- Arcane Torrent
                if ArcaneTorrent:Exists() and module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:Power() < Player:PowerMax()-30 and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent);
                    return;
                end
                -- Chaos Blades | Fel Barrage
                if module.IsOptionEnabled("Chaos Blades | Fel Barrage") and (module.CooldownsAllowed() or module.GetSecondOptionValue("Chaos Blades | Fel Barrage") == "Always") then
                    if ChaosBlades:Exists() and Player:CanCast(ChaosBlades) then
                        Player:Cast(ChaosBlades);
                        return;
                    end
                    if FelBarrage:Exists() and FelBarrage:Charges() >= module.GetOptionValue("Chaos Blades | Fel Barrage") and Target:CanCast(FelBarrage) then
                        Target:Cast(FelBarrage);
                        return;
                    end
                end
                -- Nemesis
                if module.IsOptionEnabled("Nemesis") and Nemesis:Exists() and (module.CooldownsAllowed() or module.GetOptionValue("Nemesis") == "Always") and Target:CanCast(Nemesis) then
                    Target:Cast(Nemesis);
                end
                -- Fury of the Illidari
                if module.IsOptionEnabled("Fury of the Illidari") and FuryoftheIllidari:Exists() and (module.CooldownsAllowed() or module.GetOptionValue("Fury of the Illidari") == "Always") and Player:CanCast(FuryoftheIllidari) then
                    Player:Cast(FuryoftheIllidari);
                    return;
                end
            end
            if Momentum:Exists() and Prepared:Exists() then
                --Vengeful Retreat / Fel Rush / Felblade trick
                if module.IsOptionEnabled("VR | FR | FB Trick") and FelBlade:Exists() then
                    if (Target:CanCast(FelBlade) or (module.GetTime()-VR_FR_FB_Sync < 1 and module.GetTime()-VR_FR_FB_Sync > 0)) and not NoPathFromEvent then
                        if Player:CanCast(VengefulRetreat) and Player:CanCast(FelRush) then
                            Player:Cast(VengefulRetreat);
                            Player:Cast(FelRush);
                            FelBladeTarget = Target;
                            VR_FR_FB_Sync = module.GetTime();
                            return;
                        end
                        if module.GetTime()-VR_FR_FB_Sync > 0.4 and FelBladeTarget and FelBladeTarget:CanCast(FelBlade) then
                            FelBladeTarget:Cast(FelBlade);
                            VR_FR_FB_Sync = -1;
                            return;
                        end
                    end
                -- Vengeful Retreat / Fel Rush trick
                elseif module.IsOptionEnabled("VR | FR Trick") then
                    if Player:CanCast(VengefulRetreat) and Player:CanCast(FelRush) then
                        Player:Cast(VengefulRetreat);
                        Player:Cast(FelRush);
                        return;
                    end
                end
            end
            -- Eye Beam
            if module.IsOptionEnabled("Eye Beam") and EyeBeam:Exists() and (module.CooldownsAllowed() or module.GetSecondOptionValue("Eye Beam") == "Always") and (module.GetOptionValue("Eye Beam") == 1 or (module.GetOptionValue("Eye Beam") > 1 and module.UseAOE())) and EyeBeamNumEnemies >= module.GetOptionValue("Eye Beam") and Player:Standing() >= EyeBeamStanding then
                EyeBeamPooling = true; -- In case we want to pool for EyeBeam
                if Player:CanCast(EyeBeam) then
                    Player:Cast(EyeBeam);
                    return;
                end
            end
            if (EyeBeam:IsOnCooldown() or not EyeBeamPooling) then
                -- AoE Rotation
                if NumEnemies >= 2 then
                    -- Chaos Nova AoE
                    if module.IsOptionEnabled("Chaos Nova") and ChaosNova:Exists() and (module.CooldownsAllowed() or module.GetOptionValue("Chaos Nova") == "Always") and Player:CanCast(ChaosNova) then
                        Player:Cast(ChaosNova);
                        return;
                    end
                    -- Spender AoE
                    if Player:Buff(MetamorphosisBuff) then
                        if Player:CanCast(DeathSweep) then
                            Player:Cast(DeathSweep);
                            return;
                        end
                    else
                        if BladeDance:Exists() and Player:CanCast(BladeDance) then
                            Player:Cast(BladeDance);
                            return;
                        end
                    end
                end
                -- Single Target Rotation
                if module.IsOptionEnabled("Fel Eruption") and FelEruption:Exists() and Target:CanCast(FelEruption) then
                    Target:Cast(FelEruption);
                    return;
                end
                -- Use Blade Dance in Single Target if we have First Blood talent.
                if FirstBlood:Exists() then
                    if Player:Buff(MetamorphosisBuff) then
                        if Player:CanCast(DeathSweep) then
                            Player:Cast(DeathSweep);
                            return;
                        end
                    else
                        if Player:CanCast(BladeDance) then
                            Player:Cast(BladeDance);
                            return;
                        end
                    end
                end
            end
            -- Throw Glaive AoE
            if module.UseAOE() and module.IsOptionEnabled("Throw Glaive") and ThrowGlaive:Exists() then
                if Player:Chain(ThrowGlaive, 3, 10, 30, true) then
                    return;
                else
                    if Player:Chain(ThrowGlaive, 2, 10, 30, true) then
                        return;
                    end
                end
            end
            -- Spender Single
            if (EyeBeam:IsOnCooldown() or not EyeBeamPooling) and (Player:Power() >= Player:PowerMax()*0.6 or Player:Buff(MetamorphosisBuff)) then
                if Player:Buff(MetamorphosisBuff) or MetamorphosisCasted then
                    if Target:CanCast(Annihilation) then
                        Target:Cast(Annihilation);
                        return;
                    end
                else
                    if Target:CanCast(ChaosStrike) then
                        Target:Cast(ChaosStrike);
                        return;
                    end
                end
            end
            -- Fel Blade
            if module.IsOptionEnabled("Felblade") and FelBlade:Exists() and not NoPathFromEvent and (not Momentum:Exists() or (not module.IsOptionEnabled("VR | FR | FB Trick") or VengefulRetreat:Cooldown() > 5)) and Target:CanCast(FelBlade) then
                Target:Cast(FelBlade);
                return;
            end
            -- Demon's Bite
            if Target:CanCast(DemonsBite) then
                Target:Cast(DemonsBite);
                return;
            end
            -- Throw Glaive Out of Range
            if module.IsOptionEnabled("Throw Glaive") and ThrowGlaive:Exists() and Target:CanCast(ThrowGlaive) then
                Target:Cast(ThrowGlaive);
                return;
            end
            return;
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Status Update
        if Momentum:Exists() and Prepared:Exists() then
            if FelBlade:Exists() then
                if module.IsOptionEnabled("VR | FR | FB Trick") then
                    module.SetOutput("Next VR | FR Trick :", tostring(math.floor(math.max(VengefulRetreat:Cooldown(), FelRush:Cooldown(), FelBlade:Cooldown()))).."s");
                else
                    module.SetOutput("Next VR | FR Trick :", "Disabled");
                end
            else
                if module.IsOptionEnabled("VR | FR Trick") then
                    module.SetOutput("Next VR | FR Trick :", tostring(math.floor(math.max(VengefulRetreat:Cooldown(), FelRush:Cooldown()))).."s");
                else
                    module.SetOutput("Next VR | FR Trick :", "Disabled");
                end
            end
        else
            module.SetOutput("Next VR | FR Trick :", "Disabled");
        end
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        -- Engage Target
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            if Player:Buff(MetamorphosisBuff) or MetamorphosisCasted then
                if Target:CanCast(Annihilation) then
                    Target:Cast(Annihilation);
                    return;
                end
            else
                if Target:CanCast(ChaosStrike) then
                    Target:Cast(ChaosStrike);
                    return;
                end
            end
            if module.IsOptionEnabled("Felblade") and FelBlade:Exists() and not NoPathFromEvent and Target:CanCast(FelBlade) then
                Target:Cast(FelBlade);
                return;
            end
            if Target:CanCast(DemonsBite) then
                Target:Cast(DemonsBite);
                return;
            end
            if module.IsOptionEnabled("Throw Glaive") and ThrowGlaive:Exists() and Target:CanCast(ThrowGlaive) then
                Target:Cast(ThrowGlaive);
                return;
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Vengeance Demon Hunter Rotation
    local Rotation = {};
    module.SetRotation("_"..581, Rotation);

    --- Localization
    -- Core
    local TargetEnemies_8y, Enemies_30y, Enemies_5y1, FelDevastationNumEnemies, NumEnemies, NumEnemies_5_1 = {}, {}, {}, 1, 1, 1; -- Enemies
    local SpamPrevention, TPSTime = 0, 0.1; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local NoPathFromEvent, NoPathFromEventPositionX, NoPathFromEventPositionY, NoPathFromEventPositionZ = nil, nil, nil, nil; -- No Path Available Handler
    local FelDevastationStanding = 0.7; -- Time to Stand before casting Fel Devastation (because movements cancel it).

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        --- Spells
        -- (ID, RequiresFacing, Hostile, Instant)
        -- Racials
        ArcaneTorrent = Spell(202719, false, false, true);
        Shadowmeld = Spell(58984, false, false, true);
        -- Items
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Abilities
        ConsumeMagic = Spell(183752, true, true, true);
        DemonSpikes = Spell(203720, false, false, true);
        DemonSpikesBuff = Spell(203819, false, false, true);
        FelBlade = Spell(213241, true, true, true);
        FelDevastation = Spell(212084, false, false, true);
        FelEruption = Spell(211881, true, true, true);
        FieryBrand = Spell(204021, true, true, true);
        Fracture = Spell(209795, true, true, true);
        ImmolationAura = Spell(178740, false, false, true);
        RazorSpikes = Spell(209400, false, false, true);
        Shear = Spell(203782, true, true, true);
        SigilofFlame = Spell(204596, false, true, true);
        SpiritBomb = Spell(218679, false, true, true);
        SpiritBombDebuff = Spell(218677, false, false, true);
        SoulCleave = Spell(203798, true, true, true);
        SoulFragments = Spell(203981, false, true, true);
        ThrowGlaive = Spell(204157, true, true, true);
        Torment = Spell(185245, false, true, true);
        -- Offensive Cooldowns
        Metamorphosis = Spell(187827, false, false, true);
        SoulCarver = Spell(207407, true, true, true);
        -- Defensive Cooldowns
        EmpowerWards = Spell(218256, false, false, true);

        --- GUI Frame
        -- Pages
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {6, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest", "Untanked"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_SUBVALUE("Untanked").."Integrate tanking logic that will priorise the untaked units."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.TauntManagerOptions("Torment");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Consume Magic to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Fiery Brand", 223, true, {100, 1, 100, 1}, {2, "Always", "Cooldown Only"}, "Enable for the automatic usage of Fiery Brand."..C.TOOLTIP_VALUE_1.."Minimum Health Percentage required to use it."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Soul Carver", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Soul Carver."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Metamorphosis", 210, true, nil, nil, "Enable for the automatic usage of Metamorphosis.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Only Arcane Torrent is supported."));
        end
        module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Disabled", "Enabled"}, {2, "Disabled", "Enabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Fel Devastation", 222, true, {1, 1, 5, 1}, {100, 1, 100, 1}, "Enable for the automatic usage of Fel Devastation."..C.TOOLTIP_VALUE_1.."Number of enemies required in front of you."..C.TOOLTIP_VALUE_2.."Minimum Health Percentage required to use it.");
        module.AddNewOption("Offensive Settings", "Sigil of Flame", 210, true, nil, nil, "Enable for the automatic usage of Sigil of Flame.");
        module.AddNewOption("Offensive Settings", "Fel Eruption", 210, true, nil, nil, "Enable for the automatic usage of Fel Eruption.");
        module.AddNewOption("Offensive Settings", "Immolation Aura", 210, true, nil, nil, "Enable for the automatic usage of Immolation Aura.");
        module.AddNewOption("Offensive Settings", "Felblade", 210, true, nil, nil, "Enable for the automatic usage of Felblade.");
        module.AddNewOption("Offensive Settings", "Throw Glaive", 210, true, nil, nil, "Enable for the automatic usage of Throw Glaive.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Health Percentage to use Healing Belt / Healing Pot / Healthstone.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Demon Spikes", 220, true, {80, 1, 100, 1}, nil, "Health Percentage to use Demon Spikes.");
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, false, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Empower Wards", 220, true, {60, 1, 100, 1}, nil, "Health Percentage to use Empower Wards.");

        --- Misc
        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
        -- No Path Available Handler Event Register
        local PathFrame = CreateFrame("FRAME", "PathFrameFrame");
        PathFrame:RegisterEvent("UI_ERROR_MESSAGE");
        local function PathCheck(Self, Event, Message)
            -- Legion Alpha Message : SPELL_FAILED_NOPATH = 50;
            if Message == SPELL_FAILED_NOPATH or Message == 50 then
                NoPathFromEvent = true;
                NoPathFromEventPositionX, NoPathFromEventPositionY, NoPathFromEventPositionZ = Player:Position():Expand();
            end
        end
        PathFrame:SetScript("OnEvent", PathCheck);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Empower Wards") and Player:HealthPercentage() <= module.GetOptionValue("Empower Wards") and (EmpowerWards:Exists() and Player:Level() >= 100) and not Player:Buff(EmpowerWards) and Player:CanCast(EmpowerWards) then
            Player:Cast(EmpowerWards);
        end
        if module.IsOptionEnabled("Demon Spikes") and Player:HealthPercentage() <= module.GetOptionValue("Demon Spikes") and not Player:Buff(DemonSpikesBuff) and Player:CanCast(DemonSpikes) then
            Player:Cast(DemonSpikes);
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(ConsumeMagic, ArcaneTorrent);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(Shear, false) or Unit.Target;
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            --- Enemies Check
            if module.UseAOE() then
                TargetEnemies_8y = Target:EnemiesWithinDistance(8, false, false, false);
                Enemies_30y = Player:EnemiesWithinDistance(30, false); -- Used for Torment
                Enemies_5y1 = Player:FilterEnemiesByDistance(Enemies_30y, 5.1, false, false, true); -- Take Enemies in 5.1y range and 180 cone.
                NumEnemies = #TargetEnemies_8y;
                NumEnemies_5_1 = #Enemies_5y1;
            else
                NumEnemies = 1;
                NumEnemies_5_1 = 1;
            end

            -- Torment
            if Player:TauntManager(Torment, "Torment", Target, Enemies_30y) then
                return;
            end

            -- Fel Devastation Handler
            if module.IsOptionEnabled("Fel Devastation") and FelDevastation:Exists() then
                FelDevastationNumEnemies = #Player:UnitsInFrontRectangle(16, 3); -- Same as Eye Beam : Measured on 04/18/2016 : 7.0.3.21491 (Normal Range + Pythagore for Width)
            end
            -- No Path Available Handler (Check if we moved or not since last error)
            if NoPathFromEvent then
                local X, Y, Z = Player:Position():Expand();
                if NoPathFromEventPositionX ~= X or NoPathFromEventPositionY ~= Y or NoPathFromEventPositionZ ~= Z then
                    NoPathFromEvent = false;
                    NoPathFromEventPositionX, NoPathFromEventPositionY, NoPathFromEventPositionZ = nil, nil, nil;
                end
            end

            if Player:IsWithinCastRange(Target, Shear) then
                --- Cooldowns
                if module.CooldownsAllowed() then
                    -- Metamorphosis
                    if module.IsOptionEnabled("Metamorphosis") and (Player:Level() >= 110 or (Metamorphosis:Exists() and IsQuestFlaggedCompleted(40051))) and not Player:Buff(Metamorphosis) and Player:CanCast(Metamorphosis) then
                        Player:Cast(Metamorphosis);
                    end
                    -- Trinkets
                    if Trinket1:IsUsableInventory() and module.GetOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket1:UseInventory();
                    end
                    if Trinket2:IsUsableInventory() and module.GetSecondOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket2:UseInventory();
                    end
                end
                -- Arcane Torrent
                if ArcaneTorrent:Exists() and module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:Power() < 80 and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent);
                    return;
                end
                -- Fiery Brand
                if module.IsOptionEnabled("Fiery Brand") and (Player:Level() >= 110 or (FieryBrand:Exists() and (IsQuestFlaggedCompleted(40253) or IsQuestFlaggedCompleted(38723)))) and (module.CooldownsAllowed() or module.GetSecondOptionValue("Fiery Brand") == "Always") and Player:HealthPercentage() <= module.GetOptionValue("Fiery Brand") and Target:CanCast(FieryBrand) then
                    Target:Cast(FieryBrand);
                end
                -- Soul Carver
                if module.IsOptionEnabled("Soul Carver") and SoulCarver:Exists() and (module.CooldownsAllowed() or module.GetOptionValue("Soul Carver") == "Always") and Target:CanCast(SoulCarver) then
                    Target:Cast(SoulCarver);
                    return;
                end
            end
            -- Spirit Bomb Talent (Keep Debuff on Target)
            if SpiritBomb:Exists() and Target:DebuffRemains(SpiritBombDebuff) < 1 and Player:Buff(SoulFragments) and Target:CanCast(SpiritBomb) then
                Target:Cast(SpiritBomb);
                return;
            end
            -- Fel Devastation
            if module.IsOptionEnabled("Fel Devastation") and FelDevastation:Exists() and Player:HealthPercentage() <= module.GetSecondOptionValue("Fel Devastation") and (module.GetOptionValue("Fel Devastation") == 1 or (module.GetOptionValue("Fel Devastation") > 1 and module.UseAOE())) and FelDevastationNumEnemies >= module.GetOptionValue("Fel Devastation") and Player:Standing() >= FelDevastationStanding and Player:CanCast(FelDevastation) then
                Player:Cast(FelDevastation);
                return;
            end
            -- Immolation Aura
            if module.IsOptionEnabled("Immolation Aura") and (Player:Level() >= 110 or (ImmolationAura:Exists() and (IsQuestFlaggedCompleted(40254) or IsQuestFlaggedCompleted(39683)))) and Player:IsWithinCastRange(Target, Shear) and Player:CanCast(ImmolationAura) then
                Player:Cast(ImmolationAura);
                return;
            end
            -- Sigil of Flame
            if module.IsOptionEnabled("Sigil of Flame") and SigilofFlame:Exists() and NumEnemies >= 2 and Target:CanCast(SigilofFlame) and Player:CastGround(SigilofFlame, 2, 8, 30, true) then
                return;
            end
            -- Fel Eruption
            if module.IsOptionEnabled("Fel Eruption") and FelEruption:Exists() and Target:CanCast(FelEruption) then
                Target:Cast(FelEruption);
                return;
            end
            -- Spenders
            if Player:Power() >= 60 then
                -- Soul Cleave AoE
                if NumEnemies_5_1 >= 2 and Target:CanCast(SoulCleave) then
                    Target:Cast(SoulCleave);
                    return;
                end
                -- Fracture
                if Fracture:Exists() then
                    if Target:CanCast(Fracture) then
                        Target:Cast(Fracture);
                        return;
                    end
                -- Soul Cleave Single Target
                elseif Target:CanCast(SoulCleave) then
                    Target:Cast(SoulCleave);
                    return;
                end
            end
            -- Fel Blade
            if module.IsOptionEnabled("Felblade") and FelBlade:Exists() and not NoPathFromEvent and Target:CanCast(FelBlade) then
                Target:Cast(FelBlade);
                return;
            end
            -- Shear
            if Target:CanCast(Shear) then
                Target:Cast(Shear);
                return;
            end
            -- Throw Glaive Out of Range
            if module.IsOptionEnabled("Throw Glaive") and Target:CanCast(ThrowGlaive) then
                Target:Cast(ThrowGlaive);
                return;
            end
            return;
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        -- Engage Target
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Fel Blade
            if module.IsOptionEnabled("Felblade") and FelBlade:Exists() and not NoPathFromEvent and Target:CanCast(FelBlade) then
                Target:Cast(FelBlade);
                return;
            end
            -- Shear
            if Target:CanCast(Shear) then
                Target:Cast(Shear);
                return;
            end
            -- Throw Glaive Out of Range
            if module.IsOptionEnabled("Throw Glaive") and Target:CanCast(ThrowGlaive) then
                Target:Cast(ThrowGlaive);
                return;
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Balance Druid
    local Rotation = {};
    module.SetRotation("_"..102, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local UpdateInterruptPercentage, InterruptPercentage = 0, 0; -- Interrupt Handler
    local MainTankResDelay, OffTankResDelay = nil, nil; -- Main Tank Resurrection
    local Enemies, TyphoonUnits, PlayerEnemies_10y, Enemies_20y, Enemies_5y, MoonfireUnit, SunfireUnit, NumEnemies = {}, {}, {}, {}, {}, nil, nil, 0; -- Units
    local StellarFlareUnit = nil;
    -- Healers Specific
    local MainTank, MainTankTarget, OffTank, OffTankTarget, Lowest, HealUnits = nil, nil, nil, nil, nil, {};
    local StarfallAstralPower = 60;

    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        IntellectPotion = Item(109218, false, false, true);
        IntellectPotionBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        AstralCommunion = Spell(202359, false, false, true); -- lvl 90 grants 75 Astral Power
        Barkskin = Spell(22812, false, false, true);-- As Usual
        BearForm = Spell(5487, false, false, true);
        CatForm = Spell(768, false, false, true);
        CelestialAlignment = Spell(194223, false, false, true);
        DisplacerBeast = Spell(137452, false, false , true);
        ForceOfNature = Spell(205636, false, true, true); -- lvl 15 talent - Like Meteor but good for ST
        FullMoon = Spell(202771, false, true, false);
        FuryOfElune = Spell(202770, true, true, true);
        HalfMoon = Spell(202768, false, true, false);
        HealingTouch = Spell(5185, false, false, false); -- As usual
        Incarnation = Spell(102560, false, false, true);
        LunarEmpowerment = Spell(164547);
        Moonfire = Spell(8921, true, true, true);
        MoonfireDebuff = Spell(164812);
        MoonkinForm = Spell(24858, false, false, true);
        NewMoon = Spell(202767, false, true, false);
        Rebirth = Spell(20484, false, false, false, true);
        Renewal = Spell(108238, false, false, true);
        SolarBeam = Spell(78675, true, true, true);
        SolarEmpowerment = Spell(164545);
        SoulOfTheForest = Spell(114107);
        Starfall = Spell(191034, false, true, true);
        StarfallBuff = Spell(184989);
        LunarStrike = Spell(194153, true, true, false);
        Starsurge = Spell(78674, true, true, true);
        StellarFlare = Spell(202347, true, true, false);
        Sunfire = Spell(93402, true, true, true);
        SunfireDebuff = Spell(164815);
        TravelForm = Spell(783, false, false, true);
        SolarWrath = Spell(190984, true, true, false);
        WarriorOfElune = Spell(202425, false, false, true);

        FeralAffinity = Spell(202157);
        FerociousBite = Spell(22568 , true, true, true);
        Rip = Spell(1079 , true, true, true);
        Shred = Spell(5221 , true, true, true);
        Swipe = Spell(106785 , false, false, true);

        GuardianAffinity = Spell(197491);
        FrenziedRegeneration = Spell(22842, false, false, true);
        Ironfur = Spell(192081, false, false, true);
        Mangle = Spell(33917, true, true, true);
        Thrash = Spell(77758, false, false, true);
        ThrashDebuff = Spell(192090);

        RestorationAffinity = Spell(197492);
        Regrowth = Spell(8936, false, false, false);
        Rejuvenation = Spell(774, false, false, true);
        Swiftmend = Spell(18562, false, false, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Moonkin Form", 210, true, nil, nil, "Use Moonkin Form.");
        module.AddNewOption("General Settings", "Rebirth", 210, true, nil, nil, "Enable to automatically resurrect targeted dead player targets in combat.");
        module.AddNewOption("General Settings", "Instant Rebirth Tank", 220, true, {2, 0, 3, 0.1}, nil, "Enable to use Rebirth to resurrect a dead Tank."..C.TOOLTIP_VALUE.."Set the delay before using it.");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Solar Beam to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our LunarStrike to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Astral Communion", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Astral Communion."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Celestial Alignment", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Celestial Alignment."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Force Of Nature", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Force Of Nature."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Incarnation", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Incarnation."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Warrior Of Elune", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Warrior Of Elune."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Full Moon", 120, true, {2, 1, 10, 1}, nil, "Full Moon with artifact."..C.TOOLTIP_VALUE.."Amount of units needed within 5 yards of target to use Full Moon.");
        module.AddNewOption("Offensive Settings", "Fury Of Elune", 120, true, {2, 1, 10, 1}, nil, "Use Fury Of Elune."..C.TOOLTIP_HINT("If you have the artifact Weapon, Fury Of Elune will be used when Full Moon is Ready to be used."));
        module.AddNewOption("Offensive Settings", "Multi-Dot Moonfire", 222, false, { 5, 1, 10, 1 }, { 3, 0, 25, 0.1 }, "Multi-Dot Moonfire Cycle."..C.TOOLTIP_VALUE_1.."Number of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Stellar Flare", 222, false, { 10, 1, 10, 1 }, { 3, 0, 25, 0.1 }, "Multi-Dot Stellar Flare Cycle."..C.TOOLTIP_VALUE_1.."Number of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Sunfire", 222, false, { 10, 1, 10, 1 }, { 3, 0, 25, 0.1 }, "Multi-Dot Sunfire Cycle."..C.TOOLTIP_VALUE_1.."Number of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Moonfire While Moving", 220, true, { 0.7, 0, 4, 0.1 }, nil, "Time to wait in seconds before using Moonfire/Sunfire filler while moving.");
        module.AddNewOption("Offensive Settings", "Starsurge", 210, true, nil, nil, "Use Starsurge.");
        module.AddNewOption("Offensive Settings", "Starfall", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {2, 1, 25, 1}, "Use Starfall."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Target").."Always use on the current target."..C.TOOLTIP_SUBVALUE("Target Standing").."Always use on the current target. Target must be standing still."..C.TOOLTIP_SUBVALUE("Centered").."Use centered on a cluster of enemies."..C.TOOLTIP_SUBVALUE("Centered Standing").."Use centered on a cluster of enemies. Enemies must be standing still."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the spell effect to use.");
        module.AddSection("Offensive Settings", "Feral Affinity", "Green");
        module.AddNewOption("Offensive Settings", "Feral Affinity", 210, false, nil, nil, "Enable Feral Affinity DPS.");
        module.AddNewOption("Offensive Settings", "Rip", 210, true, nil, nil, "Use Rip.");
        module.AddNewOption("Offensive Settings", "Swipe", 220, true, {3, 1, 10, 1}, nil, "Use Swipe."..C.TOOLTIP_VALUE.."Amount of units needed within 10 yards of player to use Swipe.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Barkskin", 220, true, {40, 1, 100, 1}, nil, "Use Barkskin."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Rejuvenation Self", 220, true, {30, 1, 100, 1}, nil, "Use Rejuvenation on ourself."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Healing Touch Self", 222, true, {30, 1, 100, 1}, {80, 1, 100, 1}, "Use Healing Touch on ourself."..C.TOOLTIP_VALUE_1.."Health threshold while In Combat."..C.TOOLTIP_VALUE_2.."Health threshold while Out of Combat.");
        module.AddNewOption("Defensive Settings", "Renewal", 220, true, {30, 1, 100, 1}, nil, "Use Renewal on ourself."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Restoration Affinity", "Green");
        module.AddNewOption("Defensive Settings", "Restoration Affinity", 210, false, nil, nil, "Enable Restoration Affinity Healing.");
        module.AddNewOption("Defensive Settings", "Healing Touch", 222, true, {95, 0, 100, 1}, {90, 0, 100, 1}, "Use Healing Touch."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Defensive Settings", "Regrowth", 222, true, {35, 0, 100, 1}, {25, 0, 100, 1}, "Use Regrowth."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Defensive Settings", "Rejuvenation", 222, true, {85, 0, 100, 1}, {80, 0, 100, 1}, "Use Rejuvenation."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Defensive Settings", "Swiftmend", 222, true, {40, 0, 100, 1}, {25, 0, 100, 1}, "Use Swiftmend."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddSection("Defensive Settings", "Guardian Affinity", "Green");
        module.AddNewOption("Defensive Settings", "Guardian Affinity", 210, false, nil, nil, "Enable Guardian Affinity Tanking.");
        module.AddNewOption("Defensive Settings", "Frenzied Regeneration", 220, true, {35, 1, 100, 1}, nil, "Use Frenzied Regeneration."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Ironfur", 220, true, {90, 1, 100, 1}, nil, "Use Ironfur."..C.TOOLTIP_VALUE.."Health threshold.");


        module.AddOutput("|cFF9A2EFEMain Tank:");
        module.AddOutput("|cFF9A2EFEOff Tank:");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [HalfMoon:ID()] = "Half Moon",
            [HealingTouch:ID()] = "Healing Touch",
            [LunarStrike:ID()] = "Lunar Strike",
            [NewMoon:ID()] = "New Moon",
            [Regrowth:ID()] = "Regrowth",
            [SolarWrath:ID()] = "Solar Wrath",
            [StellarFlare:ID()] = "Stellar Flare"
        };
    end

    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end
        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        local OpenerSpell = NewMoon:Exists() and NewMoon or LunarStrike;
        -- 1) Incarnation
        if BMPullTime() < OpenerSpell:CastTime() + Player:GCD() + module.GetSecondOptionValue("Pre-Pull BossMod") and Target:CanCast(OpenerSpell) and Incarnation:Exists() and module.IsOptionEnabled("Incarnation") and (module.CooldownsAllowed() or module.GetOptionValue("Incarnation") == "Always") and Player:CanCast(Incarnation) then
            Player:Cast(Incarnation);
            return;
        end
        -- 2) Potion
        if module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) and Player:IsWithinCastRange(Target, OpenerSpell) then
            if Player:Potion("Intellect", Potion) then module.Bug("Pre-Pull - Intellect Potion"); Potion = true; end
        end
        -- 3) New Moon / Lunar Strike
        if BMPullTime() < OpenerSpell:CastTime() + module.GetSecondOptionValue("Pre-Pull BossMod") and Target:CanCast(OpenerSpell) then
            Target:Cast(OpenerSpell);
            return;
        end
    end

    function Rotation:Interrupts ()
        Player:UseInterrupt(SolarBeam);
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- barkskin
        if module.IsOptionEnabled("Barkskin") and Player:HealthPercentage() <= module.GetOptionValue("Barkskin") and Player:CanCast(Barkskin) then
            Player:Cast(Barkskin);
        end
    end

    function Rotation:OffGCDAbilities ()
        -- Guardian Affinity
        if GuardianAffinity:Exists() and module.IsOptionEnabled("Guardian Affinity") and Player:Buff(BearForm) then
            -- Ironfur
            if module.IsOptionEnabled("Ironfur") and Player:CanCast(Ironfur) then
                if Player:Rage() >= 85 or (Player:HealthPercentage() <= module.GetOptionValue("Ironfur") and Player:Rage() >= 40 and not Player:Buff(Ironfur)) then
                    Player:Cast(Ironfur);
                    return;
                end
            end
            -- Frenzied Regeneration
            if module.IsOptionEnabled("Frenzied Regeneration") and Player:CanCast(FrenziedRegeneration) and not Player:Buff(FrenziedRegeneration) then
                if Player:HealthPercentage() <= module.GetOptionValue("Frenzied Regeneration") and Player:Rage() >= 10 then
                    Player:Cast(FrenziedRegeneration);
                    return;
                end
            end
        end
        -- Astral Communion
        if AstralCommunion:Exists() and module.IsOptionEnabled("Astral Communion") and (module.CooldownsAllowed() or module.GetOptionValue("Astral Communion") == "Always") and Player:AstralPower() < 15 and (not FuryOfElune:Exists() or FuryOfElune:TimeSinceCast() < 15) and Player:CanCast(AstralCommunion) then
            Player:Cast(AstralCommunion);
            return;
        end
    end

    local function AstralDump (Energy, Delay)
        -- Starfall
        if Starfall:Exists() and module.IsOptionEnabled("Starfall") and Player:AstralPower() >= Energy and Target:CanCast(Starfall) then
            if Target:CastGroundSpell(Starfall, "Starfall", 20) then return; end
        end
        -- Starsurge
        if Starsurge:Exists() and module.IsOptionEnabled("Starsurge") and (Player:AstralPower() >= 90 or (not Delay and Player:AstralPower() >= Energy)) and Target:CanCast(Starsurge) then
            Target:Cast(Starsurge);
            return;
        end
    end

    local function HealCycle (Spell, SpellOption, SpellBuff)
        if Spell:Exists() and module.IsOptionEnabled(SpellOption) then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue(SpellOption) and (not SpellBuff or MainTank:BuffRemains(SpellBuff) < 3) and MainTank:CanHeal(Spell) then
                MainTank:Cast(Spell);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue(SpellOption) and (not SpellBuff or OffTank:BuffRemains(SpellBuff) < 3) and OffTank:CanHeal(Spell) then
                OffTank:Cast(Spell);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue(SpellOption) and (not SpellBuff or Lowest:BuffRemains(SpellBuff) < 3) and Lowest:CanCast(Spell) then
                Lowest:Cast(Spell);
                return;
            end
            if SpellBuff then
                -- Cycle
                for i = 1, #HealUnits do
                    local ThisUnit = HealUnits[i];
                    if ThisUnit:CanHeal(Spell) and ThisUnit:BuffRemains(Spell) < 3 and ThisUnit:SpecialHealthPercentage() <= module.GetSecondOptionValue(SpellOption) then
                        ThisUnit:Cast(Spell);
                        return;
                    end
                end
            end
        end
    end

    function Rotation:Combat ()
        -- Rejuvenation
        if module.IsOptionEnabled("Rejuvenation Self") and Player:HealthPercentage() <= module.GetOptionValue("Rejuvenation Self") and Player:CanCast(Rejuvenation) and not Player:Buff(Rejuvenation) then
            Player:Cast(Rejuvenation);
            return;
        end
        -- Healing Touch
        if HealingTouch:Exists() and module.IsOptionEnabled("Healing Touch Self") and Player:HealthPercentage() <= module.GetOptionValue("Healing Touch Self") and Player:CanCast(HealingTouch) then
            Player:Cast(HealingTouch);
            return;
        end
        -- Renewal
        if Renewal:Exists() and module.IsOptionEnabled("Renewal") and Player:HealthPercentage() <= module.GetOptionValue("Renewal") and Player:CanCast(Renewal) then
            Player:Cast(Renewal);
            return;
        end
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();
        -- Combat Res Tanks
        if MainTank and MainTank:Exists() and not MainTank:IsDeadOrGhost() then MainTankResDelay = nil; end
        if OffTank and OffTank:Exists() and not OffTank:IsDeadOrGhost() then OffTankResDelay = nil; end
        if module.IsOptionEnabled("Instant Rebirth Tank") then
            if MainTank and MainTank:Exists() and MainTank:IsDeadOrGhost() and MainTank:IsPlayer() and MainTank:CanCast(Rebirth) then
                if not MainTankResDelay then MainTankResDelay = module.GetTime(); end
                if module.GetTime()-MainTankResDelay >= module.GetOptionValue("Instant Rebirth Tank") then
                    MainTankResDelay = nil;
                    MainTank:Cast(Rebirth);
                    return;
                end
            elseif OffTank and OffTank:Exists() and OffTank:IsDeadOrGhost() and OffTank:IsPlayer() and OffTank:CanCast(Rebirth) then
                if not OffTankResDelay then OffTankResDelay = module.GetTime(); end
                if module.GetTime()-OffTankResDelay >= module.GetOptionValue("Instant Rebirth Tank") then
                    OffTankResDelay = nil;
                    OffTank:Cast(Rebirth);
                    return;
                end
            end
        end
        -- Combat Res Target
        if Rebirth:Exists() and module.IsOptionEnabled("Rebirth") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and Target:IsPlayer() and Target:CanCast(Rebirth) then
            Target:Cast(Rebirth);
            return;
        end
        -- Restoration Affinity
        if RestorationAffinity:Exists() and module.IsOptionEnabled("Restoration Affinity") then
            HealUnits = Player:HealUnitsAround(100, 40) or {};
            Lowest = Unit.Lowest(MainTank, OffTank);
            -- Swiftmend
            if Swiftmend:Exists() and module.IsOptionEnabled("Swiftmend") and not Swiftmend:IsOnCooldown() then
                if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Swiftmend") and (MainTank:Buff(Rejuvenation) or MainTank:Buff(Regrowth)) and MainTank:CanHeal(Swiftmend) then
                    MainTank:Cast(Swiftmend);
                    return;
                end
                if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Swiftmend") and (OffTank:Buff(Rejuvenation) or OffTank:Buff(Regrowth)) and OffTank:CanHeal(Swiftmend) then
                    OffTank:Cast(Swiftmend);
                    return;
                end
                if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Swiftmend") and (Lowest:Buff(Rejuvenation) or Lowest:Buff(Regrowth)) and Lowest:CanHeal(Swiftmend) then
                    Lowest:Cast(Swiftmend);
                    return;
                end
            end
            -- Regrowth Cycle
            HealCycle(Regrowth, "Regrowth", Regrowth);
            -- Rejuvenation Cycle
            HealCycle(Rejuvenation, "Rejuvenation", Rejuvenation);
            -- Healing Touch
            HealCycle(HealingTouch, "Healing Touch", nil);
        end
        -- Determine if we have enough time to use Celestial Alignment
        if Target:Exists() and Player:CanAttack(Target)  then
            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                Enemies = Player:EnemiesWithinDistance(40); -- 40 yards for Dots Cycles.
                MoonfireUnit = Unit.DotCycle(Enemies, Moonfire, MoonfireDebuff, 22, "Multi-Dot Moonfire"); -- Moonfire DoT Cycle
                SunfireUnit = Unit.DotCycle(Enemies, Sunfire, SunfireDebuff, 18, "Multi-Dot Sunfire"); -- Sunfire DoT Cycle
                StellarFlareUnit = Unit.DotCycle(Enemies, StellarFlare, StellarFlare, 24, "Multi-Dot Stellar Flare"); -- Stellar Flare DoT Cycle
                StarfallAstralPower = SoulOfTheForest:Exists() and 50 or 60;
                Enemies_20y = Target:EnemiesWithinDistance(20, true); -- 20 yards for Starfall.
                Enemies_5y = Target:FilterEnemiesByDistance(Enemies_20y, 5, true); -- 5 yards for Lunar Strike.
                PlayerEnemies_10y = FeralAffinity:Exists() and module.IsOptionEnabled("Feral Affinity") and module.IsOptionEnabled("Swipe") and Player:EnemiesWithinDistance(10, true) or {};
                NumEnemies = #Enemies_5y;
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- Guardian Affinity
            if GuardianAffinity:Exists() and module.IsOptionEnabled("Guardian Affinity") then
                -- Apply Bear Form
                if not Player:Buff(BearForm) and Player:CanCast(BearForm) then
                    Player:Cast(BearForm);
                    return;
                end
                -- Bear DPS
                if Player:IsWithinCastRange(Target, Mangle) then
                    if not Target:Debuff(ThrashDebuff) and Player:CanCast(Thrash) then
                        Player:Cast(Thrash);
                        return;
                    end
                    if Target:CanCast(Mangle) then
                        Target:Cast(Mangle);
                        return;
                    end
                    if Player:CanCast(Thrash) then
                        Player:Cast(Thrash);
                        return;
                    end
                end
                -- Full Moon
                if NewMoon:Exists() and NewMoon:CurrentID() == FullMoon.Identifier and Target:CanCast(NewMoon) and (NumEnemies >= module.GetOptionValue("Full Moon") or NewMoon:Charges() >= 3 or (NewMoon:Charges() >= 2 and NewMoon:Recharge() < 5)) then
                    Target:Cast(NewMoon);
                    return;
                end
                -- Dump Moon
                if NewMoon:Exists() and Target:CanCast(NewMoon) and (NewMoon:Charges() >= 3 or (NewMoon:Charges() >= 2 and NewMoon:Recharge() < 5)) then
                    Target:Cast(NewMoon);
                    return;
                end
                -- Apply Moonfire
                if Moonfire:Exists() then
                    if Target:DebuffRemains(MoonfireDebuff) < 6 and Target:CanCast(Moonfire) then
                        Target:Cast(Moonfire);
                        return;
                    end
                    if module.IsOptionEnabled("Multi-Dot Moonfire") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                        MoonfireUnit:Cast(Moonfire);
                        return;
                    end
                end
                -- New Moon
                if NewMoon:Exists() and NewMoon:CurrentID() == NewMoon.Identifier and Target:CanCast(NewMoon) then
                    Target:Cast(NewMoon);
                    return;
                end
                -- Half Moon
                if NewMoon:Exists() and NewMoon:CurrentID() == HalfMoon.Identifier and Target:CanCast(NewMoon) then
                    Target:Cast(NewMoon);
                    return;
                end
                return;
            end

            -- Feral Affinity
            if FeralAffinity:Exists() and module.IsOptionEnabled("Feral Affinity") then
                -- Apply Cat Form
                if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
                    Player:Cast(CatForm);
                    return;
                end
                -- Use Combos
                -- Rip with 5 Combo Points
                if Rip:Exists() and module.IsOptionEnabled("Rip") and Player:ComboPoints() >= 5 and Target:DebuffRemains(Rip) < 6 then
                    Target:Cast(Rip);
                    return;
                end
                -- Ferocious Bite with 5 Combo Points or less than 5 second till death
                if FerociousBite:Exists() and (Player:ComboPoints() >= 5 or Target:TimeToDie() < 5) then
                    Target:Cast(FerociousBite);
                    return;
                end

                -- Use Energy
                -- Swipe
                if module.IsOptionEnabled("Swipe") and #PlayerEnemies_10y >= module.GetOptionValue("Swipe") then
                    if Player:CanCast(Swipe) then
                        Player:Cast(Swipe);
                        return;
                    end
                else
                    -- Shred
                    if Target:CanCast(Shred) then
                        Target:Cast(Shred);
                        return;
                    end
                end

                -- Dump Moon
                if NewMoon:Exists() and Target:CanCast(NewMoon) and (NewMoon:Charges() >= 3 or (NewMoon:Charges() >= 2 and NewMoon:Recharge() < 5)) then
                    Target:Cast(NewMoon);
                    return;
                end
                -- New Moon
                if NewMoon:Exists() and NewMoon:CurrentID() == NewMoon.Identifier and Target:CanCast(NewMoon) then
                    Target:Cast(NewMoon);
                    return;
                end
                -- Half Moon
                if NewMoon:Exists() and NewMoon:CurrentID() == HalfMoon.Identifier and Target:CanCast(NewMoon) then
                    Target:Cast(NewMoon);
                    return;
                end
                return;
            end

            -- Moonkin Form
            if MoonkinForm:Exists() and module.IsOptionEnabled("Moonkin Form") and not Player:Buff(MoonkinForm) and Player:CanCast(MoonkinForm) and (not Player:Buff(CatForm) or Player:Buff(DisplacerBeast)) and not Player:Buff(BearForm) and not Player:Buff(TravelForm) then
                Player:Cast(MoonkinForm);
                return;
            end
            -- Cooldowns
            if Player:IsWithinCastRange(Target, SolarWrath) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Celestial Alignment
                if not Incarnation:Exists() and CelestialAlignment:Exists() and module.IsOptionEnabled("Celestial Alignment") and (module.CooldownsAllowed() or module.GetOptionValue("Celestial Alignment") == "Always") and Player:CanCast(CelestialAlignment) then
                    Player:Cast(CelestialAlignment);
                    return;
                end
                -- Force Of Nature
                if ForceOfNature:Exists() and module.IsOptionEnabled("Force Of Nature") and (module.CooldownsAllowed() or module.GetOptionValue("Force Of Nature") == "Always") and Target:CanCast(ForceOfNature) then
                    Target:Cast(ForceOfNature);
                    return;
                end
                -- Timing Warrior Of Elune with Celestial Alignment
                local CelestialAlignmentReady = not Incarnation:Exists() and CelestialAlignment:Exists() and module.IsOptionEnabled("Celestial Alignment") and (module.CooldownsAllowed() or module.GetOptionValue("Celestial Alignment") == "Always") and CelestialAlignment:Cooldown() or Incarnation:Exists() and module.IsOptionEnabled("Incarnation") and (module.CooldownsAllowed() or module.GetOptionValue("Incarnation") == "Always") and CelestialAlignment:Cooldown() or 100;
                -- Warrior Of Elune
                if WarriorOfElune:Exists() and module.IsOptionEnabled("Warrior Of Elune") and (module.CooldownsAllowed() or module.GetOptionValue("Warrior Of Elune") == "Always") and CelestialAlignmentReady > 40 and Player:CanCast(WarriorOfElune) then
                    Player:Cast(WarriorOfElune);
                    return;
                end
                -- Incarnation
                if Incarnation:Exists() and module.IsOptionEnabled("Incarnation") and (module.CooldownsAllowed() or module.GetOptionValue("Incarnation") == "Always") and Player:CanCast(Incarnation) then
                    Player:Cast(Incarnation);
                    return;
                end
            end

            -- Rotation
            -- Full Moon
            if NewMoon:Exists() and NewMoon:CurrentID() == FullMoon.Identifier and Target:CanCast(NewMoon) and (NumEnemies >= module.GetOptionValue("Full Moon") or NewMoon:Charges() >= 3 or (NewMoon:Charges() >= 2 and NewMoon:Recharge() < 5)) then
                if FuryOfElune:Exists() and module.IsOptionEnabled("Fury Of Elune") then
                    if not Target:IsMoving() and ((#Enemies_20y > module.GetSecondOptionValue("Starfall") and Player:AstralPower() >= StarfallAstralPower) or Player:AstralPower() >= 90) and (not AstralCommunion:Exists() or AstralCommunion:Cooldown() < 5) and Target:CanCast(FuryOfElune) then
                        Target:Cast(FuryOfElune);
                        FuryOfElune.LastCastTime = module.GetTime();
                        return;
                    end
                    if FuryOfElune:TimeSinceCast() < 10 and Player:AstralPower() < 70 then
                        module.Bug("Full Moon");
                        Target:Cast(NewMoon);
                        return;
                    end
                else
                    -- Starsurge/Starfall with 60 Astral Power
                    AstralDump(60);
                    module.Bug("Full Moon");
                    Target:Cast(NewMoon);
                    return;
                end
            end
            -- Starsurge/Starfall with 90 Astral Power
            AstralDump(90);
            -- Sunfire
            if Sunfire:Exists() then
                if Target:DebuffRemains(SunfireDebuff) < 5 and Target:CanCast(Sunfire) then
                    Target:Cast(Sunfire);
                    return;
                end
                if module.IsOptionEnabled("Multi-Dot Sunfire") and SunfireUnit and SunfireUnit:CanCast(Sunfire) then
                    SunfireUnit:Cast(Sunfire);
                    return;
                end
            end
            -- Apply Moonfire
            if Moonfire:Exists() then
                if Target:DebuffRemains(MoonfireDebuff) < 6 and Target:CanCast(Moonfire) then
                    Target:Cast(Moonfire);
                    return;
                end
                if module.IsOptionEnabled("Multi-Dot Moonfire") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                    MoonfireUnit:Cast(Moonfire);
                    return;
                end
            end
            -- Stellar Flare
            if StellarFlare:Exists() then
                if Target:DebuffRemains(StellarFlare) < 5 and Target:CanCast(StellarFlare) then
                    Target:Cast(StellarFlare);
                    return;
                end
                if module.IsOptionEnabled("Multi-Dot Stellar Flare") and StellarFlareUnit and StellarFlareUnit:CanCast(StellarFlare) then
                    StellarFlareUnit:Cast(StellarFlare);
                    return;
                end
            end
            -- Lunar Strike with 3 Lunar Empowerments or Warrior Of Elune
            if LunarStrike:Exists() and (((Player:BuffCount(LunarEmpowerment) == 3 or Player:BuffCount(WarriorOfElune) == 1) and not Player:Casting(LunarStrike)) or Player:BuffCount(WarriorOfElune) == 2) and Target:CanCast(LunarStrike) then
                Target:Cast(LunarStrike);
                return;
            end
            -- Starsurge/Starfall with 60 Astral Power
            AstralDump(StarfallAstralPower, true);
            -- New Moon
            if NewMoon:Exists() and NewMoon:CurrentID() == NewMoon.Identifier and Target:CanCast(NewMoon) then
                module.Bug("New Moon");
                Target:Cast(NewMoon);
                return;
            end
            -- Half Moon
            if NewMoon:Exists() and NewMoon:CurrentID() == HalfMoon.Identifier and Target:CanCast(NewMoon) then
                module.Bug("Half Moon");
                Target:Cast(NewMoon);
                return;
            end
            -- Solar Wrath single Target
            if SolarWrath:Exists() and NumEnemies < 2 and Target:CanCast(SolarWrath) then
                Target:Cast(SolarWrath);
                return;
            end
            -- Lunar Strike with at least 2 enemies in range of the target
            if LunarStrike:Exists() and Target:CanCast(LunarStrike) then
                Target:Cast(LunarStrike);
                return;
            end
            -- Moonfire / Sunfire fillers
            if module.IsOptionEnabled("Moonfire While Moving") and Player:Moving() > module.GetOptionValue("Moonfire While Moving") then
                if NumEnemies > 1 and Target:CanCast(Sunfire) then
                    Target:Cast(Sunfire);
                    return;
                end
                if Target:CanCast(Moonfire) then
                    Target:Cast(Moonfire);
                    return;
                end
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(SolarWrath, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    function Rotation:OutOfCombat ()
        -- Rejuvenation
        if module.IsOptionEnabled("Rejuvenation Self") and Player:HealthPercentage() <= module.GetOptionValue("Rejuvenation Self") and Player:CanCast(Rejuvenation) and not Player:Buff(Rejuvenation) then
            Player:Cast(Rejuvenation);
            return;
        end
        -- Healing Touch
        if Player:Standing() > 1.5 and module.IsOptionEnabled("Healing Touch Self") and Player:HealthPercentage() <= module.GetSecondOptionValue("Healing Touch Self") and Player:CanCast(HealingTouch) then
            Player:Cast(HealingTouch);
        end
        if not Player:Buff(CatForm) and not Player:Buff(BearForm) and not Player:Buff(TravelForm) then
            -- Guardian Affinity
            if GuardianAffinity:Exists() and module.IsOptionEnabled("Guardian Affinity") then
                if not Player:Buff(BearForm) and Player:CanCast(BearForm) then
                    Player:Cast(BearForm);
                    return;
                end
            -- Feral Affinity
            elseif FeralAffinity:Exists() and module.IsOptionEnabled("Feral Affinity") then
                if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
                    Player:Cast(CatForm);
                    return;
                end
            -- Moonkin Form
            elseif module.IsOptionEnabled("Moonkin Form") then
                if not Player:Buff(MoonkinForm) and Player:CanCast(MoonkinForm) then
                    Player:Cast(MoonkinForm);
                    return;
                end
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Feral Druid Rotation
    local Rotation = {};
    module.SetRotation("_"..103, Rotation);

    --- Localization
    -- Core
    local Enemies_45y, Enemies_8y, Enemies_5y, NumEnemies = {}, {}, {}, 1; -- Enemies
    local SpamPrevention, TPSTime = 0, 0.1; -- Combat Module Throttle
    -- Rotation Specific
    local UnitNeedRes = nil; -- OoC Res Handler
    local Lowest = nil; -- Lowest Unit
    local MainTank, OffTank, MainTankResDelay, OffTankResDelay = nil, nil, nil, nil; -- Battle Resurection timers
    local ShadowmeldStanding = 0.7; -- Time to Stand before casting S.Shadowmeld (because movements cancel it)
    local FBValue = 50; -- Energy required for a full Ferocious Bite
    local RipTargetTTD, RipCycleTTD, RakeTargetTTD, RakeCycleTTD = 0, 0, 0, 0; -- Minimum TTD Value to use Rip and Rake
    local RakeTickTime, MoonfireTickTime = 3, 2; -- Tick Times
    local RakePandemic, RipPandemic, ThrashPandemic, ThrashSmartDuration = 4.5, 7.2, 4.5, 10;

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        --- Spells
        S = {
            -- (ID, RequiresFacing, Hostile, Instant, Resurrect)
            -- Racials
            Berserking = Spell(26297, false, false, true),
            Shadowmeld = Spell(58984, false, false, true),
            -- Items
            DraenicAgility = Item(109217, false, false, true),
            DraenicAgilityBuff = Spell(156423, false, false, true),
            -- Offensive Abilities
            Bloodtalons = Spell(155672, false, false, false),
            BloodtalonsBuff = Spell(145152, false, false, false),
            BrutalSlash = Spell(202028, false, false, true),
            Clearcasting = Spell(135700, false, false, false),
            FerociousBite = Spell(22568, true, true, true),
            JaggedWounds = Spell(202032, false, false, false),
            LunarInspiration = Spell(155580, false, false, false),
            MomentofClarity = Spell(155577, false, false, false),
            Moonfire = Spell(8921, false, true, true),
            MoonfireDebuff = Spell(164812, false, false, false),
            PredatorySwiftness = Spell(69369, false, false, false),
            Prowl = Spell(5215, false, false, true),
            Rake = Spell(1822, true, true, true),
            RakeDebuff = Spell(155722, false, false, false),
            Rip = Spell(1079, true, true, true),
            Sabertooth = Spell(202031, false, false, false),
            SavageRoar = Spell(52610, false, false, true),
            Shred = Spell(5221, true, true, true),
            Swipe = Spell(106785, false, false, true),
            Thrash = Spell(106830, false, false, true),
            ThrashDebuff = Spell(106830, false, false, false),
            -- Offensive Cooldowns
            AshamanesFrenzy = Spell(210722, true, true, true),
            Berserk = Spell(106951, false, false, true),
            ElunesGuidance = Spell(202060, false, false, true),
            Incarnation = Spell(102543, false, false, true),
            TigersFury = Spell(5217, false, false, true),
            -- Defensive Abilities
            HealingTouch = Spell(5185, false, false, false),
            Rebirth = Spell(20484, false, false, false, true),
            Revive = Spell(50769, false, false, false, true),
            -- Defensive Cooldowns
            Renewal = Spell(108238, false, false, true),
            SurvivalInstincts = Spell(61336, false, false, true),
            -- Utility
            Dash = Spell(1850, false, false, true),
            SkullBash = Spell(106839, true, true, true),
            -- Shapeshift
            BearForm = Spell(5487, false, false, true),
            CatForm = Spell(768, false, false, true),
            MoonkinForm = Spell(197625, false, false, true),
            -- Balance Affinity
            BalanceAffinity = Spell(197488, false, false, false),
            LunarEmpowerment = Spell(164547, false, false, false),
            LunarStrike = Spell(197628, true, true, false),
            SolarEmpowerment = Spell(164545, false, false, false),
            SolarWrath = Spell(197629, true, true, false),
            Starsurge = Spell(197626, true, true, false),
            Sunfire = Spell(197630, true, true, false),
            SunfireDebuff = Spell(164815, false, false, false),
            -- Guardian Affinity
            GuardianAffinity = Spell(217615, false, false, false),
            Mangle = Spell(33917, true, true, true),
            Ironfur = Spell(192081, false, false, true),
            FrenziedRegeneration = Spell(22842, false, false, true),
            -- Restoration AFfinity
            Regrowth = Spell(8936, false, false, false),
            Rejuvenation = Spell(774, false, false, true),
            RestorationAffinity = Spell(197492, false, false, false),
            Swiftmend = Spell(18562, false, false, false)
        };

        --- GUI Frame
        -- Pages
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        module.AddCommonOptions();
        module.AddPresetOption("TargetAttack");
        module.AddPresetOption("ReTarget");
        module.AddPresetOption("BossCD");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddPresetOption("Interrupt");
        module.AddSection("General Settings", "Shapeshifting", "Green");
        module.AddNewOption("General Settings", "Auto Cat Form and Prowl", 220, true, {15, 1, 40, 1}, nil, "Enable to auto put in Cat Form or use Prowl."..C.TOOLTIP_VALUE.."Distance away from the target."..C.TOOLTIP_HINT("The distance is checked only while out of combat."));
        module.AddNewOption("General Settings", "Auto Cancel Cat Form", 220, false, {20, 1, 40, 1}, nil, "Enable to auto cancel Cat Form."..C.TOOLTIP_VALUE.."Distance away from the target."..C.TOOLTIP_HINT("Does cancel only when out of combat."));
        module.AddNewOption("General Settings", "Proc Bloodtalons", 220, true, {20, 1, 25, 1}, nil, "Enable to auto proc Bloodtalons."..C.TOOLTIP_VALUE.."Set the duration to refresh it."..C.TOOLTIP_HINT("Does proc only when out of combat and not in cat form or stealth."));
        module.AddSection("General Settings", "Rebirth", "Green");
        module.AddNewOption("General Settings", "Rebirth", 210, true, nil, nil, "Enable to automatically resurrect targeted dead player targets in combat.");
        module.AddNewOption("General Settings", "Instant Rebirth Tank", 220, false, {0, 0, 3, 0.1}, nil, "Enable to use the Predatory Swiftness buff on rebirth to resuscitate a dead tank"..C.TOOLTIP_VALUE.."Set the delay before using it.");
        module.AddSection("General Settings", "Out of Combat", "Green");
        module.AddNewOption("General Settings", "Mark of The Wild", 210, true, nil, nil, "Enable for automatic buff application.");
        module.AddPresetOption("AutoResuscitate");
        module.AddPresetOption("AutoHeal");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddPresetOption("PrePot");
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Tiger's Fury", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Tiger's Fury."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Elune's Guidance", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Elune's Guidance."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Ashamane's Frenzy", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Ashamane's Frenzy."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Berserk", 210, true, nil, nil, "Enable for the automatic usage of Berserk (or Incarnation if talented into).");
        if S.Berserking:Exists() or S.Shadowmeld:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Berserking and Shadowmeld are supported."));
        end
        module.AddPresetOption("Trinket");
        --module.AddPresetOption("Potion");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Rip: Target | Adds", 222, true, {12, 0, 25, 1}, {16, 0, 25, 1}, "Enable to use Rip and set the TimeToDie threshold in order to apply it."..C.TOOLTIP_VALUE_1.."Set TTD for target."..C.TOOLTIP_VALUE_2.."Set TTD for Adds (Multi-DoT).");
        module.AddNewOption("Offensive Settings", "Rake: Target | Adds", 122, true, {6, 0, 25, 1}, {9, 0, 25, 1}, "Set the TimeToDie threshold in order to apply Rake (and Moonfire if talented into Lunar Inspiration)."..C.TOOLTIP_VALUE_1.."Set TTD for target."..C.TOOLTIP_VALUE_2.."Set TTD for Adds (Multi-DoT).");
        module.AddNewOption("Offensive Settings", "Swipe", 220, true, {4, 2, 5, 1}, nil, "Enable for the automatic usage of Swipe (or Brutal Slash) during AoE."..C.TOOLTIP_VALUE.."Set the minimum number of units in order to use Swipe (or Brutal Slash)");
        module.AddNewOption("Offensive Settings", "Thrash", 222, true, {2, 1, 7, 1}, {2, 1, 7, 1}, "Enable to use Thrash for AoE."..C.TOOLTIP_VALUE_1.."Set the total number of enemies around you in order to use Trash."..C.TOOLTIP_VALUE_2.."Set the min. number of enemies to refresh Trash if it has been applied recently (during AoE).");
        module.AddNewOption("Offensive Settings", "Moonfire", 230, true, {2, "Always", "Lunar Inspiration"}, nil, "Enable for the automatic usage of Moonfire while in Human Form or with Lunar Inspiration talent."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability both while in Human Form and with Lunar Inspiration talent."..C.TOOLTIP_SUBVALUE("Lunar Inspiration").."Will only use the ability with Lunar Inspiration talent.");
        module.AddNewOption("Offensive Settings", "Incarnation Prowl", 210, false, nil, nil, "Enable for the automatic usage of Prowl if available while Incarnation is up. (Check it until Blizzard fixes this bug)");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddPresetOption("HealingItem");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Healing Touch High Priority", 220, false, {90, 1, 100, 1}, nil, "Health Percentage to use Survival Instincts.");
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Survival Instincts", 220, true, {45, 1, 100, 1}, nil, "Health Percentage to use Survival Instincts.");

        --- Misc
        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Improved Spell Casting Logic
        module.ISCL = {
            [S.LunarStrike:ID()] = "Lunar Strike",
            [S.SolarWrath:ID()] = "Solar Wrath",
            [S.HealingTouch:ID()] = "Healing Touch",
            [S.Regrowth:ID()] = "Regrowth",
            [S.Revive:ID()] = "Revive"
        };
    end

    --- Combat's Local Functions
    local function ProwlHotfix ()
        if S.Incarnation:Exists() and Player:Buff(S.Berserk) and Player:CanCast(S.Prowl) then
            Player:Cast(S.Prowl);
        end
    end
    local function Generator ()
        -- ashamanes_frenzy,if=combo_points<=2&buff.elunes_guidance.down&(!talent.bloodtalons.enabled|buff.bloodtalons.up)
        if module.IsOptionEnabled("Ashamane's Frenzy") and (module.CooldownsAllowed() or module.GetOptionValue("Ashamane's Frenzy") == "Always") and S.AshamanesFrenzy:Exists() and Player:ComboPoints() <= 2 and not Player:Buff(S.ElunesGuidance) and (not S.Bloodtalons:Exists() or Player:Buff(S.BloodtalonsBuff)) and Target:CanCast(S.AshamanesFrenzy) then
            Target:Cast(S.AshamanesFrenzy);
            return;
        end
        -- pool_resource,for_next=1
        -- brutal_slash,if=spell_targets.brutal_slash>desired_targets
        -- pool_resource,for_next=1
        -- brutal_slash,if=active_enemies>=2&raid_event.adds.exists&raid_event.adds.in>(1+max_charges-charges_fractional)*15
        -- pool_resource,for_next=1
        -- brutal_slash,if=active_enemies>=2&!raid_event.adds.exists&(charges_fractional>2.66&time>10)
        -- swipe_cat,if=spell_targets.swipe_cat>=4
        if module.UseAOE() and module.IsOptionEnabled("Swipe") and NumEnemies >= module.GetOptionValue("Swipe") then
            if S.BrutalSlash:Exists() then
                if Player:CanCast(S.BrutalSlash) then
                    Player:Cast(S.BrutalSlash);
                    return;
                end
            elseif Player:CanCast(S.Swipe) then
                Player:Cast(S.Swipe);
                return;
            end
        end
        -- shred,if=spell_targets.swipe_cat<=3|talent.brutal_slash.enabled
        if (NumEnemies < module.GetOptionValue("Swipe") or S.BrutalSlash:Exists()) and Target:CanCast(S.Shred) then
            Target:Cast(S.Shred);
            return;
        end
    end
    local function Finisher ()
        -- rip,cycle_targets=1,if=remains<=duration*0.3&(target.health.pct>25|!dot.rip.ticking)
        if Target:DebuffRemains(S.Rip) <= RipPandemic and (Target:HealthPercentage() > 25 or not Target:Debuff(S.Rip)) and Target:TimeToDie() > RipTargetTTD and Target:CanCast(S.Rip) then
            Target:Cast(S.Rip);
            return;
        end
        if module.UseAOE() then
            local ThisUnit;
            for i = 1, #Enemies_5y do
                ThisUnit = Enemies_5y[i];
                if ThisUnit:DebuffRemains(S.Rip) <= RipPandemic and (ThisUnit:HealthPercentage() > 25 or not ThisUnit:Debuff(S.Rip)) and Target:TimeToDie() > RipCycleTTD and ThisUnit:CanCast(S.Rip) then
                    ThisUnit:Cast(S.Rip);
                    return;
                end
            end
        end
        -- savage_roar,if=buff.savage_roar.remains<=7.2&(target.health.pct<25|energy.time_to_max<1|buff.berserk.up|buff.incarnation.up|dot.rake.remains<1.5|buff.elunes_guidance.up|cooldown.tigers_fury.remains<3|(talent.moment_of_clarity.enabled&buff.clearcasting.react))
        if S.SavageRoar:Exists() and Player:BuffRemains(S.SavageRoar) <= 7.2 and (Target:HealthPercentage() < 25 or Player:EnergyTimeToMax() < 1 or Player:Buff(S.Berserk) or Target:DebuffRemains(S.RakeDebuff) < 1.5 or Player:Buff(S.ElunesGuidance) or S.TigersFury:Cooldown() < 3 or (S.MomentofClarity:Exists() and Player:Buff(S.Clearcasting))) and Player:CanCast(S.SavageRoar) then
            Player:Cast(S.SavageRoar);
            return;
        end
        -- ferocious_bite,max_energy=1,cycle_targets=1,if=(target.health.pct<25|talent.sabertooth.enabled)&(cooldown.tigers_fury.remains<3|energy.time_to_max<1|buff.berserk.up|buff.incarnation.up|dot.rake.remains<1.5|buff.elunes_guidance.up|(talent.moment_of_clarity.enabled&buff.clearcasting.react))
        if (Target:HealthPercentage() < 25 or S.Sabertooth:Exists()) and (S.TigersFury:Cooldown() < 3 or Player:EnergyTimeToMax() < 1 or Player:Buff(S.Berserk) or Target:DebuffRemains(S.RakeDebuff) < 1.5 or Player:Buff(S.ElunesGuidance) or (S.MomentofClarity:Exists() and Player:Buff(S.Clearcasting))) and Target:CanCast(S.FerociousBite, nil, true) then
            if Player:Energy() >= FBValue then
                Target:Cast(S.FerociousBite);
                return;
            else
                return "Pooling";
            end
        end
        if module.UseAOE() then
            local ThisUnit;
            local SabertoothExists = S.Sabertooth:Exists();
            local StaticCondition = S.TigersFury:Cooldown() < 3 or Player:EnergyTimeToMax() < 1 or Player:Buff(S.Berserk) or Player:Buff(S.ElunesGuidance) or (S.MomentofClarity:Exists() and Player:Buff(S.Clearcasting));
            for i = 1, #Enemies_5y do
                ThisUnit = Enemies_5y[i];
                if (SabertoothExists or ThisUnit:HealthPercentage() > 25) and (StaticCondition or ThisUnit:DebuffRemains(S.RakeDebuff) < 1.5) and ThisUnit:CanCast(S.FerociousBite, nil, true) then
                    if Player:Energy() >= FBValue then
                        ThisUnit:Cast(S.FerociousBite);
                        return;
                    else
                        return "Pooling";
                    end
                end
            end
        end
        -- ferocious_bite,max_energy=1,if=buff.berserk.up|buff.incarnation.up|cooldown.tigers_fury.remains<3|buff.elunes_guidance.up
        if Player:Buff(S.Berserk) or S.TigersFury:Cooldown() < 3 or Player:Buff(S.ElunesGuidance) and Target:CanCast(S.FerociousBite, nil, true) then
            if Player:Energy() >= FBValue then
                Target:Cast(S.FerociousBite);
                return;
            else
                return "Pooling";
            end
        end
        -- ferocious_bite,max_energy=1,if=energy.time_to_max<1
        if Player:EnergyTimeToMax() < 1 and Target:CanCast(S.FerociousBite, nil, true) then
            if Player:Energy() >= FBValue then
                Target:Cast(S.FerociousBite);
                return;
            else
                return "Pooling";
            end
        end
    end
    local function Maintain ()
        -- shadowmeld,if=energy>=35&dot.rake.pmultiplier<2.1&buff.tigers_fury.up&(buff.bloodtalons.up|!talent.bloodtalons.enabled)&(!talent.incarnation.enabled|cooldown.incarnation.remains>18)&!buff.incarnation.up
        if S.Shadowmeld:Exists() and module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:Standing() >= ShadowmeldStanding and Player:Energy() >= 35 and Target:RakeDamage() < 2.1 and Player:Buff(S.TigersFury) and (Player:Buff(S.BloodtalonsBuff) or not S.Bloodtalons:Exists()) and (not S.Incarnation:Exists() or S.Incarnation:Cooldown() > 18) and not Player:Buff(S.Incarnation) and Player:CanCast(S.Shadowmeld) then
            Player:Cast(S.Shadowmeld);
            return;
        end
        -- rake,cycle_targets=1,if=remains<=tick_time&((target.time_to_die-remains>3&spell_targets.swipe_cat<3)|target.time_to_die-remains>6)
        RakeTickTime = S.JaggedWounds:Exists() and 3*(1-0.33) or 3; -- 0.33 is the % from Jagged Wounds, currently 33%.
        if Target:DebuffRemains(S.RakeDebuff) <= RakeTickTime and ((Target:TimeToDie()-Target:DebuffRemains(S.RakeDebuff) > 3 and NumEnemies < 3) or Target:TimeToDie()-Target:DebuffRemains(S.RakeDebuff) > 6) and Target:TimeToDie() > RakeTargetTTD and Target:CanCast(S.Rake) then
            ProwlHotfix();
            Target:Cast(S.Rake);
            return;
        end
        if module.UseAOE() then
            local ThisUnit;
            for i = 1, #Enemies_5y do
                ThisUnit = Enemies_5y[i];
                if ThisUnit:DebuffRemains(S.RakeDebuff) <= RakeTickTime and ((ThisUnit:TimeToDie()-ThisUnit:DebuffRemains(S.RakeDebuff) > 3 and NumEnemies < 3) or ThisUnit:TimeToDie()-ThisUnit:DebuffRemains(S.RakeDebuff) > 6) and ThisUnit:TimeToDie() > RakeCycleTTD and ThisUnit:CanCast(S.Rake) then
                    ProwlHotfix();
                    ThisUnit:Cast(S.Rake);
                    return;
                end
            end
        end
        -- rake,cycle_targets=1,if=remains<=duration*0.3&(persistent_multiplier>=dot.rake.pmultiplier|(talent.bloodtalons.enabled&(buff.bloodtalons.up|!buff.predatory_swiftness.up)))&((target.time_to_die-remains>3&spell_targets.swipe_cat<3)|target.time_to_die-remains>6)
        if Target:DebuffRemains(S.RakeDebuff) <= RakePandemic and (module.BleedDamage("Rake") >= Target:RakeDamage() or (S.Bloodtalons:Exists() and (Player:Buff(S.BloodtalonsBuff) or not Player:Buff(S.PredatorySwiftness)))) and ((Target:TimeToDie()-Target:DebuffRemains(S.RakeDebuff) > 3 and NumEnemies < 3) or Target:TimeToDie()-Target:DebuffRemains(S.RakeDebuff) > 6) and Target:TimeToDie() > RakeTargetTTD and Target:CanCast(S.Rake) then
            ProwlHotfix();
            Target:Cast(S.Rake);
            return;
        end
        if module.UseAOE() then
            local ThisUnit;
            local StaticCondition = S.Bloodtalons:Exists() and (Player:Buff(S.BloodtalonsBuff) or not Player:Buff(S.PredatorySwiftness));
            for i = 1, #Enemies_5y do
                ThisUnit = Enemies_5y[i];
                if ThisUnit:DebuffRemains(S.RakeDebuff) <= RakePandemic and (module.BleedDamage("Rake") >= ThisUnit:RakeDamage() or StaticCondition) and ((ThisUnit:TimeToDie()-ThisUnit:DebuffRemains(S.RakeDebuff) > 3 and NumEnemies < 3) or ThisUnit:TimeToDie()-ThisUnit:DebuffRemains(S.RakeDebuff) > 6) and ThisUnit:TimeToDie() > RakeCycleTTD and ThisUnit:CanCast(S.Rake) then
                    ProwlHotfix();
                    ThisUnit:Cast(S.Rake);
                    return;
                end
            end
        end
        -- moonfire_cat,cycle_targets=1,if=remains<=4.2&spell_targets.swipe_cat<=5&target.time_to_die-remains>tick_time*5
        if module.IsOptionEnabled("Moonfire") and S.LunarInspiration:Exists() and NumEnemies <= 5 then
            MoonfireTickTime = (20.0/(1+UnitSpellHaste("player")/100)/10)*5;
            if Target:DebuffRemains(S.MoonfireDebuff) <= 4.2 and Target:TimeToDie() > RakeTargetTTD and Target:TimeToDie()-Target:DebuffRemains(S.MoonfireDebuff) > MoonfireTickTime and Target:CanCast(S.Moonfire) then
                Target:Cast(S.Moonfire);
                return;
            end
            if module.UseAOE() then
                local ThisUnit;
                for i = 1, #Enemies_45y do
                    ThisUnit = Enemies_45y[i];
                    if ThisUnit:DebuffRemains(S.MoonfireDebuff) <= 4.2 and ThisUnit:TimeToDie() > RakeCycleTTD and ThisUnit:TimeToDie()-ThisUnit:DebuffRemains(S.MoonfireDebuff) > MoonfireTickTime and ThisUnit:CanCast(S.Moonfire) then
                        ThisUnit:Cast(S.Moonfire);
                        return;
                    end
                end
            end
        end
    end
    local function AoEList ()
        -- thrash_cat,cycle_targets=1,if=remains<=duration*0.3&spell_targets.thrash_cat>=2
        if module.UseAOE() and module.IsOptionEnabled("Thrash") and NumEnemies >= module.GetOptionValue("Thrash") then
            local Count = 0;
            local ThisUnit;
            for i = 1, #Enemies_8y do
                ThisUnit = Enemies_8y[i];
                if ThisUnit:DebuffRemains(S.Thrash) > ThrashSmartDuration then
                    Count = Count + 1;
                end
            end
            if NumEnemies-Count >= module.GetSecondOptionValue("Thrash") then
                for i = 1, #Enemies_8y do
                    ThisUnit = Enemies_8y[i];
                    if ThisUnit:DebuffRemains(S.Thrash) < ThrashPandemic then
                        if Player:CanCast(S.Thrash) then
                            Player:Cast(S.Thrash);
                            return;
                        elseif (Player:Energy() < 50 or (Player:Buff(S.Berserk) and Player:Energy() < 25)) then
                            return;
                        end
                    end
                end
            end
        end
        -- call_action_list,name=finisher,if=combo_points=5
        if Player:ComboPoints() == 5 then
            if Finisher() == "Pooling" then
                return;
            end
        end
        -- swipe_cat
        if module.UseAOE() and module.IsOptionEnabled("Swipe") and NumEnemies >= module.GetOptionValue("Swipe") then
            if Player:CanCast(S.Swipe) then
                Player:Cast(S.Swipe);
                return;
            end
        end
    end
    local function TigersFurySync ()
        -- Trinkets
        Player:UseTrinkets();
        -- Berserking
        if S.Berserking:Exists() and module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:CanCast(S.Berserking) then
            CastSpellByID(26297, "player")
        end
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we wait to keep updated
        Player:SetCommonMeleeStatus();
        -- Multiple Spell IDs Handler
        S.HealingTouch = Player:Buff(S.PredatorySwiftness) and Spell(5185, false, false, true) or Spell(5185, false, false, false); -- w/ or w/o Predatory Swiftness Buff (HT Instant)
        if S.Incarnation:Exists() then -- w/ or w/ Incarnation Talent
            S.Berserk = Spell(102543, false, false, true); --102453
            S.Prowl = Player:Buff(S.Incarnation) and Spell(102547, false, false, true) or Spell(5215, false, false, true); -- w/ or w/o Incarnation Buff
        else
            S.Berserk = Spell(106951, false, false, true);
            S.Prowl = Spell(5215, false, false, true);
        end
        if S.LunarInspiration:Exists() and Player:Buff(S.CatForm) then -- w/ or w/o LunarInspiration Talent
            S.Moonfire = Spell(155625, false, true, true);
            S.MoonfireDebuff = Spell(155625, false, false, false);
        else
            S.Moonfire = Spell(8921, false, true, true);
            S.MoonfireDebuff = Spell(164812, false, false, false);
        end
        if Player:Buff(S.CatForm) then -- Swipe & Thrash while in Cat Form
            S.Swipe = Spell(106785, false, false, true);
            S.Thrash = Spell(106830, false, false, true);
            S.ThrashDebuff = Spell(106830, false, false, false);
        elseif Player:Buff(S.BearForm) then -- Swipe & Thrash while in Bear Form
            S.Swipe = Spell(213771, false, false, true);
            S.Thrash = Spell(77758, false, false, true);
            S.ThrashDebuff = Spell(192090, false, false, false);
        else -- Swipe & Thrash while in Normal/Travel/Moonkin Form
            S.Swipe = Spell(213764, false, false, true);
            S.Thrash = Spell(106832, false, false, true);
            S.ThrashDebuff = Spell(106832, false, false, false);
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Survival Instincts") and Player:HealthPercentage() <= module.GetOptionValue("Survival Instincts") and not Player:Buff(S.SurvivalInstincts) and S.SurvivalInstincts:TimeSinceCast() > 0.5 and Player:CanCast(S.SurvivalInstincts) then
            Player:Cast(S.SurvivalInstincts);
            S.SurvivalInstincts.LastCastTime = module.GetTime();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(S.SkullBash);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(S.Shred, true) or Unit.Target;
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        -- Combat Res Tanks
        if module.IsOptionEnabled("Instant Rebirth Tank") then
            MainTank, OffTank = Unit.MainTank(), Unit.OffTank();
            if MainTank and MainTank:Exists() and MainTank:IsPlayer() then
                if not MainTank:IsDeadOrGhost() then
                    MainTankResDelay = nil;
                else
                    if not MainTankResDelay then MainTankResDelay = module.GetTime() + module.GetOptionValue("Instant Rebirth Tank"); end
                    if module.GetTime() >= MainTankResDelay and Player:Buff(S.PredatorySwiftness) and MainTank:CanCast(S.Rebirth) then
                        MainTankResDelay = nil;
                        MainTank:Cast(S.Rebirth);
                        return;
                    end
                end
            end
            if OffTank and OffTank:Exists() and OffTank:IsPlayer() then
                if not OffTank:IsDeadOrGhost() then
                    OffTankResDelay = nil;
                else
                    if not OffTankResDelay then OffTankResDelay = module.GetTime() + module.GetOptionValue("Instant Rebirth Tank"); end
                    if module.GetTime() >= OffTankResDelay and Player:Buff(S.PredatorySwiftness) and OffTank:CanCast(S.Rebirth) then
                        OffTankResDelay = nil;
                        OffTank:Cast(S.Rebirth);
                        return;
                    end
                end
            end
        end
        -- Combat Res Target
        if module.IsOptionEnabled("Rebirth") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and Target:IsPlayer() and Target:CanCast(S.Rebirth) then
            Target:Cast(S.Rebirth);
            return;
        end

        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Enemies Check:
            if module.UseAOE() then
                Enemies_45y = Player:EnemiesWithinDistance(45, false);-- This Table is the used for Moonfire Cycling (+ others use it as the master).
                if S.BalanceAffinity:Exists() then -- Add +5y range
                    Enemies_8y = Player:FilterEnemiesByDistance(Enemies_45y, 13, true); -- Using 13y (real range w/ Balance Affinity) for Thrash & Swipe and true as they are PlayerCenteredAoE Spells.
                    Enemies_5y = Player:FilterEnemiesByDistance(Enemies_8y, 10, false); -- This table is used for Melee Range Cycling Abilities (like Rip, Rake, etc...).
                else
                    Enemies_8y = Player:FilterEnemiesByDistance(Enemies_45y, 8, true); -- Using 8y (real range) for Thrash & Swipe and true as they are PlayerCenteredAoE Spells.
                    Enemies_5y = Player:FilterEnemiesByDistance(Enemies_8y, 5, false); -- This table is used for Melee Range Cycling Abilities (like Rip, Rake, etc...).
                end
                NumEnemies = #Enemies_8y;
            else
                NumEnemies = 1;
            end
            -- Energy cost to have a full Ferocious Bite
            if Player:Buff(S.Berserk) and Player:Buff(S.Clearcasting) then
                FBValue = 12.5;
            elseif Player:Buff(S.Berserk) or Player:Buff(S.Clearcasting) then
                FBValue = 25;
            else
                FBValue = 50;
            end
            -- TTD Values
            RipTargetTTD = module.GetOptionValue("Rip: Target | Adds");
            RipCycleTTD = module.GetSecondOptionValue("Rip: Target | Adds");
            RakeTargetTTD = module.GetOptionValue("Rake: Target | Adds");
            RakeCycleTTD = module.GetSecondOptionValue("Rake: Target | Adds");
            -- Jagged Wounds Handler
            if S.JaggedWounds:Exists() then
                RakePandemic = 3.015;
                RipPandemic = 4.824;
                ThrashPandemic = 3.015;
                ThrashSmartDuration = 6.7;
            else
                RakePandemic = 4.5;
                RipPandemic = 7.2;
                ThrashPandemic = 4.5;
                ThrashSmartDuration = 10;
            end

            Lowest = Unit.Lowest();

            -- Balance Affinity
            if Player:Buff(S.MoonkinForm) then
                -- Starsurge
                if Target:CanCast(S.Starsurge) then
                    Target:Cast(S.Starsurge);
                    return;
                end
                -- DoT Target
                if Target:TimeToDie() > RakeTargetTTD then
                    -- Sunfire
                    if Target:DebuffRemains(S.SunfireDebuff) <= 4 and Target:CanCast(S.Sunfire) then
                        Target:Cast(S.Sunfire);
                        return;
                    end
                    -- Moonfire
                    if Target:DebuffRemains(S.MoonfireDebuff) <= 4 and Target:CanCast(S.Moonfire) then
                        Target:Cast(S.Moonfire);
                        return;
                    end
                end
                -- DoT AoE
                if module.UseAOE() then
                    local ThisUnit;
                    for i = 1, #Enemies_45y do
                        ThisUnit = Enemies_45y[i];
                        if ThisUnit:TimeToDie() > RakeCycleTTD then
                            -- Sunfire
                            if ThisUnit:DebuffRemains(S.SunfireDebuff) <= 4 and ThisUnit:CanCast(S.Sunfire) then
                                ThisUnit:Cast(S.Sunfire);
                                return;
                            end
                            -- Moonfire
                            if ThisUnit:DebuffRemains(S.MoonfireDebuff) <= 4 and ThisUnit:CanCast(S.Moonfire) then
                                ThisUnit:Cast(S.Moonfire);
                                return;
                            end
                        end
                    end
                end
                -- Solar Wrath
                if Player:Buff(S.SolarEmpowerment) and Target:CanCast(S.SolarWrath) then
                    Target:Cast(S.SolarWrath);
                    return;
                end
                -- Lunar Strike
                if Target:CanCast(S.LunarStrike) then
                    Target:Cast(S.LunarStrike);
                    return;
                end
                return;
            end
            -- Bear Rotation
            if Player:Buff(S.BearForm) then
                -- Guardian Affinity Active Mitigation
                if S.GuardianAffinity:Exists() then
                    -- Frenzied Regeneration
                    if Player:HealthPercentage() <= 60 and Player:Rage() >= 10 and Player:CanCast(S.FrenziedRegeneration) then
                        Player:Cast(S.FrenziedRegeneration);
                    end
                    -- Ironfur
                    if Player:Rage() >= 45 and Player:CanCast(S.Ironfur) then
                        Player:Cast(S.Ironfur);
                        return;
                    end
                end
                -- Thrash
                if Player:DistanceTo(Target, false, true) <= 8+(S.BalanceAffinity:Exists() and 5 or 0) and Player:CanCast(S.Thrash) then
                    Player:Cast(S.Thrash);
                    return;
                end
                -- Guardian Affinity Mangle
                if S.GuardianAffinity:Exists() and Target:CanCast(S.Mangle) then
                    Target:Cast(S.Mangle);
                    return;
                end
                -- Moonfire
                if Target:TimeToDie() > RakeTargetTTD and Target:DebuffRemains(S.MoonfireDebuff) <= 4 and Target:CanCast(S.Moonfire) then
                    Target:Cast(S.Moonfire);
                    return;
                end
                -- Swipe
                if not S.BrutalSlash:Exists() and Player:DistanceTo(Target, false, true) <= 8+(S.BalanceAffinity:Exists() and 5 or 0) and Player:CanCast(S.Swipe) then
                    Player:Cast(S.Swipe);
                    return;
                end
                -- Moonfire
                if module.UseAOE() then
                    local ThisUnit;
                    for i = 1, #Enemies_45y do
                        ThisUnit = Enemies_45y[i];
                        if ThisUnit:TimeToDie() > RakeCycleTTD and ThisUnit:DebuffRemains(S.MoonfireDebuff) <= 4 and ThisUnit:CanCast(S.Moonfire) then
                            ThisUnit:Cast(S.Moonfire);
                            return;
                        end
                    end
                end
                -- Moonfire Out of Range
                if Target:CanCast(S.Moonfire) then
                    Target:Cast(S.Moonfire);
                    return;
                end
                return;
            end
            -- Restoration Affinity
            if S.RestorationAffinity:Exists() and not Player:Buff(S.CatForm) then
                -- Swiftmend
                if Lowest:CanCast(S.Swiftmend) then
                    Lowest:Cast(S.Swiftmend);
                    return;
                end
                -- Rejuvenation
                if Lowest:BuffRemains(S.Rejuvenation) <= 4.5 and Lowest:CanCast(S.Rejuvenation) then
                    Lowest:Cast(S.Rejuvenation);
                    return;
                end
                -- Regrowth
                if Player:Standing() >= 0.7 and Lowest:BuffRemains(S.Regrowth) <= 3 and Lowest:CanCast(S.Regrowth) then
                    Lowest:Cast(S.Regrowth);
                    return;
                end
                -- Healing Touch
                if Player:Standing() >= 0.7 and Lowest:CanCast(S.HealingTouch) then
                    Lowest:Cast(S.HealingTouch);
                    return;
                end
            end

            -- Cat Form
            if module.IsOptionEnabled("Auto Cat Form and Prowl") and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Cat Form and Prowl") and not Player:Buff(S.CatForm) and Player:CanCast(S.CatForm) then
                Player:Cast(S.CatForm);
                return;
            end
            -- Cat Rotation
            if Player:Buff(S.CatForm) then
                -- Stealth Rake
                if S.Rake:TimeSinceCast() > 0.5 and Player:IsStealthed(true, true) and Target:CanCast(S.Rake) then
                    ProwlHotfix();
                    Target:Cast(S.Rake);
                    S.Rake.LastCastTime = module.GetTime();
                    return;
                end
                -- Stealth Pool
                if Player:IsStealthed(true, true) then
                    return;
                end
                -- Healing Touch High priority
                if module.IsOptionEnabled("Healing Touch High Priority") and Lowest and Player:Buff(S.PredatorySwiftness) and not Player:IsStealthed(true, true) and Lowest:HealthPercentage() <= module.GetOptionValue("Healing Touch High Priority") and Lowest:CanCast(S.HealingTouch) then
                    Lowest:Cast(S.HealingTouch);
                    return;
                end
                -- Cooldowns
                if Player:IsWithinCastRange(Target, S.Shred) then
                    -- elunes_guidance,if=combo_points=0&(!artifact.ashamanes_bite.enabled|!dot.ashamanes_rip.ticking)
                    -- TODO : Add Ashamanes Bite Support
                    if module.IsOptionEnabled("Elune's Guidance") and (module.CooldownsAllowed() or module.GetOptionValue("Elune's Guidance") == "Always") and S.ElunesGuidance:Exists() and Player:ComboPoints() == 0 and Player:CanCast(S.ElunesGuidance) then
                        Player:Cast(S.ElunesGuidance);
                        return;
                    end
                    -- berserk,if=buff.tigers_fury.up
                    -- incarnation,if=cooldown.tigers_fury.remains<gcd
                    -- use_item,slot=trinket1,if=(prev.tigers_fury&(target.time_to_die>trinket.stat.any.cooldown|target.time_to_die<45))|prev.berserk|(buff.incarnation.up&time<10)
                    if module.IsOptionEnabled("Berserk") and module.CooldownsAllowed() and not Player:Buff(S.Berserk) and ((not S.Incarnation:Exists() and Player:Buff(S.TigersFury)) or (S.Incarnation:Exists() and S.TigersFury:Cooldown() < Player:GCD())) and Player:CanCast(S.Berserk) then
                        Player:UseTrinkets();
                        Player:Cast(S.Berserk);
                        return;
                    end
                    -- potion,name=draenic_agility,if=((buff.berserk.remains>10|buff.incarnation.remains>20)&(target.time_to_die<180|(trinket.proc.all.react&target.health.pct<25)))|target.time_to_die<=40
                        -- TOREADD
                    -- tigers_fury,if=(!buff.clearcasting.react&energy.deficit>=60)|energy.deficit>=80|(t18_class_trinket&buff.berserk.up&buff.tigers_fury.down)
                    -- tigers_fury,if=talent.sabertooth.enabled&time<10&combo_points=5
                    if module.IsOptionEnabled("Tiger's Fury") and (module.CooldownsAllowed() or module.GetOptionValue("Tiger's Fury") == "Always") and ((not Player:Buff(S.Clearcasting) and Player:EnergyDeficit() >= 60) or Player:EnergyDeficit() >= 80 or (module.HasT18_ClassTrinket and Player:Buff(S.Berserk) and not Player:Buff(S.TigersFury)) or (S.Sabertooth:Exists() and CombatTime() < 10 and Player:ComboPoints() == 5)) and Player:CanCast(S.TigersFury) then
                        TigersFurySync();
                        Player:Cast(S.TigersFury);
                        return;
                    end
                    -- incarnation,if=energy.time_to_max>1
                    if module.IsOptionEnabled("Berserk") and module.CooldownsAllowed() and S.Incarnation:Exists() and not Player:Buff(S.Berserk) and Player:EnergyTimeToMax() > 1 and Player:CanCast(S.Berserk) then
                        Player:UseTrinkets();
                        Player:Cast(S.Berserk);
                        return;
                    end
                end
                -- ferocious_bite,cycle_targets=1,if=dot.rip.ticking&dot.rip.remains<3&target.health.pct<25
                if Target:Debuff(S.Rip) and Target:DebuffRemains(S.Rip) < 3 and Target:HealthPercentage() < 25 and Target:CanCast(S.FerociousBite, nil, true) then
                    Target:Cast(S.FerociousBite);
                    return;
                end
                if module.UseAOE() then
                    local ThisUnit;
                    for i = 1, #Enemies_5y do
                        ThisUnit = Enemies_5y[i];
                        if ThisUnit:Debuff(S.Rip) and ThisUnit:DebuffRemains(S.Rip) < 3 and ThisUnit:HealthPercentage() < 25 and ThisUnit:CanCast(S.FerociousBite, nil, true) then
                            ThisUnit:Cast(S.FerociousBite);
                            return;
                        end
                    end
                end
                -- healing_touch,if=talent.bloodtalons.enabled&buff.predatory_swiftness.up&((combo_points>=4&!set_bonus.tier18_4pc)|combo_points=5|buff.predatory_swiftness.remains<1.5)
                -- healing_touch,if=talent.bloodtalons.enabled&buff.predatory_swiftness.up&combo_points=2&buff.bloodtalons.down&cooldown.ashamanes_frenzy.ready
                if S.Bloodtalons:Exists() and Player:Buff(S.PredatorySwiftness) then
                    if ((Player:ComboPoints() >= 4 and not module.HasT18_4Pc) or Player:ComboPoints() == 5 or Player:BuffRemains(S.PredatorySwiftness) <= 1.5) or (Player:ComboPoints() == 2 and not Player:Buff(S.BloodtalonsBuff) and S.AshamanesFrenzy:Exists() and not S.AshamanesFrenzy:IsOnCooldown()) then
                        if Focus:Exists() and Focus:CanCast(S.HealingTouch) then
                            Focus:Cast(S.HealingTouch);
                            return;
                        end
                        if Lowest and Lowest:CanCast(S.HealingTouch) then
                            Lowest:Cast(S.HealingTouch);
                            return;
                        end
                        if Player:CanCast(S.HealingTouch) then
                            Player:Cast(S.HealingTouch)
                            return;
                        end
                    end
                end
                -- savage_roar,if=buff.savage_roar.down
                if S.SavageRoar:Exists() and not Player:Buff(S.SavageRoar) and Player:CanCast(S.SavageRoar) then
                    Player:Cast(S.SavageRoar);
                    return;
                end
                -- call_action_list,name=aoe,if=spell_targets.swipe_cat>=3
                AoEList();
                -- call_action_list,name=finisher,if=combo_points=5
                if Player:ComboPoints() == 5 then
                    if Finisher() == "Pooling" then
                        return;
                    end
                end
                -- savage_roar,if=buff.savage_roar.remains<gcd
                if S.SavageRoar:Exists() and Player:BuffRemains(S.SavageRoar) < Player:GCD() and Player:CanCast(S.SavageRoar) then
                    Player:Cast(S.SavageRoar);
                    return;
                end
                -- ashamanes_frenzy,if=time<10&dot.rake.ticking&!talent.elunes_guidance.enabled
                if module.IsOptionEnabled("Ashamane's Frenzy") and (module.CooldownsAllowed() or module.GetOptionValue("Ashamane's Frenzy") == "Always") and S.AshamanesFrenzy:Exists() and CombatTime() < 10 and Target:Debuff(S.RakeDebuff) and not S.ElunesGuidance:Exists() and Target:CanCast(S.AshamanesFrenzy) then
                    Target:Cast(S.AshamanesFrenzy);
                    return;
                end
                -- call_action_list,name=maintain,if=combo_points<5
                if Player:ComboPoints() < 5 then
                    Maintain();
                end
                -- pool_resource,for_next=1
                -- thrash_cat,cycle_targets=1,if=remains<=duration*0.3&(spell_targets.thrash_cat>=2&set_bonus.tier17_2pc|spell_targets.thrash_cat>=4)
                if module.UseAOE() and module.IsOptionEnabled("Thrash") and NumEnemies >= module.GetOptionValue("Thrash") then
                    local Count = 0;
                    local ThisUnit;
                    for i = 1, #Enemies_8y do
                        ThisUnit = Enemies_8y[i];
                        if ThisUnit:DebuffRemains(S.Thrash) > ThrashSmartDuration then
                            Count = Count + 1;
                        end
                    end
                    if NumEnemies-Count >= module.GetSecondOptionValue("Thrash") then
                        for i = 1, #Enemies_8y do
                            ThisUnit = Enemies_8y[i];
                            if ThisUnit:DebuffRemains(S.Thrash) < ThrashPandemic then
                                if Player:CanCast(S.Thrash) then
                                    Player:Cast(S.Thrash);
                                    return;
                                elseif (Player:Energy() < 50 or (Player:Buff(S.Berserk) and Player:Energy() < 25)) then
                                    return;
                                end
                            end
                        end
                    end
                end
                -- call_action_list,name=generator,if=combo_points<5
                if Player:ComboPoints() < 5 then
                    Generator();
                end
                -- Healing Filler
                if Lowest and not S.Bloodtalons:Exists() and Player:Buff(S.PredatorySwiftness) and Lowest:CanCast(S.HealingTouch) then
                    Lowest:Cast(S.HealingTouch);
                    return;
                end
            elseif module.IsOptionEnabled("Moonfire") and module.GetSecondOptionValue("Moonfire") == "Always" then
                -- Moonfire AoE
                if module.UseAOE() then
                    local ThisUnit;
                    for i = 1, #Enemies_45y do
                        ThisUnit = Enemies_45y[i];
                        if ThisUnit:DebuffRemains(S.MoonfireDebuff) <= 4.2 and ThisUnit:TimeToDie() > RakeCycleTTD and ThisUnit:CanCast(S.Moonfire) then
                            ThisUnit:Cast(S.Moonfire);
                            return;
                        end
                    end
                end
                -- Moonfire Out of Range
                if Target:CanCast(S.Moonfire) then
                    Target:Cast(S.Moonfire);
                    return;
                end
            end
            return;
        end
        return;
        -- cat_form
        -- wild_charge
        -- displacer_beast,if=movement.distance>10
        -- dash,if=movement.distance&buff.displacer_beast.down&buff.wild_charge_movement.down
        -- rake,if=buff.prowl.up|buff.shadowmeld.up
        -- auto_attack
        -- skull_bash
        -- pool_resource,wait=0.1,for_next=1,extra_amount=50
        -- elunes_guidance,if=combo_points=0&(!artifact.ashamanes_bite.enabled|!dot.ashamanes_rip.ticking)
        -- berserk,if=buff.tigers_fury.up
        -- incarnation,if=cooldown.tigers_fury.remains<gcd
        -- use_item,slot=trinket1,if=(prev.tigers_fury&(target.time_to_die>trinket.stat.any.cooldown|target.time_to_die<45))|prev.berserk|(buff.incarnation.up&time<10)
        -- potion,name=draenic_agility,if=((buff.berserk.remains>10|buff.incarnation.remains>20)&(target.time_to_die<180|(trinket.proc.all.react&target.health.pct<25)))|target.time_to_die<=40
        -- blood_fury,sync=tigers_fury
        -- berserking,sync=tigers_fury
        -- arcane_torrent,sync=tigers_fury
        -- tigers_fury,if=(!buff.clearcasting.react&energy.deficit>=60)|energy.deficit>=80|(t18_class_trinket&buff.berserk.up&buff.tigers_fury.down)
        -- tigers_fury,if=talent.sabertooth.enabled&time<10&combo_points=5
        -- incarnation,if=energy.time_to_max>1
        -- ferocious_bite,cycle_targets=1,if=dot.rip.ticking&dot.rip.remains<3&target.health.pct<25
        -- healing_touch,if=talent.bloodtalons.enabled&buff.predatory_swiftness.up&((combo_points>=4&!set_bonus.tier18_4pc)|combo_points=5|buff.predatory_swiftness.remains<1.5)
        -- healing_touch,if=talent.bloodtalons.enabled&buff.predatory_swiftness.up&combo_points=2&buff.bloodtalons.down&cooldown.ashamanes_frenzy.ready
        -- savage_roar,if=buff.savage_roar.down
        -- pool_resource,for_next=1
        -- thrash_cat,cycle_targets=1,if=remains<=duration*0.3&(spell_targets.thrash_cat>=2&set_bonus.tier17_2pc|spell_targets.thrash_cat>=4)
        -- call_action_list,name=aoe,if=spell_targets.swipe_cat>=3
        -- call_action_list,name=finisher,if=combo_points=5
        -- savage_roar,if=buff.savage_roar.remains<gcd
        -- ashamanes_frenzy,if=time<10&dot.rake.ticking&!talent.elunes_guidance.enabled
        -- call_action_list,name=maintain,if=combo_points<5
        -- pool_resource,for_next=1
        -- thrash_cat,cycle_targets=1,if=remains<=duration*0.3&spell_targets.thrash_cat>=2
        -- call_action_list,name=generator,if=combo_points<5

        -- ashamanes_frenzy,if=combo_points<=2&buff.elunes_guidance.down&(!talent.bloodtalons.enabled|buff.bloodtalons.up)
        -- pool_resource,for_next=1
        -- brutal_slash,if=spell_targets.brutal_slash>desired_targets
        -- pool_resource,for_next=1
        -- brutal_slash,if=active_enemies>=2&raid_event.adds.exists&raid_event.adds.in>(1+max_charges-charges_fractional)*15
        -- pool_resource,for_next=1
        -- brutal_slash,if=active_enemies>=2&!raid_event.adds.exists&(charges_fractional>2.66&time>10)
        -- swipe_cat,if=spell_targets.swipe_cat>=4
        -- shred,if=spell_targets.swipe_cat<=3|talent.brutal_slash.enabled

        -- rip,cycle_targets=1,if=remains<=duration*0.3&(target.health.pct>25|!dot.rip.ticking)
        -- savage_roar,if=buff.savage_roar.remains<=7.2&(target.health.pct<25|energy.time_to_max<1|buff.berserk.up|buff.incarnation.up|dot.rake.remains<1.5|buff.elunes_guidance.up|cooldown.tigers_fury.remains<3|(talent.moment_of_clarity.enabled&buff.clearcasting.react))
        -- ferocious_bite,max_energy=1,cycle_targets=1,if=(target.health.pct<25|talent.sabertooth.enabled)&(cooldown.tigers_fury.remains<3|energy.time_to_max<1|buff.berserk.up|buff.incarnation.up|dot.rake.remains<1.5|buff.elunes_guidance.up|(talent.moment_of_clarity.enabled&buff.clearcasting.react))
        -- ferocious_bite,max_energy=1,if=buff.berserk.up|buff.incarnation.up|cooldown.tigers_fury.remains<3|buff.elunes_guidance.up
        -- ferocious_bite,max_energy=1,if=energy.time_to_max<1

        -- shadowmeld,if=energy>=35&dot.rake.pmultiplier<2.1&buff.tigers_fury.up&(buff.bloodtalons.up|!talent.bloodtalons.enabled)&(!talent.incarnation.enabled|cooldown.incarnation.remains>18)&!buff.incarnation.up
        -- rake,cycle_targets=1,if=remains<=tick_time&((target.time_to_die-remains>3&spell_targets.swipe_cat<3)|target.time_to_die-remains>6)
        -- rake,cycle_targets=1,if=remains<=duration*0.3&(persistent_multiplier>=dot.rake.pmultiplier|(talent.bloodtalons.enabled&(buff.bloodtalons.up|!buff.predatory_swiftness.up)))&((target.time_to_die-remains>3&spell_targets.swipe_cat<3)|target.time_to_die-remains>6)
        -- moonfire_cat,cycle_targets=1,if=remains<=4.2&spell_targets.swipe_cat<=5&target.time_to_die-remains>tick_time*5

        -- thrash_cat,cycle_targets=1,if=remains<=duration*0.3&spell_targets.thrash_cat>=2
        -- call_action_list,name=finisher,if=combo_points=5
        -- swipe_cat


        --- DoT TickTime = Full_Duraction/(1+HastePct/100)/NB_Tick
        --- Bleed TickTime = Full_Duraction/NB_Tick
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Auto Cancel Form
        if module.IsOptionEnabled("Auto Cancel Cat Form") and Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and Player:DistanceTo(Target) > module.GetOptionValue("Auto Cancel Cat Form") and Player:Buff(S.CatForm) then
            CancelShapeshiftForm();
            return;
        end
        -- Healing Part
        if not Player:Buff(S.CatForm) then
            -- Auto-Resuscitate Friends
            if module.IsOptionEnabled("Auto-Resuscitate Friends") and Player:Standing() >= 0.7 then
                UnitNeedRes = Unit.Resurrect(S.Revive);
                if UnitNeedRes and UnitNeedRes:CanCast(S.Revive) then
                    UnitNeedRes:Cast(S.Revive);
                    return;
                end
                if not UnitNeedRes then Unit:ResurrectCheck(true); end
            end
            -- Auto-Heal OutOfCombat
            if module.IsOptionEnabled("Auto-Heal OutOfCombat") and Player:Mana()/Player:ManaMax()*100 >= module.GetSecondOptionValue("Auto-Heal OutOfCombat") and Player:HealthPercentage() <= module.GetOptionValue("Auto-Heal OutOfCombat") then
                if S.RestorationAffinity:Exists() then
                    if Player:CanCast(S.Swiftmend) then
                        Player:Cast(S.Swiftmend);
                        return;
                    end
                    if Player:BuffRemains(S.Rejuvenation) <= 4.5 and Player:CanCast(S.Rejuvenation) then
                        Player:Cast(S.Rejuvenation);
                        return;
                    end
                    if Player:Standing() >= 0.7 and Player:BuffRemains(S.Regrowth) <= 3 and Player:CanCast(S.Regrowth) then
                        Player:Cast(S.Regrowth);
                        return;
                    end
                end
                if Player:Standing() >= 0.7 and Player:CanCast(S.HealingTouch) then
                    Player:Cast(S.HealingTouch);
                    return;
                end
            end
            -- PreCasting S.HealingTouch to proc Bloodtalons Buff
            if module.IsOptionEnabled("Proc Bloodtalons") and S.Bloodtalons:Exists() and Player:BuffRemains(S.BloodtalonsBuff) <= module.GetOptionValue("Proc Bloodtalons") and not Player:Buff(S.CatForm) and Player:Standing() >= 0.7 and Player:CanCast(S.HealingTouch) then
                Player:Cast(S.HealingTouch);
                return;
            end
        end
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(S.DraenicAgilityBuff) and S.DraenicAgility:InStock() and not S.DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            if module.IsOptionEnabled("Auto Cat Form and Prowl") and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Cat Form and Prowl") then
                -- Auto Stealth
                if not Player:IsStealthed(true, true) and Player:CanCast(S.Prowl) then
                    Player:Cast(S.Prowl);
                    return;
                end
                -- Auto Cat Form
                if not Player:Buff(S.CatForm) and Player:CanCast(S.CatForm) then
                    Player:Cast(S.CatForm);
                    return;
                end
            end
            -- Open with rake when in range and stealthed
            if Player:IsStealthed(true, true) and Target:CanCast(S.Rake) then
                Target:Cast(S.Rake);
                return;
            end
        end
        return;
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Guardian Druid
    local Rotation = {};
    module.SetRotation("_"..104, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local Enemies_40y, Enemies_30y , MoonfireUnit, SunfireUnit, PlayerEnemies_10y, SurroundingEnemies, NumEnemies = {}, {}, nil, nil, {}, {}, 0; -- Units
    local RandomOffGCD;
    -- Healers Specific
    local MainTank, MainTankTarget, OffTank, OffTankTarget, Lowest, HealUnits = nil, nil, nil, nil, nil, {};

    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        IntellectPotion = Item(109218, false, false, true);
        IntellectPotionBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        Barkskin = Spell(22812, false, false, true);
        BearForm = Spell(5487, false, false, true);
        BristlingFur = Spell(155835, false, false, true);
        CatForm = Spell(768, false, false, true);
        DisplacerBeast = Spell(137452, false, false , true);
        FrenziedRegeneration = Spell(22842, false, false, true);
        GalacticGuardian = Spell(203964);
        GalacticGuardianBuff = Spell(213708);
        Growl = Spell(6795, false, true, true);
        HealingTouch = Spell(5185, false, false, true);
        Incarnation = Spell(102558, false, false, true);
        Ironfur = Spell(192081, false, false, true);
        LunarBeam = Spell(204066, false, false, true);
        Maul = Spell(6807, true, true, true);
        Mangle = Spell(33917, true, true, true);
        MarkOfUrsol = Spell(192083, false, false, true);
        Pulverize = Spell(80313, true, true, true);
        PulverizeBuff = Spell(158792, false, false, true);
        RageOfTheSleeper = Spell(200851, false, false, true);
        Rebirth = Spell(20484, false, false, false, true);
        SoulOfTheForest = Spell(158447);
        SkullBash = Spell(106839, true, true, true);
        SurvivalInstincts = Spell(61336, false, false, true);
        Swipe = Spell(213764 , false, false, true);
        Thrash = Spell(106832, false, false, true);
        ThrashDebuff = Spell(192090);
        TravelForm = Spell(783, false, false, true);

        -- Feral Affinity
        FeralAffinity = Spell(202155);
        FeralThrash = Spell(77758, false, false, true);
        FerociousBite = Spell(22568 , true, true, true);
        Rip = Spell(1079 , true, true, true);
        Shred = Spell(5221 , true, true, true);

        -- Balance Affinity
        BalanceAffinity = Spell(197488);
        LunarEmpowerment = Spell(164547);
        LunarStrike = Spell(197628, true, true, false);
        MoonkinForm = Spell(197625, false, false, true);
        Moonfire = Spell(8921, true, true, true);
        MoonfireDebuff= Spell(164812);
        Sunfire = Spell(197630, true, true, true);
        SunfireDebuff= Spell(164815);
        SolarEmpowerment = Spell(164545);
        SolarWrath = Spell(197629, true, true, false);
        Starsurge = Spell(197626, true, true, true);

        -- Restoration Affinity
        RestorationAffinity = Spell(197492);
        Regrowth = Spell(8936, false, false, false);
        Rejuvenation = Spell(774, false, false, true);
        Swiftmend = Spell(18562, false, false, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {6, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest", "Untanked"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_SUBVALUE("Untanked").."Integrate tanking logic that will priorise the untaked units."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range.\n\n|cffFF0044Mode (Left Box)|r\n|cFF0088FFKeep:|r Cast on the new unit but keep your target the same.\n|cFF0088FFSwitch:|r Cast on the new unit and change your target to this unit.\n\n|cffFF0044Range (Right Box)|r\nSet the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.TauntManagerOptions("Growl");
        module.AddNewOption("General Settings", "Bear Form", 210, true, nil, nil, "Automatically handle Bear Form.");
        module.AddNewOption("General Settings", "Rebirth", 210, true, nil, nil, "Enable to automatically resurrect targeted dead player targets in combat.");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Skull Bash to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our LunarStrike to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Bristling Fur", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Bristling Fur."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Incarnation", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Incarnation."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Lunar Beam", 223, true, {1, 1, 10, 1}, {2, "Always", "Cooldown Only"}, "Use Incarnation."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Maul", 220, true, {80, 1, 85, 1}, nil, "Use Maul to dump rage when we do not need our Active Mitigation."..C.TOOLTIP_VALUE.."Minimum Rage needed to use Maul.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Moonfire", 222, false, { 5, 1, 10, 1 }, { 3, 0, 25, 0.1 }, "Multi-Dot Moonfire Cycle."..C.TOOLTIP_VALUE_1.."Number of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply."..C.TOOLTIP_HINT("Also applies to Balance Affinity."));
        module.AddNewOption("Offensive Settings", "Swipe", 120, true, {3, 1, 10, 1}, nil, "Use Swipe while in Bear Form."..C.TOOLTIP_VALUE.."Amount of units needed in range of player to use Swipe."..C.TOOLTIP_HINT("It will still be used as filler even if less units are detected."));
        module.AddNewOption("Offensive Settings", "Thrash", 120, true, {3, 1, 10, 1}, nil, "Use Thrash."..C.TOOLTIP_VALUE.."Amount of units needed in range of player to use Thrash."..C.TOOLTIP_HINT("It will still be used as filler even if less units are detected."));
        module.AddSection("Offensive Settings", "Balance Affinity", "Green");
        module.AddNewOption("Offensive Settings", "Balance Affinity", 210, false, nil, nil, "Enable Balance Affinity DPS.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Sunfire", 222, false, { 10, 1, 10, 1 }, { 3, 0, 25, 0.1 }, "Multi-Dot Sunfire Cycle."..C.TOOLTIP_VALUE_1.."Number of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddSection("Offensive Settings", "Feral Affinity", "Green");
        module.AddNewOption("Offensive Settings", "Feral Affinity", 210, false, nil, nil, "Enable Feral Affinity DPS.");
        module.AddNewOption("Offensive Settings", "Rip", 210, true, nil, nil, "Use Rip.");
        module.AddNewOption("Offensive Settings", "Feral Swipe", 220, true, {3, 1, 10, 1}, nil, "Use Swipe with Feral Affinity."..C.TOOLTIP_VALUE.."Amount of units needed within 10 yards of player to use Swipe.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Active Mitigation", 232, true, {1, "Ironfur", "Mark Of Ursol"}, {90, 1, 100, 1}, "Use Active Mitigation."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Barkskin", 220, true, {40, 1, 100, 1}, nil, "Use Barkskin."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Frenzied Regeneration", 220, true, {35, 1, 100, 1}, nil, "Use Frenzied Regeneration."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, true, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddNewOption("Defensive Settings", "Healing Touch Self", 220, true, {80, 1, 100, 1}, nil, "Use Healing Touch on ourself."..C.TOOLTIP_VALUE.."Health threshold while Out of Combat.");
        module.AddNewOption("Defensive Settings", "Pulverize", 220, true, {90, 1, 100, 1}, nil, "Use Pulverize."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Rage Of The Sleeper", 220, true, {45, 1, 100, 1}, nil, "Use Rage Of The Sleeper."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Survival Instincts", 220, true, {25, 1, 100, 1}, nil, "Use Survival Instincts."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Restoration Affinity", "Green");
        module.AddNewOption("Defensive Settings", "Healing Touch", 222, true, {95, 0, 100, 1}, {90, 0, 100, 1}, "Use Healing Touch."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Defensive Settings", "Regrowth", 222, true, {35, 0, 100, 1}, {25, 0, 100, 1}, "Use Regrowth."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Defensive Settings", "Rejuvenation", 222, true, {85, 0, 100, 1}, {80, 0, 100, 1}, "Use Rejuvenation."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Defensive Settings", "Rejuvenation Self", 220, true, {30, 1, 100, 1}, nil, "Use Rejuvenation on ourself."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Restoration Affinity", 210, false, nil, nil, "Enable Restoration Affinity Healing.");
        module.AddNewOption("Defensive Settings", "Swiftmend", 222, true, {40, 0, 100, 1}, {25, 0, 100, 1}, "Use Swiftmend."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we wait to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pot BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        -- Potion
        if module.GetOptionValue("Pre-Pot BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pot BossMod") == "Always" or Target:IsBoss()) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pot BossMod") or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) and Player:IsWithinCastRange(Target, Moonfire) then
            if Player:Potion("Agility", Potion) then module.Bug("Pre-Pull - Agility Potion"); Potion = true; end
        end
    end

    function Rotation:Interrupts ()
        Player:UseInterrupt(SkullBash);
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- barkskin
        if module.IsOptionEnabled("Barkskin") and Player:HealthPercentage() <= module.GetOptionValue("Barkskin") and Player:CanCast(Barkskin) then
            Player:Cast(Barkskin);
        end
    end

    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(Mangle, false) or Unit.Target;
        -- Survival Instincts
        if SurvivalInstincts:Exists() and module.IsOptionEnabled("Survival Instincts") and Player:HealthPercentage() <= module.GetOptionValue("Survival Instincts") and Player:CanCast(SurvivalInstincts) then
            Player:Cast(SurvivalInstincts);
            return;
        end
        -- Rage of the Sleeper
        if RageOfTheSleeper:Exists() and module.IsOptionEnabled("Rage Of The Sleeper") and Player:HealthPercentage() <= module.GetOptionValue("Rage Of The Sleeper") and Player:CanCast(RageOfTheSleeper) then
            Player:Cast(RageOfTheSleeper);
            return;
        end
        --- Maul
        RandomOffGCD = RandomOffGCD or math.random(35,115)*0.01;
        if Swipe:Cooldown() < RandomOffGCD then
            if Maul:Exists() and module.IsOptionEnabled("Maul") and Player:Rage() >= module.GetOptionValue("Maul") and Target:CanCast(Maul) then
                Target:Cast(Maul);
                RandomOffGCD = nil;
            end
            -- Active Mitigation
            if module.IsOptionEnabled("Active Mitigation") and (Player:Rage() >= 85 or (Player:HealthPercentage() <= module.GetSecondOptionValue("Active Mitigation") and Player:Rage() >= 45)) then
                if module.GetOptionValue("Active Mitigation") == "Ironfur" and (Player:BuffRemains(Ironfur) < 2 or Player:HealthPercentage() <= module.GetSecondOptionValue("Active Mitigation") or Player:Rage() >= 90) and Player:CanCast(Ironfur) then
                    Player:Cast(Ironfur);
                    RandomOffGCD = nil;
                end
                if module.GetOptionValue("Active Mitigation") == "Mark Of Ursol" and (Player:BuffRemains(MarkOfUrsol) < 2 or Player:HealthPercentage() <= module.GetSecondOptionValue("Active Mitigation") or Player:Rage() >= 90) and Player:CanCast(MarkOfUrsol) then
                    Player:Cast(MarkOfUrsol);
                    RandomOffGCD = nil;
                end
            end
            -- Frenzied Regeneration
            if module.IsOptionEnabled("Frenzied Regeneration") and Player:CanCast(FrenziedRegeneration) and not Player:Buff(FrenziedRegeneration) then
                if Player:HealthPercentage() <= module.GetOptionValue("Frenzied Regeneration") and Player:Rage() >= 10 then
                    Player:Cast(FrenziedRegeneration);
                    return;
                end
            end
        end
    end

    local function HealCycle (Spell, SpellOption, SpellBuff)
        if Spell:Exists() and module.IsOptionEnabled(SpellOption) then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue(SpellOption) and (not SpellBuff or MainTank:BuffRemains(SpellBuff) < 3) and MainTank:CanHeal(Spell) then
                MainTank:Cast(Spell);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue(SpellOption) and (not SpellBuff or OffTank:BuffRemains(SpellBuff) < 3) and OffTank:CanHeal(Spell) then
                OffTank:Cast(Spell);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue(SpellOption) and (not SpellBuff or Lowest:BuffRemains(SpellBuff) < 3) and Lowest:CanCast(Spell) then
                Lowest:Cast(Spell);
                return;
            end
            if SpellBuff then
                -- Cycle
                for i = 1, #HealUnits do
                    local ThisUnit = HealUnits[i];
                    if ThisUnit:CanHeal(Spell) and ThisUnit:BuffRemains(Spell) < 3 and ThisUnit:SpecialHealthPercentage() <= module.GetSecondOptionValue(SpellOption) then
                        ThisUnit:Cast(Spell);
                        return;
                    end
                end
            end
        end
    end

    function Rotation:Combat ()
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();
        -- Combat Res Target
        if Rebirth:Exists() and module.IsOptionEnabled("Rebirth") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and Target:IsPlayer() and Target:CanCast(Rebirth) then
            Target:Cast(Rebirth);
            return;
        end
        -- Restoration Affinity
        if RestorationAffinity:Exists() and module.IsOptionEnabled("Restoration Affinity") then
            if Player:Buff(BearForm) and Player:CanCast(BearForm) then
                Player:Cast(BearForm);
                return;
            end
            HealUnits = Player:HealUnitsAround(100, 40) or {};
            Lowest = Unit.Lowest(MainTank, OffTank);
            -- Swiftmend
            if Swiftmend:Exists() and module.IsOptionEnabled("Swiftmend") and not Swiftmend:IsOnCooldown() then
                if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Swiftmend") and (MainTank:Buff(Rejuvenation) or MainTank:Buff(Regrowth)) and MainTank:CanHeal(Swiftmend) then
                    MainTank:Cast(Swiftmend);
                    return;
                end
                if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Swiftmend") and (OffTank:Buff(Rejuvenation) or OffTank:Buff(Regrowth)) and OffTank:CanHeal(Swiftmend) then
                    OffTank:Cast(Swiftmend);
                    return;
                end
                if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Swiftmend") and (Lowest:Buff(Rejuvenation) or Lowest:Buff(Regrowth)) and Lowest:CanHeal(Swiftmend) then
                    Lowest:Cast(Swiftmend);
                    return;
                end
            end
            -- Regrowth Cycle
            HealCycle(Regrowth, "Regrowth", Regrowth);
            -- Rejuvenation Cycle
            HealCycle(Rejuvenation, "Rejuvenation", Rejuvenation);
            -- Healing Touch
            HealCycle(HealingTouch, "Healing Touch", nil);
        end
        -- Determine if we have enough time to use Celestial Alignment
        if Target:Exists() and Player:CanAttack(Target)  then
            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                local SourroundingRange = BalanceAffinity:Exists() and 13 or 8;
                Enemies_40y = Player:EnemiesWithinDistance(40); -- 40 yards for Dots Cycles.
                Enemies_30y = Player:FilterEnemiesByDistance(Enemies_40y, 30, false);
                MoonfireUnit = Unit.DotCycle(Enemies_40y, Moonfire, MoonfireDebuff, 16, "Multi-Dot Moonfire") or nil; -- Moonfire DoT Cycle
                SunfireUnit = BalanceAffinity:Exists() and module.IsOptionEnabled("Moonkin Affinity") and Unit.DotCycle(Enemies_40y, Sunfire, SunfireDebuff, 18, "Multi-Dot Sunfire") or nil; -- Sunfire DoT Cycle
                PlayerEnemies_10y = FeralAffinity:Exists() and module.IsOptionEnabled("Feral Affinity") and module.IsOptionEnabled("Feral Swipe") and Player:EnemiesWithinDistance(10, true) or {};
                SurroundingEnemies = Player:EnemiesWithinDistance(SourroundingRange);
                NumEnemies = #SurroundingEnemies;
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- Growl
            if Player:TauntManager(Growl, "Growl", Target, Enemies_30y) then
                return;
            end

            -- Balance Affinity
            if BalanceAffinity:Exists() and module.IsOptionEnabled("Balance Affinity") and Target:Exists() then
                -- Moonkin Form
                if MoonkinForm:Exists() and not Player:Buff(MoonkinForm) and Player:CanCast(MoonkinForm) and (not Player:Buff(CatForm) or Player:Buff(DisplacerBeast)) and not Player:Buff(TravelForm) then
                    Player:Cast(MoonkinForm);
                    return;
                end
                if Player:Buff(MoonkinForm) then
                    -- Starsurge
                    if Starsurge:Exists() and Target:CanCast(Starsurge) then
                        Target:Cast(Starsurge);
                        return;
                    end
                    -- Sunfire
                    if Sunfire:Exists() then
                        if Target:DebuffRemains(SunfireDebuff) < 5 and Target:CanCast(Sunfire) then
                            Target:Cast(Sunfire);
                            return;
                        end
                        if module.IsOptionEnabled("Multi-Dot Sunfire") and SunfireUnit and SunfireUnit:CanCast(Sunfire) then
                            SunfireUnit:Cast(Sunfire);
                            return;
                        end
                    end
                    -- Apply Moonfire
                    if Moonfire:Exists() then
                        if Target:DebuffRemains(MoonfireDebuff) < 6 and Target:CanCast(Moonfire) then
                            Target:Cast(Moonfire);
                            return;
                        end
                        if module.IsOptionEnabled("Multi-Dot Moonfire") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                            MoonfireUnit:Cast(Moonfire);
                            return;
                        end
                    end
                    -- Solar Wrath
                    if SolarWrath:Exists() and Player:Buff(SolarEmpowerment) and Target:CanCast(SolarWrath) then
                        Target:Cast(SolarWrath);
                        return;
                    end
                    -- Lunar Strike
                    if LunarStrike:Exists() and Target:CanCast(LunarStrike) then
                        Target:Cast(LunarStrike);
                        return;
                    end
                end
                return;
            end

            -- Feral Affinity
            if FeralAffinity:Exists() and module.IsOptionEnabled("Feral Affinity") then
                -- Apply Cat Form
                if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
                    Player:Cast(CatForm);
                    return;
                end
                -- Use Combos
                -- Rip with 5 Combo Points
                if Rip:Exists() and module.IsOptionEnabled("Rip") and Player:ComboPoints() >= 5 and Target:DebuffRemains(Rip) < 6 then
                    Target:Cast(Rip);
                    return;
                end
                -- Ferocious Bite with 5 Combo Points or less than 5 second till death
                if FerociousBite:Exists() and (Player:ComboPoints() >= 5 or Target:TimeToDie() < 5) then
                    Target:Cast(FerociousBite);
                    return;
                end
                -- Use Energy
                -- Swipe
                if module.IsOptionEnabled("Feral Swipe") and #PlayerEnemies_10y >= module.GetOptionValue("Feral Swipe") then
                    if Player:CanCast(Swipe) then
                        Player:Cast(Swipe);
                        return;
                    end
                else
                    -- Shred
                    if Target:CanCast(Shred) then
                        Target:Cast(Shred);
                        return;
                    end
                end
                return;
            end

            -- Bear Form
            if BearForm:Exists() and module.IsOptionEnabled("Bear Form") and not Player:Buff(BearForm) and Player:CanCast(BearForm) and (not Player:Buff(CatForm) or Player:Buff(DisplacerBeast)) and not Player:Buff(TravelForm) then
                Player:Cast(BearForm);
                return;
            end
            -- Cooldowns
            if Player:IsWithinCastRange(Target, Mangle) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Incarnation
                if Incarnation:Exists() and module.IsOptionEnabled("Incarnation") and (module.CooldownsAllowed() or module.GetOptionValue("Incarnation") == "Always") and Player:CanCast(Incarnation) then
                    Player:Cast(Incarnation);
                    return;
                end
                -- Bristling Fur
                if BristlingFur:Exists() and module.IsOptionEnabled("Bristling Fur") and (module.CooldownsAllowed() or module.GetOptionValue("Bristling Fur") == "Always") and Player:CanCast(BristlingFur) then
                    Player:Cast(BristlingFur);
                    return;
                end
            end

            -- Rotation
            -- Lunar Beam
            if LunarBeam:Exists() and Player:Standing() >= 1.5 and NumEnemies >= module.GetOptionValue("Lunar Beam") and (module.CooldownsAllowed() or module.GetSecondOptionValue("Lunar Beam") == "Always") and Player:IsWithinCastRange(Target, Mangle) and Player:CanCast(LunarBeam) then
                Player:Cast(LunarBeam);
                return;
            end
            -- Pulverize
            if Pulverize:Exists() and module.IsOptionEnabled("Pulverize") and Player:HealthPercentage() <= module.GetOptionValue("Pulverize") and Target:DebuffCount(ThrashDebuff) >= 2 and Player:BuffRemains(PulverizeBuff) < 3 and Target:CanCast(Pulverize) then
                Target:Cast(Pulverize);
                return;
            end
            -- Thrash - Apply or AoE - Weird Spell ID
            if (Thrash:Exists() or FeralThrash:Exists()) and Player:IsWithinCastRange(Target, Mangle) and (not Target:Debuff(ThrashDebuff) or (NumEnemies >= module.GetOptionValue("Thrash"))) and Player:CanCast(Thrash) and Player:CanCast(FeralThrash) then
                Player:Cast(Thrash);
                return;
            end
            -- Mangle
            if Mangle:Exists() and Target:CanCast(Mangle) then
                Target:Cast(Mangle);
                return;
            end
            -- Galactic Guardian
            if GalacticGuardian:Exists() and Player:Buff(GalacticGuardianBuff) and module.IsOptionEnabled("Multi-Dot Moonfire") then
                if MoonfireUnit and MoonfireUnit:Exists() and MoonfireUnit:CanCast(Moonfire) then
                    MoonfireUnit:Cast(Moonfire);
                    return;
                elseif Target:CanCast(Moonfire) then
                    Target:Cast(Moonfire);
                    return;
                end
            end
            -- Thrash - Weird Spell ID
            if (Thrash:Exists() or FeralThrash:Exists()) and Player:IsWithinCastRange(Target, Mangle) and Player:CanCast(Thrash) and Player:CanCast(FeralThrash) then
                Player:Cast(Thrash);
                return;
            end
            -- Swipe - Weird Spell ID
            if Swipe:Exists() and NumEnemies >= module.GetOptionValue("Swipe") and Player:IsWithinCastRange(Target, Mangle) and Player:CanCast(Swipe) then
                Player:Cast(Swipe);
                return;
            end
            -- Moonfire
            if Moonfire:Exists() and Target:DebuffRemains(MoonfireDebuff) < 3 and Target:CanCast(Moonfire) then
                Target:Cast(Moonfire);
                return;
            end
            -- Moonfire - Cycle
            if module.IsOptionEnabled("Multi-Dot Moonfire") and MoonfireUnit and MoonfireUnit:Exists() and MoonfireUnit:CanCast(Moonfire) then
                MoonfireUnit:Cast(Moonfire);
                return;
            end
            -- Swipe - Weird Spell ID
            if Swipe:Exists() and Player:IsWithinCastRange(Target, Mangle) and Player:CanCast(Swipe) then
                Player:Cast(Swipe);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Mangle, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    function Rotation:OutOfCombat ()
        -- Rejuvenation
        if RestorationAffinity:Exists() and Rejuvenation:Exists() and module.IsOptionEnabled("Rejuvenation Self") and Player:HealthPercentage() <= module.GetOptionValue("Rejuvenation Self") and Player:CanCast(Rejuvenation) and not Player:Buff(Rejuvenation) then
            Player:Cast(Rejuvenation);
            return;
        end
        -- Healing Touch
        if HealingTouch:Exists() and Player:Standing() > 1.5 and module.IsOptionEnabled("Healing Touch Self") and Player:HealthPercentage() <= module.GetOptionValue("Healing Touch Self") and Player:CanCast(HealingTouch) then
            Player:Cast(HealingTouch);
            return;
        end
        if not Player:Buff(CatForm) and not Player:Buff(BearForm) and not Player:Buff(TravelForm) then
            -- Feral Affinity
            if FeralAffinity:Exists() and module.IsOptionEnabled("Feral Affinity") then
                if not Player:Buff(CatForm) and Player:CanCast(CatForm) then
                    Player:Cast(CatForm);
                    return;
                end
            -- Moonkin Form
            elseif BalanceAffinity:Exists() and module.IsOptionEnabled("Balance Affinity") then
                if not Player:Buff(MoonkinForm) and Player:CanCast(MoonkinForm) then
                    Player:Cast(MoonkinForm);
                    return;
                end
            -- Bear Form
            elseif not (RestorationAffinity:Exists() and module.IsOptionEnabled("Restoration Affinity")) and BearForm:Exists() and module.IsOptionEnabled("Bear Form") then
                if not Player:Buff(BearForm) and Player:CanCast(BearForm) then
                    Player:Cast(BearForm);
                    return;
                end
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Restoration Druid
    local Rotation = {};
    module.SetRotation("_"..105, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshTables = 0, 0.1, 0; -- Combat Module Throttle
    -- Healers Specific
    local MainTank, MainTankTarget, OffTank, OffTankTarget, HealUnits, Lowest, CurrentBadDebuffs, BestTarget, DispelUnit;
    local Trinket1Units, Trinket2Units, RacialsUnits;
    -- Profile Specific
    local HealingRange, WildGrowthUnit, TranquilityUnits, IncarnationTreeOfLifeUnits, EssenceOfGHanirUnits, EfflorescenceUnits = 40, nil, {}, {}, {}, 0; -- Spells
    local Enemies, MoonfireUnit, SunfireUnit, PlayerEnemies_10y; -- Affinities
    local LifebloomUnits, MaxLifebloomValue, RejuvenationUnits, GerminationUnits = 0, 1, 0, 0;

    --- Initialize the rotation.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        LukewarmYakRoastBroth = Item(120293, false, false, true);
        DraenicChanneledManaPotion = Spell(156432, false, false, false);
        --Racials
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33697, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        AstralInfluence = Spell(197524);
        Barkskin = Spell(22812, false, false, true);
        CenarionWard = Spell(102351, false, false, true);
        Clearcasting = Spell(16870, false, false, true); -- Omen of Clarity proc
        Dash = Spell(1850, false, false, true);
        DisplacerBeast = Spell(137452, false, false , true);
        Efflorescence = Spell(145205, false, false, true);
        EssenceOfGHanir = Spell(208253, false, false, true);
        Germination = Spell(155675); -- Talent - Allow double Rejuv
        GerminationRejuvenation = Spell(155777, false, false, true); -- Buff ID of second Rejuv
        HealingTouch = Spell(5185, false, false, false);
        IncarnationTreeOfLife = Spell(33891, false, false, true);
        Ironbark = Spell(102342, false, false, true);
        Lifebloom = Spell(33763, false, false, true);
        MomentOfClarity = Spell(155577); -- Talent - Omen has 3 stacks when it proc
        NaturesCure = Spell(88423, false, false, true);
        RampantGrowth = Spell(155834, false, false, true);
        Rebirth = Spell(20484, false, false, false, true);
        Rejuvenation = Spell(774, false, false, true);
        Regrowth = Spell(8936, false, false, false);
        Renewal = Spell(108238, false, false, true);
        Revive = Spell(50769, false, false, false, true);
        SoulOfTheForest = Spell(158478, false, false, true);
        SoulOfTheForestBuff = Spell(114108, false, false, true);
        Swiftmend = Spell(18562, false, false, true);
        Tranquility = Spell(740, false, false, true);
        TravelForm = Spell(783, false, false, true);
        WildGrowth = Spell(48438, false, false, false);


        -- Balance Affinity
        BalanceAffinity = Spell(197632);
        LunarEmpowerment = Spell(164547);
        LunarStrike = Spell(197628, true, true, false);
        MoonkinForm = Spell(197625, false, false, true);
        Moonfire = Spell(8921, true, true, true);
        MoonfireDebuff= Spell(164812);
        Sunfire = Spell(93402, true, true, true);
        SunfireDebuff= Spell(164815);
        SolarEmpowerment = Spell(164545);
        SolarWrath = Spell(5176, true, true, false);
        Starsurge = Spell(197626, true, true, true);

        -- Feral Affinity
        FeralAffinity = Spell(197490);
        CatForm = Spell(768, false, false, true);
        FerociousBite = Spell(22568 , true, true, true);
        Rake = Spell(1822, true, true, true);
        RakeDebuff = Spell(155722);
        Rip = Spell(1079 , true, true, true);
        Shred = Spell(5221 , true, true, true);
        Swipe = Spell(213764 , false, false, true);

        -- Guardian Affinity
        BearForm = Spell(5487, false, false, true);
        GuardianAffinity = Spell(197491);
        FrenziedRegeneration = Spell(22842, false, false, true);
        Ironfur = Spell(192081, false, false, true);
        Mangle = Spell(33917, true, true, true);
        Thrash = Spell(77758, false, false, true);
        ThrashDebuff = Spell(192090);

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Healing Settings");
        module.AddPage("Cooldowns Settings");
        module.AddPage("Offensive/Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        -- Add options to pages
        module.AddNewOption("General Settings", "Focus Assignation", 230, true, {2, "Main Tank", "Off Tank"}, nil, "Select which Tank slot should be given to the focussed unit.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Nature's Cure", 232, false, {1, "Auto", "High", "Normal"}, {0.2, 0, 1, 0.1}, "Use Nature's Cure to Dispel bad debuffs on allied units."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Auto").."Dispel Active Dispel Raid debuffs as High Priority and other not listed debuffs as Normal Priority."..C.TOOLTIP_SUBVALUE("High").."Dispel all debuffs as High Priority even before urgent cooldowns."..C.TOOLTIP_SUBVALUE("Normal").."Dispel all debuffs as Normal Priority after urgent cooldowns."..C.TOOLTIP_VALUE_2.."Define how long you want to wait before dispelling to look more human. This does not apply to Active Dispels Raid debuffs which will always be as soon as Global Cooldown ends."..C.TOOLTIP_HINT("Active Raid Dispels are based on an hardcoded list. Please report of any dispels you may encounter that requires specific strategies so that they can be properly added to the list."));
        module.AddOption("General Settings", "Rebirth", true, "Enable to automatically resurrect targeted dead player targets in combat.");
        module.AddOption("General Settings", "Rebirth Tank", false, "Enable to use rebirth to resuscitate a dead tank. Set the delay before using it.", true, 0, 0, 3, 0.1);
        module.AddNewOption("General Settings", "Revive", 210, true, nil, nil, "Enable to use Redemption on dead friendly players while out of combat.");
        module.AddSection("General Settings", "Active Healing", "Green");
        module.AddNewOption("General Settings", "Heal Target", 230, true, {1, "Known Unit", "Any Unit"}, nil, "Heal our current target if it is listed to be healed." .. C.TOOLTIP_VALUE .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Known Unit") .. "Allow Heal Target to be used only when we are targetting a unit listed for it." .. C.TOOLTIP_SUBVALUE("Any Unit") .. "Allow Heal Target to be used on any unit.");
        module.AddNewOption("General Settings", "Raid Debuffs", 220, true, {40, 0, 100, 1}, nil, "Use Rejuvenation/Germination on Debuffed units." .. C.TOOLTIP_VALUE .. "Helath threshold.");
        module.AddNewOption("General Settings", "Tank Debuffs", 220, true, {50, 0, 100, 1}, nil, "Use Rejuvenation/Germination on Debuffed tanks." .. C.TOOLTIP_VALUE .. "Helath threshold.");
        module.AddNewOption("General Settings", "Topping", 220, true, {100, 0, 100, 1}, nil, "Use Rejuvenation/Germination/Regrowth/Healing Touch on units to be topped." .. C.TOOLTIP_VALUE .. "Helath threshold.");

        module.AddSection("Healing Settings", "Common Healing Thresholds", "Green");
        module.AddNewOption("Healing Settings", "Efflorescence", 222, true, {3, 1, 10, 1}, {90, 0, 100, 1}, "Use when selected number of units are under health threshold." .. C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold.");
        module.AddNewOption("Healing Settings", "Healing Touch", 222, true, {80, 0, 100, 1}, {70, 0, 100, 1}, "Use Healing Touch." .. C.TOOLTIP_VALUE_1 .. "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Lifebloom", 220, true, { 80, 0, 100, 1 }, nil, "Use Lifebloom." .. C.TOOLTIP_VALUE .. "Health threshold under wich we want to let the Lifebloom bloom."..C.TOOLTIP_HINT("We will always apply Lifebloom and maintain it as long as the unit have more health than the specified value. Main Tank will be preferred but if it is not tanking then the Off Tank will be preferred."));
        module.AddNewOption("Healing Settings", "Regrowth", 222, true, {65, 0, 100, 1}, {55, 0, 100, 1}, "Use Regrowth." .. C.TOOLTIP_VALUE_1 .. "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Regrowth Emergency", 222, true, {40, 0, 100, 1}, {25, 0, 100, 1}, "Use Regrowth without Regrowth Buff check." .. C.TOOLTIP_VALUE_1 .. "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid."..C.TOOLTIP_HINT("This should be set very low unless you know you can afford the high mana cost of Regrowth."));
        module.AddNewOption("Healing Settings", "Rejuvenation Counts", 122, true, {10, 1, 25, 1}, {10, 1, 25, 1}, "Maximum buffs counts for Rejuvenation and Germination." .. C.TOOLTIP_VALUE_1 .. "Maximum buffs counts for Rejuvenation." .. C.TOOLTIP_VALUE_2 .. "Maximum buffs counts for Germination.");
        module.AddNewOption("Healing Settings", "Rejuvenation", 222, true, {90, 0, 100, 1}, {80, 0, 100, 1}, "Use Rejuvenation." .. C.TOOLTIP_VALUE_1 .. "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Rejuvenation Germination", 222, true, {80, 0, 100, 1}, {70, 0, 100, 1}, "Use Rejuvenation for Germination." .. C.TOOLTIP_VALUE_1 .. "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Wild Growth", 222, true, {4, 1, 5, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold." .. C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold.");
        module.AddNewOption("Healing Settings", "Out Of Combat Healing", 210, true, nil, nil, "Allow Healing while Out of Combat." .. C.TOOLTIP_VALUE .. "Select Spell to use.");

        module.AddSection("Cooldowns Settings", "Cooldowns", "Green");
        module.AddNewOption("Cooldowns Settings", "Cenarion Ward", 222, true, {80, 0, 100, 1}, {70, 0, 100, 1}, "Use Cenarion Ward on tanking units." .. C.TOOLTIP_VALUE_1 .. "Threshold to use on the Tanks." .. C.TOOLTIP_VALUE_2 .. "Threshold to use on the Raid.");
        module.AddNewOption("Cooldowns Settings", "Essence Of G'Hanir", 222, true, {1, 1, 5, 1}, {50, 0, 100, 1}, "Use when selected number of units are under health threshold." .. C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Incarnation: Tree Of Life", 222, true, {2, 1, 25, 1}, {60, 0, 100, 1}, "Use when selected number of units are under health threshold." .. C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Ironbark", 220, true, {30, 0, 100, 1}, nil, "Use Ironbark on a tank that fall under threshold.");
        module.AddNewOption("Cooldowns Settings", "Swiftmend", 222, true, {35, 0, 100, 1}, {15, 0, 100, 1}, "Use Swiftmend." .. C.TOOLTIP_VALUE_1 .. "Health threshold to use on Tanks." .. C.TOOLTIP_VALUE_2 .. "Health threshold to use on any Raid members.");
        module.AddNewOption("Cooldowns Settings", "Tranquility", 222, true, {3, 1, 25, 1}, {70, 0, 100, 1}, "Use when selected number of units are under health threshold." .. C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Soft Cooldowns Units", 120, true, {3, 1, 25, 1}, nil, "Number of units that needs to be under thresholds to use Racials and Trinkets with Health.");
        module.AddNewOption("Cooldowns Settings", "Use Racials", 220, true, {80, 0, 100, 1}, nil, "Use Racials. \n\n|cFF0088FFArcane Torrent:|r Mana threshold under which we want to use Arcane Torrent.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 1", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 1 with selected values." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Always") .." Use Always." .. C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value." .. C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold." .. C.TOOLTIP_VALUE_2 .. "Define Health or Mana threshold.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 2", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 2 with selected values." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Always") .." Use Always." .. C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value." .. C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold." .. C.TOOLTIP_VALUE_2 .. "Define Health or Mana threshold.");

        module.AddSection("Offensive/Defensive Settings", "DPS Offensive", "Green");
        module.AddPresetOption("TargetAttack");
        module.AddNewOption("Offensive/Defensive Settings", "DPS", 220, true, {95, 0, 100, 1}, nil, "Enables DPS options." .. C.TOOLTIP_VALUE .. "Will only DPS if the Lowest unit is above DPS health treshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Moonfire", 210, false, nil, nil, "Use Moonfire in the DPS rotation." .. C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Multi-Dot Moonfire", 222, false, { 5, 1, 10, 1 }, { 3, 0, 25, 0.1 }, "Multi-Dot Moonfire Cycle."..C.TOOLTIP_VALUE_1.."Number of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply."..C.TOOLTIP_HINT("Also applies to Balance, Guardian and Feral Affinities."));
        module.AddNewOption("Offensive/Defensive Settings", "Multi-Dot Sunfire", 222, false, { 10, 1, 10, 1 }, { 3, 0, 25, 0.1 }, "Multi-Dot Sunfire Cycle."..C.TOOLTIP_VALUE_1.."Number of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply."..C.TOOLTIP_HINT("Also applies to Balance Affinity."));
        module.AddNewOption("Offensive/Defensive Settings", "Sunfire", 210, false, nil, nil, "Use Sunfire in the DPS rotation." .. C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Solar Wrath", 210, false, nil, nil, "Use Solar Wrath in the DPS rotation." .. C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddSection("Offensive/Defensive Settings", "Balance Affinity", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Balance Affinity", 221, false, {70, 0, 100, 1, 15}, {90}, "Enable Balance Affinity DPS."..C.TOOLTIP_VALUE_1.."Swap out of Moonkin Form when the Lowest unit health is under this threshold."..C.TOOLTIP_VALUE_2.."Enter Moonkin Form when the Lowest unit's health is higher than this threshold.");
        module.AddSection("Offensive/Defensive Settings", "Feral Affinity", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Feral Affinity", 221, false, {70, 0, 100, 1, 15}, {90}, "Enable Feral Affinity DPS."..C.TOOLTIP_VALUE_1.."Swap out of Cat Form when the Lowest unit health is under this threshold."..C.TOOLTIP_VALUE_2.."Enter Cat Form when the Lowest unit's health is higher than this threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Rip", 210, true, nil, nil, "Use Rip.");
        module.AddNewOption("Offensive/Defensive Settings", "Swipe", 220, true, {3, 1, 10, 1}, nil, "Use Swipe."..C.TOOLTIP_VALUE.."Amount of units needed within 10 yards of player to use Swipe.");
        module.AddSection("Offensive/Defensive Settings", "Guardian Affinity", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Guardian Affinity", 210, false, nil, nil, "Enable Guardian Affinity Tanking.");
        module.AddNewOption("Offensive/Defensive Settings", "Frenzied Regeneration", 220, true, {35, 1, 100, 1}, nil, "Use Frenzied Regeneration."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Ironfur", 220, true, {90, 1, 100, 1}, nil, "Use Ironfur."..C.TOOLTIP_VALUE.."Health threshold."..C.TOOLTIP_HINT("Will be used regardless of health when rage is higher than 85."));
        module.AddSection("Offensive/Defensive Settings", "Defensive", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Barkskin", 220, true, {60, 1, 100, 1}, nil, "Use Barkskin." .. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Renewal", 220, true, {40, 1, 100, 1}, nil, "Use Renewal." .. C.TOOLTIP_VALUE .. "Health threshold.");

        -- Healers Specific
        module.AddOutput("|cFF9A2EFEMain Tank:");
        module.AddOutput("|cFF9A2EFEOff Tank:");
        module.AddOutput("|cFF9A2EFEBad Debuffs:");
        module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [HealingTouch:ID()] = "Healing Touch",
            [Regrowth:ID()] = "Regrowth",
            [SolarWrath:ID()] = "Solar Wrath",
            [Starsurge:ID()] = "Starsurge",
            [WildGrowth:ID()] = "Wild Growth"
        };
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:Buff(DraenicChanneledManaPotion) or not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or (Player:Buff(Dash) and Player:Buff(CatForm)) then
            return;
        end

        -- Define Main Tanks
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();

        if Player:IsInCombat() then
            self:Defensives();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end


    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Renewal
        if module.IsOptionEnabled("Renewal") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Renewal") and Player:CanCast(Renewal) then
            Player:Cast(Renewal);
            return;
        end
        -- Barkskin
        if module.IsOptionEnabled("Barkskin") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Barkskin") and Player:CanCast(Barkskin) then
            Player:Cast(Barkskin);
        end
    end

    function Rotation:OffGCDAbilities ()
        -- Guardian Affinity
        if GuardianAffinity:Exists() and module.IsOptionEnabled("Guardian Affinity") and Player:Buff(BearForm) then
            -- Ironfur
            if module.IsOptionEnabled("Ironfur") and Player:CanCast(Ironfur) then
                if Player:Rage() >= 85 or (Player:HealthPercentage() <= module.GetOptionValue("Ironfur") and Player:Rage() >= 40 and not Player:Buff(Ironfur)) then
                    Player:Cast(Ironfur);
                    return;
                end
            end
            -- Frenzied Regeneration
            if module.IsOptionEnabled("Frenzied Regeneration") and Player:CanCast(FrenziedRegeneration) and not Player:Buff(FrenziedRegeneration) then
                if Player:HealthPercentage() <= module.GetOptionValue("Frenzied Regeneration") and Player:Rage() >= 10 then
                    Player:Cast(FrenziedRegeneration);
                    return;
                end
            end
        end
    end

    -- Active Healing Heal Target handler
    local function HealTarget (ThisUnit)
        -- Regrowth
        if ThisUnit:CanHeal(Regrowth) then
            module.Bug("Heal Target - Regrowth");
            ThisUnit:Cast(Regrowth);
            return;
        end
    end

    -- Get Tanks Status
    local TanksStatus, MainTankTanking, OffTankTanking = {Main = {IsTanking = module.GetTime()},Off = {IsTanking = module.GetTime()}};
    local function RefreshTanksStatus ()
        TanksStatus = {
            Main = {IsTanking = MainTank and MainTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Main.IsTanking},
            Off = {IsTanking = OffTank and OffTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Off.IsTanking}
        };
        MainTankTanking = module.GetTime() - TanksStatus.Main.IsTanking < 3 or false;
        OffTankTanking = module.GetTime() - TanksStatus.Off.IsTanking < 3 or false;
    end

    local function Efflorescences ()
        if module.IsOptionEnabled("Efflorescence") and Player:CanCast(Efflorescence) and (not module.LastEfflorescenceTime or module.GetTime() - module.LastEfflorescenceTime > 8) then
            local UnitsTreshold = module.GetOptionValue("Efflorescence");
            if EfflorescenceUnits < UnitsTreshold or (not module.LastEfflorescenceTime or module.GetTime() - module.LastEfflorescenceTime > 30) then
                local HealthThreshold = module.GetSecondOptionValue("Efflorescence");
                local HealUnits = Player:HealUnitsAround(HealthThreshold, 35);
                local BestHealUnits = {};
                for i = 1, #HealUnits do
                    local ThisUnit = HealUnits[i]
                    if ThisUnit:CanHeal(HealingTouch) and not ThisUnit:IsMoving() then
                        local TheseHealUnits = ThisUnit:HealUnitsAround(HealthThreshold, 10);
                        if #TheseHealUnits + 1 >= UnitsTreshold and #TheseHealUnits > #BestHealUnits then
                            BestHealUnits = TheseHealUnits;
                            BestUnit = ThisUnit;
                        end
                    end
                end
                if #BestHealUnits >= UnitsTreshold then
                    module.LastEfflorescenceTime = module.GetTime();
                    Player:CastGroundHeal(Efflorescence, BestHealUnits, true);
                    return;
                end
            end
        end
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
    -- Init + Dispels
        HealingRange = AstralInfluence:Exists() and 45 or 40;

        -- T18 Lifebloom tweak
        if module.HasT18_4Pc and select(8,GetInstanceInfo()) ~= 1148 then
            Lifebloom = Spell(188550, false, false, true);
            MaxLifebloomValue = 2;
        else
            Lifebloom = Spell(33763, false, false, true);
            MaxLifebloomValue = 1;
        end

        -- Find best unit to attack
        if Target:Exists() and Target:CanCast(SolarWrath) then
            BestTarget = Target;
        elseif MainTankTarget and MainTankTarget:CanCast(SolarWrath) then
            BestTarget = MainTankTarget;
        elseif OffTankTarget and OffTankTarget:CanCast(SolarWrath) then
            BestTarget = OffTankTarget;
        elseif Mouseover:Exists() and Mouseover:CanCast(SolarWrath) then
            BestTarget = Mouseover;
        else
            BestTarget = Target;
        end

        -- Refresh tables every 0.5 seconds sync with CanCast to avoid refreshing too early during Casts or GCD.
        if RefreshTables < module.GetTime() and (RefreshTables == 0 or Player:CanCast(Rejuvenation)) then
            HealUnits = Player:HealUnitsAround(100, HealingRange);
            Lowest = Unit.Lowest(MainTank, OffTank);
            RefreshTanksStatus();
            LifebloomUnits = #Player:GroupUnitsWithLifebloom(Lifebloom);
            RejuvenationUnits = #Player:UnitsWithBuff(HealUnits, Rejuvenation, 4);
            GerminationUnits = #Player:UnitsWithBuff(HealUnits, GerminationRejuvenation, 4);
            WildGrowthUnit = module.IsOptionEnabled("Wild Growth") and WildGrowth:Exists() and ((Player:Buff(SoulOfTheForestBuff) and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Wild Growth") - 1, module.GetSecondOptionValue("Wild Growth"), 30)) or Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Wild Growth"), module.GetSecondOptionValue("Wild Growth"), 30)) or nil;
            TranquilityUnits = Tranquility:Exists() and Player:HealUnitsAround(module.GetSecondOptionValue("Tranquility"), HealingRange) or {};
            IncarnationTreeOfLifeUnits = IncarnationTreeOfLife:Exists() and Player:HealUnitsAround(module.GetSecondOptionValue("Incarnation: Tree Of Life"), HealingRange) or {};
            EssenceOfGHanirUnits = EssenceOfGHanir:Exists() and Player:HealUnitsAround(module.GetSecondOptionValue("Essence Of G'Hanir"), HealingRange) or {};
            Trinket1Units = module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 1"), HealingRange) or 0;
            Trinket2Units = module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 2"), HealingRange) or 0;
            RacialsUnits = module.IsOptionEnabled("Use Racials") and ((Berserking:Exists() and Player:CanCast(Berserking)) or (BloodFury:Exists() and Player:CanCast(BloodFury))) and #Player:HealUnitsAround(module.GetOptionValue("Use Racials"), HealingRange) or 0;
            Enemies = Player:EnemiesWithinDistance(40); -- 40 yards for Dots Cycles.
            EfflorescenceUnits = Unit.FriendliesNearMushroom(12);
            MoonfireUnit = Unit.DotCycle(Enemies, Moonfire, MoonfireDebuff, 22, "Multi-Dot Moonfire"); -- Moonfire DoT Cycle
            SunfireUnit = Unit.DotCycle(Enemies, Sunfire, SunfireDebuff, 22, "Multi-Dot Sunfire"); -- Sunfire DoT Cycle
            PlayerEnemies_10y = FeralAffinity:Exists() and module.IsOptionEnabled("Feral Affinity") and module.IsOptionEnabled("Swipe") and Player:EnemiesWithinDistance(10, true) or {};
            -- Bad Debuffs
            CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits);
            if CurrentBadDebuffs ~= nil then
                module.SetOutput("|cFF9A2EFEBad Debuffs:", #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff);
            end
            DispelUnit = Unit.Dispel(NaturesCure);
            RefreshTables = module.GetTime() + 0.5;
        end
        -- Guardian Affinity
        if GuardianAffinity:Exists() and module.IsOptionEnabled("Guardian Affinity") then
            -- Apply Bear Form
            if not Player:Buff(BearForm) and Player:CanCast(BearForm) then
                Player:Cast(BearForm);
                return;
            end
            -- Bear DPS
            if Player:IsWithinCastRange(BestTarget, Mangle) then
                if not BestTarget:Debuff(ThrashDebuff) and Player:CanCast(Thrash) then
                    Player:Cast(Thrash);
                    return;
                end
                if BestTarget:CanCast(Mangle) then
                    BestTarget:Cast(Mangle);
                    return;
                end
                if Player:CanCast(Thrash) then
                    Player:Cast(Thrash);
                    return;
                end
            end
            -- Apply Moonfire
            if Moonfire:Exists() then
                if BestTarget:DebuffRemains(MoonfireDebuff) < 6 and BestTarget:CanCast(Moonfire) then
                    BestTarget:Cast(Moonfire);
                    return;
                end
                if MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                    MoonfireUnit:Cast(Moonfire);
                    return;
                end
            end
            return;
        end
        -- Combat Res Tanks
        if MainTank and MainTank:Exists() and not MainTank:IsDeadOrGhost() then MainTankResDelay = nil; end
        if OffTank and OffTank:Exists() and not OffTank:IsDeadOrGhost() then OffTankResDelay = nil; end
        if module.IsOptionEnabled("Rebirth Tank") then
            if MainTank and MainTank:Exists() and MainTank:IsDeadOrGhost() and MainTank:IsPlayer() and MainTank:CanCast(Rebirth) then
                if not MainTankResDelay then MainTankResDelay = module.GetTime(); end
                if module.GetTime()-MainTankResDelay >= module.GetOptionValue("Rebirth Tank") then
                    MainTankResDelay = nil;
                    MainTank:Cast(Rebirth);
                    return;
                end
            elseif OffTank and OffTank:Exists() and OffTank:IsDeadOrGhost() and OffTank:IsPlayer() and OffTank:CanCast(Rebirth) then
                if not OffTankResDelay then OffTankResDelay = module.GetTime(); end
                if module.GetTime()-OffTankResDelay >= module.GetOptionValue("Rebirth Tank") then
                    OffTankResDelay = nil;
                    OffTank:Cast(Rebirth);
                    return;
                end
            end
        end
        -- Res Target
        if module.IsOptionEnabled("Rebirth") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and Target:IsPlayer() and Target:CanCast(Rebirth) then
            Target:Cast(Rebirth);
            return;
        end

        -- Dispels Handling
        Player:DispelHandler(NaturesCure, "Nature's Cure", DispelUnit, CurrentBadDebuffs.Dispel, "High");

        -- Feral Affinity
        if FeralAffinity:Exists() and module.IsOptionEnabled("Feral Affinity") and not (CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0) then
            LowestUnit = Unit.Lowest();
            -- Apply Cat Form
            if not Player:Buff(CatForm) and LowestUnit:HealthPercentage() > module.GetSecondOptionValue("Feral Affinity") and BestTarget and BestTarget:Exists() and Player:CanAttack(BestTarget) and Player:IsWithinCastRange(BestTarget, Shred) and Player:CanCast(CatForm) then
                Player:Cast(CatForm);
                return;
            end
            -- Swap out of Cat Form
            if Player:Buff(CatForm) and LowestUnit:HealthPercentage() < module.GetOptionValue("Feral Affinity") and Player:CanCast(CatForm) then
                Player:Cast(CatForm);
                return;
            end
            if BestTarget and BestTarget:Exists() and Player:Buff(CatForm) and LowestUnit:HealthPercentage() > module.GetOptionValue("Feral Affinity") then
                -- Use Combos
                -- Rip with 5 Combo Points
                -- actions.finisher=rip,if=combo=5&remains<=duration*0.3&(target.health.pct>25|!dot.rip.ticking)
                if Rip:Exists() and module.IsOptionEnabled("Rip") and Player:ComboPoints() >= 5 and BestTarget:DebuffRemains(Rip) < 7.2 and (BestTarget:HealthPercentage() > 25 or not BestTarget:Debuff(Rip)) and BestTarget:TimeToDie() > 12 and BestTarget:CanCast(Rip) then
                    BestTarget:Cast(Rip);
                    return;
                end
                -- actions.finisher=rip,if=combo>=1&!dot.rip.ticking&ttd<12&ttd>3
                if Rip:Exists() and module.IsOptionEnabled("Rip") and Player:ComboPoints() >= 1 and not BestTarget:Debuff(Rip) and BestTarget:TimeToDie() < 12 and BestTarget:TimeToDie() > 3 and BestTarget:CanCast(Rip) then
                    BestTarget:Cast(Rip);
                    return;
                end
                -- actions+=/ferocious_bite,if=combo>=1&dot.rip.ticking&dot.rip.remains<3&target.health.pct<25
                if FerociousBite:Exists() and Player:ComboPoints() >= 1 and BestTarget:Debuff(Rip) and BestTarget:DebuffRemains(Rip) < 3 and BestTarget:HealthPercentage() < 25 and BestTarget:CanCast(FerociousBite) then
                    BestTarget:Cast(FerociousBite);
                    return;
                end
                -- actions.finisher+=/ferocious_bite,max_energy=1,if=energy.time_to_max<1
                if FerociousBite:Exists() and Player:ComboPoints() >= 5 and Player:PowerTimeToMax() < 1 and BestTarget:CanCast(FerociousBite) then
                    BestTarget:Cast(FerociousBite);
                    return;
                end
                -- Swipe
                if module.IsOptionEnabled("Swipe") and #PlayerEnemies_10y >= module.GetOptionValue("Swipe") then
                    if Player:CanCast(Swipe) then
                        Player:Cast(Swipe);
                        return;
                    end
                else
                    -- Rake
                    if Rake:Exists() and BestTarget:DebuffRemains(RakeDebuff) < 4.5 and BestTarget:TimeToDie() > 6 and BestTarget:CanCast(Rake) then
                        BestTarget:Cast(Rake);
                        return;
                    end
                    -- Shred
                    if BestTarget:CanCast(Shred) then
                        BestTarget:Cast(Shred);
                        return;
                    end
                end
            end
            -- Prevent Swapout
            if Player:Buff(CatForm) and LowestUnit:HealthPercentage() > module.GetOptionValue("Feral Affinity") and BestTarget and BestTarget:Exists() and Player:IsWithinCastRange(BestTarget, Shred) then
                return;
            end
        end

        -- Balance Affinity
        if BalanceAffinity:Exists() and module.IsOptionEnabled("Balance Affinity") and BestTarget and BestTarget:Exists() and Player:CanAttack(BestTarget) and Player:IsWithinCastRange(BestTarget, Moonfire) and not (CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0) then
            LowestUnit = Unit.Lowest();
            -- Moonkin Form
            if MoonkinForm:Exists() and LowestUnit:HealthPercentage() > module.GetSecondOptionValue("Balance Affinity") and not Player:Buff(MoonkinForm) and (not Player:Buff(CatForm) or Player:Buff(DisplacerBeast)) and not Player:Buff(BearForm) and not Player:Buff(TravelForm) and Player:CanCast(MoonkinForm) then
                Player:Cast(MoonkinForm);
                return;
            end
            -- Swap out of Moonkin Form
            if Player:Buff(MoonkinForm) and LowestUnit:HealthPercentage() < module.GetOptionValue("Balance Affinity") and Player:CanCast(MoonkinForm) then
                Player:Cast(MoonkinForm);
                return;
            end
            if Player:Buff(MoonkinForm) and LowestUnit:HealthPercentage() > module.GetOptionValue("Balance Affinity") then
                -- Starsurge
                if Starsurge:Exists() and BestTarget:CanCast(Starsurge) then
                    BestTarget:Cast(Starsurge);
                    return;
                end
                -- Sunfire
                if Sunfire:Exists() then
                    if BestTarget:DebuffRemains(SunfireDebuff) < 5 and BestTarget:CanCast(Sunfire) then
                        BestTarget:Cast(Sunfire);
                        return;
                    end
                    if module.IsOptionEnabled("Multi-Dot Sunfire") and SunfireUnit and SunfireUnit:CanCast(Sunfire) then
                        SunfireUnit:Cast(Sunfire);
                        return;
                    end
                end
                -- Apply Moonfire
                if Moonfire:Exists() then
                    if BestTarget:DebuffRemains(MoonfireDebuff) < 6 and BestTarget:CanCast(Moonfire) then
                        BestTarget:Cast(Moonfire);
                        return;
                    end
                    if module.IsOptionEnabled("Multi-Dot Moonfire") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                        MoonfireUnit:Cast(Moonfire);
                        return;
                    end
                end
                -- Solar Wrath
                if SolarWrath:Exists() and Player:Buff(SolarEmpowerment) and BestTarget:CanCast(SolarWrath) then
                    BestTarget:Cast(SolarWrath);
                    return;
                end
                -- Lunar Strike
                if LunarStrike:Exists() and BestTarget:CanCast(LunarStrike) then
                    BestTarget:Cast(LunarStrike);
                    return;
                end
            end
            -- Prevent Swapout
            if Player:Buff(MoonkinForm) and LowestUnit:HealthPercentage() > module.GetOptionValue("Balance Affinity") and BestTarget and BestTarget:Exists() and Player:IsWithinCastRange(BestTarget, Moonfire) then
                return;
            end
        end
    -- DPS Management
        -- Only use DPS and Cooldowns during combat
        if Player:IsInCombat() then
            if BestTarget and module.IsOptionEnabled("DPS") and Lowest:HealthPercentage() >= module.GetOptionValue("DPS") and (not MainTank or MainTank:HealthPercentage() >= module.GetOptionValue("DPS")) and (not OffTank or OffTank:HealthPercentage() >= module.GetOptionValue("DPS")) and BestTarget:IsInCombat() then
                -- Sunfire
                if Sunfire:Exists() then
                    if module.IsOptionEnabled("Sunfire") and BestTarget:DebuffRemains(SunfireDebuff) < 5 and BestTarget:CanCast(Sunfire) then
                        BestTarget:Cast(Sunfire);
                        return;
                    end
                    if module.IsOptionEnabled("Multi-Dot Sunfire") and SunfireUnit and SunfireUnit:CanCast(Sunfire) then
                        SunfireUnit:Cast(Sunfire);
                        return;
                    end
                end
                -- Apply Moonfire
                if Moonfire:Exists() then
                    if module.IsOptionEnabled("Moonfire") and BestTarget:DebuffRemains(MoonfireDebuff) < 6 and BestTarget:CanCast(Moonfire) then
                        BestTarget:Cast(Moonfire);
                        return;
                    end
                    if module.IsOptionEnabled("Multi-Dot Moonfire") and MoonfireUnit and MoonfireUnit:CanCast(Moonfire) then
                        MoonfireUnit:Cast(Moonfire);
                        return;
                    end
                end
                -- Wrath
                if SolarWrath:Exists() and module.IsOptionEnabled("Solar Wrath") and BestTarget:CanCast(SolarWrath) then
                    BestTarget:Cast(SolarWrath);
                    return;
                end
            end
    -- Cooldowns
            -- Racials with Specific Handlers
            if module.IsOptionEnabled("Use Racials") then
                if RacialsUnits >= module.GetOptionValue("Soft Cooldowns Units") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                        return;
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                        return;
                    end
                end
            end
            -- Trinkets with specific handlers
            if module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 1"), module.GetSecondOptionValue("Use Trinket 1");
                if Option1 == "Always" or (Option1 == "Health" and Trinket1Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 1")) then
                    Trinket1:UseInventory();
                end
            end
            if module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 2"), module.GetSecondOptionValue("Use Trinket 2");
                if Option1 == "Always" or (Option1 == "Health" and Trinket2Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 2")) then
                    Trinket2:UseInventory();
                end
            end
            if module.CooldownsAllowed() then
                -- Incarnation: Tree of Life
                if IncarnationTreeOfLife:Exists() and module.IsOptionEnabled("Incarnation: Tree Of Life") and #IncarnationTreeOfLifeUnits >= module.GetOptionValue("Incarnation: Tree Of Life") and not Player:Buff(IncarnationTreeOfLife) and Player:CanCast(IncarnationTreeOfLife) then
                    Player:Cast(IncarnationTreeOfLife);
                    return;
                end
                -- Tranquility
                if Tranquility:Exists() and module.IsOptionEnabled("Tranquility") and #TranquilityUnits >= module.GetOptionValue("Tranquility") and Player:CanCast(Tranquility) then
                    Player:Cast(Tranquility);
                    return;
                end
                -- Ironbark
                if Ironbark:Exists() and module.IsOptionEnabled("Ironbark") then
                    if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Ironbark") and MainTank:CanCast(Ironbark) then
                        module.Bug("Ironbark - MainTank");
                        MainTank:Cast(Ironbark);
                        return;
                    end
                    if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Ironbark") and OffTank:CanCast(Ironbark) then
                        module.Bug("Ironbark - OffTank");
                        OffTank:Cast(Ironbark);
                        return;
                    end
                end
                -- Essence of G'Hanir
                if EssenceOfGHanir:Exists() and module.IsOptionEnabled("Essence Of G'Hanir") and #EssenceOfGHanirUnits >= module.GetOptionValue("Essence Of G'Hanir") and Player:CanCast(EssenceOfGHanir) then
                    Player:Cast(EssenceOfGHanir);
                    return;
                end
            end
        end
        -- Swiftmend
        if Swiftmend:Exists() and module.IsOptionEnabled("Swiftmend") then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Swiftmend") and MainTank:CanHeal(Swiftmend) then
                module.Bug("Swiftmend - MainTank");
                MainTank:Cast(Swiftmend);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Swiftmend") and OffTank:CanHeal(Swiftmend) then
                module.Bug("Swiftmend - OffTank");
                OffTank:Cast(Swiftmend);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() < module.GetSecondOptionValue("Swiftmend") and Lowest:CanHeal(Swiftmend) then
                module.Bug("Swiftmend - Lowest");
                Lowest:Cast(Swiftmend);
                return;
            end
        end

        -- Dispels Handling
        Player:DispelHandler(NaturesCure, "Nature's Cure", DispelUnit, CurrentBadDebuffs.Dispel, "Normal");

    -- Active Healing Heal Target handler
        if Target:CanHeal(Regrowth) and module.IsOptionEnabled("Heal Target") and (module.GetOptionValue("Heal Target") == 2 or (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed())) then
            HealTarget(Target);
            return;
        end
    -- AoE Healing
        Efflorescences();
        -- Wild Growth
        if WildGrowthUnit and WildGrowthUnit:CanCast(WildGrowth) then
            -- Use Swiftmend with Soul Of The Forest
            if SoulOfTheForest:Exists() and not Swiftmend:IsOnCooldown() and not Player:Buff(SoulOfTheForestBuff) then
                local BestLowest, BestLowestHealth = nil, 100;
                if Lowest and Lowest:CanHeal(Swiftmend) then
                    BestLowest, BestLowestHealth = Lowest, Lowest:SpecialHealthPercentage();
                end
                if OffTank and OffTank:CanHeal(Swiftmend) and (not BestLowest or OffTank:SpecialHealthPercentage() < BestLowestHealth) then
                    BestLowest, BestLowestHealth = OffTank, OffTank:SpecialHealthPercentage();
                end
                if MainTank and MainTank:CanHeal(Swiftmend) and (not BestLowest or MainTank:SpecialHealthPercentage() < BestLowestHealth) then
                    BestLowest, BestLowestHealth = MainTank, MainTank:SpecialHealthPercentage();
                end
                if BestLowest and BestLowest:CanHeal(Swiftmend) then
                    BestLowest:Cast(Swiftmend);
                    return;
                end
            end
            if WildGrowthUnit:CanCast(WildGrowth) then
                WildGrowthUnit:Cast(WildGrowth);
                return;
            end
        end
    -- High Priority Healing
        -- Lifebloom
        if module.IsOptionEnabled("Lifebloom") and (MaxLifebloomValue == 2 or Lifebloom:TimeSinceCast() > 7) then
            if MainTank and MainTankTanking and (not MainTank:Buff(Lifebloom) or (MainTank:BuffRemains(Lifebloom) < 3 and MainTank:SpecialHealthPercentage() >= module.GetOptionValue("Lifebloom"))) and MainTank:CanCast(Lifebloom) then
                Lifebloom.LastCastTime = module.GetTime();
                MainTank:Cast(Lifebloom);
                return;
            end
            if OffTank and OffTankTanking and (not (MainTank and MainTankTanking) or LifebloomUnits < MaxLifebloomValue) and (not OffTank:Buff(Lifebloom) or (OffTank:BuffRemains(Lifebloom) < 3 and OffTank:SpecialHealthPercentage() >= module.GetOptionValue("Lifebloom"))) and OffTank:CanCast(Lifebloom) then
                Lifebloom.LastCastTime = module.GetTime();
                OffTank:Cast(Lifebloom);
                return;
            end
            if MainTank and (not (OffTank and OffTankTanking) or LifebloomUnits < MaxLifebloomValue) and not MainTank:Buff(Lifebloom) and MainTank:CanCast(Lifebloom) then
                Lifebloom.LastCastTime = module.GetTime();
                MainTank:Cast(Lifebloom);
                return;
            end
        end
        -- Cenarion Ward
        if CenarionWard:Exists() and module.IsOptionEnabled("Cenarion Ward") then
            if MainTank and MainTank:ThreatSituation() >= 2 and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Cenarion Ward") and MainTank:CanHeal(CenarionWard) then
                MainTank:Cast(CenarionWard);
                return;
            elseif OffTank and OffTank:ThreatSituation() >= 2 and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Cenarion Ward") and OffTank:CanHeal(CenarionWard) then
                OffTank:Cast(CenarionWard);
                return;
            elseif Lowest
                and Lowest:ThreatSituation() >= 2
                and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Cenarion Ward")
                and Lowest:CanHeal(CenarionWard) then
                Lowest:Cast(CenarionWard);
                return;
            end
        end
    -- Bad Debuffs - Tank
        if module.IsOptionEnabled("Tank Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Tanks do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Tanks[i], CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Rejuvenation) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if module.IsOptionEnabled("Tank Debuffs") and BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Tank Debuffs") then
                -- Rejuvenation
                if BestUnit:CanCast(Rejuvenation) and not BestUnit:Buff(Rejuvenation) then
                    BestUnit:Cast(Rejuvenation);
                    module.Bug("Rejuvenation on " .. BestUnit:Name() .. " to heal debuff");
                    return;
                end
                -- Germination
                if Germination:Exists() and BestUnit:CanCast(Rejuvenation) and not BestUnit:Buff(GerminationRejuvenation) then
                    BestUnit:Cast(Rejuvenation);
                    module.Bug("Germination on " .. BestUnit:Name() .. " to heal debuff");
                    return;
                end
            end
        end
    -- Bad Debuffs - Debuffs
        if module.IsOptionEnabled("Raid Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Debuff do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Debuff[i], CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Rejuvenation) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if module.IsOptionEnabled("Raid Debuffs") and BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Raid Debuffs") then
                -- Rejuvenation
                if BestUnit:CanCast(Rejuvenation) and not BestUnit:Buff(Rejuvenation) then
                    BestUnit:Cast(Rejuvenation);
                    module.Bug("Rejuvenation on " .. BestUnit:Name() .. " to heal debuff");
                    return;
                end
                -- Germination
                if Germination:Exists() and BestUnit:CanCast(Rejuvenation) and not BestUnit:Buff(GerminationRejuvenation) then
                    BestUnit:Cast(Rejuvenation);
                    module.Bug("Germination on " .. BestUnit:Name() .. " to heal debuff");
                    return;
                end
            end
        end
    -- Regular Healing
        -- Regrowth
        if module.IsOptionEnabled("Regrowth") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Regrowth") and MainTank:BuffRemains(Regrowth) < 3.6 + Regrowth:CastTime() and MainTank:CanHeal(Regrowth) then
                MainTank:Cast(Regrowth);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Regrowth") and OffTank:BuffRemains(Regrowth) < 3.6 + Regrowth:CastTime() and OffTank:CanHeal(Regrowth) then
                OffTank:Cast(Regrowth);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Regrowth") and Lowest:BuffRemains(Regrowth) < 3.6 + Regrowth:CastTime() and Lowest:CanHeal(Regrowth) then
                Lowest:Cast(Regrowth);
                return;
            end
        end
        -- Regrowth - Use Clearcasting Procs
        if module.IsOptionEnabled("Regrowth") and Player:Buff(Clearcasting) then
            -- Top priority add Regrowth Buff to priority targets
            if MainTank and MainTank:SpecialHealthPercentage() <= 95 and MainTank:BuffRemains(Regrowth) < 6 and MainTank:CanHeal(Regrowth) then
                MainTank:Cast(Regrowth);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= 95 and OffTank:BuffRemains(Regrowth) < 6 and OffTank:CanHeal(Regrowth) then
                OffTank:Cast(Regrowth);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= 95 and Lowest:BuffRemains(Regrowth) < 6 and Lowest:CanHeal(Regrowth) then
                Lowest:Cast(Regrowth);
                return;
            end
            -- Regrowth Cycle to apply buffs
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #HealUnits do
                local ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage();
                if ThisUnitHealth <= BestUnitHealth and ThisUnit:CanHeal(Regrowth) and not ThisUnit:Buff(Regrowth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnitHealth <= module.GetSecondOptionValue("Regrowth") then
                module.Bug("Regrowth - Cycle with Clearcast");
                BestUnit:Cast(Regrowth);
                return;
            end
            -- last Call, heal even without buff check
            if MainTank and MainTank:SpecialHealthPercentage() <= 80 and MainTank:CanHeal(Regrowth) then
                MainTank:Cast(Regrowth);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= 80 and OffTank:CanHeal(Regrowth) then
                OffTank:Cast(Regrowth);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= 80 and Lowest:CanHeal(Regrowth) then
                Lowest:Cast(Regrowth);
                return;
            end
        end
    -- Bad Debuffs - Topping
        if module.IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Top do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Top[i], CurrentBadDebuffs.Top[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Regrowth) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth <= module.GetOptionValue("Topping") then
                if BestUnit:CanCast(Regrowth) and not BestUnit:Buff(Regrowth) then
                    BestUnit:Cast(Regrowth);
                    module.Bug("Regrowth on " .. BestUnit:Name() .. " to top it");
                    return;
                end
                if not BestUnit:Buff(Rejuvenation) and BestUnit:CanCast(Rejuvenation)  then
                    BestUnit:Cast(Rejuvenation);
                    module.Bug("Rejuvenation on " .. BestUnit:Name() .. " to top it");
                    return;
                end
                if Germination:Exists() and not BestUnit:Buff(GerminationRejuvenation) and BestUnit:CanCast(Rejuvenation) then
                    BestUnit:Cast(Rejuvenation);
                    module.Bug("Germination on " .. BestUnit:Name() .. " to top it");
                    return;
                end
                if BestUnit:CanCast(HealingTouch) then
                    BestUnit:Cast(HealingTouch);
                    module.Bug("Healing Touch on " .. BestUnit:Name() .. " to top it");
                    return;
                end
            end
        end
    -- Low Priority Healing
        -- Rejuvenation
        if module.IsOptionEnabled("Rejuvenation") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Rejuvenation") and MainTank:CanHeal(Rejuvenation) and not (MainTank:Buff(Rejuvenation) or MainTank:Buff(GerminationRejuvenation)) then
                MainTank:Cast(Rejuvenation);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Rejuvenation") and OffTank:CanHeal(Rejuvenation) and not (OffTank:Buff(Rejuvenation) or OffTank:Buff(GerminationRejuvenation)) then
                OffTank:Cast(Rejuvenation);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Rejuvenation") and Lowest:CanHeal(Rejuvenation) and not (Lowest:Buff(Rejuvenation) or Lowest:Buff(GerminationRejuvenation)) then
                Lowest:Cast(Rejuvenation);
                return;
            end
        end
        -- Germination
        if module.IsOptionEnabled("Rejuvenation Germination") and Germination:Exists() then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Rejuvenation Germination") and MainTank:CanHeal(Rejuvenation) and not (MainTank:Buff(Rejuvenation) and MainTank:Buff(GerminationRejuvenation)) then
                MainTank:Cast(Rejuvenation);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Rejuvenation Germination") and OffTank:CanHeal(Rejuvenation) and not (OffTank:Buff(Rejuvenation) and OffTank:Buff(GerminationRejuvenation)) then
                OffTank:Cast(Rejuvenation);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Rejuvenation Germination") and Lowest:CanHeal(Rejuvenation) and not (Lowest:Buff(Rejuvenation) and Lowest:Buff(GerminationRejuvenation)) then
                Lowest:Cast(Rejuvenation);
                return;
            end
        end
        -- Regrowth Emergency
        if module.IsOptionEnabled("Regrowth Emergency") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Regrowth Emergency") and MainTank:CanHeal(Regrowth) then
                MainTank:Cast(Regrowth);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Regrowth Emergency") and OffTank:CanHeal(Regrowth) then
                OffTank:Cast(Regrowth);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Regrowth Emergency")  and Lowest:CanHeal(Regrowth) then
                Lowest:Cast(Regrowth);
                return;
            end
        end
        -- Rejuvenation Cycle
        if module.IsOptionEnabled("Rejuvenation") and RejuvenationUnits < module.GetOptionValue("Rejuvenation Counts") then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #HealUnits do
                local ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage();
                if ThisUnitHealth <= BestUnitHealth and ThisUnit:CanHeal(Rejuvenation) and ThisUnit:BuffRemains(Rejuvenation) < 3 and ThisUnit:BuffRemains(GerminationRejuvenation) < 3 then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnitHealth <= module.GetSecondOptionValue("Rejuvenation") then
                module.Bug("Rejuvenation - Cycle");
                BestUnit:Cast(Rejuvenation);
                return;
            end
        end
        -- Germination Cycle
        if Germination:Exists() and module.IsOptionEnabled("Rejuvenation Germination") and GerminationUnits < module.GetSecondOptionValue("Rejuvenation Counts") then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #HealUnits do
                local ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage();
                if ThisUnitHealth <= BestUnitHealth and ThisUnit:CanHeal(Rejuvenation) and (ThisUnit:BuffRemains(Rejuvenation) < 3 or not ThisUnit:Buff(GerminationRejuvenation)) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnitHealth <= module.GetSecondOptionValue("Rejuvenation Germination") then
                module.Bug("Germination - Cycle");
                BestUnit:Cast(Rejuvenation);
                return;
            end
        end
        -- Healing Touch - Tanks
        if module.IsOptionEnabled("Healing Touch") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Healing Touch") and MainTank:CanHeal(HealingTouch) then
                MainTank:Cast(HealingTouch);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Healing Touch") and OffTank:CanHeal(HealingTouch) then
                OffTank:Cast(HealingTouch);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Healing Touch") and Lowest:CanHeal(HealingTouch) then
                Lowest:Cast(HealingTouch);
                return;
            end
        end
    end



    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Resurrect Deads
        if Revive:Exists() and module.IsOptionEnabled("Revive") and Unit.ResurrectCycle(Revive) then
            return;
        end
        -- Proving Grounds Food
        if MainTank and MainTank:CreatureID() == 72218 and Player:PowerPercentage() < 95 and not Player:IsMoving() and LukewarmYakRoastBroth:InStock() and not LukewarmYakRoastBroth:IsOnCooldown() then
            LukewarmYakRoastBroth:Use(Player);
        end
        if module.IsOptionEnabled("Out Of Combat Healing") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Beastmaster Hunter
    local Rotation = {};
    module.SetRotation("_"..253, Rotation);

    --- Localization
    -- Core
    local Enemies_40y, TargetEnemies_8y, BarrageEnemies, NumEnemies = {}, {}, {}, 1; -- Enemies
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local TriedToResurrectPet, TriedToSummonPet = 0, 0; -- Summon/Whistle Pet alternate
    local BestialWrathEnabled;
    local PlayerPet = module.PlayerPet;
    local PlayerPetTarget = module.Unit.PlayerPetTarget;


    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        --Racials
        ArcaneTorrent = Spell(80483, false, false, true);
        RocketBarrage = Spell(69041, true, true, true);
        BloodFury = Spell(20572, false, false, true);
        Berserking = Spell(26297, false, false, true);
        GiftOfTheNaaru = Spell(59543, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        AMurderOfCrows = Spell(131894, false, true, true);
        AspectOfTheTurtle = Spell(186265, false, false, true);
        AspectOfTheWild = Spell(193530, false, false, true);
        Barrage = Spell(120360, true, true, false);
        BeastCleave = Spell(118455, false, false, true);
        BestialWrath = Spell(19574, false, false, true);
        ChimaeraShot = Spell(53209, true, true, true);
        CobraShot = Spell(193455, true, true, false);
        ConcussiveShot = Spell(5116, true, true, true);
        CounterShot = Spell(147362, true, true, true);
        DireBeast = Spell(120679, false, true, true);
        DireFrenzy = Spell(217200, false, true, true);
        Exhilaration = Spell(109304, false, false, true);
        FeignDeath = Spell(5384, false, false, true);
        KillCommand = Spell(34026, false, true, true);
        KillerCobra = Spell(199532);
        MendPet = Spell(982, false, false, true);
        MendPetBuff = Spell(136, false, false, true);
        Misdirection = Spell(34477, false, false, true);
        MisdirectionBuff = Spell(35079, false, false, true);
        MultiShot = Spell(2643, true, true, true);
        Stampede = Spell(201430, false, true, true);
        TitansThunder = Spell(207068, false, false, true);
        Volley = Spell(194386, false, true, true);

        -- Pet Manager section
        CallPets = {Spell(883, false, false, true),
                    Spell(83242, false, false, true),
                    Spell(83243, false, false, true),
                    Spell(83244, false, false, true),
                    Spell(83245, false, false, true)}
        RevivePet = Spell(982, false, false, false);


        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        -- Add options to pages
        module.AddPresetOption("TargetAttack");
        module.AddPresetOption("BossCD");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Auto Summon/Revive Pet", 222, true, {3, 1, 25, 0.5}, {1, 1, 5, 1}, "Automatically Whistle/Revive your Pet."..C.TOOLTIP_VALUE_1.."How long would you like to wait before using Whistle when your pet is dismissed."..C.TOOLTIP_VALUE_2.."Which pet you would like to auto summon?");
        module.AddNewOption("General Settings", "Misdirection", 232, true, {1, "Always", "Engage", "Threath Any", "Threath Target"}, {80, 0, 100, 5}, "Use Misdirection on your Tank, Focus or Pet."..C.TOOLTIP_VALUE_1.."Choose prefered Mode."..C.TOOLTIP_VALUE_2.."Define threath percentage threshold. Set to 100 to use always.");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Pummel to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Will use Potion when the BossMod (Support DBM & BW) timer will met the timer set.");
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists()  or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Only Arcane Torrent is supported."));
        end
        module.AddPresetOption("Trinket");
        -- module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions (only if your target is a Boss).");
        module.AddNewOption("Offensive Settings", "A Murder Of Crows", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use A Murder Of Crows."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Aspect Of The Wild", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Aspect Of The Wild."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Bestial Wrath", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Bestial Wrath."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Stampede", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Stampede."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Titan's Thunder", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Titan's Thunder."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Barrage", 220, true, {1, 1, 5, 1}, nil, "Use Barrage."..C.TOOLTIP_VALUE.."Minimum number of units to use Barrage.");
        module.AddNewOption("Offensive Settings", "Concussive Shot", 210, false, nil, nil, "Maintain Concussive Shot on our current target.");
        module.AddNewOption("Offensive Settings", "Cobra Shot", 122, false, {90, 1, 120, 1}, {119, 1, 120, 1}, "Cobra Shot Focus thresholds."..C.TOOLTIP_VALUE_1.."Minimum Focus to use as filler without Killer Cobra."..C.TOOLTIP_VALUE_2.."Minimum Focus to use as filler with Killer Cobra.");
        module.AddNewOption("Offensive Settings", "Dire Beast", 210, true, nil, nil, "Use Dire Beast or Dire Frenzy.");
        module.AddNewOption("Offensive Settings", "Pet Damage Handling", 230, true, {1, "Handle Assist", "Do Not Handle Assist"}, nil, "Manage Pet."..C.TOOLTIP_VALUE_1.."Enable this to automatically change between assist and passive mode depending if you have a target or not.");
        module.AddNewOption("Offensive Settings", "Volley", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {1, 1, 20, 1}, "Use Spell on Target or Centered Between Units, Standing means spell will be used only if units are not moving.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddPresetOption("HealingItem");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Mend Pet", 222, true, {35, 0, 100, 1}, {85, 0, 100, 1}, "Enable use of Mend Pet when pet health fall under threshold. \n\n|cFF0088FFValue 1:|r In combat threshold. \n\n|cFF0088FFValue 2:|r Out of combat threshold.");
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Auto Feign Death", 220, true, {10, 0, 100, 1}, nil, "Use Feign Death."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Aspect Of The Turtle", 220, true, {35, 0, 100, 1}, nil, "Use Aspect Of The Turtle."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Exhilaration", 220, true, {20, 1, 100, 1}, nil, "Use Exhilaration."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {20, 1, 100, 1}, nil, "Use Gift Of The Naaru on self."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- Macro to queue Barrage
        module.RegisterCommand("barrage",
            function ()
                if Barrage:Exists() then
                    if module.ShouldBarrage == true then
                        module.ShouldBarrage = false;
                        module.Bug("Barrage Queue Canceled");
                    elseif Barrage:Cooldown() < 5 then
                        module.ShouldBarrage = true;
                        module.Bug("Barrage Queued");
                    end
                else
                    module.Bug("You do not have Barrage talented.");
                end
            end
        );
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Buff(FeignDeath) then
            return;
        end

        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Defensives ()
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Healing Item") and Player:HealthPercentage() <= module.GetOptionValue("Healing Item") then
            if HealingTonic:IsUsable() then
                Healthstone:Use(Player);
            elseif Healthstone:IsUsable() then
                HealingTonic:Use(Player);
            end
        end
        -- Exhilaration
        if Exhilaration:Exists() and module.IsOptionEnabled("Exhilaration") and Player:HealthPercentage() <= module.GetOptionValue("Exhilaration") and Player:CanCast(Exhilaration) then
            Player:Cast(Exhilaration);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
        -- Aspect of the Turtle
        if AspectOfTheTurtle:Exists() and module.IsOptionEnabled("Aspect Of The Turtle") and Player:HealthPercentage() <= module.GetOptionValue("Aspect Of The Turtle") and Player:CanCast(AspectOfTheTurtle) then
            Player:Cast(AspectOfTheTurtle);
            return;
        end
        -- Feign Death
        if FeignDeath:Exists() and module.IsOptionEnabled("Auto Feign Death") and Player:HealthPercentage() <= module.GetOptionValue("Auto Feign Death") and Player:CanCast(FeignDeath) then
            Player:Cast(FeignDeath);
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(CounterShot, ArcaneTorrent);
    end

    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(CobraShot, false) or Unit.Target;
    end

    -- Function to check if we can use Kill Command
    local function CanKillCommand ()
        return not module.KillFailTime or module.GetTime() > module.KillFailTime;
    end

    -- Pet Manager
    local function ManagePet ()
        if module.IsOptionEnabled("Auto Summon/Revive Pet") and (InstantWhistle or module.PetDismissed + module.GetOptionValue("Auto Summon/Revive Pet") < module.GetTime()) then
            InstantWhistle = false;
            -- if whistle works, fine, otherwise blacklist it fro 5 second (usually should work fine with 1 attempt)
            if not PlayerPet:Exists() and module.GetTime() > TriedToSummonPet and Player:CanCast(CallPets[module.GetSecondOptionValue("Auto Summon/Revive Pet")]) then
                TriedToSummonPet = module.GetTime() + 5;
                Player:Cast(CallPets[module.GetSecondOptionValue("Auto Summon/Revive Pet")]);
                return;
            end
            -- if revive didnt work then we blacklist it 3 seconds (usually happens when user moves during resurrection cast)
            if not Player:IsMoving() and (not PlayerPet:Exists() or PlayerPet:IsDead()) and Player:CanCast(RevivePet) and module.GetTime() > TriedToResurrectPet then
                TriedToResurrectPet = module.GetTime() + 3;
                Player:Cast(MendPet);
                return;
            end
        end
        -- Mend Pet
        if PlayerPet:Exists() and module.IsOptionEnabled("Mend Pet") and Player:CanCast(MendPet) and not PlayerPet:Buff(MendPetBuff) and MendPet:TimeSinceCast() > 8 then
            if (Player:IsInCombat() and PlayerPet:HealthPercentage() <= module.GetOptionValue("Mend Pet")) or (not Player:IsInCombat() and PlayerPet:HealthPercentage() <= module.GetSecondOptionValue("Mend Pet")) then
                PlayerPet:Cast(MendPet);
                return;
            end
        end
    end

    -- Misdirection
    local function MisdirectionHandler ()
        if module.IsOptionEnabled("Misdirection") and not Player:Buff(MisdirectionBuff) then
            local MisdirectionTarget = (Focus and Focus:Exists() and Focus:CanCast(Misdirection) and Focus) or (MainTank and MainTank:Exists() and MainTank:CanCast(Misdirection) and MainTank) or (OffTank and OffTank:Exists() and OffTank:CanCast(Misdirection) and OffTank) or (PlayerPet and PlayerPet:Exists() and PlayerPet:CanCast(Misdirection) and PlayerPet);
            if MisdirectionTarget then
                -- Always
                if module.GetOptionValue("Misdirection") == "Always" then
                    MisdirectionTarget:Cast(Misdirection);
                    return;
                end
                -- When Fight just started
                if module.GetOptionValue("Misdirection") == "Engage" and CombatTime() < 5 then
                    MisdirectionTarget:Cast(Misdirection);
                    return;
                end
                -- If Target Threath is too high
                if module.GetOptionValue("Misdirection") == "Threath Target" and Player:Threat(Target) >= module.GetSecondOptionValue("Misdirection") then
                    MisdirectionTarget:Cast(Misdirection);
                    return;
                end
                -- If Any Target Threath is too high
                if module.GetOptionValue("Misdirection") == "Threath Any" then
                    for i = 1, #BarrageEnemies do
                        local ThisUnit = BarrageEnemies[i];
                        if Player:Threat(ThisUnit) >= module.GetSecondOptionValue("Misdirection") then
                            module.Bug("Misdirection on " .. MisdirectionTarget:Name() .. " as " .. ThisUnit:Name() .. " is at " .. Player:Threat(ThisUnit) .. "% threath")
                            MisdirectionTarget:Cast(Misdirection);
                            return;
                        end
                    end
                end
            end
        end
    end


    -- Handling of Pet Actionbar Abilities
    local PetAssisting, PetForceAssistDelay = nil, 0;
    local function PlayerPetHandling ()
        -- Player Pet Handling
        if module.IsOptionEnabled("Pet Damage Handling") then
            if PlayerPet:Exists() then
                -- Assist/Passive Mode
                if module.GetOptionValue("Pet Damage Handling") == "Handle Assist" then
                    if Target:Exists() and not PetAssisting then
                        PetAssistMode();
                        RunMacroText("/petattack target");
                        PetAssisting = true;
                    elseif not Target:Exists() and PetAssisting then
                        PetPassiveMode();
                        PetAssisting = false;
                    end
                    if Target:Exists() and PetAssisting and PlayerPetTarget and PlayerPetTarget:GUID() ~= Target:GUID() and PetForceAssistDelay < module.GetTime() then
                        PetPassiveMode();
                        PetAssistMode();
                        RunMacroText("/petattack target");
                        PetForceAssistDelay = module.GetTime() + 2;
                    end
                end
            end
        end
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        ManagePet();
        PlayerPetHandling();
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and Player:IsFacing(Target) then
            -- Barrage Queueing Macro
            if Barrage:Exists() and module.ShouldBarrage == true then
                if Barrage:Cooldown() > 6 then
                    module.ShouldBarrage = false;
                else
                    if Player:Focus() < 60 then
                        if PlayerPet:Exists() and PlayerPetTarget:Exists() and not PlayerPet:IsDead() and CanKillCommand() and PlayerPet:DistanceTo(PlayerPetTarget) < 20 then
                            -- Chimaera Shot
                            if ChimaeraShot:Exists() and Target:CanCast(ChimaeraShot) then
                                Target:Cast(ChimaeraShot);
                                return;
                            end
                            -- Dire Beast
                            if DireBeast:Exists() and not DireFrenzy:Exists() and PlayerPetTarget:CanCast(DireBeast) then
                                PlayerPetTarget:Cast(DireBeast);
                                return;
                            end
                            -- Dire Frenzy (30 Talent)
                            if DireFrenzy:Exists() and PlayerPetTarget:CanCast(DireFrenzy) then
                                PlayerPetTarget:Cast(DireFrenzy);
                                return;
                            end
                        end
                        return;
                    end
                    if Player:Focus() >= 60 and Target:CanCast(Barrage) then
                        Target:Cast(Barrage);
                        return;
                    end
                end
            end
            -- Enemies Check
            if module.UseAOE() and RefreshEnemies < module.GetTime() then
                BarrageEnemies = Player:UnitsInFrontConeAroundUnit(Target, 45, 160);
                Enemies_40y = Player:EnemiesWithinDistance(40, false);
                TargetEnemies_8y = Target:EnemiesWithinDistance(8, true, true);
                NumEnemies = #TargetEnemies_8y;
                RefreshEnemies = module.GetTime() + 0.2;
            else
                BarrageEnemies, Enemies_40y, TargetEnemies_8y, NumEnemies = {}, {}, {}, 1;
            end
            -- Misdirection
            MisdirectionHandler();
            -- Concussive Shot
            if ConcussiveShot:Exists() and module.IsOptionEnabled("Concussive Shot") and Target:CanCast(ConcussiveShot) then
                Target:Cast(ConcussiveShot);
                return;
            end
            BestialWrathEnabled = module.IsOptionEnabled("Bestial Wrath") and (module.CooldownsAllowed() or module.GetOptionValue("Bestial Wrath") == "Always") or false;
            -- Common Cooldowns
            if Player:IsWithinCastRange(Target, CobraShot) then
                -- Trinkets
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and Player:Focus() < 85 and Player:CanCast(ArcaneTorrent) then
                        Player:Cast(ArcaneTorrent);
                        return;
                    end
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                end
            end
            -- Titan's Thunder

            -- actions+=/a_murder_of_crows
            if AMurderOfCrows:Exists() and module.IsOptionEnabled("A Murder Of Crows") and (module.CooldownsAllowed() or module.GetOptionValue("A Murder Of Crows") == "Always") and Target:TimeToDie() >= 20 and Target:CanCast(AMurderOfCrows) then
                Target:Cast(AMurderOfCrows);
                return;
            end
            -- actions+=/stampede,if=(buff.bloodlust.up)|target.time_to_die<=15
            if Stampede:Exists() and module.IsOptionEnabled("Stampede") and (module.CooldownsAllowed() or module.GetOptionValue("Stampede") == "Always") and Target:TimeToDie() >= 20 and Target:CanCast(Stampede) then
                Target:Cast(Stampede);
                return;
            end
            -- actions+=/dire_beast,if=cooldown.bestial_wrath.remains>2
            -- actions+=/dire_frenzy,if=cooldown.bestial_wrath.remains>2
            if module.IsOptionEnabled("Dire Beast") and PlayerPet:Exists() and PlayerPetTarget:Exists() and not PlayerPet:IsDead() and CanKillCommand() and PlayerPet:DistanceTo(PlayerPetTarget) < 20 and (BestialWrath:Cooldown() > 2 or not BestialWrathEnabled) then
                -- Dire Beast
                if DireBeast:Exists() and not DireFrenzy:Exists() and Target:CanCast(DireBeast) then
                    Target:Cast(DireBeast);
                    return;
                end
                -- Dire Frenzy (30 Talent)
                if DireFrenzy:Exists() and Target:CanCast(DireFrenzy) then
                    Target:Cast(DireFrenzy);
                    return;
                end
            end
            -- actions+=/aspect_of_the_wild,if=buff.bestial_wrath.up
            if AspectOfTheWild:Exists() and module.IsOptionEnabled("Aspect Of The Wild") and (module.CooldownsAllowed() or module.GetOptionValue("Aspect Of The Wild") == "Always") and Player:Buff(BestialWrath) and Target:TimeToDie() >= 20 and Player:CanCast(AspectOfTheWild) then
                Player:Cast(AspectOfTheWild);
                return;
            end
            -- actions+=/barrage,if=spell_targets.barrage>1|(spell_targets.barrage=1&focus>90)
            if Barrage:Exists() and module.IsOptionEnabled("Barrage") and #BarrageEnemies >= module.GetOptionValue("Barrage") and Barrage:Cooldown() < 5 then
                if Player:Focus() >= 60 and Target:CanCast(Barrage) then
                    Target:Cast(Barrage);
                    return;
                end
            end
            -- Volley (90 Talent)
            if Volley:Exists() and module.IsOptionEnabled("Volley") and Target:CanCast(Volley) then
                if Target:CastGroundSpell(Volley, "Volley", 6) then return; end
            end
            -- actions+=/titans_thunder,if=cooldown.dire_beast.remains>=3|talent.dire_frenzy.enabled
            if TitansThunder:Exists() and module.IsOptionEnabled("Titan's Thunder") and (module.CooldownsAllowed() or module.GetOptionValue("Titan's Thunder") == "Always") and (DireBeast:Cooldown() >= 3 or not DireBeast:Exists()) and Player:CanCast(TitansThunder) then
                Player:Cast(TitansThunder);
                return;
            end
            -- actions+=/bestial_wrath
            if BestialWrath:Exists() and BestialWrathEnabled and Player:CanCast(BestialWrath) then
                Player:Cast(BestialWrath);
                return;
            end
            -- actions+=/multishot,if=spell_targets.multi_shot>=3&pet.buff.beast_cleave.down
            if MultiShot:Exists() and NumEnemies >= 3 and Target:CanCast(MultiShot) and PlayerPet:BuffRemains(BeastCleave) < 1.2 then
                module.Bug("Multi-Shot - Beast Cleave");
                Target:Cast(MultiShot);
                return;
            end
            -- actions+=/kill_command
            if KillCommand:Exists() and PlayerPet:Exists() and PlayerPetTarget:Exists() and not PlayerPet:IsDead() and CanKillCommand() and PlayerPet:DistanceTo(PlayerPetTarget) - PlayerPetTarget:CombatReach() < 20 and PlayerPetTarget:CanCast(KillCommand) then
                PlayerPetTarget:Cast(KillCommand);
                return;
            end
            -- actions+=/cobra_shot,if=talent.killer_cobra.enabled&(cooldown.bestial_wrath.remains>=4&(buff.bestial_wrath.up&cooldown.kill_command.remains>=2)|focus>119)|!talent.killer_cobra.enabled&focus>90
            if CobraShot:Exists() and ((KillerCobra:Exists() and (BestialWrath:Cooldown() >= 4 and (Player:Buff(BestialWrath) and KillCommand:Cooldown() >= 2) or Player:Focus() > module.GetSecondOptionValue("Cobra Shot"))) or (not KillerCobra:Exists() and Player:Focus() > module.GetOptionValue("Cobra Shot"))) and Target:CanCast(CobraShot) then
                Target:Cast(CobraShot);
                return;
            end
            -- actions+=/chimaera_shot,if=focus<90
            if ChimaeraShot:Exists() and Player:Focus() < 90 and Target:CanCast(ChimaeraShot) then
                Target:Cast(ChimaeraShot);
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        ManagePet();
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Marksmanship Hunter
    local Rotation = {};
    module.SetRotation("_"..254, Rotation);

    --- Localization
    -- Core
    local Enemies_40y, TargetEnemies_8y, BarrageEnemies, NumEnemies = {}, {}, {}, 1; -- Enemies
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local TriedToResurrectPet, TriedToSummonPet = 0, 0; -- Summon/Whistle Pet alternate

    local PlayerPet = module.PlayerPet;
    local PlayerPetTarget = module.Unit.PlayerPetTarget;
    local Detonate, DetonateTime = false, 0;


    local DraenicAgility, DraenicAgilityBuff, ArcaneTorrent, RocketBarrage, BloodFury, Berserking, GiftOfTheNaaru;
    local AimedShot, AMurderOfCrows, ArcaneShot, AspectOfTheTurtle, Barrage, BlackArrow, BurstingShot, CarefulAim, ConcussiveShot, CounterShot;
    local Exhilaration, ExplosiveShot, FeignDeath, HuntersMark, LockAndLoad, LoneWolf;
    local MarkedShot, MarkingTargets, MendPet, MendPetBuff, Misdirection, MisdirectionBuff, MultiShot;
    local PatientSniper, PiercingShot, Sentinel, Sidewinders, SteadyFocus, SteadyFocusBuff, TrueAim, TrueAimDebuff, Trueshot;
    local Volley, Vulnerable, Windburst, CallPets, RevivePet;

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        S = {
            -- Items
            DraenicAgility = Item(109217, false, false, true),
            DraenicAgilityBuff = Spell(156423, false, false, true),

            --Racials
            ArcaneTorrent = Spell(80483, false, false, true),
            RocketBarrage = Spell(69041, true, true, true),
            BloodFury = Spell(20572, false, false, true),
            Berserking = Spell(26297, false, false, true),
            GiftOfTheNaaru = Spell(59543, false, false, true),

            -- (ID, RequiresFacing, Hostile, instant)
            AimedShot = Spell(19434, true, true, false),
            AMurderOfCrows = Spell(131894, false, true, true),
            ArcaneShot = Spell(185358, true, true, true),
            AspectOfTheTurtle = Spell(186265, false, false, true),
            Barrage = Spell(120360, true, true, false),
            BlackArrow = Spell(194599, true, true, true),
            BurstingShot = Spell(186387, false, false, true),
            CarefulAim = Spell(53238),
            ConcussiveShot = Spell(5116, true, true, true),
            CounterShot = Spell(147362, true, true, true),
            Exhilaration = Spell(194291, false, false, true),
            ExplosiveShot = Spell(212431, false, false, true),
            FeignDeath = Spell(5384, false, false, true),
            HuntersMark = Spell(185365),
            LockAndLoad = Spell(194594),
            LoneWolf = Spell(155228),
            MarkedShot = Spell(185901, true, true, true),
            MarkingTargets = Spell(223138),
            MendPet = Spell(982, false, false, true),
            MendPetBuff = Spell(136, false, false, true),
            Misdirection = Spell(34477, false, false, true),
            MisdirectionBuff = Spell(35079, false, false, true),
            MultiShot = Spell(2643, true, true, true),
            PatientSniper = Spell(213423),
            PiercingShot = Spell(198670, true, true, true),
            Sentinel = Spell(206817, true, true, true),
            Sidewinders = Spell(214579, true, true, true),
            SteadyFocus = Spell(193533),
            SteadyFocusBuff = Spell(193534),
            TrueAim = Spell(199527),
            TrueAimDebuff = Spell(199803),
            Trueshot = Spell(193526, false, false, true),
            Volley = Spell(194386, false, true, true),
            Vulnerable = Spell(187131),
            Windburst = Spell(204147, true, true, true),

            -- Pet Manager section
            CallPets = {Spell(883, false, false, true),
                        Spell(83242, false, false, true),
                        Spell(83243, false, false, true),
                        Spell(83244, false, false, true),
                        Spell(83245, false, false, true)},
            RevivePet = Spell(982, false, false, false)
        };


        DraenicAgility = S.DraenicAgility;
        DraenicAgilityBuff = S.DraenicAgilityBuff;
        ArcaneTorrent = S.ArcaneTorrent;
        RocketBarrage = S.RocketBarrage;
        BloodFury = S.BloodFury;
        Berserking = S.Berserking;
        GiftOfTheNaaru = S.GiftOfTheNaaru;
        AimedShot = S.AimedShot;
        AMurderOfCrows = S.AMurderOfCrows;
        ArcaneShot = S.ArcaneShot;
        AspectOfTheTurtle = S.AspectOfTheTurtle;
        Barrage = S.Barrage;
        BlackArrow = S.BlackArrow;
        BurstingShot = S.BurstingShot;
        CarefulAim = S.CarefulAim;
        ConcussiveShot = S.ConcussiveShot;
        CounterShot = S.CounterShot;
        Exhilaration = S.Exhilaration;
        ExplosiveShot = S.ExplosiveShot;
        FeignDeath = S.FeignDeath;
        HuntersMark = S.HuntersMark;
        LockAndLoad = S.LockAndLoad;
        LoneWolf = S.LoneWolf;
        MarkedShot = S.MarkedShot;
        MarkingTargets = S.MarkingTargets;
        MendPet = S.MendPet;
        MendPetBuff = S.MendPetBuff;
        Misdirection = S.Misdirection;
        MisdirectionBuff = S.MisdirectionBuff;
        MultiShot = S.MultiShot;
        PatientSniper = S.PatientSniper;
        PiercingShot = S.PiercingShot;
        Sentinel = S.Sentinel;
        Sidewinders = S.Sidewinders;
        SteadyFocus = S.SteadyFocus;
        SteadyFocusBuff = S.SteadyFocusBuff;
        TrueAim = S.TrueAim;
        TrueAimDebuff = S.TrueAimDebuff;
        Trueshot = S.Trueshot;
        Volley = S.Volley;
        Vulnerable = S.Vulnerable;
        Windburst = S.Windburst;
        CallPets = S.CallPets;
        RevivePet = S.RevivePet;

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        -- Add options to pages
        module.AddPresetOption("TargetAttack");
        module.AddPresetOption("BossCD");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Auto Summon/Revive Pet", 222, true, {3, 1, 25, 0.5}, {1, 1, 5, 1}, "Automatically Whistle/Revive your Pet."..C.TOOLTIP_VALUE_1.."How long would you like to wait before using Whistle when your pet is dismissed."..C.TOOLTIP_VALUE_2.."Which pet you would like to auto summon?");
        module.AddNewOption("General Settings", "Misdirection", 232, true, {1, "Always", "Engage", "Threath Any", "Threath Target"}, {80, 0, 100, 5}, "Use Misdirection on your Tank, Focus or Pet."..C.TOOLTIP_VALUE_1.."Choose prefered Mode."..C.TOOLTIP_VALUE_2.."Define threath percentage threshold. Set to 100 to use always.");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Counter Shot to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists()  or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Only Arcane Torrent is supported."));
        end
        module.AddPresetOption("Trinket");
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "A Murder Of Crows", 230, true, {1, "Always", "With Cooldowns"}, nil, "Use A Murder of Crows."..C.TOOLTIP_VALUE.."Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Sentinel", 230, true, {2, "Always", "With Cooldowns"}, nil, "Use Sentinel."..C.TOOLTIP_VALUE.."Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Trueshot", 230, true, {2, "Always", "With Cooldowns"}, nil, "Use Trueshot."..C.TOOLTIP_VALUE.."Define if you want to always use the ability or only with cooldowns.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Barrage", 220, true, {3, 1, 10, 1}, nil, "Use Barrage."..C.TOOLTIP_VALUE.."Minimum amount of units to use.");
        module.AddNewOption("Offensive Settings", "Bursting Shot", 220, false, {5, 1, 10, 1}, nil, "Use Bursting Shot."..C.TOOLTIP_VALUE.."Minimum amount of units to use.");
        module.AddNewOption("Offensive Settings", "Concussive Shot", 210, false, nil, nil, "Maintain Concussive Shot on our current target.");
        module.AddNewOption("Offensive Settings", "Explosive Shot", 220, true, {1, 1, 10, 1}, nil, "Use Explosive Shot."..C.TOOLTIP_VALUE.."Minimum amount of units that needs to be in 8 yards of our target to use Explosive Shot.");
        module.AddNewOption("Offensive Settings", "Piercing Shot", 220, true, {1, 1, 10, 1}, nil, "Use Piercing Shot."..C.TOOLTIP_VALUE.."Minimum amount of units that needs to be in the path to our target to use Piercing Shot.");
        module.AddNewOption("Offensive Settings", "Multi-Shot", 220, true, {3, 1, 10, 1}, nil, "Use Multi-Shot."..C.TOOLTIP_VALUE.."Minimum amount of units that needs to be in 8 yards of our target to use Multi-Shot.");
        module.AddNewOption("Offensive Settings", "Pet Damage Handling", 230, true, {1, "Handle Assist", "Do Not Handle Assist"}, nil, "Manage Pet."..C.TOOLTIP_VALUE_1.."Enable this to automatically change between assist and passive mode depending if you have a target or not.");
        module.AddNewOption("Offensive Settings", "Volley", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {4, 1, 20, 1}, "Use Volley." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddPresetOption("HealingItem");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Mend Pet", 222, true, {35, 0, 100, 1}, {85, 0, 100, 1}, "Enable use of Mend Pet when pet health fall under threshold. \n\n|cFF0088FFValue 1:|r In combat threshold. \n\n|cFF0088FFValue 2:|r Out of combat threshold.");
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Auto Feign Death", 220, true, {10, 0, 100, 1}, nil, "Use Feign Death." .. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddNewOption("Defensive Settings", "Aspect Of The Turtle", 220, true, {35, 0, 100, 1}, nil, "Use Aspect Of The Turtle." .. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddNewOption("Defensive Settings", "Exhilaration", 220, true, {35, 0, 100, 1}, nil, "Use Exhilaration." .. C.TOOLTIP_VALUE .. "Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {35, 0, 100, 1}, nil, "Health Percentage to use Gift Of The Naaru on self");
        end

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- Macro to queue Barrage
        module.RegisterCommand("barrage",
            function ()
                if Barrage:Exists() then
                    if module.ShouldBarrage == true then
                        module.ShouldBarrage = false;
                        module.Bug("Barrage Queue Canceled");
                    elseif Barrage:Cooldown() < 5 then
                        module.ShouldBarrage = true;
                        module.Bug("Barrage Queued");
                    end
                else
                    module.Bug("You do not have Barrage talented.");
                end
            end
        );

        -- Explosive Shot Detonation
        local Frame = CreateFrame('Frame');
        local function DetonateExplosiveShot (self, ...)
            if Detonate and module.GetTime() > DetonateTime then
                Detonate = false;
                module.Bug("Explosive Shot - Explode");
                Player:Cast(ExplosiveShot);
            end
        end
        Frame:SetScript("OnUpdate", DetonateExplosiveShot);

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [Windburst:ID()] = "Windburst"
        };

    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Buff(FeignDeath) then
            return;
        end

        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Exhilaration
        if Exhilaration:Exists() and module.IsOptionEnabled("Exhilaration") and Player:HealthPercentage() <= module.GetOptionValue("Exhilaration") and Player:CanCast(Exhilaration) then
            Player:Cast(Exhilaration);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
        -- Aspect of the Turtle
        if AspectOfTheTurtle:Exists() and module.IsOptionEnabled("Aspect Of The Turtle") and Player:HealthPercentage() <= module.GetOptionValue("Aspect Of The Turtle") and Player:CanCast(AspectOfTheTurtle) then
            Player:Cast(AspectOfTheTurtle);
            return;
        end
        -- Feign Death
        if FeignDeath:Exists() and module.IsOptionEnabled("Auto Feign Death") and Player:HealthPercentage() <= module.GetOptionValue("Auto Feign Death") and Player:CanCast(FeignDeath) then
            Player:Cast(FeignDeath);
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(CounterShot, ArcaneTorrent);
    end

    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(AimedShot, false) or Unit.Target;
    end

    -- Pet Manager
    local function ManagePet ()
        if module.IsOptionEnabled("Auto Summon/Revive Pet") and (InstantWhistle or module.PetDismissed + module.GetOptionValue("Auto Summon/Revive Pet") < module.GetTime()) then
            InstantWhistle = false;
            -- if whistle works, fine, otherwise blacklist it fro 5 second (usually should work fine with 1 attempt)
            if not PlayerPet:Exists() and module.GetTime() > TriedToSummonPet and Player:CanCast(CallPets[module.GetSecondOptionValue("Auto Summon/Revive Pet")]) then
                TriedToSummonPet = module.GetTime() + 5;
                Player:Cast(CallPets[module.GetSecondOptionValue("Auto Summon/Revive Pet")]);
                return;
            end
            -- if revive didnt work then we blacklist it 3 seconds (usually happens when user moves during resurrection cast)
            if not Player:IsMoving() and (not PlayerPet:Exists() or PlayerPet:IsDead()) and Player:CanCast(RevivePet) and module.GetTime() > TriedToResurrectPet then
                TriedToResurrectPet = module.GetTime() + 3;
                Player:Cast(MendPet);
                return;
            end
        end
        -- Mend Pet
        if PlayerPet:Exists() and module.IsOptionEnabled("Mend Pet") and Player:CanCast(MendPet) and not PlayerPet:Buff(MendPetBuff) and MendPet:TimeSinceCast() > 8 then
            if (Player:IsInCombat() and PlayerPet:HealthPercentage() <= module.GetOptionValue("Mend Pet")) or (not Player:IsInCombat() and PlayerPet:HealthPercentage() <= module.GetSecondOptionValue("Mend Pet")) then
                PlayerPet:Cast(MendPet);
                return;
            end
        end
    end

    -- Misdirection
    local function MisdirectionHandler ()
        if module.IsOptionEnabled("Misdirection") and not Player:Buff(MisdirectionBuff) then
            local MisdirectionTarget = (Focus and Focus:Exists() and Focus:CanCast(Misdirection) and Focus) or (MainTank and MainTank:Exists() and MainTank:CanCast(Misdirection) and MainTank) or (OffTank and OffTank:Exists() and OffTank:CanCast(Misdirection) and OffTank) or (PlayerPet and PlayerPet:Exists() and PlayerPet:CanCast(Misdirection) and PlayerPet);
            if MisdirectionTarget then
                -- Always
                if module.GetOptionValue("Misdirection") == "Always" then
                    MisdirectionTarget:Cast(Misdirection);
                    return;
                end
                -- When Fight just started
                if module.GetOptionValue("Misdirection") == "Engage" and CombatTime() < 5 then
                    MisdirectionTarget:Cast(Misdirection);
                    return;
                end
                -- If Target Threath is too high
                if module.GetOptionValue("Misdirection") == "Threath Target" and Player:Threat(Target) >= module.GetSecondOptionValue("Misdirection") then
                    MisdirectionTarget:Cast(Misdirection);
                    return;
                end
                -- If Any Target Threath is too high
                if module.GetOptionValue("Misdirection") == "Threath Any" then
                    for i = 1, #BarrageEnemies do
                        local ThisUnit = BarrageEnemies[i];
                        if Player:Threat(ThisUnit) >= module.GetSecondOptionValue("Misdirection") then
                            module.Bug("Misdirection on " .. MisdirectionTarget:Name() .. " as " .. ThisUnit:Name() .. " is at " .. Player:Threat(ThisUnit) .. "% threath")
                            MisdirectionTarget:Cast(Misdirection);
                            return;
                        end
                    end
                end
            end
        end
    end

    -- Handling of Pet Actionbar Abilities
    local PetAssisting;
    local function PlayerPetHandling ()
        -- Player Pet Handling
        if module.IsOptionEnabled("Pet Damage Handling") then
            if PlayerPet:Exists() then
                -- Assist/Passive Mode
                if module.GetOptionValue("Pet Damage Handling") == "Handle Assist" then
                    if Target:Exists() and not PetAssisting then
                        RunMacroText("/petattack target");
                        PetAssistMode();
                        PetAssisting = true;
                    elseif not Target:Exists() and PetAssisting then
                        PetPassiveMode();
                        PetAssisting = false;
                    end
                end
            end
        end
    end

    local function CastExplosiveShot ()
        if ExplosiveShot:Exists() and module.IsOptionEnabled("Explosive Shot") and Player:CanCast(ExplosiveShot) then
            local RealDistance = Player:DistanceTo(Target, true);
            local CanExplosiveShot, ExplosiveShotTargets = false, 0;
            for i = 1, #ExplosiveShotEnemies do
                local ThisUnit = ExplosiveShotEnemies[i];
                if not CanExplosiveShot and ThisUnit:GUID() == Target:GUID() then
                    CanExplosiveShot = true;
                end
                if Player:DistanceTo(ThisUnit, true) < RealDistance + 3 and Player:DistanceTo(ThisUnit, true) > RealDistance - 3 then
                    ExplosiveShotTargets = ExplosiveShotTargets + 1;
                end
            end
            if CanExplosiveShot and ExplosiveShotTargets >= module.GetOptionValue("Explosive Shot") then
                local AdjustedDistance = RealDistance < 10 and RealDistance + 3 or RealDistance < 20 and RealDistance + 1.5 or RealDistance < 30 and RealDistance - 1 or RealDistance < 35 and RealDistance - 2 or RealDistance < 40 and RealDistance - 3 or RealDistance - 4;
                Detonate, DetonateTime = true, module.GetTime() + AdjustedDistance*0.0625;
                Player:Cast(ExplosiveShot);
                return;
            end
        end
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        if not LoneWolf:Exists() then
            ManagePet();
            PlayerPetHandling();
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and Player:IsFacing(Target) then
            -- Barrage Queueing Macro
            if Barrage:Exists() and module.ShouldBarrage == true then
                if Barrage:Cooldown() > 6 then
                    module.ShouldBarrage = false;
                else
                    if Player:Focus() < 60 then
                        if not Sidewinders:Exists() then
                            if Target:CanCast(ArcaneShot) then
                                module.Bug("Pool for Barrage");
                                Target:Cast(ArcaneShot);
                                return;
                            end
                        elseif Target:CanCast(Sidewinders) then
                            module.Bug("Pool for Barrage");
                            Target:Cast(Sidewinders);
                            return;
                        end
                    end
                    if Player:Focus() >= 60 and Target:CanCast(Barrage) then
                        Target:Cast(Barrage);
                        return;
                    end
                end
            end
            -- Enemies Check
            if module.UseAOE() and RefreshEnemies < module.GetTime() then
                BarrageEnemies = Barrage:Exists() and Player:UnitsInFrontConeAroundUnit(Target, 45, 100) or {};
                Enemies_40y = Player:EnemiesWithinDistance(40, false);
                ExplosiveShotEnemies = ExplosiveShot:Exists() and Player:UnitsInFrontRectangle(40, 5) or {};
                PiercingShotEnemies = PiercingShot:Exists() and Player:UnitsInFrontRectangle(Player:DistanceTo(Target, true), 3) or {};
                TargetEnemies_8y = Target:EnemiesWithinDistance(8, true, true);
                NumEnemies = #TargetEnemies_8y;
                RefreshEnemies = module.GetTime() + 0.2;
            else
                BarrageEnemies, Enemies_40y, ExplosiveShotEnemies, PiercingShotEnemies, TargetEnemies_8y, NumEnemies = {}, {}, {}, {}, {}, 1;
                --
            end
            -- Steady Focus
            if SteadyFocus:Exists() and (Player:Focus() < 100 or module.ShotCount >= 2) and Player:BuffRemains(SteadyFocusBuff) < 1 and module.ShotCount >= 1 and Target:CanCast(ArcaneShot) then
                if module.IsOptionEnabled("Multi-Shot") and NumEnemies >= module.GetOptionValue("Multi-Shot") and Target:CanCast(MultiShot) then
                    module.Bug("Steady Focus - Multi-Shot");
                    Target:Cast(MultiShot);
                    return;
                else
                    module.Bug("Steady Focus - Arcane Shot");
                    Target:Cast(ArcaneShot);
                    return;
                end
            end
            -- Misdirection
            MisdirectionHandler();
            -- Concussive Shot
            if ConcussiveShot:Exists() and module.IsOptionEnabled("Concussive Shot") and Target:CanCast(ConcussiveShot) then
                Target:Cast(ConcussiveShot);
                return;
            end
            -- Cooldowns
            if Player:IsWithinCastRange(Target, AimedShot) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and Player:Focus() < 70 and Player:CanCast(ArcaneTorrent) then
                        Player:Cast(ArcaneTorrent);
                        return;
                    end
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Trueshot
                if Trueshot:Exists() and module.IsOptionEnabled("Trueshot") and (module.CooldownsAllowed() or module.GetOptionValue("Trueshot") == "Always") and Player:Focus() >= 50 and Player:CanCast(Trueshot) then
                    Player:Cast(Trueshot);
                    return;
                end
            end
            -- Bursting Shot
            if BurstingShot:Exists() and module.IsOptionEnabled("Bursting Shot") and #ExplosiveShotEnemies >= module.GetOptionValue("Bursting Shot") and Player:CanCast(BurstingShot) then
                Player:Cast(BurstingShot);
                return;
            end
            -- Volley (90 Talent)
            if Volley:Exists() and module.IsOptionEnabled("Volley") and Target:CanCast(Volley) then
                if Target:CastGroundSpell(Volley, "Volley", 6) then return; end
                --
            end

            -- actions+=/trueshot,if=(target.time_to_die>195|target.health.pct<5)|buff.bullseye.stack>15
            -- actions+=/marked_shot,if=!talent.sidewinders.enabled&prev_gcd.sentinel&debuff.hunters_mark.up
            if MarkedShot:Exists() and not Sidewinders:Exists() and Sentinel:TimeSinceCast() < 1 and Target:Debuff(HuntersMark) and Target:CanCast(MarkedShot) then
                Target:Cast(MarkedShot);
                return;
            end


            -- actions+=/call_action_list,name=careful_aim,if=(talent.careful_aim.enabled&target.health.pct>80)&spell_targets.barrage=1
            if CarefulAim:Exists() and Target:HealthPercentage() > 80 and #BarrageEnemies < 2 then
                -- actions.careful_aim=windburst
                if Windburst:Exists() and Target:CanCast(Windburst) then
                    Target:Cast(Windburst);
                    return;
                end
                -- actions.careful_aim+=/arcane_shot,if=(talent.steady_focus.enabled&buff.steady_focus.down&spell_targets.arcane_shot=1)|(talent.true_aim.enabled&(debuff.true_aim.stack<1&focus.time_to_max>=2|debuff.true_aim.remains<2))
                -- actions.careful_aim+=/marked_shot,if=talent.sidewinders.enabled&(!talent.patient_sniper.enabled|debuff.vulnerability.remains<2)|!talent.sidewinders.enabled
                if MarkedShot:Exists() and ((Sidewinders:Exists() and (not PatientSniper:Exists() or Target:DebuffRemains(Vulnerable) < 2)) or not Sidewinders:Exists()) and Target:Debuff(HuntersMark) and Target:CanCast(MarkedShot) then
                    Target:Cast(MarkedShot);
                    return;
                end
                -- actions.careful_aim+=/aimed_shot,if=debuff.hunters_mark.down&cast_time<debuff.vulnerability.remains
                if AimedShot:Exists() and not Target:Debuff(HuntersMark) and AimedShot:CastTime() < Target:DebuffRemains(Vulnerable) and Target:CanCast(AimedShot) then
                    Target:Cast(AimedShot);
                    return;
                end
                -- actions.careful_aim+=/multishot,if=spell_targets.multishot>1&(buff.marking_targets.up|focus.time_to_max>=2)
                if MultiShot:Exists() and not Sidewinders:Exists() and module.IsOptionEnabled("Multi-Shot") and NumEnemies >= module.GetOptionValue("Multi-Shot") and (Player:Buff(MarkingTargets) or Player:FocusTimeToMax() >= 2) and Target:CanCast(MultiShot) then
                    Target:Cast(MultiShot);
                    return;
                end
                -- actions.careful_aim+=/arcane_shot,if=spell_targets.arcane_shot=1&(buff.marking_targets.up|focus.time_to_max>=2)
                if ArcaneShot:Exists() and not Sidewinders:Exists() and (Player:Buff(MarkingTargets) or Player:FocusTimeToMax() >= 2) and Target:CanCast(ArcaneShot) then
                    Target:Cast(ArcaneShot);
                    return;
                end
                -- actions.careful_aim+=/sidewinders,if=!debuff.hunters_mark.up&(buff.marking_targets.up|buff.trueshot.up|charges=2|focus<80&(charges<=1&recharge_time<=5))
                if Sidewinders:Exists() and (not Target:Debuff(HuntersMark) and (Player:Buff(MarkingTargets) or Player:Buff(Trueshot) or Sidewinders:Charges() == 2 or (Player:Focus() < 80 and (Sidewinders:Charges() <= 1  and Sidewinders:ReCharge() <=5)))) and Target:CanCast(Sidewinders) then
                    Target:Cast(Sidewinders);
                    return;
                end
            end


            -- actions+=/a_murder_of_crows
            if AMurderOfCrows:Exists() and module.IsOptionEnabled("A Murder Of Crows") and (module.CooldownsAllowed() or module.GetOptionValue("A Murder Of Crows") == "Always") and Target:CanCast(AMurderOfCrows) then
                Target:Cast(AMurderOfCrows);
                return;
            end
            -- actions+=/barrage
            if Barrage:Exists() and module.IsOptionEnabled("Barrage") and #BarrageEnemies >= module.GetOptionValue("Barrage") and Target:CanCast(Barrage) then
                Target:Cast(Barrage);
                return;
            end
            -- actions+=/piercing_shot,if=!talent.patient_sniper.enabled&focus>50
            if PiercingShot:Exists() and module.IsOptionEnabled("Piercing Shot") and #PiercingShotEnemies >= module.GetOptionValue("Piercing Shot") and not PatientSniper:Exists() and Player:Focus() > 50 and Target:CanCast(PiercingShot) then
                Target:Cast(PiercingShot);
                return;
            end
            -- actions+=/windburst
            if Windburst:Exists() and Target:CanCast(Windburst) then
                Target:Cast(Windburst);
                return;
            end


            -- actions+=/call_action_list,name=patientless,if=!talent.patient_sniper.enabled
            if not PatientSniper:Exists() then
                -- actions.patientless=arcane_shot,if=debuff.vulnerability.stack<3&buff.marking_targets.up&debuff.hunters_mark.down&spell_targets.arcane_shot=1
                if ArcaneShot:Exists() and not Sidewinders:Exists() and (Target:DebuffCount(Vulnerable) < 3 and Player:Buff(MarkingTargets) and not Target:Debuff(HuntersMark) and NumEnemies <= 1) and Target:CanCast(ArcaneShot) then
                    Target:Cast(ArcaneShot);
                    return;
                end
                -- actions.patientless+=/marked_shot,if=debuff.vulnerability.stack<3|debuff.hunters_mark.remains<5|(focus<50|focus>80)
                if MarkedShot:Exists() and (Target:DebuffCount(Vulnerable) < 3 or Target:DebuffRemains(HuntersMark) < 5 or (Player:Focus() < 50 or Player:Focus() > 80)) and Target:Debuff(HuntersMark) and Target:CanCast(MarkedShot) then
                    Target:Cast(MarkedShot);
                    return;
                end
                -- actions.patientless+=/sentinel,if=!talent.sidewinders.enabled&debuff.hunters_mark.down&spell_targets.sentinel>1
                if Sentinel:Exists() and not Sidewinders:Exists() and not Target:Debuff(HuntersMark) and NumEnemies > 1 and Target:CanCast(Sentinel) then
                    Target:Cast(Sentinel);
                    return;
                end
                -- actions.patientless+=/explosive_shot
                CastExplosiveShot();
                -- actions.patientless+=/aimed_shot,if=debuff.hunters_mark.down&cast_time<debuff.vulnerability.remains
                if AimedShot:Exists() and not Target:Debuff(HuntersMark) and AimedShot:CastTime() < Target:DebuffRemains(Vulnerable) and Target:CanCast(AimedShot) then
                    Target:Cast(AimedShot);
                    return;
                end
                -- actions.patientless+=/marked_shot,if=debuff.hunters_mark.remains>5
                if MarkedShot:Exists() and Target:DebuffRemains(HuntersMark) > 5 and Target:CanCast(MarkedShot) then
                    Target:Cast(MarkedShot);
                    return;
                end
                -- actions.patientless+=/black_arrow
                if BlackArrow:Exists() and Target:CanCast(BlackArrow) then
                    Target:Cast(BlackArrow);
                    return;
                end
                -- actions.patientless+=/multishot,if=spell_targets.multishot>1&(cast_regen+action.aimed_shot.cast_regen<=focus.deficit)
                if MultiShot:Exists() and not Sidewinders:Exists() and NumEnemies > 1 and Player:FocusRegen()*(Player:GCD() + AimedShot:CastTime()) <= Player:FocusDeficit() and Target:CanCast(MultiShot) then
                    Target:Cast(MultiShot);
                    return;
                end
                -- actions.patientless+=/arcane_shot,if=cast_regen+action.aimed_shot.cast_regen<=focus.deficit&spell_targets.arcane_shot=1
                if ArcaneShot:Exists() and not Sidewinders:Exists() and NumEnemies <= 1 and Player:FocusRegen()*(Player:GCD() + AimedShot:CastTime()) <= Player:FocusDeficit() and Target:CanCast(ArcaneShot) then
                    Target:Cast(ArcaneShot);
                    return;
                end
            end


            -- actions+=/arcane_shot,if=(talent.steady_focus.enabled&buff.steady_focus.down&focus.time_to_max>=2)|(talent.true_aim.enabled&(debuff.true_aim.stack<1&focus.time_to_max>=2|debuff.true_aim.remains<2))
            if ArcaneShot:Exists() and not Sidewinders:Exists() and ((SteadyFocus:Exists() and not Player:Buff(SteadyFocusBuff) and Player:FocusTimeToMax() >=2) or (TrueAim:Exists() and ((Target:DebuffCount(TrueAimDebuff) < 1 and Player:FocusTimeToMax() >= 2) or Target:DebuffRemains(TrueAimDebuff) < 2))) and Target:CanCast(ArcaneShot) then
                Target:Cast(ArcaneShot);
                return;
            end
            -- actions+=/multishot,if=(talent.steady_focus.enabled&buff.steady_focus.down&focus.time_to_max>=2&spell_targets.multishot>1)
            if MultiShot:Exists() and not Sidewinders:Exists() and (SteadyFocus:Exists() and not Player:Buff(SteadyFocusBuff) and Player:FocusTimeToMax() >=2) and NumEnemies > 1 and Target:CanCast(MultiShot) then
                Target:Cast(MultiShot);
                return;
            end
            -- actions+=/sidewinders,if=spell_targets.sidewinders>1&(!debuff.hunters_mark.up&(buff.marking_targets.up|buff.trueshot.up|charges=2|focus<80&(charges<=1&recharge_time<=5)))
            if Sidewinders:Exists() and NumEnemies > 1 and (not Target:Debuff(HuntersMark) and (Player:Buff(MarkingTargets) or Player:Buff(Trueshot) or Sidewinders:Charges() == 2 or (Player:Focus() < 80 and (Sidewinders:Charges() <= 1 and Sidewinders:Recharge() <= 5)))) and Target:CanCast(Sidewinders) then
                Target:Cast(Sidewinders);
                return;
            end
            -- actions+=/explosive_shot
            CastExplosiveShot();
            -- actions+=/piercing_shot,if=talent.patient_sniper.enabled&focus>80
            if PiercingShot:Exists() and module.IsOptionEnabled("Piercing Shot") and #PiercingShotEnemies >= module.GetOptionValue("Piercing Shot") and PatientSniper:Exists() and Player:Focus() > 80 and Target:CanCast(PiercingShot) then
                Target:Cast(PiercingShot);
                return;
            end
            -- actions+=/marked_shot,if=talent.sidewinders.enabled&(!talent.patient_sniper.enabled|debuff.vulnerability.remains<2)|!talent.sidewinders.enabled
            if MarkedShot:Exists() and ((Sidewinders:Exists() and (not PatientSniper:Exists() or Target:DebuffRemains(Vulnerable) < 2)) or not Sidewinders:Exists()) and Target:Debuff(HuntersMark) and Target:CanCast(MarkedShot) then
                Target:Cast(MarkedShot);
                return;
            end
            -- actions+=/aimed_shot,if=cast_time<debuff.vulnerability.remains&(focus+cast_regen>80|debuff.hunters_mark.down)
            if AimedShot:Exists() and (AimedShot:CastTime() < Target:DebuffRemains(Vulnerable) and (Player:Focus() + Player:FocusRegen()*AimedShot:CastTime() > 80 or not Target:Debuff(HuntersMark))) and Target:CanCast(AimedShot) then
                Target:Cast(AimedShot);
                return;
            end
            -- actions+=/black_arrow
            if BlackArrow:Exists() and Target:CanCast(BlackArrow) then
                Target:Cast(BlackArrow);
                return;
            end
            -- actions+=/multishot,if=spell_targets.multishot>1&(!debuff.hunters_mark.up&buff.marking_targets.up&cast_regen+action.aimed_shot.cast_regen<=focus.deficit)
            if MultiShot:Exists() and not Sidewinders:Exists() and NumEnemies > 1 and (not Target:Debuff(HuntersMark) and Player:Buff(MarkingTargets) and Player:FocusRegen()*(Player:GCD() + AimedShot:CastTime()) <= Player:FocusDeficit()) and Target:CanCast(MultiShot) then
                Target:Cast(MultiShot);
                return;
            end
            -- actions+=/arcane_shot,if=(!debuff.hunters_mark.up&buff.marking_targets.up)|focus.time_to_max>=2
            if ArcaneShot:Exists() and not Sidewinders:Exists() and ((not Target:Debuff(HuntersMark) and Player:Buff(MarkingTargets)) or Player:FocusTimeToMax() >= 2) and Target:CanCast(ArcaneShot) then
                Target:Cast(ArcaneShot);
                return;
            end
            -- actions+=/sidewinders,if=!debuff.hunters_mark.up&(buff.marking_targets.up|buff.trueshot.up|charges=2|focus<80&(charges<=1&recharge_time<=5))
            if Sidewinders:Exists() and (not Target:Debuff(HuntersMark) and (Player:Buff(MarkingTargets) or Player:Buff(Trueshot) or Sidewinders:Charges() == 2 or (Player:Focus() < 80 and (Sidewinders:Charges() <= 1 and Sidewinders:Recharge() <= 5)))) and Target:CanCast(Sidewinders) then
                Target:Cast(Sidewinders);
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        if not LoneWolf:Exists() then
            ManagePet();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Survival Hunter
    local Rotation = {};
    module.SetRotation("_"..255, Rotation);

    --- Localization
    -- Core
    local FrontUnits, ButcheryEnemies, NumEnemies = {}, 0, 1; -- Enemies
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local TriedToResurrectPet, TriedToSummonPet = 0, 0; -- Summon/Whistle Pet alternate
    local GCDMax, Focus, FocusRegen;
    local PlayerPet = module.PlayerPet;
    local PlayerPetTarget = module.Unit.PlayerPetTarget;


    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        -- Items
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);

        --Racials
        ArcaneTorrent = Spell(80483, false, false, true);
        RocketBarrage = Spell(69041, true, true, true);
        BloodFury = Spell(20572, false, false, true);
        Berserking = Spell(26297, false, false, true);
        GiftOfTheNaaru = Spell(59543, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        AMurderOfCrows = Spell(206505, false, true, true);
        AspectOfTheEagle = Spell(186289, false, false, true);
        AspectOfTheTurtle = Spell(186265, false, false, true);
        Butchery = Spell(212436, false, false, true);
        Carve = Spell(187708, false, false, true);
        DragonsfireGrenade = Spell(194855, true, true, true);
        Exhilaration = Spell(194291, false, false, true);
        ExplosiveTrap = Spell(191433, false, false, true);
        FeignDeath = Spell(5384, false, false, true);
        FlankingStrike = Spell(202800, true, true, true);
        FuryOfTheEagle = Spell(203415, false, false, true);
        Harpoon = Spell(190925, true, true, true); -- 5 + HitBox - 30
        HatchetToss = Spell(193265, true, true, true); -- 5 - 30
        Lacerate = Spell(185855, true, true, true);
        MendPet = Spell(982, false, false, true);
        MendPetBuff = Spell(136, false, false, true);
        MongooseBite = Spell(190928, true, true, true);
        MongooseFury = Spell(190931);
        Muzzle = Spell(187707, true, true, true);
        RangersNet = Spell(200108, true, true, true);
        RaptorStrike = Spell(186270, true, true, true);
        RangersNetSlow = Spell(206755);
        SerpentSting = Spell(87935);
        SerpentStingDebuff = Spell(118253);
        SnakeHunter = Spell(201078, false, false, true);
        SpittingCobra = Spell(194407, false, false, true);
        SteelTrap = Spell(162488, false, true, true);
        ThrowingAxes = Spell(200163, true, true ,true);
        WayOfTheMokNathalBuff = Spell(201081);
        WayOfTheMokNathal = Spell(201082);
        WingClip = Spell(195645, true, true, true);

        -- Pet Manager section
        CallPets = {Spell(883, false, false, true),
                    Spell(83242, false, false, true),
                    Spell(83243, false, false, true),
                    Spell(83244, false, false, true),
                    Spell(83245, false, false, true)}
        RevivePet = Spell(982, false, false, false);


        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        -- Add options to pages
        module.AddPresetOption("TargetAttack");
        module.AddPresetOption("ReTarget");
        module.AddPresetOption("BossCD");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Auto Summon/Revive Pet", 222, true, {3, 1, 25, 0.5}, {1, 1, 5, 1}, "Automatically Whistle/Revive your Pet."..C.TOOLTIP_VALUE_1.."How long would you like to wait before using Whistle when your pet is dismissed."..C.TOOLTIP_VALUE_2.."Which pet you would like to auto summon?");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Muzzle to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Only Arcane Torrent is supported."));
        end
        module.AddPresetOption("Trinket");
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "A Murder Of Crows", 230, true, {1, "Always", "With Cooldowns"}, nil, "Use A Murder of Crows."..C.TOOLTIP_VALUE.."Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Aspect Of The Eagle", 230, true, {1, "Always", "With Cooldowns"}, nil, "Use Aspect Of The Eagle."..C.TOOLTIP_VALUE.."Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Dragonsfire Grenade", 230, true, {1, "Always", "With Cooldowns"}, nil, "Use Dragonsfire Grenade."..C.TOOLTIP_VALUE.."Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Snake Hunter", 230, true, {1, "Always", "With Cooldowns"}, nil, "Use Snake Hunter."..C.TOOLTIP_VALUE.."Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Spitting Cobra", 230, true, {1, "Always", "With Cooldowns"}, nil, "Use Spitting Cobra."..C.TOOLTIP_VALUE.."Define if you want to always use the ability or only with cooldowns.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Explosive Trap", 220, true, {2, 1, 10, 1}, nil, "Use Explosive Trap."..C.TOOLTIP_VALUE.."Minimum amount of units to use.");
        module.AddNewOption("Offensive Settings", "Fury Of The Eagle", 220, true, {2, 1, 10, 1}, nil, "Use Fury Of The Eagle."..C.TOOLTIP_VALUE.."Minimum amount of units to use.");
        module.AddNewOption("Offensive Settings", "Hatchet Toss", 210, true, nil, nil, "Use Hatchet Toss while we are out of range.");
        module.AddNewOption("Offensive Settings", "Pet Damage Handling", 230, true, {1, "Handle Assist", "Do Not Handle Assist"}, nil, "Manage Pet."..C.TOOLTIP_VALUE_1.."Enable this to automatically change between assist and passive mode depending if you have a target or not.");
        module.AddNewOption("Offensive Settings", "Wing Clip | Ranger's Net", 210, false, nil, nil, "Maintain Wing Clip or Ranger's Net on our current target.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddPresetOption("HealingItem");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Mend Pet", 222, true, {35, 0, 100, 1}, {85, 0, 100, 1}, "Enable use of Mend Pet when pet health fall under threshold. \n\n|cFF0088FFValue 1:|r In combat threshold. \n\n|cFF0088FFValue 2:|r Out of combat threshold.");
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Auto Feign Death", 220, true, {10, 0, 100, 1}, nil, "Use Feign Death." .. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddNewOption("Defensive Settings", "Aspect Of The Turtle", 220, true, {35, 0, 100, 1}, nil, "Use Aspect Of The Turtle." .. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddNewOption("Defensive Settings", "Exhilaration", 220, true, {35, 0, 100, 1}, nil, "Use Exhilaration." .. C.TOOLTIP_VALUE .. "Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {35, 0, 100, 1}, nil, "Health Percentage to use Gift Of The Naaru on self");
        end

        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Buff(FeignDeath) then
            return;
        end

        -- Put the Outputs here that we wait to keep updated
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Exhilaration
        if Exhilaration:Exists() and module.IsOptionEnabled("Exhilaration") and Player:HealthPercentage() <= module.GetOptionValue("Exhilaration") and Player:CanCast(Exhilaration) then
            Player:Cast(Exhilaration);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
        -- Aspect of the Turtle
        if AspectOfTheTurtle:Exists() and module.IsOptionEnabled("Aspect Of The Turtle") and Player:HealthPercentage() <= module.GetOptionValue("Aspect Of The Turtle") and Player:CanCast(AspectOfTheTurtle) then
            Player:Cast(AspectOfTheTurtle);
            return;
        end
        -- Feign Death
        if FeignDeath:Exists() and module.IsOptionEnabled("Auto Feign Death") and Player:HealthPercentage() <= module.GetOptionValue("Auto Feign Death") and Player:CanCast(FeignDeath) then
            Player:Cast(FeignDeath);
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Muzzle, ArcaneTorrent);
    end

    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(MongooseBite, false) or Unit.Target;
    end

    -- Pet Manager
    local function ManagePet ()
        if module.IsOptionEnabled("Auto Summon/Revive Pet") and (InstantWhistle or module.PetDismissed + module.GetOptionValue("Auto Summon/Revive Pet") < module.GetTime()) then
            InstantWhistle = false;
            -- if whistle works, fine, otherwise blacklist it fro 5 second (usually should work fine with 1 attempt)
            if not PlayerPet:Exists() and module.GetTime() > TriedToSummonPet and Player:CanCast(CallPets[module.GetSecondOptionValue("Auto Summon/Revive Pet")]) then
                TriedToSummonPet = module.GetTime() + 5;
                Player:Cast(CallPets[module.GetSecondOptionValue("Auto Summon/Revive Pet")]);
                return;
            end
            -- if revive didnt work then we blacklist it 3 seconds (usually happens when user moves during resurrection cast)
            if not Player:IsMoving() and (not PlayerPet:Exists() or PlayerPet:IsDead()) and Player:CanCast(RevivePet) and module.GetTime() > TriedToResurrectPet then
                TriedToResurrectPet = module.GetTime() + 3;
                Player:Cast(MendPet);
                return;
            end
        end
        -- Mend Pet
        if PlayerPet:Exists() and module.IsOptionEnabled("Mend Pet") and Player:CanCast(MendPet) and not PlayerPet:Buff(MendPetBuff) and MendPet:TimeSinceCast() > 8 then
            if (Player:IsInCombat() and PlayerPet:HealthPercentage() <= module.GetOptionValue("Mend Pet")) or (not Player:IsInCombat() and PlayerPet:HealthPercentage() <= module.GetSecondOptionValue("Mend Pet")) then
                PlayerPet:Cast(MendPet);
                return;
            end
        end
    end

    -- Handling of Pet Actionbar Abilities
    local PetAssisting, PetForceAssistDelay = nil, 0;
    local function PlayerPetHandling ()
        -- Player Pet Handling
        if module.IsOptionEnabled("Pet Damage Handling") then
            if PlayerPet:Exists() then
                -- Assist/Passive Mode
                if module.GetOptionValue("Pet Damage Handling") == "Handle Assist" then
                    if Target:Exists() and not PetAssisting then
                        PetAssistMode();
                        RunMacroText("/petattack target");
                        PetAssisting = true;
                    elseif not Target:Exists() and PetAssisting then
                        PetPassiveMode();
                        PetAssisting = false;
                    end
                    if Target:Exists() and PetAssisting and PlayerPetTarget and PlayerPetTarget:GUID() ~= Target:GUID() and PetForceAssistDelay < module.GetTime() then
                        PetPassiveMode();
                        PetAssistMode();
                        RunMacroText("/petattack target");
                        PetForceAssistDelay = module.GetTime() + 2;
                    end
                end
            end
        end
    end

    -- Function to check if we can use Kill Command
    local function CanKillCommand ()
        return not module.KillFailTime or module.GetTime() > module.KillFailTime;
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        ManagePet();
        PlayerPetHandling();
        -- Common values for SimC Calculations
        GCDMax, Focus, FocusRegen = Player:GCD(), Player:Focus(), Player:FocusRegen();
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and Player:IsFacing(Target) then
            -- Enemies Check
            if module.UseAOE() and RefreshEnemies < module.GetTime() then
                FrontUnits = Player:UnitsInFrontCone(7, 180);
                ButcheryEnemies = Butchery:Exists() and #Player:EnemiesWithinDistance(7, true) or 0;
                NumEnemies = #FrontUnits;
                RefreshEnemies = module.GetTime() + 0.2;
            else
                FrontUnits, ButcheryEnemies, NumEnemies = {}, 0, 1;
            end
            -- Ranger's Net | Wing Clip
            if module.IsOptionEnabled("Wing Clip | Ranger's Net") then
                if RangersNet:Exists() then
                    if not Target:Debuff(RangersNet) and not Target:Debuff(RangersNetSlow) and Target:CanCast(RangersNet) then
                        Target:Cast(RangersNet);
                        return;
                    end
                else
                    if not Target:Debuff(WingClip) and Target:CanCast(WingClip) then
                        Target:Cast(WingClip);
                        return;
                    end
                end
            end
            -- Cooldowns
            if Player:IsWithinCastRange(Target, MongooseBite) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and Focus < 70 and Player:CanCast(ArcaneTorrent) then
                        Player:Cast(ArcaneTorrent);
                        return;
                    end
                end
            end
            -- actions+=/explosive_trap
            if ExplosiveTrap:Exists() and Player:Standing() > 0.5 and module.IsOptionEnabled("Explosive Trap") and NumEnemies >= module.GetOptionValue("Explosive Trap") and Player:CanCast(ExplosiveTrap) then
                Player:Cast(ExplosiveTrap);
                return;
            end
            -- actions+=/dragonsfire_grenade
            if DragonsfireGrenade:Exists() and module.IsOptionEnabled("Dragonsfire Grenade") and (module.CooldownsAllowed() or module.GetOptionValue("Dragonsfire Grenade") == "Always") and Target:CanCast(DragonsfireGrenade) then
                Target:Cast(DragonsfireGrenade);
                return;
            end
            -- actions+=/carve,if=talent.serpent_sting.enabled&active_enemies>=3&(!dot.serpent_sting.ticking|dot.serpent_sting.remains<=gcd.max)
            if Carve:Exists() and SerpentSting:Exists() and NumEnemies >= 3 and Target:DebuffRemains(SerpentStingDebuff) < GCDMax and Player:CanCast(Carve) then
                Player:Cast(Carve);
                return;
            end
            -- actions+=/raptor_strike,cycle_targets=1,if=talent.serpent_sting.enabled&active_enemies<=2&(!dot.serpent_sting.ticking|dot.serpent_sting.remains<=gcd.max)|talent.way_of_the_moknathal.enabled&(buff.moknathal_tactics.remains<gcd.max|buff.moknathal_tactics.down)
            if RaptorStrike:Exists() and ((SerpentSting:Exists() and NumEnemies <= 2 and Target:DebuffRemains(SerpentStingDebuff) < GCDMax) or (WayOfTheMokNathal:Exists() and Player:BuffRemains(WayOfTheMokNathalBuff) < GCDMax)) and Target:CanCast(RaptorStrike) then
                Target:Cast(RaptorStrike);
                return;
            end
            -- actions+=/aspect_of_the_eagle
            if AspectOfTheEagle:Exists() and module.IsOptionEnabled("Aspect Of The Eagle") and (module.CooldownsAllowed() or module.GetOptionValue("Aspect Of The Eagle") == "Always") and MongooseBite:Charges() < 3 and Player:Buff(MongooseFury) and Player:CanCast(AspectOfTheEagle) then
                Player:Cast(AspectOfTheEagle);
                return;
            end
            -- actions+=/fury_of_the_eagle,if=buff.mongoose_fury.up&buff.mongoose_fury.remains<=gcd.max*2
            if FuryOfTheEagle:Exists() and module.IsOptionEnabled("Fury Of The Eagle") and NumEnemies >= module.GetOptionValue("Fury Of The Eagle") and (Player:Buff(MongooseFury) and Player:BuffRemains(MongooseFury) <= GCDMax*2) and Player:CanCast(FuryOfTheEagle) then
                Player:Cast(FuryOfTheEagle);
                return;
            end
            -- actions+=/mongoose_bite,if=buff.mongoose_fury.up|cooldown.fury_of_the_eagle.remains<5|charges=3
            if MongooseBite:Exists() and (Player:Buff(MongooseFury) or (FuryOfTheEagle:Exists() and FuryOfTheEagle:Cooldown() < 5) or MongooseBite:Charges() == 3) and Target:CanCast(MongooseBite) then
                Target:Cast(MongooseBite);
                return;
            end
            -- actions+=/steel_trap
            if SteelTrap:Exists() and not Target:IsMoving() and Target:CanCast(SteelTrap) then
                Target:Cast(SteelTrap);
                return;
            end
            -- actions+=/a_murder_of_crows
            if AMurderOfCrows:Exists() and module.IsOptionEnabled("A Murder Of Crows") and (module.CooldownsAllowed() or module.GetOptionValue("A Murder Of Crows") == "Always") and Target:CanCast(AMurderOfCrows) then
                Target:Cast(AMurderOfCrows);
                return;
            end
            -- actions+=/lacerate,if=dot.lacerate.ticking&dot.lacerate.remains<=3|target.time_to_die>=5
            if Lacerate:Exists() and Target:DebuffRemains(Lacerate) <= 3 and Target:CanCast(Lacerate) then
                Target:Cast(Lacerate);
                return;
            end
            -- actions+=/snake_hunter,if=action.mongoose_bite.charges<=1&buff.mongoose_fury.remains>gcd.max*4
            if SnakeHunter:Exists() and module.IsOptionEnabled("Snake Hunter") and (module.CooldownsAllowed() or module.GetOptionValue("Snake Hunter") == "Always") and MongooseBite:Charges() <= 1 and Player:BuffRemains(MongooseFury) > GCDMax*4 and Player:CanCast(SnakeHunter) then
                Player:Cast(SnakeHunter);
                return;
            end
            -- actions+=/flanking_strike,if=talent.way_of_the_moknathal.enabled&(focus>=55&buff.moknathal_tactics.remains>=3)|focus>=55
            if FlankingStrike:Exists() and ((WayOfTheMokNathal:Exists() and (Focus >= 55 and Player:BuffRemains(WayOfTheMokNathalBuff) >= 3)) or Focus >= 55) and PlayerPet:Exists() and PlayerPetTarget:Exists() and not PlayerPet:IsDead() and CanKillCommand() and PlayerPet:DistanceTo(PlayerPetTarget) - PlayerPetTarget:CombatReach() < 20 and PlayerPetTarget:CanCast(FlankingStrike) then
                PlayerPetTarget:Cast(FlankingStrike);
                return;
            end
            -- actions+=/butchery,if=spell_targets.butchery>=2
            if Butchery:Exists() and ButcheryEnemies >= 2 and Player:CanCast(Butchery) then
                Player:Cast(Butchery);
                return;
            end
            -- actions+=/carve,if=spell_targets.carve>=4
            if Carve:Exists() and NumEnemies >= 4 and Player:CanCast(Carve) then
                Player:Cast(Carve);
                return;
            end
            -- actions+=/spitting_cobra
            if SpittingCobra:Exists() and module.IsOptionEnabled("Spitting Cobra") and (module.CooldownsAllowed() or module.GetOptionValue("Spitting Cobra") == "Always") and Player:CanCast(SpittingCobra) then
                Player:Cast(SpittingCobra);
                return;
            end
            -- actions+=/throwing_axes
            if ThrowingAxes:Exists() and Target:CanCast(ThrowingAxes) then
                Target:Cast(ThrowingAxes);
                return;
            end
            -- actions+=/raptor_strike,if=focus>75-cooldown.flanking_strike.remains*focus.regen
            if RaptorStrike:Exists() and Focus > 75-FlankingStrike:Cooldown()*FocusRegen and Target:CanCast(RaptorStrike) then
                Target:Cast(RaptorStrike);
                return;
            end
            -- Hatchet Toss - 5-30 Yards
            if HatchetToss:Exists() and module.IsOptionEnabled("Hatchet Toss") and Target:CanCast(HatchetToss) then
                if Player:DistanceTo(Target) >= 5 and Player:DistanceTo(Target) < 30 then
                    Target:Cast(HatchetToss);
                    return;
                end
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        ManagePet();
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Arcane Mage
    local Rotation = {};
    module.SetRotation("_"..62, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local ArcaneOrbUnits, Enemies_14y, TargetEnemies_10y, TargetEnemies_8y, NumEnemies = 0, {}, {}, {}, 0; -- Units
    local ShouldEvocation = nil; -- Evocation Managaement

    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicIntellect = Item(109218, false, false, true);
        DraenicIntellectBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);
        GiftOfTheNaaru = Spell(59548, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        ArcaneBarrage = Spell(44425, true, true, true);
        ArcaneBlast = Spell(30451, true, true, false);
        ArcaneExplosion = Spell(1449, false, false, true);
        ArcaneFamiliar = Spell(205022, false, false, true);
        ArcaneFamiliarBuff = Spell(210126);
        ArcaneMissiles = Spell(5143, true, true, false);
        ArcaneMissilesBuff = Spell(79683);
        ArcaneOrb = Spell(153626, false, false, true);
        ArcanePower = Spell(12042, false, false, true);
        ChargedUp = Spell(205032, false, false, true);
        ColdSnap = Spell(11958, false, false, true);
        Counterspell = Spell(2139, false, true, true);
        Evocation = Spell(12051, false, false, false);
        GreaterInvisibility = Spell(110959, false, false, true);
        GreaterInvisibilityBuff = Spell(110960);
        IceBarrier = Spell(11426, false, false, true);
        IceBlock = Spell(45438, false, false, true);
        IceFloes = Spell(108839, false, false, true);
        IncantersFlow = Spell(1463, false, false, false);
        IncantersFlowBuff = Spell(116267);
        IncantersFlowDirection = 0;
        MirrorImage = Spell(55342, false, false, true);
        NetherTempest = Spell(114923, false, true, true);
        Overpowered = Spell(155147);
        Polymorph = Spell(118, false, true, false);
        PresenceOfMind = Spell(205025, false, false, true);
        RuneOfPower = Spell(116011, false, false, false);
        RuneOfPowerBuff = Spell(116014);
        Supernova = Spell(157980, false, true, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {1, "Disabled", "Enabled"}, "|cffFF0044Target (Left Box)|r \nAutomatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode. \n|cFF0088FFClosest:|r Target the closest enemy. \n|cFF0088FFLeast HP:|r Target the enemy with the least health remaining. \n|cFF0088FFMost HP:|r Target the enemy with the most health remaining. \n|cFF0088FFTarget Closest:|r Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining. \n\n|cffFF0044Attack (Right Box)|r \nUse /startattack when you changes target. Good for melee classes.");
        module.AddOption("General Settings", "Cooldowns Only On Bosses", false, "Only cast CD's on boss targets.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddOption("General Settings", "Ice Floes", true);
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Counterspell to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Mirror Image", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Mirror Image."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Arcane Power", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Arcane Power."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Rune Of Power", 233, true, {2, "Always", "Cooldown Only"}, {2, "Anytime", "Before Arcane Power"}, "Use Rune Of Power."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Anytime", true).."Use Rune Of Power whenever it is ready."..C.TOOLTIP_SUBVALUE("Before Arcane Power", true).."Save one charge for Arcane Power. Use second charge after Evocation to take profit of full mana.");
        module.AddNewOption("Offensive Settings", "Presence Of Mind", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Presence Of Mind."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Arcane Explosion", 220, true, {5, 1, 10, 1}, nil, "Use Arcane Explosion."..C.TOOLTIP_VALUE.."Amount of units that needs to be within 8y around player to use.");
        module.AddNewOption("Offensive Settings", "Charged Up", 230, true, {1, "Always", "Not Out Of Combat", "Opener Only"}, nil, "Use Charged Up."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Use Charged Up when we have 0 Arcane Charges even when Out Of Combat."..C.TOOLTIP_SUBVALUE("Not Out Of Combat", true).."Only use Cahrged Up we are at 0 charges and are in Combat."..C.TOOLTIP_SUBVALUE("Opener Only", true).."Only use in the opener.");
        module.AddNewOption("Offensive Settings", "Evocation", 232, true, {1, "Anytime", "Not During Arcane Power"}, { 45, 10, 90, 1 }, "Use Evocation."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Anytime", true).."Use Evocation when we fall under threshold regardless of Arcane Power buff."..C.TOOLTIP_SUBVALUE("Not During Arcane Power", true).."Only use Evocation when Arcane Power ends, only if we are under the mana threshold."..C.TOOLTIP_VALUE_2.."Mana percentage to use Evocation.");
        module.AddNewOption("Offensive Settings", "Arcane Orb", 220, true, {1, 1, 10, 1}, nil, "Use Arcane Orb."..C.TOOLTIP_VALUE.."Amount of units that needs to be in 40y corridor in front of us to use.");
        module.AddNewOption("Offensive Settings", "Nether Tempest", 220, true, {1, 1, 10, 1}, nil, "Use Nether Tempest."..C.TOOLTIP_VALUE.."Amount of units that needs to be within 10y around our target to use.");
        module.AddNewOption("Offensive Settings", "Supernova", 220, true, {1, 1, 10, 1}, nil, "Use Supernova."..C.TOOLTIP_VALUE.."Amount of units that needs to be within 8y around our target to use.");


        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {40, 1, 100, 1}, nil, "Use Gift Of The Naaru on self."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Greater Invisibility", 220, true, {20, 1, 100, 1}, nil, "Use Greater Invisibility."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Ice Barrier", 220, true, {80, 1, 100, 1}, nil, "Use Ice Barrier."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Ice Block", 220, true, {30, 1, 100, 1}, nil, "Use Ice Block."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- Incanters Flow Tracker
        local Frame = CreateFrame('Frame');
        Frame:RegisterEvent("PLAYER_DAMAGE_DONE_MODS");
        local function IncantersFlowTracker (self, ...)
            IncantersFlowBuffCount = Player:BuffCount(IncantersFlowBuff);
            --module.Bug("Incanter's Flow: "..IncantersFlowBuffCount);
            if IncantersFlowBuffCount == 1 then
                IncantersFlowDirection = 1;
            elseif IncantersFlowBuffCount == 5 then
                IncantersFlowDirection = 2;
            end
        end
        Frame:SetScript("OnEvent", IncantersFlowTracker);
    end

    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Channeling(ArcaneMissiles) or (Player:Channeling(Evocation) and Player:PowerPercentage() < 95) then
            return;
        end

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end
        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        -- Charged Up
        if ChargedUp:Exists() and module.IsOptionEnabled("Charged Up") and Player:ArcaneCharges() ~= 4 and Player:CanCast(ChargedUp) then
            Player:Cast(ChargedUp);
        end
        -- Potion
        if module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + ArcaneBlast:CastTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) and Player:IsWithinCastRange(Target, ArcaneBlast) then
            if Player:Potion("Intellect", Potion) then module.Bug("Pre-Pull - Intellect Potion"); Potion = true; end
        end
        -- Mirror Images
        if MirrorImage:Exists() and BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + ArcaneBlast:CastTime() + Player:GCD() and module.IsOptionEnabled("Mirror Image") and (module.CooldownsAllowed() or module.GetOptionValue("Mirror Image") == "Always") and Player:CanCast(MirrorImage) then
            module.Bug("Mirror Image");
            Player:Cast(MirrorImage);
            return;
        end
        -- Rune Of Power
        if RuneOfPower:Exists() and BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + ArcaneBlast:CastTime() + RuneOfPower:CastTime() and module.IsOptionEnabled("Rune Of Power") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and Player:CanCast(RuneOfPower) then
            module.Bug("Rune of Power");
            Player:Cast(RuneOfPower);
            return;
        end
        -- Arcane Blast
        if ArcaneBlast:Exists() and BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + ArcaneBlast:CastTime() and Target:CanCast(ArcaneBlast) then
            module.Bug("Pre-Pull - Arcane Blast");
            Target:Cast(ArcaneBlast);
            return;
        end
        -- Ice Barrier
        if IceBarrier:Exists() and BMPullTime() > module.GetSecondOptionValue("Pre-Pull BossMod") + 3 and BMPullTime() < 5 and not Player:Buff(IceBarrier) and Player:CanCast(IceBarrier) then
            module.Bug("Pre-Pull - Ice Barrier");
            Player:Cast(IceBarrier);
            return;
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Counterspell, ArcaneTorrent);
    end


    function Rotation:OffGCDAbilities ()
        -- Ice floes if moving
        if module.IsOptionEnabled("Ice Floes") and IceFloes:Exists() and Player:IsMoving() and not Player:Buff(IceFloes) and Player:CanCast(IceFloes) and IceFloes:TimeSinceCast() > 1 then
            Player:Cast(IceFloes);
            IceFloes.LastCastTime = module.GetTime();
        end
        -- Charged Up
        if ChargedUp:Exists() and module.IsOptionEnabled("Charged Up") and not module.GetOptionValue("Charged Up") == "Opener Only" and Player:ArcaneCharges() == 0 and Player:CanCast(ChargedUp) then
            Player:Cast(ChargedUp);
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Ice Block
        if IceBlock:Exists() and module.IsOptionEnabled("Ice Block") and Player:HealthPercentage() <= module.GetOptionValue("Ice Block") and not Player:Buff(GreaterInvisibilityBuff) and Player:CanCast(IceBlock) then
            SpellStopCasting();
            Player:Cast(IceBlock);
            return;
        end
        -- Ice Barrier
        if IceBarrier:Exists() and module.IsOptionEnabled("Ice Barrier") and Player:HealthPercentage() <= module.GetOptionValue("Ice Barrier") and not Player:Buff(IceBarrier) and Player:CanCast(IceBarrier) then
            Player:Cast(IceBarrier);
            return;
        end
        -- Greater Invisibility
        if GreaterInvisibility:Exists() and module.IsOptionEnabled("Greater Invisibility") and Player:HealthPercentage() <= module.GetOptionValue("Greater Invisibility") and not Player:Buff(IceBlock) and Player:CanCast(GreaterInvisibility) then
            SpellStopCasting();
            Player:Cast(GreaterInvisibility);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    function Rotation:Combat ()
        local ArcaneCharges = Player:Casting(ArcaneBlast) and Player:ArcaneCharges() + 1 or Player:ArcaneCharges();
        -- Arcane Familiar
        if ArcaneFamiliar:Exists() and (not Player:Buff(ArcaneFamiliarBuff) or 3600 - (module.GetTime() - select(3,GetTotemInfo(4))) < 60) and Player:CanCast(ArcaneFamiliar) then
            Player:Cast(ArcaneFamiliar);
            return;
        end
        if Target:Exists() and Player:CanAttack(Target) then


            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                ArcaneOrbUnits = ArcaneOrb:Exists() and #Player:UnitsInFrontRectangle(40, 5) or 0; -- 40 Yards Corridor for Arcane Orb
                Enemies_14y = Player:EnemiesWithinDistance(14) or {}; -- 14 Yards for Arcane Explosion
                TargetEnemies_10y = Target:EnemiesWithinDistance(10); -- 10 yards for Nether Tempest
                TargetEnemies_8y = Target:FilterEnemiesByDistance(TargetEnemies_10y, 8, false);
                NumEnemies = #Enemies_14y;
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, ArcaneBlast) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Rune Of Power - Anytime
                if RuneOfPower:Exists() and module.IsOptionEnabled("Rune Of Power") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and module.GetSecondOptionValue("Rune Of Power") == "Anytime" and RuneOfPower:TimeSinceCast() >= 5 and not Player:Buff(RuneOfPowerBuff) and Player:Standing() >= 1 and Player:CanCast(RuneOfPower) then
                    module.Bug("Rune Of Power - Anytime");
                    Player:Cast(RuneOfPower);
                    RuneOfPower.LastCastTime = module.GetTime();
                    return;
                end
                -- Rune Of Power - After Evocation
                if RuneOfPower:Exists() and module.IsOptionEnabled("Rune Of Power") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and Evocation:TimeSinceCast() < 5 and RuneOfPower:TimeSinceCast() >= 5 and not Player:Buff(RuneOfPowerBuff) and Player:Standing() >= 1 and Player:CanCast(RuneOfPower) then
                    module.Bug("Rune Of Power - After Evocation");
                    Player:Cast(RuneOfPower);
                    RuneOfPower.LastCastTime = module.GetTime();
                    return;
                end
                -- Arcane Power
                if ArcanePower:Exists() and module.IsOptionEnabled("Arcane Power") and (module.CooldownsAllowed() or module.GetOptionValue("Arcane Power") == "Always") and ArcaneCharges >= 4 and Evocation:Cooldown() < 17 and Player:CanCast(ArcanePower) then
                    -- Rune Of Power
                    if RuneOfPower:Exists() and module.IsOptionEnabled("Rune Of Power") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and (module.GetSecondOptionValue("Rune Of Power") == "Before Arcane Power") and RuneOfPower:TimeSinceCast() >= 5 and not Player:Buff(RuneOfPowerBuff) and Player:Standing() >= 1 and Player:CanCast(RuneOfPower) then
                        module.Bug("Rune Of Power - Before Arcane Power");
                        Player:Cast(RuneOfPower);
                        RuneOfPower.LastCastTime = module.GetTime();
                        return;
                    end
                    ShouldEvocation = module.GetTime() + 16
                    Player:Cast(ArcanePower);
                    return;
                end
                -- Presence Of Mind
                if PresenceOfMind:Exists() and module.IsOptionEnabled("Presence Of Mind") and (module.CooldownsAllowed() or module.GetOptionValue("Presence Of Mind") == "Always") and Player:CanCast(PresenceOfMind) then
                    Player:Cast(PresenceOfMind);
                    return;
                end
                -- Mirror Images
                if MirrorImage:Exists() and module.IsOptionEnabled("Mirror Image") and (module.CooldownsAllowed() or module.GetOptionValue("Mirror Image") == "Always") and Player:CanCast(MirrorImage) then
                    Player:Cast(MirrorImage);
                    return;
                end
            end
            -- Evocation
            if Evocation:Exists() and ((Player:BuffRemains(ArcanePower) < ArcaneBlast:CastTime() and ShouldEvocation and ShouldEvocation < module.GetTime()) or Player:Power() < 35000) and Player:CanCast(Evocation) then
                ShouldEvocation = nil;
                Evocation.LastCastTime = module.GetTime();
                if Player:PowerPercentage() < 90 then
                    Player:Cast(Evocation);
                    return;
                end
            end

            -- Rotation
            -- Supernova
            if Supernova:Exists() and module.IsOptionEnabled("Supernova") and not Player:Buff(ArcanePower) and not Player:Buff(RuneOfPowerBuff) and #TargetEnemies_8y >= module.GetOptionValue("Supernova") and Target:CanCast(Supernova) then
                Target:Cast(Supernova);
                return;
            end
            -- Arcane Missiles - 4 Arcane Charges or 3 Arcane Missiles Buff
            if ArcaneMissiles:Exists() and (ArcaneCharges >= 4 or Player:BuffCount(ArcaneMissilesBuff) == 3) and Player:Buff(ArcaneMissilesBuff) and Target:CanCast(ArcaneMissiles) then
                Target:Cast(ArcaneMissiles);
                return;
            end
            -- Nether Tempest
            if NetherTempest:Exists() and module.IsOptionEnabled("Nether Tempest") and ArcaneCharges >= 4 and #TargetEnemies_10y >= module.GetOptionValue("Nether Tempest") and NetherTempest:TimeSinceCast() >= 10 and Target:CanCast(NetherTempest) then
                NetherTempest.LastCastTime = module.GetTime();
                Target:Cast(NetherTempest);
                return;
            end
            -- Arcane Barrage
            if ArcaneBarrage:Exists() and not ShouldEvocation and not Player:Buff(ArcanePower) and ArcaneCharges >= 4 and Player:PowerPercentage() < 90 and Target:CanCast(ArcaneBarrage) then
                Target:Cast(ArcaneBarrage);
                return;
            end
            -- Arcane Orb
            if ArcaneOrb:Exists() and module.IsOptionEnabled("Arcane Orb") and ArcaneOrbUnits >= module.GetOptionValue("Arcane Orb") and Player:CanCast(ArcaneOrb) then
                Player:Cast(ArcaneOrb);
                return;
            end
            -- Arcane Blast
            if ArcaneBlast:Exists() and Target:CanCast(ArcaneBlast) then
                Target:Cast(ArcaneBlast);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(ArcaneBlast, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        ShouldEvocation = nil;
        -- Arcane Familiar
        if ArcaneFamiliar:Exists() and (not Player:Buff(ArcaneFamiliarBuff) or 3600 - (module.GetTime() - select(3,GetTotemInfo(4))) < 60) and Player:CanCast(ArcaneFamiliar) then
            Player:Cast(ArcaneFamiliar);
            return;
        end
        -- Charged Up
        if ChargedUp:Exists() and module.IsOptionEnabled("Charged Up") and module.GetOptionValue("Charged Up") == "Always" and Player:ArcaneCharges() == 0 and Player:CanCast(ChargedUp) then
            Player:Cast(ChargedUp);
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Fire Mage
    local Rotation = {};
    module.SetRotation("_"..63, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local Enemies, NumEnemies, LivingBombUnits, CombustionUnits, PyroblastUnits, DragonsBreathUnits = {}, 0, 0, 0, 0, 0;
    local CombustPhase, PyroChain, MeteorBuff = false, false, nil;
    local IncantersFlowDirection, PyroblastOpened = 0, false;
    local CinderstormEnemies = {};

    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicIntellect = Item(109218, false, false, true);
        DraenicIntellectBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);
        GiftOfTheNaaru = Spell(59548, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        BlastWave = Spell(157981, false, true, true);
        Cinderstorm = Spell(198929, false, false, false);
        Combustion = Spell(190319, false, false, true);
        Counterspell = Spell(2139, false, true, true);
        DragonsBreath = Spell(31661, true, false, true);
        Fireball = Spell(133, true, true, false);
        FireStarter = Spell(205026);
        FlameOn = Spell(205029, false, false, true);
        Flamestrike = Spell(2120, false, true, false);
        FlamestrikeInstant = Spell(2120, false, true, true);
        Invisibility = Spell(66, false, false, true);
        HeatingUp = Spell(48107, false, true, true);
        HotStreak = Spell(48108);
        IceBarrier = Spell(11426, false, false, true);
        IceBlock = Spell(45438, false, false, true);
        IceFloes = Spell(108839, false, false, true);
        IncantersFlow = Spell(1463, false, false, false);
        IncantersFlowBuff = Spell(116267, false, false, false);
        FireBlast = Spell(108853, true, true, true);
        Kindling = Spell(155148, false, true, true);
        LivingBomb = Spell(44457, false, true, true);
        Meteor = Spell(153561, false, true, true);
        MirrorImage = Spell(55342, false, false, true);
        PhoenixsFlames = Spell(194466, true, true, true);
        Pyroblast = Spell(11366, true, true, false);
        PyroblastInstant = Spell(11366, true, true, true);
        RuneOfPower = Spell(116011, false, false, false);
        RuneOfPowerBuff = Spell(116014, false, false, true);
        Scorch = Spell(2948, true, true, true);
        UnstableMagic = Spell(157976, false, false, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, { 4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest" }, { 2, "Disabled", "Enabled" }, "|cffFF0044Target (Left Box)|r \nAutomatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode. \n|cFF0088FFClosest:|r Target the closest enemy. \n|cFF0088FFLeast HP:|r Target the enemy with the least health remaining. \n|cFF0088FFMost HP:|r Target the enemy with the most health remaining. \n|cFF0088FFTarget Closest:|r Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining. \n\n|cffFF0044Attack (Right Box)|r \nUse /startattack when you changes target. Good for melee classes.");
        module.AddOption("General Settings", "Cooldowns Only On Bosses", false, "Only cast CD's on boss targets.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddOption("General Settings", "Ice Floes", true);
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Counterspell to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Mirror Image", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Mirror Image."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Rune Of Power", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Rune Of Power."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Combustion", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Combustion."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Blast Wave", 220, true, {1, 1, 10, 1}, nil, "Use Blast Wave."..C.TOOLTIP_VALUE.."Define minimum number of units that needs to be in 8 yards around our target to use Blast Wave.");
        module.AddNewOption("Offensive Settings", "Cinderstorm", 222, true, {1, 1, 10, 1}, {1, 1, 10, 1}, "Use Cinderstorm."..C.TOOLTIP_VALUE_1.."Define minimum number of units that needs to be in front of you for Cinderstorm."..C.TOOLTIP_VALUE_2.."Define minimum number of units that needs to be in front of you for Cinderstorm when at optimal range (between 27 and 29 yard).");
        module.AddNewOption("Offensive Settings", "Dragon's Breath", 220, true, {1, 1, 10, 1}, nil, "Use Dragon's Breath."..C.TOOLTIP_VALUE.."Define minimum number of units that needs to be in 10 yards in front of us to use Dragon's Breath.");
        module.AddNewOption("Offensive Settings", "Fire Starter Other Units", 210, true, {1, 1, 10, 1}, nil, "Use Fireball on other units above 90% Health."..C.TOOLTIP_HINT("Requires Fire Starter talent."));
        module.AddNewOption("Offensive Settings", "Flamestrike", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {8, 1, 25, 1}, "Use Flamestrike."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Target").."Always use on the current target."..C.TOOLTIP_SUBVALUE("Target Standing").."Always use on the current target. Target must be standing still."..C.TOOLTIP_SUBVALUE("Centered").."Use centered on a cluster of enemies."..C.TOOLTIP_SUBVALUE("Centered Standing").."Use centered on a cluster of enemies. Enemies must be standing still."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Flamestrike Hot Streak", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {5, 1, 25, 1}, "Use Flamestrike."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Target").."Always use on the current target."..C.TOOLTIP_SUBVALUE("Target Standing").."Always use on the current target. Target must be standing still."..C.TOOLTIP_SUBVALUE("Centered").."Use centered on a cluster of enemies."..C.TOOLTIP_SUBVALUE("Centered Standing").."Use centered on a cluster of enemies. Enemies must be standing still."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Fire Blast", 210, true, nil, nil, "Use Fire Blast.");
        module.AddNewOption("Offensive Settings", "Living Bomb", 222, false, { 1, 1, 10, 1 }, {3, 0, 25, 0.1}, "Use Living Bomb."..C.TOOLTIP_VALUE_1.."Amount of enemies that must be in the spell effect to use."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Meteor", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {2, 1, 25, 1}, "Use Meteor."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Target").."Always use on the current target."..C.TOOLTIP_SUBVALUE("Target Standing").."Always use on the current target. Target must be standing still."..C.TOOLTIP_SUBVALUE("Centered").."Use centered on a cluster of enemies."..C.TOOLTIP_SUBVALUE("Centered Standing").."Use centered on a cluster of enemies. Enemies must be standing still."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Phoenix's Flames", 222, true, {2, 1, 3, 1}, {1, 1, 10, 1}, "Use Phoenix's Flames."..C.TOOLTIP_VALUE_1.."How many charges should we keep for AoE."..C.TOOLTIP_VALUE_2.."Define minimum number of units that needs to be in 8 yards around our target to use Phoenix's Flames."..C.TOOLTIP_HINT("If set to 3, we will only use it when there are enough units around the target. Best if set to 2 as the ability will be constantly recharging. Phoenix's Flames will also be used as high priority within Combustion to quickly build Hot Streak."));

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {40, 1, 100, 1}, nil, "Use Gift Of The Naaru on self."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Ice Barrier", 220, true, {80, 1, 100, 1}, nil, "Use Ice Barrier."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Ice Block", 220, true, {30, 1, 100, 1}, nil, "Use Ice Block."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Invisibility", 220, true, {20, 1, 100, 1}, nil, "Use Invisibility."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- Incanters Flow Tracker
        local Frame = CreateFrame('Frame');
        Frame:RegisterEvent("PLAYER_DAMAGE_DONE_MODS");
        local function IncantersFlowTracker (self, ...)
            IncantersFlowBuffCount = Player:BuffCount(IncantersFlowBuff);
            --module.Bug("Incanter's Flow: "..IncantersFlowBuffCount);
            if IncantersFlowBuffCount == 1 then
                IncantersFlowDirection = 1;
            elseif IncantersFlowBuffCount == 5 then
                IncantersFlowDirection = 2;
            end
        end
        Frame:SetScript("OnEvent", IncantersFlowTracker);

        module.AddOutput("Target Distance:");
        module.SetOutput("Target Distance:", "No Target");
    end

    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Colored Distance Status
        if Target:Exists() then
            local PlayerDistance = math.floor(Player:DistanceTo(Target)*10)/10;
            local TargetReach = Target:CombatReach() and Target:CombatReach() > 0 and Target:CombatReach() or 1;
            local SuitedDistance = 41.25/TargetReach < 27 and 41.25/TargetReach or 27;
            local DistanceColor = PlayerDistance > SuitedDistance and PlayerDistance < 29 and "|cff00FF00" or "|cffFF0000";
            module.SetOutput("Target Distance:", DistanceColor .. PlayerDistance .. "|r");
        else
            module.SetOutput("Target Distance:", "No Target");
        end

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end
        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        -- 2) Potion
        if module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + Pyroblast:CastTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) and Player:IsWithinCastRange(Target, Pyroblast) then
            if Player:Potion("Intellect", Potion) then module.Bug("Pre-Pull - Intellect Potion"); Potion = true; end
        end
        -- 4) Cooldowns
        if PyroblastOpened then
            -- Mirror Images
            if MirrorImage:Exists() and module.IsOptionEnabled("Mirror Image") and (module.CooldownsAllowed() or module.GetOptionValue("Mirror Image") == "Always") and Player:CanCast(MirrorImage) then
                module.Bug("Mirror Image");
                RuneOfPower.LastCastTime = module.GetTime();
                Player:Cast(MirrorImage);
                return;
            end
            -- Rune Of Power
            if RuneOfPower:Exists() and module.IsOptionEnabled("Rune Of Power") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and Player:CanCast(RuneOfPower) then
                module.Bug("Rune of Power");
                RuneOfPower.LastCastTime = module.GetTime();
                Player:Cast(RuneOfPower);
                return;
            end
        end
        -- 3) Pyroblast
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + Pyroblast:CastTime() and Target:CanCast(Pyroblast) then
            PyroblastOpened = true;
            module.Bug("Pre-Pull - Pyroblast");
            Target:Cast(Pyroblast);
            return;
        end
        -- 1) Ice Barrier
        if BMPullTime() > module.GetSecondOptionValue("Pre-Pull BossMod") + 1.5 and BMPullTime() < 7 and BMPullTime() > 6 and not Player:Buff(IceBarrier) and Player:CanCast(IceBarrier) then
            module.Bug("Pre-Pull - Ice Barrier");
            Player:Cast(IceBarrier);
            return;
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Counterspell, ArcaneTorrent);
    end


    function Rotation:OffGCDAbilities ()
        -- Pyroblast whenever we have Hot Streak during combustion
        if (Player:Casting(Fireball) or Player:Casting(Scorch)) and Player:Buff(HotStreak) and Player:Buff(Combustion) then
            SpellStopCasting();
            Target:Cast(PyroblastInstant);
            PyroblastInstant.LastCastTime = module.GetTime();
            return;
        end

        -- if not heating up and rune of power and time in combat is less than 5 seconds
        if Combustion:Exists() and module.IsOptionEnabled("Combustion") and (module.CooldownsAllowed() or module.GetOptionValue("Combustion") == "Always") and CombatTime() < 5 and (Player:Buff(RuneOfPowerBuff) or RuneOfPower:TimeSinceCast() < 2) and not Player:Buff(HeatingUp) and Player:CanCast(Combustion) then
            -- Cast Scorch
            if Scorch:Exists() and Target:CanCast(Scorch) then
                module.Bug("Scorch to get Heating Up");
                Target:Cast(Scorch);
                return;
            end
            -- Cast Combustion when Scorch is almost over
            if Combustion:Exists() and Player:Casting(Scorch) and Player:CastedPercent() >= 25 then
                module.Bug("Combutstion Scorch to get Heating Up");
                Player:Cast(Combustion);
            end
        end

        if not Player:Buff(Combustion) then
            -- Flame On - If no Fire Blast charges left
            if FlameOn:Exists() and FireBlast:Charges() == 0 and FireBlast:Recharge() >= 3 and Combustion:Cooldown() > 30 and Player:CanCast(FlameOn) then
                module.Bug("Flame On - Without Combustion.");
                Player:Cast(FlameOn);
                return;
            end
            -- FireBlast - If we are casting Fireball and we have Heating Up
            if FireBlast:Exists() and (Player:Casting(Fireball) or Player:Casting(Scorch))
                and ((Player:Buff(HeatingUp) and Player:CastedPercent() >= 75 and Player:CastedPercent() < 92) or CombatTime() < 1)
                and FireBlast:TimeSinceCast() > 1
                and (Combustion:Cooldown() > 25 or ((FireBlast:Charges() >= 1 and FireBlast:Recharge() < 1.5) or FireBlast:Charges() >= 2)) and Target:CanCast(FireBlast) then
                module.Bug("Fire Blast - Without Combustion.");
                Target:Cast(FireBlast);
                FireBlast.LastCastTime = module.GetTime();
                return;
            end
        else
            -- Flame On - If no Fire Blast charges left
            if FlameOn:Exists() and FireBlast:Charges() == 0 and Player:CanCast(FlameOn) then
                module.Bug("Flame On - With Combustion.");
                Player:Cast(FlameOn);
                return;
            end
            -- FireBlast - If we are casting Fireball and we have Heating Up
            if FireBlast:Exists() and Player:Buff(HeatingUp) and FireBlast:TimeSinceCast() > 0.5 and Target:CanCast(FireBlast) then
                module.Bug("Fire Blast - With Combustion.");
                Target:Cast(FireBlast);
                FireBlast.LastCastTime = module.GetTime();
                return;
            end
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Ice Block
        if IceBlock:Exists() and module.IsOptionEnabled("Ice Block") and Player:HealthPercentage() <= module.GetOptionValue("Ice Block") and not Player:Buff(Invisibility) and Player:CanCast(IceBlock) then
            SpellStopCasting();
            Player:Cast(IceBlock);
            return;
        end
        -- Ice Barrier
        if IceBarrier:Exists() and module.IsOptionEnabled("Ice Barrier") and Player:HealthPercentage() <= module.GetOptionValue("Ice Barrier") and not Player:Buff(IceBarrier) and Player:CanCast(IceBarrier) then
            Player:Cast(IceBarrier);
            return;
        end
        -- Greater Invisibility
        if Invisibility:Exists() and module.IsOptionEnabled("Invisibility") and Player:HealthPercentage() <= module.GetOptionValue("Invisibility") and not Player:Buff(IceBlock) and Player:CanCast(Invisibility) then
            SpellStopCasting();
            Player:Cast(Invisibility);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    function Rotation:Combat ()
        if Target:Exists() and Player:CanAttack(Target) then
            -- Ice floes if moving
            if module.IsOptionEnabled("Ice Floes") and IceFloes:Exists() and Player:IsMoving() and not Player:Buff(IceFloes) and Player:CanCast(IceFloes) and IceFloes:TimeSinceCast() > 1 then
                Player:Cast(IceFloes);
                IceFloes.LastCastTime = module.GetTime();
            end

            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                Enemies = FireStarter:Exists() and Player:EnemiesWithinDistance(40) or {}; -- 40 yards for Fire Starter.
                DragonsBreathUnits = #Player:UnitsInFrontCone(10, 140); -- Frontal Cone.
                CinderstormEnemies = #Player:UnitsInFrontRectangle(32, 5); -- Cinderstorm
                Enemies_10y = Target:EnemiesWithinDistance(10); -- 10 yards for Fire Blast.
                Enemies_8y = Target:FilterEnemiesByDistance(Enemies_10y, 8, true); -- Using 8 yards (real range) for Blast Wave.
                NumEnemies = #Enemies_10y;
                BlastWaveEnemies = #Enemies_8y;
                RefreshEnemies = module.GetTime() + 0.25;
            end
            -- Cooldowns
            if Player:IsWithinCastRange(Target, Fireball) and (Player:Moving() == 0 or RuneOfPower:Exists()) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Rune Of Power
                if RuneOfPower:Exists() and module.IsOptionEnabled("Rune Of Power") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and Player:Buff(HotStreak) and (RuneOfPower:Charges() >= 2 or (RuneOfPower:Charges() >= 1 and RuneOfPower:Recharge() < 10 and Combustion:Cooldown() > 12) or Combustion:Cooldown() < RuneOfPower:CastTime()) and RuneOfPower:TimeSinceCast() > 2 and Player:CanCast(RuneOfPower) and not Player:Buff(RuneOfPowerBuff) then
                    Player:Cast(RuneOfPower);
                    RuneOfPower.LastCastTime = module.GetTime();
                    return;
                end
                -- Mirror Images
                if MirrorImage:Exists() and module.IsOptionEnabled("Mirror Image") and (module.CooldownsAllowed() or module.GetOptionValue("Mirror Image") == "Always") and Player:Buff(HotStreak) and Combustion:Cooldown() < 2 and Player:CanCast(MirrorImage) then
                    Player:Cast(MirrorImage);
                    return;
                end
                -- Combustion
                if Combustion:Exists() and module.IsOptionEnabled("Combustion") and (module.CooldownsAllowed() or module.GetOptionValue("Combustion") == "Always") and Player:Buff(HotStreak) and Player:CanCast(Combustion) then
                    Player:Cast(Combustion);
                    return;
                end
            end

            -- Rotation
            -- Flamestrike - Hot Streak
            if FlamestrikeInstant:Exists() and Player:Buff(HotStreak) and module.IsOptionEnabled("Flamestrike Hot Streak") and Target:CanCast(FlamestrikeInstant) then
                if Target:CastGroundSpell(FlamestrikeInstant, "Flamestrike Hot Streak", 8) then return; end
            end
            -- Pyroblast - Hot Streak
            if PyroblastInstant:Exists() and Player:Buff(HotStreak) and ((PyroblastInstant:TimeSinceCast() > 2 and not PyroblastInstant:WasLastCast()) or Player:Buff(Combustion)) and Target:CanCast(PyroblastInstant) then
                Target:Cast(PyroblastInstant);
                PyroblastInstant.LastCastTime = module.GetTime();
                return;
            end
            -- Meteor
            if Meteor:Exists() and module.IsOptionEnabled("Meteor") and Target:CanCast(Meteor) then
                if Target:CastGroundSpell(Meteor, "Meteor", 8) then return; end
            end

            -- Wait for Pyro proc during combustion
            if PyroblastInstant:TimeSinceCast() < 1.25 and Player:Buff(Combustion) and FireBlast:Charges() >= 1 then return; end
            if Player:Buff(HeatingUp) and Player:Buff(Combustion) and FireBlast:Charges() >= 1 then return; end

            -- Phoenix Flames - Combustion
            if PhoenixsFlames:Exists() and module.IsOptionEnabled("Phoenix's Flames") and Player:Buff(Combustion) and Target:CanCast(PhoenixsFlames) then
                Target:Cast(PhoenixsFlames);
                return;
            end
            -- Scorch - Combustion
            if Scorch:Exists() and Player:BuffRemains(Combustion) > Scorch:CastTime() + Player:GCD() and Target:CanCast(Scorch, true) then
                Target:Cast(Scorch);
                return;
            end
            -- Fireball to get Heating Up
            if Fireball:Exists() and Player:Buff(Combustion) and not Player:IsMoving() and Target:CanCast(Fireball) then
                Target:Cast(Fireball);
                return;
            end

            -- Cinderstorm
            if Cinderstorm:Exists() and module.IsOptionEnabled("Cinderstorm") then
                local TargetReach = Target:CombatReach() and Target:CombatReach() > 0 and Target:CombatReach() or 1;
                local SuitedDistance = 41.25/TargetReach < 27 and 41.25/TargetReach or 27;
                if (Player:DistanceTo(Target) > SuitedDistance and Player:DistanceTo(Target) < 29) and CinderstormEnemies >= module.GetSecondOptionValue("Cinderstorm") and Player:CanCast(Cinderstorm) then
                    module.Bug("Cinderstorm - High Priority");
                    Player:Cast(Cinderstorm);
                    return;
                end
            end
            -- Living Bomb - With Units Count
            if LivingBomb:Exists() and module.IsOptionEnabled("Living Bomb") and #Enemies_10y >= module.GetOptionValue("Living Bomb") and Target:Health() >= module.GetSecondOptionValue("Living Bomb")*1000000 and Target:CanCast(LivingBomb) then
                Target:Cast(LivingBomb);
                return;
            end
            -- Blast Wave
            if BlastWave:Exists() and module.IsOptionEnabled("Blast Wave") and #Enemies_8y >= module.GetOptionValue("Blast Wave") and Target:CanCast(BlastWave) then
                Target:Cast(BlastWave);
                return;
            end
            -- Dragon's Breath
            if DragonsBreath:Exists() and module.IsOptionEnabled("Dragon's Breath") and DragonsBreathUnits >= module.GetOptionValue("Dragon's Breath") and Player:CanCast(DragonsBreath) then
                Player:Cast(DragonsBreath);
                return;
            end
            -- Flamestrike
            if Flamestrike:Exists() and module.IsOptionEnabled("Flamestrike") and Target:CanCast(Flamestrike) then
                if Target:CastGroundSpell(Flamestrike, "Flamestrike", 8) then return; end
            end
            -- Fire Starter Fireball Tweak
            if FireStarter:Exists() and module.IsOptionEnabled("Fire Starter Other Units") then
                -- Fireball on other target above 90% Health if our target is under 90%
                local BestFireballUnit = Target:HealthPercentage() < 90 and Unit.LightEnemyAvailableForSpellHP(Enemies, Fireball, 90, true) or nil;
                if BestFireballUnit and BestFireballUnit:CanCast(Fireball) then
                    module.Bug("Fireball Other Unit - With Fire Starter");
                    BestFireballUnit:Cast(Fireball);
                    return;
                end
            end
            -- Phoenix Flames
            if PhoenixsFlames:Exists() and module.IsOptionEnabled("Phoenix's Flames") and (PhoenixsFlames:Charges() >= module.GetOptionValue("Phoenix's Flames") or (PhoenixsFlames:Charges() >= module.GetOptionValue("Phoenix's Flames") and PhoenixsFlames:Recharge() < 3)) and #Enemies_8y >= module.GetSecondOptionValue("Phoenix's Flames") and not Player:Buff(HotStreak) and Target:CanCast(PhoenixsFlames) then
                Target:Cast(PhoenixsFlames);
                return;
            end
            -- Cinderstorm
            if Cinderstorm:Exists() and module.IsOptionEnabled("Cinderstorm") and CinderstormEnemies >= module.GetOptionValue("Cinderstorm") and Player:CanCast(Cinderstorm) then
                module.Bug("Cinderstorm - Low Priority");
                Player:Cast(Cinderstorm);
                return;
            end
            -- Fireball to get Heating Up
            if Fireball:Exists() and not Player:IsMoving() and Target:CanCast(Fireball) then
                Target:Cast(Fireball);
                return;
            end
            -- Scorch if we are moving
            if Scorch:Exists() and Target:CanCast(Scorch, true) then
                Target:Cast(Scorch);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Fireball, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        PyroblastOpened = false;
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Frost Mage
    local Rotation = {};
    module.SetRotation("_"..64, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local FrozenOrbCount, TargetEnemies_10y, TargetEnemies_8y, TargetEnemies_4y = 0, {}, {}, {}; -- Units

    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicIntellect = Item(109218, false, false, true);
        DraenicIntellectBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);
        GiftOfTheNaaru = Spell(59548, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        ArcticGale = Spell(205038);
        Blizzard = Spell(190356, false, true, false);
        BoneChilling = Spell(205027);
        BoneChillingBuff = Spell(205766);
        BrainFreeze = Spell(190446);
        ChainReaction = Spell(195418);
        ColdSnap = Spell(11958, false, false, true);
        CometStorm = Spell(153595, true, true, true);
        ConeOfCold = Spell(120, false, false, true);
        Counterspell = Spell(2139, false, true, true);
        Ebonbolt = Spell(214634, true, true, false);
        FingersOfFrost = Spell(44544);
        Flurry = Spell(44614, true, true, false);
        FlurryInstant = Spell(44614, true, true, true);
        Freeze = Spell(33395, false, true, true);
        Frostbolt = Spell(116, true, true, true);
        FrostBomb = Spell(112948, true, true, false);
        FrozenOrb = Spell(84714, false, false, true);
        FrozenTouch = Spell(205030, false, false, true);
        GlacialSpike = Spell(199786, true, true, false);
        IceBarrier = Spell(11426, false, false, true);
        IceBlock = Spell(45438, false, false, true);
        IceFloes = Spell(108839, false, false, true);
        IceLance = Spell(30455, true, true, true);
        IceNova = Spell(157997, true, true, true);
        Icicles = Spell(205473);
        IcyVeins = Spell(12472, false, false, true);
        Invisibility = Spell(66, false, false, true);
        InvisibilityBuff = Spell(32612);
        LonelyWinter = Spell(205024);
        MirrorImage = Spell(55342, false, false, true);
        Polymorph = Spell(118, false, true, false);
        RayOfFrost = Spell(205021, true, true, false);
        RuneOfPower = Spell(116011, false, false, false);
        RuneOfPowerBuff = Spell(116014);
        SpellSteal = Spell(30449, true, true, true);
        SummonWaterElemental = Spell(31687, false, false, false);
        ThermalVoid = Spell(155149);
        Waterbolt = Spell(31707, true, true, true);
        WaterJet = Spell(135029, true, true, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {1, "Disabled", "Enabled"}, "|cffFF0044Target (Left Box)|r \nAutomatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode. \n|cFF0088FFClosest:|r Target the closest enemy. \n|cFF0088FFLeast HP:|r Target the enemy with the least health remaining. \n|cFF0088FFMost HP:|r Target the enemy with the most health remaining. \n|cFF0088FFTarget Closest:|r Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining. \n\n|cffFF0044Attack (Right Box)|r \nUse /startattack when you changes target. Good for melee classes.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Ice Floes", 210, true, nil, nil, "");
        module.AddSection("General Settings", "Pet Options", "Green");
        module.AddNewOption("General Settings", "Auto Summon Elemental", 220, true, {3, 1, 25, 0.5}, nil, "Automatically Summon your Pet."..C.TOOLTIP_VALUE_1.."How long would you like to wait before using Summon when your Elemental is dismissed.");
        module.AddNewOption("General Settings", "Freeze", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {2, 1, 5, 1}, "Use Freeze." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use."..C.TOOLTIP_HINT("This ability uses the same cooldown as Water Jet. It should only be used for dungeons or questing.")..C.TOOLTIP_HINT("Pet Damage Handling must be checked."));
        module.AddNewOption("General Settings", "Pet Damage Handling", 233, true, {1, "Handle Assist", "Do Not Handle Assist"}, {1, "Handle Spells", "Do Not Handle Spells"}, "Manage Pet Casts."..C.TOOLTIP_VALUE_1.."Enable this to automatically change between assist and passive mode depending if you have a target or not."..C.TOOLTIP_VALUE_2.."Enable this to automatically disable spells the profile should be handling so that they are handled by the rotation."..C.TOOLTIP_HINT("Spells handling applies to Waterbolt(Enable Auto) and Water Jet(Disable Auto)."));
        module.AddNewOption("General Settings", "Water Jet", 210, false, nil, {1, 1, 10, 1}, "Use Water Jet while we are casting Frostbolt to get Fingers Of Frost buffs."..C.TOOLTIP_HINT("Pet Damage Handling must be checked."));
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Counterspell to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Icy Veins", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Icy Veins."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Frozen Touch", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Frozen Touch."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Mirror Image", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Mirror Image."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Rune Of Power", 233, true, {2, "Always", "Cooldown Only"}, {2, "Anytime", "Before Icy Veins"}, "Use Rune Of Power."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Anytime", true).."Use Rune Of Power whenever it is ready."..C.TOOLTIP_SUBVALUE("Before Icy Veins", true).."Save one charge for Icy Veins.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Blizzard", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {3, 1, 10, 1}, "Use Blizzard." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use."..C.TOOLTIP_HINT("Also used for Defile."));
        module.AddNewOption("Offensive Settings", "Comet Storm", 220, true, {1, 1, 10, 1}, nil, "Use Comet Storm."..C.TOOLTIP_VALUE.."Amount of units that needs to be within 4 yards of the target to use.");
        module.AddNewOption("Offensive Settings", "Frost Bomb", 220, true, {3, 1, 10, 1}, nil, "Use Frost Bomb."..C.TOOLTIP_VALUE.."Amount of units that needs to be within 10 yards of the target to use.");
        module.AddNewOption("Offensive Settings", "Frozen Orb", 220, true, {1, 1, 10, 1}, nil, "Use Frozen Orb."..C.TOOLTIP_VALUE.."Amount of units that needs to be in 40y corridor in front of us to use.");
        module.AddNewOption("Offensive Settings", "Ice Nova", 220, true, {3, 1, 10, 1}, nil, "Use Ice Nova."..C.TOOLTIP_VALUE.."Amount of units that needs to be within 8 yards of the target to use.");
        module.AddNewOption("Offensive Settings", "Ray Of Frost", 210, true, nil, nil, "Use Ray Of Frost.");


        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {40, 1, 100, 1}, nil, "Use Gift Of The Naaru on self."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Invisibility", 220, true, {20, 1, 100, 1}, nil, "Use Greater Invisibility."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Ice Barrier", 220, true, {80, 1, 100, 1}, nil, "Use Ice Barrier."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Ice Block", 220, true, {30, 1, 100, 1}, nil, "Use Ice Block."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- Incanters Flow Tracker
        IncantersFlow = Spell(1463, false, false, false);
        IncantersFlowBuff = Spell(116267);
        IncantersFlowDirection = 0;
        local Frame = CreateFrame('Frame');
        Frame:RegisterEvent("PLAYER_DAMAGE_DONE_MODS");
        local function IncantersFlowTracker (self, ...)
            IncantersFlowBuffCount = Player:BuffCount(IncantersFlowBuff);
            --module.Bug("Incanter's Flow: "..IncantersFlowBuffCount);
            if IncantersFlowBuffCount == 1 then
                IncantersFlowDirection = 1;
            elseif IncantersFlowBuffCount == 5 then
                IncantersFlowDirection = 2;
            end
        end
        Frame:SetScript("OnEvent", IncantersFlowTracker);

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [Blizzard:ID()] = "Blizzard",
            [FrostBomb:ID()] = "Frost Bomb",
            [GlacialSpike:ID()] = "Glacial Spike"
        };
    end

    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Channeling(RayOfFrost) then
            return;
        end

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end
        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and not Player:Casting(Frostbolt) and not Player:Casting(Ebonbolt) then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        -- Potion
        if module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + Frostbolt:CastTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) and Player:IsWithinCastRange(Target, Frostbolt) then
            if Player:Potion("Intellect", Potion) then module.Bug("Pre-Pull - Intellect Potion"); Potion = true; end
        end
        -- Mirror Images
        if MirrorImage:Exists() and BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + Frostbolt:CastTime() + Player:GCD() and module.IsOptionEnabled("Mirror Image") and (module.CooldownsAllowed() or module.GetOptionValue("Mirror Image") == "Always") and Player:CanCast(MirrorImage) then
            module.Bug("Mirror Image");
            Player:Cast(MirrorImage);
            return;
        end
        -- Rune Of Power
        if RuneOfPower:Exists() and BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + Frostbolt:CastTime() + RuneOfPower:CastTime() and module.IsOptionEnabled("Rune Of Power") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and Player:CanCast(RuneOfPower) then
            module.Bug("Rune of Power");
            Player:Cast(RuneOfPower);
            return;
        end
        -- WaterBolt
        if PlayerPet:Exists() and BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + WaterBolt:CastTime() and Target:PetCanCast(Waterbolt) then
            Target:Cast(Waterbolt);
            return;
        end
        -- Ebonbolt
        if Ebonbolt:Exists() and BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + Ebonbolt:CastTime() and Target:CanCast(Ebonbolt) and not Player:Casting(Ebonbolt) then
            module.Bug("Pre-Pull - Ebonbolt");
            Target:Cast(Ebonbolt);
            return;
        end
        -- Frostbolt
        if Frostbolt:Exists() and BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + Frostbolt:CastTime() and Target:CanCast(Frostbolt) and not Player:Casting(Frostbolt) then
            module.Bug("Pre-Pull - Frostbolt");
            Target:Cast(Frostbolt);
            return;
        end
        -- Ice Barrier
        if IceBarrier:Exists() and BMPullTime() > module.GetSecondOptionValue("Pre-Pull BossMod") + 3 and BMPullTime() < 5 and not Player:Buff(IceBarrier) and Player:CanCast(IceBarrier) then
            module.Bug("Pre-Pull - Ice Barrier");
            Player:Cast(IceBarrier);
            return;
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Counterspell, ArcaneTorrent);
    end


    -- Handling of Pet Actionbar Abilities
    local PetActionName, IsPetActionActive, PetActionID; -- Used to store GetPetActionInfo Data
    local WaterboltPosition, WaterJetPosition, ShouldFindAbilities = 5, 6, false; -- Used to prevent Cycling to find abilities when we can avoid it
    local function PlayerPetHandling ()
        if PlayerPet:Exists() then
            if module.IsOptionEnabled("Pet Damage Handling") then
                if module.GetSecondOptionValue("Pet Damage Handling") == "Handle Spells" then
                    -- Enable Waterbolt
                    PetActionName, _, _, _, _, _, IsPetActionActive, PetActionID = GetPetActionInfo(WaterboltPosition)
                    if PetActionID == 31707 and not IsPetActionActive then
                        EnableSpellAutocast(PetActionName);
                    else
                        ShouldFindAbilities = true;
                    end
                    -- Disable WaterJet
                    PetActionName, _, _, _, _, _, IsPetActionActive, PetActionID = GetPetActionInfo(WaterJetPosition)
                    if PetActionID == 135029 and IsPetActionActive then
                        DisableSpellAutocast(PetActionName);
                    else
                        ShouldFindAbilities = true;
                    end
                    -- If positions were not found, try to find these and store them
                    if ShouldFindAbilities == true then
                        for i = 1, 10 do
                            PetActionName, _, _, _, _, _, IsPetActionActive, PetActionID = GetPetActionInfo(i);
                            if PetActionID == 31707 and not IsPetActionActive then
                                WaterboltPosition = i;
                                EnableSpellAutocast(PetActionName);
                            end
                            if PetActionID == 135029 and IsPetActionActive then
                                WaterJetPosition = i;
                                DisableSpellAutocast(PetActionName);
                            end
                        end
                        ShouldFindAbilities = false;
                    end
                end
                -- Assist/Passive Mode
                if module.GetOptionValue("Pet Damage Handling") == "Handle Assist" then
                    if Target:Exists() and Player:CanAttack(Target) and not IsPetAttackActive() then
                        -- Enable Assist
                        PetAssistMode();
                    elseif (not Target:Exists() or not Player:CanAttack(Target)) and IsPetAttackActive() then
                        PetPassiveMode();
                    end
                end
                -- Profile Handled Abilities
                if Player:BuffCount(FingersOfFrost) < 2 then
                    -- Freeze
                    if module.IsOptionEnabled("Freeze") and Target:PetCanCast(Freeze) then
                        if Target:CastGroundSpell(Freeze, "Freeze", 10) then return; end
                    end
                    -- Water Jet
                    if module.IsOptionEnabled("Water Jet") and Target:PetCanCast(WaterJet) and Frostbolt:TimeSinceCast() > 1 and Frostbolt:TimeSinceCast() < 1.5 then
                        Target:Cast(WaterJet);
                    end
                end
            else
                -- Enable Waterbolt
                PetActionName, _, _, _, _, _, IsPetActionActive, PetActionID = GetPetActionInfo(WaterboltPosition)
                if PetActionID == 31707 and not IsPetActionActive then
                    EnableSpellAutocast(PetActionName);
                else
                    ShouldFindAbilities = true;
                end
                -- Enable WaterJet
                PetActionName, _, _, _, _, _, IsPetActionActive, PetActionID = GetPetActionInfo(WaterJetPosition)
                if PetActionID == 135029 and not IsPetActionActive then
                    EnableSpellAutocast(PetActionName);
                else
                    ShouldFindAbilities = true;
                end
                -- If positions were not found, try to find these and store them
                if ShouldFindAbilities == true then
                    for i = 1, 10 do
                        PetActionName, _, _, _, _, _, IsPetActionActive, PetActionID = GetPetActionInfo(i);
                        if PetActionID == 31707 and not IsPetActionActive then
                            WaterboltPosition = i;
                            EnableSpellAutocast(PetActionName);
                        end
                        if PetActionID == 135029 and not IsPetActionActive then
                            WaterJetPosition = i;
                            EnableSpellAutocast(PetActionName);
                        end
                    end
                    ShouldFindAbilities = false;
                end
            end
        end
    end

    function Rotation:OffGCDAbilities ()
        PlayerPetHandling();
        -- Ice floes if moving
        if module.IsOptionEnabled("Ice Floes") and IceFloes:Exists() and Player:IsMoving() and not Player:Buff(IceFloes) and Player:CanCast(IceFloes) and IceFloes:TimeSinceCast() > 1 then
            Player:Cast(IceFloes);
            IceFloes.LastCastTime = module.GetTime();
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Ice Block
        if IceBlock:Exists() and module.IsOptionEnabled("Ice Block") and Player:HealthPercentage() <= module.GetOptionValue("Ice Block") and not Player:Buff(IceBlock) and not Player:Buff(InvisibilityBuff) and not Player:Buff(Invisibility) and Player:CanCast(IceBlock) then
            SpellStopCasting();
            Player:Cast(IceBlock);
            return;
        end
        -- Ice Barrier
        if IceBarrier:Exists() and module.IsOptionEnabled("Ice Barrier") and Player:HealthPercentage() <= module.GetOptionValue("Ice Barrier") and not Player:Buff(IceBarrier) and Player:CanCast(IceBarrier) then
            Player:Cast(IceBarrier);
            return;
        end
        -- Greater Invisibility
        if Invisibility:Exists() and module.IsOptionEnabled("Invisibility") and Player:HealthPercentage() <= module.GetOptionValue("Invisibility") and not Player:Buff(IceBlock) and Player:CanCast(Invisibility) then
            SpellStopCasting();
            Player:Cast(Invisibility);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    -- Frost Bolt + Ice Floes Handling
    local function FrostboltHandler ()
        if IceFloes:Exists() and Player:IsMoving() and not Player:Buff(IceFloes) and Player:CanCast(IceFloes) then
            Player:Cast(IceFloes);
            return;
        end
        if (not Player:IsMoving() or Player:Buff(IceFloes)) and Target:CanCast(Frostbolt) then
            Frostbolt.LastCastTime = module.GetTime();
            Target:Cast(Frostbolt);
            return;
        end
    end

    -- Frost Bomb
    local function FrostBombHandler ()
        if FrostBomb:Exists() and module.IsOptionEnabled("Frost Bomb") and #TargetEnemies_10y >= module.GetOptionValue("Frost Bomb") and not Target:Debuff(FrostBomb) and Target:CanCast(FrostBomb) then
            Target:Cast(FrostBomb);
            return;
        end
    end

    -- Pet Manager
    local function ManagePet ()
        if module.IsOptionEnabled("Auto Summon Elemental") and not LonelyWinter:Exists() and not PlayerPet:Exists() and module.PetDismissed + module.GetOptionValue("Auto Summon Elemental") < module.GetTime() and Player:CanCast(SummonWaterElemental) then
            Player:Cast(SummonWaterElemental);
            return;
        end
    end

    function Rotation:Combat ()
        ManagePet();
        if Target:Exists() and Player:CanAttack(Target) then

            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                FrozenOrbCount = FrozenOrb:Exists() and #Player:UnitsInFrontRectangle(40, 5) or 0; -- 40 Yards Corridor for Frozen Orb
                TargetEnemies_10y = Target:EnemiesWithinDistance(10, false); -- Frost Bomb
                TargetEnemies_8y = Target:FilterEnemiesByDistance(TargetEnemies_10y, 8, false); -- Ice Nova
                TargetEnemies_4y = Target:FilterEnemiesByDistance(TargetEnemies_8y, 4, false); -- Comet Storm
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, Frostbolt) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Icy Veins Handling
                IcyVeinsSoon = IcyVeins:Exists() and module.IsOptionEnabled("Icy Veins") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and Player:Standing() > 1 and IcyVeins:IsOnCooldown() and IcyVeins:Cooldown() < 30;
                ShouldRayOfFrost = RayOfFrost:Exists() and module.IsOptionEnabled("Ray Of Frost") and not IcyVeinsSoon and Player:Standing() >= 1 and Target:CanCast(RayOfFrost);
                ShouldIcyVeins = IcyVeins:Exists() and module.IsOptionEnabled("Icy Veins") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and Player:Standing() > 1 and (not RayOfFrost:Exists() or not module.IsOptionEnabled("Ray Of Frost") or ShouldRayOfFrost) and Player:CanCast(IcyVeins);
                -- Rune Of Power - Anytime
                if RuneOfPower:Exists() and module.IsOptionEnabled("Rune Of Power") and (module.CooldownsAllowed() or module.GetOptionValue("Rune Of Power") == "Always") and RuneOfPower:TimeSinceCast() >= 5 and not Player:Buff(RuneOfPowerBuff) and Player:Standing() >= 1 and Player:CanCast(RuneOfPower) then
                    if RuneOfPower:Charges() == 2 or ShouldRayOfFrost or ShouldIcyVeins or module.GetSecondOptionValue("Rune Of Power") == "Anytime" then
                        Player:Cast(RuneOfPower);
                        RuneOfPower.LastCastTime = module.GetTime();
                        return;
                    end
                end
                -- Icy Veins
                if ShouldIcyVeins then
                    Player:Cast(IcyVeins);
                    return;
                end
                -- Mirror Images
                if MirrorImage:Exists() and module.IsOptionEnabled("Mirror Image") and (module.CooldownsAllowed() or module.GetOptionValue("Mirror Image") == "Always") and Player:CanCast(MirrorImage) then
                    Player:Cast(MirrorImage);
                    return;
                end
            end
            -- Rotation
            -- Thermal Void - Ice Lances
            if ThermalVoid:Exists() and Player:Buff(IcyVeins) and Player:BuffRemains(IcyVeins) < 5 and Player:Buff(FingersOfFrost) and Target:CanCast(IceLance) then
                Target:Cast(IceLance);
                return;
            end
            -- Frostbolt - With Water Jet
            if Frostbolt:Exists() and module.WaterJetChanneling > module.GetTime() + Frostbolt:CastTime() and Player:BuffCount(FingersOfFrost) < 3 and Target:CanCast(Frostbolt) then
                FrostboltHandler();
            end
            -- GlacialSpike
            if GlacialSpike:Exists() and Target:CanCast(GlacialSpike) then
                Target:Cast(GlacialSpike);
                return;
            end
            -- Comet Storm
            if CometStorm:Exists() and module.IsOptionEnabled("Comet Storm") and #TargetEnemies_4y >= module.GetOptionValue("Comet Storm") and Target:CanCast(CometStorm) then
                Target:Cast(CometStorm);
                return;
            end
            -- Ice Nova
            if IceNova:Exists() and module.IsOptionEnabled("Ice Nova") and #TargetEnemies_8y >= module.GetOptionValue("Ice Nova") and Target:CanCast(IceNova) then
                Target:Cast(IceNova);
                return;
            end
            -- Frozen Orb
            if FrozenOrb:Exists() and FrozenOrbCount >= module.GetOptionValue("Frozen Orb") and Player:CanCast(FrozenOrb) then
                Player:Cast(FrozenOrb);
                return;
            end
            -- Blizzard - Arctic Gale
            if ArcticGale:Exists() and Blizzard:Exists() and module.IsOptionEnabled("Blizzard") and Target:CanCast(Blizzard) then
                if Target:CastGroundSpell(Blizzard, "Blizzard", 12) then return; end
            end
            -- Frostbolt - Bone Chilling
            if BoneChilling:Exists() and Player:Buff(BoneChillingBuff) and Player:BuffRemains(BoneChillingBuff) < 4 and Target:CanCast(Frostbolt) then
                FrostboltHandler();
            end
            -- Ice Lance
            if IceLance:Exists() and Player:Buff(FingersOfFrost) and (Player:Buff(ChainReaction) or Player:BuffCount(FingersOfFrost) > 2 or Player:BuffRemains(FingersOfFrost) < 5) and Target:CanCast(IceLance) then
                FrostBombHandler();
                Target:Cast(IceLance);
                return;
            end
            -- Ice Lance - Before Water Jet
            if IceLance:Exists() and PlayerPet:Exists() and Player:BuffCount(FingersOfFrost) >= 1 and ((PlayerPet:Exists() and WaterJet:Cooldown() < 3) or (RayOfFrost:Exists() and RayOfFrost:Cooldown() < 3) or (FrozenOrbCount >= module.GetOptionValue("Frozen Orb") and FrozenOrb:Cooldown() < 3) or Ebonbolt:Cooldown() < 3) and Target:CanCast(IceLance) then
                FrostBombHandler();
                Target:Cast(IceLance);
                return;
            end
            -- Flurry
            if Flurry:Exists() and Player:Buff(BrainFreeze) and Target:CanCast(FlurryInstant) then
                Target:Cast(FlurryInstant);
                return;
            end
            -- Ebonbolt
            if Ebonbolt:Exists() and Target:CanCast(Ebonbolt) then
                Target:Cast(Ebonbolt);
                return;
            end
            -- Frozen Touch
            if Player:IsWithinCastRange(Target, Frostbolt) and FrozenTouch:Exists() and module.IsOptionEnabled("Frozen Touch") and (module.CooldownsAllowed() or module.GetOptionValue("Frozen Touch") == "Always") and Player:BuffCount(FingersOfFrost) <= 1 and Player:CanCast(FrozenTouch) then
                Player:Cast(FrozenTouch);
                return;
            end
            -- Ray Of Frost
            if not Player:IsMoving() and ShouldRayOfFrost then
                Target:Cast(RayOfFrost);
                return;
            end
            -- Blizzard
            if Blizzard:Exists() and module.IsOptionEnabled("Blizzard") and Target:CanCast(Blizzard) then
                if Target:CastGroundSpell(Blizzard, "Blizzard", 10) then return; end
            end
            -- Frostbolt
            if Frostbolt:Exists() and Target:CanCast(Frostbolt) then
                FrostboltHandler();
            end
            -- Ice Lance Filler
            if IceLance:Exists() and Target:CanCast(IceLance) then
                FrostBombHandler();
                Target:Cast(IceLance);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Frostbolt, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        ManagePet();
        PlayerPetHandling();
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Brewmaster Monk
    local Rotation = {};
    module.SetRotation("_"..268, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local Enemies_30y, Enemies_8y, BreathOfFireUnits, ChiBurstUnits, NumEnemies = {}, {}, 0, 0, 0; -- Enemies

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        --Racials
        ArcaneTorrent = Spell(69179, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, resurrect)
        BlackoutCombo = Spell(196736);
        BlackoutComboBuff = Spell(228563);
        BlackoutStrike = Spell(205523, true, true, true);
        BlackOxBrew = Spell(115399, false, false, true);
        BreathOfFire = Spell(115181, false, false, true);
        ChiBurst = Spell(123986, false, false, true);
        ChiWave = Spell(115098, true, true, true);
        CracklingJadeLightning = Spell(117952, true, true, false);
        DampenHarm = Spell(122278, false, false, true);
        Detox = Spell(218164, false, false, true);
        DiffuseMagic = Spell(122783, false, false, true);
        Effuse = Spell(116694, false, false, false);
        FlamingKeg = Spell(214326, false, true, true);
        FortifyingBrew = Spell(115203, false, false, true);
        InvokeNiuzao = Spell(132578, true, true, true);
        IronskinBrew = Spell(115308, false, false, true);
        HealingElixir = Spell(122281, false, false, true);
        KegSmash = Spell(121253, true, true, true);
        LightBrewing = Spell(196721, false, false, true);
        Paralysis = Spell(115078, false, true, true);
        Provoke = Spell(115546, false, true, true);
        PurifyingBrew = Spell(119582, false, false, true);
        Resuscitate = Spell(115178, false, false, false, true);
        RushingJadeWind = Spell(116847, false, false, true);
        SpearHandStrike = Spell(116705, true, true, true);
        TigerPalm = Spell(100780, true, true, true);
        ZenMeditation = Spell(115176, false, false, false);

        -- Staggering Debuffs
        HeavyStagger = Spell(124273, false, false, true);
        LightStagger = Spell(124275, false, false, true);
        ModerateStagger = Spell(124274, false, false, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {6, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest", "Untanked"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_SUBVALUE("Untanked").."Integrate tanking logic that will priorise the untaked units."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.TauntManagerOptions("Provoke");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddOption("General Settings", "Resuscitate", true, "Resurrect dead allies with Resuscitate while Out of Combat.");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Pummel to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Invoke Niuzao", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Invoke Niuzao."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Blackout Combo", 130, true, {1, "Breath of Fire", "Tiger Palm"}, nil, "Handle Blackout Combo priority."..C.TOOLTIP_VALUE.."Spell to use with Blackout Combo.");
        module.AddNewOption("Offensive Settings", "Breath Of Fire", 220, true, {1, 1, 10, 1}, nil, "Use Breath Of Fire."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range to use.");
        module.AddNewOption("Offensive Settings", "Chi Burst", 220, true, {1, 1, 10, 1}, nil, "Use Chi Burst."..C.TOOLTIP_VALUE.."Amount of units that needs to be in the effect zone to use.");
        module.AddNewOption("Offensive Settings", "Flaming Keg", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {4, 1, 20, 1}, "Use Flaming Keg." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Rushing Jade Wind", 220, true, {2, 1, 10, 1}, nil, "Use Rushing Jade Wind."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range to use.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Purifying Brew", 232, true, {2, "Normal", "Purifying If Capping", "Inronskin If Capping"}, {25, 1, 100, 1}, "Use Purifying Brew."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Normal", true).."Only use when health stagger is high enough."..C.TOOLTIP_SUBVALUE("Purifying If Capping", true).."Use Purifying Brew automatically as soon as we have stagger when we are at max charges."..C.TOOLTIP_SUBVALUE("Ironskin If Capping", true).."Use Ironskin Brew automatically as soon as we have stagger when we are at max charges."..C.TOOLTIP_VALUE_2.."Stagger Percent Before Using Purifying Brew."..C.TOOLTIP_HINT((Player:MaxHealth()/100).." damage taken per second per percent."));
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Dampen Harm", 220, true, {30, 1, 100, 1}, nil, "Use Dampen Harm."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Diffuse Magic", 220, true, {30, 1, 100, 1}, nil, "Use Diffuse Magic."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Fortifying Brew", 220, true, {20, 1, 100, 1}, nil, "Use Fortifying Brew."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Healing Elixir", 220, true, {50, 1, 100, 1}, nil, "Use one charge of Healing Elixir."..C.TOOLTIP_VALUE.."Health threshold."..C.TOOLTIP_HINT("Second charge will always be kept and will be used automatically when your health fall under 35%."));

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pot BossMod") and Target:Exists() and BMPullTime() < 7 then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(SpearHandStrike, ArcaneTorrent);
    end


    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Purrifying Brew
        if PurifyingBrew:Exists() and module.IsOptionEnabled("Purifying Brew") and Player:CanCast(PurifyingBrew) then
            if Player:Debuff(HeavyStagger) and module.GetNumbersForDebuff(Player, HeavyStagger)[1]/Player:MaxHealth() *100 >= module.GetSecondOptionValue("Purifying Brew") then
                Player:Cast(PurifyingBrew);
            end
            if Player:Debuff(ModerateStagger) and module.GetNumbersForDebuff(Player, ModerateStagger)[1]/Player:MaxHealth() *100 >= module.GetSecondOptionValue("Purifying Brew") then
                Player:Cast(PurifyingBrew);
            end
            if Player:Debuff(LightStagger) and module.GetNumbersForDebuff(Player, LightStagger)[1]/Player:MaxHealth() *100 >= module.GetSecondOptionValue("Purifying Brew") then
                Player:Cast(PurifyingBrew);
            end
            if module.GetOptionValue("Purifying Brew") ~= "Normal" and (Player:Debuff(HeavyStagger) or Player:Debuff(ModerateStagger) or Player:Debuff(LightStagger)) then
                local MaxCharges, ChoosedSpell = LightBrewing:Exists() and 4 or 3, module.GetOptionValue("Purifying Brew") == "Purifying If Capping" and PurifyingBrew or IronskinBrew;
                if PurifyingBrew:Charges() == MaxCharges or (PurifyingBrew:Charges() == MaxCharges - 1 and PurifyingBrew:Recharge() < 3) then
                    Player:Cast(PurifyingBrew)
                end
            end
        end
        -- Defensive Items
        Player:UseHealingItem();
        -- Healing Elixir
        if HealingElixir:Exists() and HealingElixir:Charges() == 2 and module.IsOptionEnabled("Healing Elixir") and Player:HealthPercentage() <= module.GetOptionValue("Healing Elixir") and HealingElixir:TimeSinceCast() > 2 and Player:CanCast(HealingElixir) then
            Player:Cast(HealingElixir);
            HealingElixir.LastCastTime = module.GetTime();
        end
        -- Diffuse Magic
        if DiffuseMagic:Exists() and module.IsOptionEnabled("Diffuse Magic") and Player:HealthPercentage() <= module.GetOptionValue("Diffuse Magic") and Player:CanCast(DiffuseMagic) then
            Player:Cast(DiffuseMagic);
        end
        -- Dampen Harm
        if DampenHarm:Exists() and module.IsOptionEnabled("Dampen Harm") and Player:HealthPercentage() <= module.GetOptionValue("Dampen Harm") and Player:CanCast(DampenHarm) then
            Player:Cast(DampenHarm);
        end
        -- Fortifying Brew
        if FortifyingBrew:Exists() and module.IsOptionEnabled("Fortifying Brew") and Player:HealthPercentage() <= module.GetOptionValue("Fortifying Brew") and Player:CanCast(FortifyingBrew) then
            Player:Cast(FortifyingBrew);
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end


    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(TigerPalm, false) or Unit.Target;
    end

    function Rotation:Opening ()
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") then
            if Player:Potion("Armor", Potion) then Potion = true; end
        end
    end

    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then

            -- Enemies Check
            if module.UseAOE() then
                ChiBurstUnits = ChiBurst:Exists() and #Player:UnitsInFrontRectangle(40, 5) or 0;
                BreathOfFireUnits = #Player:UnitsInFrontCone(10, 140); -- Frontal Cone.
                Enemies_30y = Player:EnemiesWithinDistance(30, false);
                Enemies_8y = Player:FilterEnemiesByDistance(Enemies_30y, 8, true);
                NumEnemies = #Enemies_8y;
            else
                NumEnemies, ChiBurstEnemies, BreathOfFireUnits = 1, 0, 0;
            end

            -- Provoke
            if Player:TauntManager(Provoke, "Provoke", Target, Enemies_30y, PlayerPet) then
                return;
            end

            if Player:IsWithinCastRange(Target, TigerPalm) then
                --- Cooldowns ---
                if module.CooldownsAllowed() then
                    Player:UseTrinkets();
                    -- Racials
                    if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                        -- Blood Fury
                        if BloodFury:Exists() and Player:CanCast(BloodFury) then
                            Player:Cast(BloodFury);
                        end
                        -- Berserking
                        if Berserking:Exists() and Player:CanCast(Berserking) then
                            CastSpellByID(26297, "player")
                        end
                        -- Arcane Torrent
                        if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Energy() < 60 then
                            Player:Cast(ArcaneTorrent);
                        end
                    end
                end
                -- Invoke Niuzao
                if InvokeNiuzao:Exists() and module.IsOptionEnabled("Invoke Niuzao") and (module.CooldownsAllowed() or module.GetOptionValue("Invoke Niuzao") == "Always") and Target:CanCast(InvokeNiuzao) then
                    Target:Cast(InvokeNiuzao);
                    return;
                end
            end

            -- Rotation
            -- Keg Smash
            if KegSmash:Exists() and Player:DistanceTo(Target) < 20 and Target:CanCast(KegSmash) then
                Target:Cast(KegSmash);
                return;
            end
            if KegSmash:Cooldown() < 0.5 then return; end
            -- Blackout Combo
            if BlackoutCombo:Exists() then
                -- Tiger Palm
                if module.GetOptionValue("Blackout Combo") == "Tiger Palm" then
                    if not Player:Buff(BlackoutComboBuff) and (Player:Power() >= 45 or not KegSmash:Exists() or KegSmash:Cooldown() > 3) and Target:CanCast(BlackoutStrike) then
                        Target:Cast(BlackoutStrike);
                        return;
                    end
                    if Player:Buff(BlackoutComboBuff) and Target:CanCast(TigerPalm) then
                        Target:Cast(TigerPalm);
                        return;
                    end
                else
                    -- Breath Of Fire
                    if BreathOfFire:Exists() and module.IsOptionEnabled("Breath Of Fire") and BreathOfFireUnits >= module.GetOptionValue("Breath Of Fire") then
                        if not Player:Buff(BlackoutComboBuff) and Target:CanCast(BlackoutStrike) then
                            Target:Cast(BlackoutStrike);
                            return;
                        end
                        if Player:Buff(BlackoutComboBuff) and Player:CanCast(BreathOfFire) then
                            Player:Cast(BreathOfFire);
                            return;
                        end
                    end
                end
            end
            -- Blackout Strike
            if BlackoutStrike:Exists() and Target:CanCast(BlackoutStrike) then
                Target:Cast(BlackoutStrike);
                return;
            end
            -- Breath Of Fire
            if BreathOfFire:Exists() and Player:IsWithinCastRange(Target, TigerPalm) and Target:Debuff(KegSmash) and module.IsOptionEnabled("Breath Of Fire") and module.GetOptionValue("Blackout Combo") ~= "Breath Of Fire" and BreathOfFireUnits >= module.GetOptionValue("Breath Of Fire") and Player:CanCast(BreathOfFire) then
                Player:Cast(BreathOfFire);
                return;
            end
            -- Chi Burst
            if ChiBurst:Exists() and module.IsOptionEnabled("Chi Burst") and ChiBurstUnits >= module.GetOptionValue("Chi Burst") and Player:CanCast(ChiBurst) then
                Player:Cast(ChiBurst);
                return;
            end
            -- Rushing Jade Wind
            if RushingJadeWind:Exists() and module.IsOptionEnabled("Rushing Jade Wind") and NumEnemies >= module.GetOptionValue("Rushing Jade Wind") and Player:CanCast(RushingJadeWind) then
                Player:Cast(RushingJadeWind);
                return;
            end
            -- Chi Wave
            if ChiWave:Exists() and Target:CanCast(ChiWave) then
                Target:Cast(ChiWave);
                return;
            end
            -- Flaming Keg
            if FlamingKeg:Exists() and module.IsOptionEnabled("Flaming Keg") and Target:CanCast(FlamingKeg) then
                if Target:CastGroundSpell(FlamingKeg, "Flaming Keg", 8) then return; end
            end
            -- Tiger Palm
            if TigerPalm:Exists() and (Player:Power() >= 55 or KegSmash:Cooldown() > 3) and Target:CanCast(TigerPalm) then
                Target:Cast(TigerPalm);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(TigerPalm, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Resuscitate
        if module.IsOptionEnabled("Resuscitate") and Unit.ResurrectCycle(Resuscitate) then
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Mistweaver Monk
    local Rotation = {};
    module.SetRotation("_"..270, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshTables = 0, 0.1, 0; -- Combat Module Throttle
    -- Healers Specific
    local MainTank, MainTankTarget, OffTank, OffTankTarget, HealUnits, Lowest, CurrentBadDebuffs, BestTarget, DispelUnit;
    local Trinket1Units, Trinket2Units, RacialsUnits;
    local Option1, Option2, Option3, Option4;
    -- Profile Specific
    local MistDelay, SoothingUnit, SoothingUnitGUID, SoothingUnitHealth = 0, nil, nil, 100;
    local VivifyCyclesUnit, VivifyUpliftingTranceUnit = nil, nil;
    local TheseHealUnits = {};
    local JadeSerpentStatue, JadeSerpentStatueCount = nil, 0;
    local Enemies_8y, ChiBurstCount, EssenceFontCount, InvokeChiJiCount, JadeSerpentStatueCount = {}, 0, 0, 0, 0;
    local RevivalCount, VivifyUnit, ZenPulseMainTankCount, ZenPulseOffTankCount, ZenPulseLowestCount = 0, nil, 0, 0, 0;

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        LukewarmYakRoastBroth = Item(120293, false, false, true);
        DraenicChanneledManaPotion = Spell(156432, false, false, false);
        --Racials
        ArcaneTorrent = Spell(25046, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33697, false, false, true);
        GiftOfTheNaaru = Spell(121093, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        BlackoutKick = Spell(100784, true, true, true);
        ChiBurst = Spell(123986, false, false, false);
        CracklingJadeLightning = Spell(117952, true, true, false);
        DampenHarm = Spell(122278, false, false, true);
        Detox = Spell(115450, false, false, true);
        DiffuseMagic = Spell(122783, false, false, true);
        Effuse = Spell(116694, false, false, false);
        EnvelopingMist = Spell(124682, false, false, false);
        EssenceFont = Spell(191837, false, false, true); -- not castable while moving if not under Thunder Focus Tea
        HealingElixir = Spell(122281, false ,false, true);
        InvokeChiJi = Spell(198664, false, false, true);
        LegSweep = Spell(119381, false, false, true);
        LifeCocoon = Spell(116849, false, false, true);
        LifeCyclesEnvelopingMist = Spell(197919);
        LifeCyclesVifvify = Spell(197916);
        ManaTea = Spell(197908, false, false, true);
        Paralysis = Spell(115078, true, false, true);
        Reawaken = Spell(212051, false, false, false);
        RenewingMist = Spell(115151, false, false, true);
        RenewingMistBuff = Spell(119611);
        Resuscitate = Spell(115178, false, false, false);
        Revival = Spell(115310, false, false, true);
        RisingSunKick = Spell(107428, true, true, true);
        RisingThunder = Spell(210804);
        SheilunsGift = Spell(205406, false, false, false);
        ShroudOfMist = Spell(214478);
        SoothingMist = Spell(193884);
        SpinningCraneKick = Spell(101546, false, false, true);
        SpiritOfTheCrane = Spell(210802);
        SummonJadeSerpentStatue = Spell(115313, false, false, true);
        TeachingOfTheMonastery = Spell(202090);
        ThunderFocusTea = Spell(116680, false, false, true);
        TigerPalm = Spell(100780, true, true, true);
        UpliftingTrance = Spell(197206);
        Vivify = Spell(116670, false, false, false);
        ZenPulse = Spell(124081, false, false, true);

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Healing Settings");
        module.AddPage("Cooldowns Settings");
        module.AddPage("Offensive/Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Focus Assignation", 230, true, {2, "Main Tank", "Off Tank"}, nil, "Select which Tank slot should be given to the focussed unit.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Detox", 232, false, {1, "Auto", "High", "Normal"}, {0.2, 0, 1, 0.1}, "Use Detox to Dispel bad debuffs on allied units."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Auto").."Dispel Active Dispel Raid debuffs as High Priority and other not listed debuffs as Normal Priority."..C.TOOLTIP_SUBVALUE("High").."Dispel all debuffs as High Priority even before urgent cooldowns."..C.TOOLTIP_SUBVALUE("Normal").."Dispel all debuffs as Normal Priority after urgent cooldowns."..C.TOOLTIP_VALUE_2.."Define how long you want to wait before dispelling to look more human. This does not apply to Active Dispels Raid debuffs which will always be as soon as Global Cooldown ends."..C.TOOLTIP_HINT("Active Raid Dispels are based on an hardcoded list. Please report of any dispels you may encounter that requires specific strategies so that they can be properly added to the list."));
        module.AddNewOption("General Settings", "Resuscitate", 210, true, nil, nil, "Resurrect dead Target with Ancestral Spirit while out of combat.");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Paralysis to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Healing Settings", "Common Healing Thresholds", "Green");
        module.AddNewOption("Healing Settings", "Chi Burst", 222, true, {3, 1, 25, 1}, {85, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Effuse", 222, true, {80, 0, 100, 1}, {65, 0, 100, 1}, "Use Effuse."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Enveloping Mist", 222, true, {80, 0, 100, 1}, {15, 0, 100, 1}, "Use Enveloping Mist."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Essence Font", 222, true, {4, 1, 12, 1}, {85, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Renewing Mist", 222, true, {99, 0, 100, 1}, {95, 0, 100, 1}, "Use Renewing Mist."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Summon Jade Serpent Statue", 232, true, {2, "Between Player And Tanks", "Centered On Raid"}, {20, 1, 25, 1}, "Use Summon Jade Serpent Statue."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Between Player And Tanks").."Place the Statue between the player and the tanks."..C.TOOLTIP_SUBVALUE("Centered On Raid").."Place the Statue so that it can reach as many raid members as possible."..C.TOOLTIP_VALUE_2.."Replace statue if less than this amount of valid healing units can be found around it. This value is built on an average of 25 players. In Example: If you define the value to 20 and you are in a 5 man group, the statue will be placed on at least 4 players and replaced if the statue can reach less than 4 players."..C.TOOLTIP_HINT("Summon Jade Serpent Statue will only be used when the player and at least one tank are standing."));
        module.AddNewOption("Healing Settings", "Vivify", 222, true, {3, 1, 3, 1}, {90, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Zen Pulse", 222, true, {2, 1, 5, 1}, {90, 0, 100, 1}, "Use when selected number of enemy units are around Lowest, OffTank or MainTank that is under health threshold."..C.TOOLTIP_VALUE_1.."Number of Enemy Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Out Of Combat Healing", 210, true, nil, nil, "Allow Healing while Out of Combat.");
        module.AddSection("Healing Settings", "Procs Management", "Green");
        module.AddNewOption("Healing Settings", "Life Cycles Enveloping Mist", 222, true, {85, 0, 100, 1}, {25, 0, 100, 1}, "Use Enveloping Mist with Life Cycles."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Life Cycles Vivify", 222, true, {2, 1, 3, 1}, {90, 0, 100, 1}, "Use when selected number of units are under health threshold with Life Cycles."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Uplifting Trance Vivify", 222, true, {2, 1, 3, 1}, {90, 0, 100, 1}, "Use when selected number of units are under health threshold  with Uplifting Trance."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddSection("Healing Settings", "Active Healing", "Green");
        module.AddNewOption("Healing Settings", "Heal Target", 230, false, {1, "Known Unit", "Any Unit"}, nil, "Heal our current target if it is listed to be healed."..C.TOOLTIP_VALUE.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Known Unit").."Allow Heal Target to be used only when we are targetting a unit listed for it."..C.TOOLTIP_SUBVALUE("Any Unit").."Allow Heal Target to be used on any unit.");
        module.AddNewOption("Healing Settings", "Raid Debuffs", 220, true, {40, 0, 100, 1}, nil, "Use Renewing Mist on Debuffed units."..C.TOOLTIP_VALUE.."Helath threshold.");
        module.AddNewOption("Healing Settings", "Tank Debuffs", 220, true, {50, 0, 100, 1}, nil, "Use Renewing Mist on Debuffed tanks."..C.TOOLTIP_VALUE.."Helath threshold.");
        module.AddNewOption("Healing Settings", "Topping", 220, true, {100, 0, 100, 1}, nil, "Use Renewing Mist/Enveloping Mist/Effuse on units to be topped."..C.TOOLTIP_VALUE.."Helath threshold.");

        module.AddSection("Cooldowns Settings", "Cooldowns", "Green");
        module.AddNewOption("Cooldowns Settings", "Invoke Chi-Ji", 222, true, {3, 1, 25, 1}, {55, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Life Cocoon", 222, true, {20, 0, 100, 1}, {10, 0, 100, 1}, "Use Life Cocoon."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Cooldowns Settings", "Mana Tea", 232, true, {1, "Auto", "Essence Font", "Vivify"}, {90, 1, 100, 1}, "Use with the selected spell when it is about to be casted whenever our mana is under threshold."..C.TOOLTIP_VALUE_1.."Spell to use with. Auto will use with both."..C.TOOLTIP_VALUE_2.."Mana threshold.");
        module.AddNewOption("Cooldowns Settings", "Revival", 222, true, {3, 1, 25, 1}, {30, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Sheilun's Gift", 222, true, {40, 0, 100, 1}, {15, 0, 100, 1}, "Use Sheilun's Gift when we have at least three Clouds."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Cooldowns Settings", "Thunder Focus Tea", 233, true, {5, "None", "Always", "Auto", "Effuse", "Enveloping Mist", "Essence Font", "Renewing Mist", "Vivify"}, {6, "None", "Effuse", "Enveloping Mist", "Essence Font", "Renewing Mist", "Vivify"}, "Use with the selected spell when it is about to be casted."..C.TOOLTIP_VALUE_1.."Define Auto to use it whenever with any listed spell. Define to Always to use it whenever it is ready. Select any other spell to only use it with that particular spell whenever it is ready."..C.TOOLTIP_VALUE_2.."If not set to Auto or Always, select a second spell to use with whenever it is ready."..C.TOOLTIP_HINT("You can define the option to Auto if you want to use with any spells. In other cases, choose the spells you want to be used with it."));
        module.AddNewOption("Cooldowns Settings", "Thunder Focus Tea Spells", 133, true, {1, "None", "Effuse", "Enveloping Mist", "Essence Font", "Renewing Mist", "Vivify"}, {1, "None", "Effuse", "Enveloping Mist", "Essence Font", "Renewing Mist", "Vivify"}, "Choose more spells to use with Thunder Focus Tea. Only usefull if Thunder Focus Tea's first option not set to Auto or Always."..C.TOOLTIP_VALUE_1.."Third spell to use with Thunder Focus Tea."..C.TOOLTIP_VALUE_2.."Fourth spell to use with Thunder Focus Tea.");
        module.AddSection("Cooldowns Settings", "Trinkets And Racials", "Green");
        module.AddNewOption("Cooldowns Settings", "Soft Cooldowns Units", 120, true, {3, 1, 25, 1}, nil, "Number of units that needs to be under thresholds to use Racials and Trinkets with Health.");
        module.AddNewOption("Cooldowns Settings", "Use Racials", 220, true, {80, 0, 100, 1}, nil, "Use Racials."..C.TOOLTIP_VALUE.."Use when number of units under threshold is greater or equal to Soft Cooldowns Units value.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 1", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 1 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always") .." Use Always."..C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 2", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 2 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always") .." Use Always."..C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");

        module.AddSection("Offensive/Defensive Settings", "Offensive", "Green");
        module.AddPresetOption("TargetAttack");
        module.AddNewOption("Offensive/Defensive Settings", "Fistweaving", 222, true, {80, 0, 100, 1}, {50, 0, 100, 1}, "Enables Fistweaving. This will only use Tiger Palm to get the Teaching of the Monastery buff and then Blackout Kick to trigger the mana regeration from Spirit Of The Crane talent."..C.TOOLTIP_VALUE_1.."Fistweave if our mana is under this threshold."..C.TOOLTIP_VALUE_2.."Only Fistweave if the Lowest unit have more than this health threshold."..C.TOOLTIP_HINT("Requires Spirit of the Crane talent."));
        module.AddNewOption("Offensive/Defensive Settings", "Rising Thunder", 220, true, {50, 0, 100, 1}, nil, "Enables using Rising Sun Kick to reset Thunder Focus Tea cooldown."..C.TOOLTIP_VALUE.."Only use if the Lowest unit have more than this health threshold."..C.TOOLTIP_HINT("Requires Rising Thunder talent."));
        module.AddSection("Offensive/Defensive Settings", "DPS Offensive", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "DPS", 220, false, {95, 0, 100, 1}, nil, "Enables DPS options."..C.TOOLTIP_VALUE.."Will only DPS if the Lowest unit is above DPS health treshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Spinning Crane Kick", 220, true, {7, 1, 25, 1}, nil, "Use Spinning Crane Kick in the DPS rotation."..C.TOOLTIP_VALUE.."Amount of units required to be in 12 yards of Player to use."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Tiger Palm", 210, true, nil, nil, "Use Tiger Palm in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Blackout Kick", 210, true, nil, nil, "Use Blackout Kick in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Rising Sun Kick", 210, true, nil, nil, "Use Rising Sun Kick in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddSection("Offensive/Defensive Settings", "Defensive", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Dampen Harm", 220, true, {60, 1, 100, 1}, nil, "Use Dampen Harm."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Diffuse Magic", 220, true, {60, 1, 100, 1}, nil, "Use Diffuse Magic."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Healing Elixir", 220, true, {60, 1, 100, 1}, nil, "Use Healing Elixir."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Offensive/Defensive Settings", "Gift Of The Naaru", 222, true, {45, 0, 100, 1}, {35, 0, 100, 1}, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        end

        -- Healers Specific
        module.AddOutput("|cFF9A2EFEMain Tank:");
        module.AddOutput("|cFF9A2EFEOff Tank:");
        module.AddOutput("|cFF9A2EFELowest:");
        module.AddOutput("|cFF9A2EFEBad Debuffs:");
        module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- New Improved Spell Casting Logic
        module.ISCL = {
            [Effuse:ID()] = "Effuse",
            [EnvelopingMist:ID()] = "Enveloping Mist",
            [EssenceFont:ID()] = "Essence Font",
            [SheilunsGift:ID()] = "Sheilun's Gift",
            [Vivify:ID()] = "Vivify"
        };
        SheilunsGift.LastCastTime = module.GetTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Channeling(EssenceFont) then
            return;
        end

        -- Define Main Tanks
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Paralysis, ArcaneTorrent);
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Healing Elixir
        if HealingElixir:Exists() and module.IsOptionEnabled("Healing Elixir") and Player:HealthPercentage() <= module.GetOptionValue("Healing Elixir") and Player:CanCast(HealingElixir) then
            Player:Cast(HealingElixir);
            return;
        end
        -- Diffuse Magic
        if DiffuseMagic:Exists() and module.IsOptionEnabled("Diffuse Magic") and Player:HealthPercentage() <= module.GetOptionValue("Diffuse Magic") and Player:CanCast(DiffuseMagic) then
            Player:Cast(DiffuseMagic);
            return;
        end
        -- Dampen Harm
        if DampenHarm:Exists() and module.IsOptionEnabled("Dampen Harm") and Player:HealthPercentage() <= module.GetOptionValue("Dampen Harm") and Player:CanCast(DampenHarm) then
            Player:Cast(DampenHarm);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and MainTank:CanCast(GiftOfTheNaaru) then
                MainTank:Cast(GiftOfTheNaaru);
                return;
            elseif MainTank and OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and OffTank:CanCast(GiftOfTheNaaru) then
                OffTank:Cast(GiftOfTheNaaru);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Gift Of The Naaru") and Lowest:CanCast(GiftOfTheNaaru) then
                Lowest:Cast(GiftOfTheNaaru);
                return;
            end
        end
    end

    -- Get Tanks Status
    local TanksStatus, MainTankTanking, OffTankTanking = {Main = {IsTanking = module.GetTime()},Off = {IsTanking = module.GetTime()}}, nil, nil;
    local function RefreshTanksStatus ()
        TanksStatus = {
            Main = {IsTanking = MainTank and MainTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Main.IsTanking},
            Off = {IsTanking = OffTank and OffTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Off.IsTanking}
        };
        MainTankTanking = module.GetTime() - TanksStatus.Main.IsTanking < 3 or false;
        OffTankTanking = module.GetTime() - TanksStatus.Off.IsTanking < 3 or false;
    end

    -- Active Healing Heal Target handler
    local function HealTarget (ThisUnit)
        -- Renewing Mist
        if ThisUnit:BuffRemains(RenewingMist) < 2 and ThisUnit:CanCast(RenewingMist) then
            ThisUnit:Cast(RenewingMist);
            return;
        end
        if not Player:IsMoving() and ThisUnit:CanCast(Effuse) then
            -- Enveloping Mist
            if ThisUnit:SpecialHealthPercentage() < 60 and not ThisUnit:Buff(EnvelopingMist) and ThisUnit:CanCast(EnvelopingMist) then
                ThisUnit:Cast(EnvelopingMist);
                return;
            end
            -- Effuse
            if ThisUnit:SpecialHealthPercentage() < 100 and SoothingUnitGUID ~= ThisUnit:GUID() and ThisUnit:CanCast(Effuse) then
                ThisUnit:Cast(Effuse);
                return;
            end
        end
    end

    local function FocusTea (FirstOption, SecondOption)
        Option1, Option2 = module.GetOptionValue("Thunder Focus Tea"), module.GetSecondOptionValue("Thunder Focus Tea")
        Option3, Option4 = module.GetOptionValue("Thunder Focus Tea Spells"), module.GetSecondOptionValue("Thunder Focus Tea Spells")
        if ThunderFocusTea:Exists() and module.IsOptionEnabled("Thunder Focus Tea") then
            if (Option1 == FirstOption or Option1 == SecondOption or Option2 == SecondOption or Option3 == SecondOption or Option4 == SecondOption) and Player:CanCast(ThunderFocusTea) then
                ThunderFocusTea.LastCastTime = module.GetTime();
                Player:Cast(ThunderFocusTea);
            end
        end
    end

    local function ManaTeaTalent (FirstOption, SecondOption)
        if ManaTea:Exists() and module.IsOptionEnabled("Mana Tea") and Player:PowerPercentage() <= module.GetSecondOptionValue("Mana Tea") and (module.GetOptionValue("Mana Tea") == FirstOption or module.GetOptionValue("Mana Tea") == SecondOption) and Player:CanCast(ManaTea) then
            Player:Cast(ManaTea);
        end
    end

    --- Run the beta rotation's healing logic.
    function Rotation:Combat ()
        -- Find best unit to attack
        if Target:Exists() and Target:CanCast(TigerPalm) then
            BestTarget = Target;
        elseif MainTankTarget and MainTankTarget:CanCast(TigerPalm) then
            BestTarget = MainTankTarget;
        elseif OffTankTarget and OffTankTarget:CanCast(TigerPalm) then
            BestTarget = OffTankTarget;
        elseif Mouseover:Exists() and Mouseover:CanCast(TigerPalm) then
            BestTarget = Mouseover;
        else
            BestTarget = Target;
        end

        -- Define Jade Serpent Statue Unit
        if module.JadeSerpentStatue and module.JadeSerpentStatue.UnitID then
            JadeSerpentStatue = Unit(module.JadeSerpentStatue.UnitID);
        end

        -- Refresh tables every 0.5 seconds
        if RefreshTables < module.GetTime() then
            DispelUnit = Unit.Dispel(Detox);
            HealUnits = Player:HealUnitsAround(100, 40);
            Lowest = Unit.Lowest(MainTank, OffTank);
            module.SetOutput("|cFF9A2EFELowest:", Lowest and Lowest:Name() or "");
            RefreshTanksStatus();
            Enemies_8y = module.UseAOE() and Player:EnemiesWithinDistance(8) or {}; -- 8 yards of Player for Spinning Crane Kick.
            ChiBurstCount = ChiBurst:Exists() and #Player:UnitsInFrontRectangle(40, 5, true, module.GetSecondOptionValue("Chi Burst")) or 0;
            EssenceFontCount = EssenceFont:Exists() and module.IsOptionEnabled("Essence Font") and #Player:HealUnitsAround(module.GetSecondOptionValue("Essence Font"), 25) or 0;
            InvokeChiJiCount = InvokeChiJi:Exists() and module.IsOptionEnabled("Invoke Chi-Ji") and #Player:HealUnitsAround(module.GetSecondOptionValue("Invoke Chi-Ji"), 40) or 0;
            JadeSerpentStatueCount = JadeSerpentStatue and JadeSerpentStatue:Exists() and Unit.FriendliesNearTotem(JadeSerpentStatue, HealUnits, 40, 100) or 0;
            RevivalCount = Revival:Exists() and module.IsOptionEnabled("Revival") and #Player:HealUnitsAround(module.GetSecondOptionValue("Revival"), 40) or 0;
            VivifyUnit = Vivify:Exists() and module.IsOptionEnabled("Vivify") and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Vivify"), module.GetSecondOptionValue("Vivify"), 20) or nil;
            VivifyCyclesUnit = Vivify:Exists() and module.IsOptionEnabled("Life Cycles Vivify") and Player:Buff(LifeCyclesVifvify) and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Life Cycles Vivify"), module.GetSecondOptionValue("Life Cycles Vivify"), 20) or nil;
            VivifyUpliftingTranceUnit = Vivify:Exists() and module.IsOptionEnabled("Uplifting Trance Vivify") and Player:Buff(UpliftingTrance) and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Uplifting Trance Vivify"), module.GetSecondOptionValue("Uplifting Trance Vivify"), 20) or nil;
            ZenPulseMainTankCount = ZenPulse:Exists() and MainTank and MainTank:SpecialHealthPercentage() <= module.GetSecondOptionValue("Zen Pulse") and #MainTank:EnemiesWithinDistance(8, true) or 0;
            ZenPulseOffTankCount = ZenPulse:Exists() and OffTank and OffTank:SpecialHealthPercentage() <= module.GetSecondOptionValue("Zen Pulse") and #OffTank:EnemiesWithinDistance(8, true) or 0;
            ZenPulseLowestCount = ZenPulse:Exists() and Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Zen Pulse") and #Lowest:EnemiesWithinDistance(8, true) or 0;
            RacialsUnits = module.IsOptionEnabled("Use Racials") and ((Berserking:Exists() and Player:CanCast(Berserking)) or (BloodFury:Exists() and Player:CanCast(BloodFury))) and #Player:HealUnitsAround(module.GetOptionValue("Use Racials"), 40) or 0;
            Trinket1Units = module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 1"), 40) or 0;
            Trinket2Units = module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 2"), 40) or 0;
            -- Bad Debuffs Output
            CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits);
            if CurrentBadDebuffs ~= nil then
                module.SetOutput("|cFF9A2EFEBad Debuffs:", #CurrentBadDebuffs.Tanks + #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff);
            end
            RefreshTables = module.GetTime() + 0.5;
        end

        -- Dispels Handling
        Player:DispelHandler(Detox, "Detox", DispelUnit, CurrentBadDebuffs.Dispel, "High");

        -- Active Healing Heal Target handler
        if Target:CanCast(Effuse) and module.IsOptionEnabled("Heal Target") and (module.GetOptionValue("Heal Target") == 2 or (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed())) then
            HealTarget(Target);
            return;
        end

    -- Cooldowns
        -- Only use DPS and Cooldowns during combat
        if Player:IsInCombat() then
            -- DPS
            if module.IsOptionEnabled("DPS") and BestTarget and (not Lowest or Lowest:HealthPercentage() >= module.GetOptionValue("DPS")) and (not MainTank or MainTank:HealthPercentage() >= module.GetOptionValue("DPS")) and (not OffTank or OffTank:HealthPercentage() >= module.GetOptionValue("DPS")) and BestTarget:IsInCombat() then
                -- Tiger Palm for Teaching Of The Monastery
                if TigerPalm:Exists() and SpiritOfTheCrane:Exists() and not Player:Buff(TeachingOfTheMonastery) and module.IsOptionEnabled("Tiger Palm") and BestTarget:CanCast(TigerPalm) then
                    BestTarget:Cast(TigerPalm);
                    return;
                end
                -- Blackout Kick
                if BlackoutKick:Exists() and module.IsOptionEnabled("Blackout Kick") and BestTarget:CanCast(BlackoutKick) then
                    BestTarget:Cast(BlackoutKick);
                    return;
                end
                -- Spinning Crane Kick
                if SpinningCraneKick:Exists() and #Enemies_8y >= module.GetOptionValue("Spinning Crane Kick") and Player:CanCast(SpinningCraneKick) then
                    Player:Cast(SpinningCraneKick);
                    return;
                end
                -- Rising Sun Kick
                if RisingSunKick:Exists() and module.IsOptionEnabled("Rising Sun Kick") and BestTarget:CanCast(RisingSunKick) then
                    BestTarget:Cast(RisingSunKick);
                    return;
                end
                -- Tiger Palm
                if TigerPalm:Exists() and module.IsOptionEnabled("Tiger Palm") and BestTarget:CanCast(TigerPalm) then
                    BestTarget:Cast(TigerPalm);
                    return;
                end
                -- Find New Target
                if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
                    local NewTargetUnit = Unit.AutoTarget(TigerPalm, module.GetOptionValue("Target | Attack"));
                    if NewTargetUnit then
                        NewTargetUnit:Attack();
                        return;
                    end
                end
            end
            -- Racials with Specific Handlers
            if module.IsOptionEnabled("Use Racials") then
                if RacialsUnits >= module.GetOptionValue("Soft Cooldowns Units") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                        return;
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                        return;
                    end
                end
            end
            -- Trinkets with specific handlers
            if module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 1"), module.GetSecondOptionValue("Use Trinket 1");
                if Option1 == "Always" or (Option1 == "Health" and Trinket1Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 1")) then
                    Trinket1:UseInventory();
                end
            end
            if module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 2"), module.GetSecondOptionValue("Use Trinket 2");
                if Option1 == "Always" or (Option1 == "Health" and Trinket2Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 2")) then
                    Trinket2:UseInventory();
                end
            end
            -- Revival - Used when # of people under treshold exceed desired number of units
            if Revival:Exists() and module.IsOptionEnabled("Revival") and RevivalCount >= module.GetOptionValue("Revival") and Player:CanCast(Revival) then
                Player:Cast(Revival);
                return;
            end
            -- Invoke Chi-Ji - Used when # of people under treshold exceed desired number of units
            if InvokeChiJi:Exists() and module.IsOptionEnabled("Invoke Chi-Ji") and InvokeChiJiCount >= module.GetOptionValue("Invoke Chi-Ji") and Player:CanCast(InvokeChiJi) then
                Player:Cast(InvokeChiJi);
                return;
            end
            -- Sheilun's Gift
            if SheilunsGift:Exists() and module.IsOptionEnabled("Sheilun's Gift") and module.SheilunsCharges >= 3 then
                if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Sheilun's Gift") and MainTank:CanCast(SheilunsGift) then
                    MainTank:Cast(SheilunsGift);
                    return;
                end
                if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Sheilun's Gift") and OffTank:CanCast(SheilunsGift) then
                    OffTank:Cast(SheilunsGift);
                    return;
                end
                if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Sheilun's Gift") and Lowest:CanCast(SheilunsGift) then
                    Lowest:Cast(SheilunsGift);
                    return;
                end
            end
            -- Life Cocoon
            if LifeCocoon:Exists() and module.IsOptionEnabled("Life Cocoon") then
                if MainTank and not MainTank:BuffAny(LifeCocoon) and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Life Cocoon") and MainTank:CanCast(LifeCocoon) then
                    MainTank:Cast(LifeCocoon);
                    return;
                end
                if OffTank and not OffTank:Buff(LifeCocoon) and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Life Cocoon") and OffTank:CanCast(LifeCocoon) then
                    OffTank:Cast(LifeCocoon);
                    return;
                end
                if Lowest and not Lowest:Buff(LifeCocoon) and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Life Cocoon") and Lowest:CanCast(LifeCocoon) then
                    Lowest:Cast(LifeCocoon);
                    return;
                end
            end
            -- Thunder Focus Tea - Always
            FocusTea("Always");
        end

        -- Dispels Handling
        Player:DispelHandler(Detox, "Detox", DispelUnit, CurrentBadDebuffs.Dispel, "Normal");

        -- Soothing Mist Handling
        if MistDelay < module.GetTime() and not Player:Channeling(SoothingMist) then
            MistDelay, SoothingUnit, SoothingUnitGUID, SoothingUnitHealth = 0, nil, nil, 100;
        end
        if SoothingUnit then
            SoothingUnitGUID = SoothingUnit:GUID();
            SoothingUnitHealth = SoothingUnit:SpecialHealthPercentage();
        else
            SoothingUnitGUID = "No Soothing";
            SoothingUnitHealth = 100;
        end

    -- High Priority Healing
        -- Summon Jade Serpent Statue
        if SummonJadeSerpentStatue:Exists() and module.IsOptionEnabled("Summon Jade Serpent Statue") and #HealUnits > 1 and not Player:IsMoving() and Player:CanCast(SummonJadeSerpentStatue) then
            -- See if we should reposition
            if JadeSerpentStatueCount < module.GetSecondOptionValue("Summon Jade Serpent Statue")/25 and #HealUnits >= module.GetSecondOptionValue("Summon Jade Serpent Statue")/25 then
                -- If option is set to Tanks and there is at least one Tank in the group
                if (module.GetOptionValue("Summon Jade Serpent Statue") == "Between Player And Tanks" and (MainTank or OffTank)) then
                    -- Placed Between Player and Main Tank
                    -- If at least one tank is not moving
                    if (MainTank and not MainTank:IsMoving()) or (OffTank and not OffTank:IsMoving()) then
                        TheseHealUnits = MainTank and OffTank and {Player,MainTank,OffTank} or MainTank and {Player, MainTank} or OffTank and {Player, OffTank};
                        Player:CastGroundHeal(SummonJadeSerpentStatue, TheseHealUnits);
                        return;
                    end
                else
                    if (MainTank and not MainTank:IsMoving()) or (OffTank and not OffTank:IsMoving()) or (not MainTank and not OffTank) then
                        -- Centered On Raid
                        Player:CastGroundHeal(SummonJadeSerpentStatue, HealUnits);
                        return;
                    end
                end
            end
        end
        -- Fistweaving Only
        if SpiritOfTheCrane:Exists() and module.IsOptionEnabled("Fistweaving") and (not CurrentBadDebuffs or #CurrentBadDebuffs.Top == 0) and Player:PowerPercentage() <= module.GetOptionValue("Fistweaving") and BestTarget and (not Lowest or Lowest:HealthPercentage() >= module.GetSecondOptionValue("Fistweaving")) and (not MainTank or MainTank:HealthPercentage() >= module.GetSecondOptionValue("Fistweaving")) and (not OffTank or OffTank:HealthPercentage() >= module.GetSecondOptionValue("Fistweaving")) and BestTarget:IsInCombat() then
            -- Tiger Palm for Teaching Of The Monastery
            if TigerPalm:Exists() and BlackoutKick:Exists() and BlackoutKick:TimeSinceCast() > 3 and not Player:Buff(TeachingOfTheMonastery) and BestTarget:CanCast(TigerPalm) then
                BestTarget:Cast(TigerPalm);
                return;
            end
            -- Blackout Kick
            if BlackoutKick:Exists() and Player:Buff(TeachingOfTheMonastery) and BestTarget:CanCast(BlackoutKick) then
                BlackoutKick.LastCastTime = module.GetTime();
                BestTarget:Cast(BlackoutKick);
                return;
            end
        end
        -- Rising Sun Kick - Rising Thunder
        if RisingThunder:Exists() and RisingSunKick:Exists() and module.IsOptionEnabled("Rising Thunder") and not Player:Buff(ThunderFocusTea) and ThunderFocusTea:Cooldown() > 5 and (not CurrentBadDebuffs or #CurrentBadDebuffs.Top == 0) and BestTarget and (not Lowest or Lowest:HealthPercentage() >= module.GetOptionValue("Rising Thunder")) and (not MainTank or MainTank:HealthPercentage() >= module.GetOptionValue("Rising Thunder")) and (not OffTank or OffTank:HealthPercentage() >= module.GetOptionValue("Rising Thunder")) and BestTarget:IsInCombat() and BestTarget:CanCast(RisingSunKick) then
            BestTarget:Cast(RisingSunKick);
            return;
        end
        -- Renewing Mist - Tanks
        if RenewingMist:Exists() and module.IsOptionEnabled("Renewing Mist") then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Renewing Mist") and MainTank:BuffRemains(RenewingMistBuff) <= 5 and MainTank:CanCast(RenewingMist) then
                FocusTea("Auto", "Renewing Mist");
                MainTank:Cast(RenewingMist);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Renewing Mist") and OffTank:BuffRemains(RenewingMistBuff) <= 5 and OffTank:CanCast(RenewingMist) then
                FocusTea("Auto", "Renewing Mist");
                OffTank:Cast(RenewingMist);
                return;
            end
        end
        -- Enveloping Mist - Tanks
        if EnvelopingMist:Exists() and module.IsOptionEnabled("Enveloping Mist") then
            if MainTank and not MainTank:Buff(EnvelopingMist) and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Enveloping Mist") and MainTank:CanCast(EnvelopingMist) then
                FocusTea("Auto", "Enveloping Mist");
                MistDelay, SoothingUnit = module.GetTime() + EnvelopingMist:CastTime() + 0.3, MainTank;
                MainTank:Cast(EnvelopingMist);
                return;
            end
            if OffTank and not OffTank:Buff(EnvelopingMist) and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Enveloping Mist") and OffTank:CanCast(EnvelopingMist) then
                FocusTea("Auto", "Enveloping Mist");
                MistDelay, SoothingUnit = module.GetTime() + EnvelopingMist:CastTime() + 0.3, OffTank;
                OffTank:Cast(EnvelopingMist);
                return;
            end
        end







        -- Enveloping Mist
        if EnvelopingMist:Exists() and module.IsOptionEnabled("Life Cycles Enveloping Mist") and Player:Buff(LifeCyclesEnvelopingMist) then
            if MainTank and not MainTank:Buff(EnvelopingMist) and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Life Cycles Enveloping Mist") and MainTank:CanCast(EnvelopingMist) then
                FocusTea("Auto", "Enveloping Mist");
                MistDelay, SoothingUnit = module.GetTime() + EnvelopingMist:CastTime() + 0.3, MainTank;
                MainTank:Cast(EnvelopingMist);
                return;
            end
            if OffTank and not OffTank:Buff(EnvelopingMist) and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Life Cycles Enveloping Mist") and OffTank:CanCast(EnvelopingMist) then
                FocusTea("Auto", "Enveloping Mist");
                MistDelay, SoothingUnit = module.GetTime() + EnvelopingMist:CastTime() + 0.3, OffTank;
                OffTank:Cast(EnvelopingMist);
                return;
            end
            if Lowest and not Lowest:Buff(EnvelopingMist) and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Life Cycles Enveloping Mist") and Lowest:CanCast(EnvelopingMist) then
                FocusTea("Auto", "Enveloping Mist");
                MistDelay, SoothingUnit = module.GetTime() + EnvelopingMist:CastTime() + 0.3, Lowest;
                Lowest:Cast(EnvelopingMist);
                return;
            end
        end







        -- Essence Font
        if EssenceFont:Exists() and module.IsOptionEnabled("Essence Font") and EssenceFontCount >= module.GetOptionValue("Essence Font") then
            if Player:Channeling(EssenceFont) then
                return;
            elseif Player:CanCast(EssenceFont) then
                if Player:IsMoving() then
                    FocusTea("Auto", "Essence Font");
                end
                if not Player:IsMoving() or Player:Buff(ThunderFocusTea) or ThunderFocusTea:TimeSinceCast() < 0.1 then
                    ManaTeaTalent("Auto", "Essence Font");
                    Player:Cast(EssenceFont);
                    return;
                end
            end
        end
        -- Renewing Mist - Cycle
        if Player:IsInCombat() and RenewingMist:Exists() and module.IsOptionEnabled("Renewing Mist") then
            local BestUnit, BestUnitHealth, ThisUnit, ThisUnitHealth, HealthThreshold = nil, 100, nil, nil, module.GetSecondOptionValue("Renewing Mist");
            for i = 1, #HealUnits do
                ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage();
                if ThisUnitHealth <= HealthThreshold and ThisUnitHealth <= BestUnitHealth and ThisUnit:CanCast(RenewingMist) and ThisUnit:BuffRemains(RenewingMistBuff) < 3 then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit then
                FocusTea("Auto", "Renewing Mist");
                BestUnit:Cast(RenewingMist);
                return;
            end
        end
        -- Enveloping Mist - Lowest
        if EnvelopingMist:Exists() and module.IsOptionEnabled("Enveloping Mist") then
            if Lowest and not Lowest:Buff(EnvelopingMist) and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Enveloping Mist") and Lowest:CanCast(EnvelopingMist) then
                FocusTea("Auto", "Enveloping Mist");
                MistDelay, SoothingUnit = module.GetTime() + EnvelopingMist:CastTime() + 0.3, Lowest;
                Lowest:Cast(EnvelopingMist);
                return;
            end
        end




        -- Life Cycles Vivify
        if module.IsOptionEnabled("Life Cycles Vivify") and VivifyCyclesUnit and VivifyCyclesUnit:CanCast(Vivify) then
            FocusTea("Auto", "Vivify");
            ManaTeaTalent("Auto", "Vivify");
            MistDelay, SoothingUnit = module.GetTime() + Vivify:CastTime() + 0.3, VivifyCyclesUnit;
            VivifyCyclesUnit:Cast(Vivify);
            return;
        end
        -- Uplifting Trance
        if module.IsOptionEnabled("Uplifting Trance Vivify") and VivifyUpliftingTranceUnit and VivifyUpliftingTranceUnit:CanCast(Vivify) then
            FocusTea("Auto", "Vivify");
            ManaTeaTalent("Auto", "Vivify");
            MistDelay, SoothingUnit = module.GetTime() + Vivify:CastTime() + 0.3, VivifyUpliftingTranceUnit;
            VivifyUpliftingTranceUnit:Cast(Vivify);
            return;
        end








        -- Vivify
        if module.IsOptionEnabled("Vivify") and VivifyUnit and VivifyUnit:CanCast(Vivify) then
            FocusTea("Auto", "Vivify");
            ManaTeaTalent("Auto", "Vivify");
            MistDelay, SoothingUnit = module.GetTime() + Vivify:CastTime() + 0.3, VivifyUnit;
            VivifyUnit:Cast(Vivify);
            return;
        end
        -- Chi Burst
        if ChiBurst:Exists() and module.IsOptionEnabled("Chi Burst") and ChiBurstCount >= module.GetOptionValue("Chi Burst") and Player:CanCast(ChiBurst) then
            Player:Cast(ChiBurst);
            return;
        end
        -- Zen Pulse
        if ZenPulse:Exists() and module.IsOptionEnabled("Zen Pulse") then
            if MainTank and ZenPulseMainTankCount >= module.GetOptionValue("Zen Pulse") and MainTank:CanCast(ZenPulse) then
                MainTank:Cast(ZenPulse);
                return;
            end
            if OffTank and ZenPulseOffTankCount >= module.GetOptionValue("Zen Pulse") and OffTank:CanCast(ZenPulse) then
                OffTank:Cast(ZenPulse);
                return;
            end
            if Lowest and ZenPulseLowestCount >= module.GetOptionValue("Zen Pulse") and Lowest:CanCast(ZenPulse) then
                Lowest:Cast(ZenPulse);
                return;
            end
        end
        -- Effuse - Tanks
        if Effuse:Exists() and module.IsOptionEnabled("Effuse") and not Player:IsMoving() then
            if MainTank and SoothingUnitGUID ~= MainTank:GUID() and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Effuse") and MainTank:SpecialHealthPercentage() <= SoothingUnitHealth - 15 and MainTank:CanCast(Effuse) then
                module.Bug("Effuse - Main Tank");
                FocusTea("Auto", "Effuse");
                MistDelay, SoothingUnit = module.GetTime() + Effuse:CastTime() + 0.3, MainTank;
                MainTank:Cast(Effuse);
                return;
            end
            if OffTank and SoothingUnitGUID ~= OffTank:GUID() and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Effuse") and OffTank:SpecialHealthPercentage() <= SoothingUnitHealth - 15 and OffTank:CanCast(Effuse) then
                module.Bug("Effuse - Offtank");
                FocusTea("Auto", "Effuse");
                MistDelay, SoothingUnit = module.GetTime() + Effuse:CastTime() + 0.3, OffTank;
                OffTank:Cast(Effuse);
                return;
            end
        end
    -- Bad Debuffs - Tank
        if RenewingMist:Exists() and module.IsOptionEnabled("Tank Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Tanks do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Tanks[i], CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(RenewingMist) and not ThisUnit:Buff(RenewingMist) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Tank Debuffs") then
                FocusTea("Auto", "Renewing Mist");
                module.Bug("Renewing Mist on " .. BestUnit:Name() .. " to heal tank debuff");
                BestUnit:Cast(RenewingMist);
                return;
            end
        end
    -- Bad Debuffs - Debuffs
        if RenewingMist:Exists() and module.IsOptionEnabled("Raid Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Debuff do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Debuff[i], CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(RenewingMist) and not ThisUnit:Buff(RenewingMist) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Raid Debuffs") then
                FocusTea("Auto", "Renewing Mist");
                module.Bug("Renewing Mist on " .. BestUnit:Name() .. " to mitigate debuff");
                BestUnit:Cast(RenewingMist);
                return;
            end
        end
    -- Bad Debuffs - Topping
        if module.IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Top do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Top[i], CurrentBadDebuffs.Top[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Effuse) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil then
                if RenewingMist:Exists() and BestUnitHealth <= module.GetOptionValue("Topping") and not BestUnit:Buff(RenewingMist) and BestUnit:CanCast(RenewingMist) then
                    FocusTea("Auto", "Renewing Mist");
                    module.Bug("Renewing Mist on " .. BestUnit:Name() .. " to top it");
                    BestUnit:Cast(RenewingMist);
                    return;
                end
                if EnvelopingMist:Exists() and BestUnitHealth <= module.GetOptionValue("Topping") and not BestUnit:Buff(EnvelopingMist) and BestUnit:CanCast(EnvelopingMist) then
                    FocusTea("Auto", "Enveloping Mist");
                    module.Bug("Enveloping Mist on " .. BestUnit:Name() .. " to top it");
                    MistDelay, SoothingUnit = module.GetTime() + Effuse:CastTime() + 0.3, BestUnit;
                    BestUnit:Cast(EnvelopingMist);
                    return;
                end
                if Effuse:Exists() and SoothingUnitGUID ~= BestUnit:GUID() and BestUnitHealth <= module.GetOptionValue("Topping") and BestUnit:CanCast(Effuse) then
                    FocusTea("Auto", "Effuse");
                    module.Bug("Effuse on " .. BestUnit:Name() .. " to top it");
                    MistDelay, SoothingUnit = module.GetTime() + Effuse:CastTime() + 0.3, BestUnit;
                    BestUnit:Cast(Effuse);
                    return;
                end
            end
        end
    -- Low Priority Healing
        -- Effuse
        if Effuse:Exists() and module.IsOptionEnabled("Effuse") then
            if Lowest and SoothingUnitGUID ~= Lowest:GUID() and Lowest:SpecialHealthPercentage() <= module.GetOptionValue("Effuse") and Lowest:SpecialHealthPercentage() <= SoothingUnitHealth - 25 and Lowest:CanCast(Effuse) then
                module.Bug("Effuse - Low Prio");
                MistDelay, SoothingUnit = module.GetTime() + Effuse:CastTime() + 0.3, Lowest;
                Lowest:Cast(Effuse);
                return;
            end
        end
        -- Effuse Filler
        if Effuse:Exists() and module.IsOptionEnabled("Effuse") and MainTank and MainTankTanking and SoothingUnitGUID ~= MainTank:GUID() and MainTank:CanCast(Effuse) then
            module.Bug("Effuse - Filler");
            MistDelay, SoothingUnit = module.GetTime() + Effuse:CastTime() + 0.3, MainTank;
            MainTank:Cast(Effuse);
            return;
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Resurrect Deads
        if module.IsOptionEnabled("Resuscitate") and Unit.ResurrectCycle(AncestralSpirit) then
            return;
        end
        if module.IsOptionEnabled("Out Of Combat Healing") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Windwalker Monk Rotation
    local Rotation = {};
    module.SetRotation("_"..269, Rotation);

    --- Localization
    -- Core
    local Enemies_8y, Enemies_5y, NumEnemies = {}, {}, 1; -- Enemies
    local SpamPrevention, TPSTime = 0, 0.1; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local ChiBurstStanding = 0.7; -- Chi Burst Handler
    local UnitNeedRes, Lowest = nil, nil; -- OoC Res & Heal Handler

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        --- Spells
        -- (ID, RequiresFacing, Hostile, Instant, Resurrect)
        -- Racials
        ArcaneTorrent = Spell(25046, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);
        -- Items
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Common Misc
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Abilities
        BlackoutKick = Spell(100784, true, true, true);
        ChiBurst = Spell(123986, false, false, false);
        ChiWave = Spell(115098, false, true, true);
        ComboBreaker = Spell(116768, false, false, false);
        CracklingJadeLightning = Spell(117952, true, true, true);
        FistsOfFury = Spell(113656, true, true, true);
        RisingSunKick = Spell(107428, true, true, true);
        RushingJadeWind = Spell(116847, false, false, true);
        SpinningCraneKick = Spell(101546, false, false, true);
        StrikeoftheWindlord = Spell(205320, true, true, true);
        TigerPalm = Spell(100780, true, true, true);
        WhirlingDragonPunch = Spell(152175, false, false, true); -- Casted on Player like SCK, 5-8y range TBD
        -- Offensive Cooldowns
        EnergizingElixir = Spell(115288, false, false, true);
        InvokeXuen = Spell(123904, false, true, true);
        Serenity = Spell(152173, false, false, true);
        StormEarthAndFire = Spell(137639, false, true, true);
        TouchOfDeath = Spell(115080, true, true, true);
        -- Defensive Abilities
        Effuse = Spell(116694, false, false, true);
        HealingElixir = Spell(122281, false, false, true);
        Resuscitate = Spell(115178, false, false, true, true);
        -- Defensive Cooldowns
        DampenHarm = Spell(122278, false, false, true);
        DiffuseMagic = Spell(122783, false, false, true);
        -- Utility
        Detox = Spell(115450, false, false, true);
        SpearHandStrike = Spell(116705, true, true, true);


        --- GUI Frame
        -- Pages
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        module.AddCommonOptions();
        module.AddPresetOption("TargetAttack");
        module.AddPresetOption("ReTarget");
        module.AddPresetOption("BossCD");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddPresetOption("Interrupt");
        module.AddSection("General Settings", "Out of Combat", "Green");
        module.AddPresetOption("AutoResuscitate");
        module.AddPresetOption("AutoHeal");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddPresetOption("PrePot");
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Strike of the Windlord", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Strike of the Windlord."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Energizing Elixir", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Energizing Elixir."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Storm, Earth and Fire", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Storm, Earth and Fire."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Serenity", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Serenity."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Touch of Death", 223, true, {10, 0, 50, 0.5}, {2, "Always", "Cooldown Only"}, "Enable for the automatic usage of Touch of Death."..C.TOOLTIP_VALUE_1.."Set the minimum number of health in million the unit must have in order to use ToD."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Invoke Xuen", 210, true, nil, nil, "Enable for the automatic usage of Invoke Xuen, the White Tiger.");
        module.AddPresetOption("Trinket");
        module.AddPresetOption("Potion");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Chi Wave Pre-Combat", 210, true, nil, nil, "Enable to cast Chi Wave while walking to the target.");
        module.AddNewOption("Offensive Settings", "Chi Wave, Chi Burst", 220, true, {75, 40, 150, 1}, nil, "Enable for the automatic usage of Chi Wave / Chi Burst."..C.TOOLTIP_VALUE.."Set the minimum number of units that needs to be in Chi Burst path in order to use it.");
        module.AddNewOption("Offensive Settings", "Crackling Jade Lightning", 220, true, {1.3, 0.3, 3, 0.1}, nil, "Enable for the automatic usage of Crackling Jade Lightning while not moving and not being in melee range."..C.TOOLTIP_VALUE.."Set the minimum standing time to start using it.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddPresetOption("HealingItem");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddPresetOption("HoPCancel");
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "HE, DM, DH", 220, true, {45, 1, 100, 1}, nil, "Health Percentage to use Healing Elixir / Dampen Harm / Diffuse Magic.");

        --- Misc
        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
        -- Improved Spell Casting Logic
        module.ISCL = {
            [Effuse:ID()] = "Effuse",
            [Resuscitate:ID()] = "Resuscitate"
        };
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated
        Player:SetCommonMeleeStatus();
        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        if module.IsOptionEnabled("HE, DM, DH") and Player:SpecialHealthPercentage() <= module.GetOptionValue("HE, DM, DH") then
            if HealingElixir:Exists() then
                if Player:CanCast(HealingElixir) then Player:Cast(HealingElixir); end
            elseif DampenHarm:Exists() then
                if Player:CanCast(DampenHarm) then Player:Cast(DampenHarm); end
            elseif DiffuseMagic:Exists() then
                if Player:CanCast(DiffuseMagic) then Player:Cast(DiffuseMagic); end
            end
        end
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift of the Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift of the Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(SpearHandStrike, ArcaneTorrent);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(TigerPalm, false) or Unit.Target;
    end

    --- Run the rotation's in gcd combat logic.
    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Enemies Check:
            if module.UseAOE() then
                Enemies_8y = Player:EnemiesWithinDistance(8, true); -- Using 8y (real range) for SCK & RJW and true as they are PlayerCenteredAoE Spells.
                Enemies_5y = Player:FilterEnemiesByDistance(Enemies_8y, 5, false); -- This table is used for Melee Range Cycling Abilities.
                NumEnemies = #Enemies_8y;
            else
                NumEnemies = 1;
            end
            -- Cooldowns
            if Player:IsWithinCastRange(Target, TigerPalm) then
                if module.CooldownsAllowed() then
                    -- Invoke Xuen
                    if module.IsOptionEnabled("Invoke Xuen") and InvokeXuen:Exists() and Target:CanCast(InvokeXuen) then
                        Target:Cast(InvokeXuen);
                        return;
                    end
                    -- Trinkets
                    if Trinket1:IsUsableInventory() and module.GetOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket1:UseInventory();
                    end
                    if Trinket2:IsUsableInventory() and module.GetSecondOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket2:UseInventory();
                    end
                end
                -- Touch of Death
                if module.IsOptionEnabled("Touch of Death") and (module.CooldownsAllowed() or module.GetSecondOptionValue("Touch of Death") == "Always") and Target:Health() >= module.GetOptionValue("Touch of Death")*1000000 and Target:CanCast(TouchOfDeath) then
                    Target:Cast(TouchOfDeath);
                    return;
                end
                -- Serenity
                if module.IsOptionEnabled("Serenity") and (module.CooldownsAllowed() or module.GetOptionValue("Serenity") == "Always") and Serenity:Exists() and Player:CanCast(Serenity) then
                    Player:Cast(Serenity);
                    return;
                end
                -- Energizing Elixir
                if module.IsOptionEnabled("Energizing Elixir") and (module.CooldownsAllowed() or module.GetOptionValue("Energizing Elixir") == "Always") and EnergizingElixir:Exists() and Player:Chi() == 0 and Player:Power() < Player:PowerMax() and not Player:Buff(Serenity) and Player:CanCast(EnergizingElixir) then
                    Player:Cast(EnergizingElixir);
                    return;
                end
                -- Energizing Elixir
                if module.IsOptionEnabled("Storm, Earth and Fire") and (module.CooldownsAllowed() or module.GetOptionValue("Storm, Earth and Fire") == "Always") and not Player:Buff(StormEarthAndFire) and Target:CanCast(StormEarthAndFire) then
                    Target:Cast(StormEarthAndFire);
                    return;
                end
            end
            -- Fists of Fury
            if Target:CanCast(FistsOfFury) then
                Target:Cast(FistsOfFury);
                return;
            end
            -- Whirling Dragon Punch
            if Player:CanCast(WhirlingDragonPunch) then
                Player:Cast(WhirlingDragonPunch);
                return;
            end
            -- Rushing Jade Wind
            if RushingJadeWind:Exists() and (Player:Chi() > 1 or Player:Buff(Serenity)) and Player:CanCast(RushingJadeWind) then
                Player:Cast(RushingJadeWind);
                return;
            end
            -- Rising Sun Kick
            if Target:CanCast(RisingSunKick) then
                Target:Cast(RisingSunKick);
                return;
            end
            -- Chi Burst
            if module.IsOptionEnabled("Chi Wave, Chi Burst") and ChiBurst:Exists() and Player:Standing() >= ChiBurstStanding and Target:CanCast(ChiBurst) and #Player:UnitsInFrontRectangle(40, 5) >= module.GetOptionValue("Chi Wave, Zen Sphere, Chi Burst") then
                Target:Cast(ChiBurst);
                return;
            end
            -- Blackout Kick
            if not BlackoutKick:WasLastCast() and (Player:Chi() > 1 or Player:Buff(ComboBreaker) or Player:Buff(Serenity)) and Target:CanCast(BlackoutKick) then
                Target:Cast(BlackoutKick);
                return;
            end
            -- Chi Wave
            if module.IsOptionEnabled("Chi Wave, Chi Burst") and ChiWave:Exists() and Player:CanCast(ChiWave) then
                Target:Cast(ChiWave);
                return;
            end
            -- Artifact (Strike of the Windlord)
            if module.IsOptionEnabled("Strike of the Windlord") and (module.CooldownsAllowed() or module.GetOptionValue("Strike of the Windlord") == "Always") and StrikeoftheWindlord:Exists() and Target:CanCast(StrikeoftheWindlord) then
                Target:Cast(StrikeoftheWindlord);
                return;
            end
            -- Spinning Crane Kick
            if Player:Chi() > 4 and Player:CanCast(SpinningCraneKick) then
                Player:Cast(SpinningCraneKick);
                return;
            end
            -- Tiger Palm
            if (not TigerPalm:WasLastCast() or Player:Chi() < 2) and Target:CanCast(TigerPalm) then
                Target:Cast(TigerPalm);
                return;
            end
            -- CracklingJadeLightning if target is out of range
            if module.IsOptionEnabled("Crackling Jade Lightning") and not Player:IsWithinCastRange(Target, TigerPalm) and not Player:Channeling(CracklingJadeLightning) and Player:Standing() >= module.GetOptionValue("Crackling Jade Lightning") and Target:CanCast(CracklingJadeLightning) then
                Target:Cast(CracklingJadeLightning);
                return;
            end
            return;
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        if Player:Standing() >= 0.7 then
            -- Auto-Resuscitate Friends
            if module.IsOptionEnabled("Auto-Resuscitate Friends") then
                UnitNeedRes = Unit.Resurrect(Resuscitate);
                if UnitNeedRes and UnitNeedRes:CanCast(Resuscitate) then
                    UnitNeedRes:Cast(Resuscitate);
                    return;
                end
                if not UnitNeedRes then Unit:ResurrectCheck(true); end
            end
            -- Auto-Heal OutOfCombat
            if module.IsOptionEnabled("Auto-Heal OutOfCombat") then
                if Player:SpecialHealthPercentage() <= module.GetOptionValue("Auto-Heal OutOfCombat") and Player:CanCast(Effuse) then
                    Player:Cast(Effuse);
                    return;
                end
                -- TODO : Add Heal on Friends
            end
        end
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- ChiWave Pre-Combat
            if module.IsOptionEnabled("Chi Wave Pre-Combat") and ChiWave:Exists() and Player:CanCast(ChiWave) and Player:DistanceTo(Target) < 15 then
                Target:Cast(ChiWave);
                return;
            end
            if Target:CanCast(TigerPalm) then
                Target:Cast(TigerPalm);
                return;
            end
        end
        return;
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Holy Paladin
    local Rotation = {};
    module.SetRotation("_"..65, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshTables = 0, 0.1, 0; -- Combat Module Throttle
    -- Healers Specific
    local MainTank, MainTankTarget, OffTank, OffTankTarget, HealUnits, Lowest, CurrentBadDebuffs, BestTarget, ThisUnit;
    local Trinket1Units, Trinket2Units;
    -- Profile Specific
    local DispelUnit, HolyPrismUnitsTarget, HolyPrismUnitsMainTank, HolyPrismUnitsOffTank, LightOfDawnUnits, AvengingWrathUnits = nil, 0, 0, 0, 0, 0;
    local AuraMasteryUnits, TyrsDeliveranceUnits, HolyAvengerUnits = 0, 0, 0;
    local Enemies_30y, Enemies_15y, Enemies_10y, Enemies_8y, ThisSpell = {}, {}, {}, {}, nil;
    --- Initialize the rotation.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        LukewarmYakRoastBroth = Item(120293, false, false, true);
        DraenicChanneledManaPotion = Spell(156432, false, false, false);
        --Racials
        ArcaneTorrent = Spell(155145, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        AuraMastery = Spell(31821, false, false, true);
        AvengingWrath = Spell(31842, false, false, true);
        BeaconOfFaith = Spell(156910, false, false, true);
        BeaconOfLight = Spell(53563, false, false, true);
        BeaconOfTheLightbringer = Spell(197446);
        BeaconOfVirtue = Spell(200025, false, false, false);
        BestowFaith = Spell(223306, false, false, true);
        BlessingOfFreedom = Spell(1044, false, false, true);
        BlessingOfSacrifice = Spell(6940, false, false, true);
        BlessingOfProtection = Spell(1022, false, false, true);
        Cleanse = Spell(4987, false, false, true);
        Clemency = Spell(105922);
        CrusadersMight = Spell(196926);
        DivineProtection = Spell(498, false, false, true);
        DivinePurpose = Spell(197646);
        DivinePurposeDawn = Spell(216413);
        DivinePurposeShock = Spell(216411);
        DivineShield = Spell(642, false, false, true);
        FistOfJustice = Spell(105593, false, true, true);
        FlashOfLight = Spell(19750, false, false, false);
        Forbearance = Spell(25771);
        GiftOfTheNaaru = Spell(59547, false, false, true);
        HammerOfJustice = Spell(853, false, true, true);
        HolyAvenger = Spell(105809);
        HolyLight = Spell(82326, false, false, false);
        HolyPrismHeal = Spell(114165, false, false, true);
        HolyPrismDamage = Spell(114165, true, true, true);
        HolyShock = Spell(20473, false, false, true);
        HolyShockDamage = Spell(20473, true, true, true);
        InfusionOfLight = Spell(54149, false, false, true);
        JudgmentOfLight = Spell(183778);
        JudgmentOfLightDebuff = Spell(196941);
        LayOnHands = Spell(633, false, false, true);
        LightOfDawn = Spell(85222, false, false, false);
        LightOfTheMartyr = Spell(183998, false, false, true);
        LightsHammer = Spell(114158, false, false, true);
        Redemption = Spell(7328, false, false, true, true);
        RuleOfLaw = Spell(214202, false, false, true);
        SanctifiedWrath = Spell(53376);
        TyrsDeliverance = Spell(200652, false, false, false);
        -- Attacks
        Consecration = Spell(26573, false, false, true);
        CrusaderStrike = Spell(35395, true, true, true);
        HammerOfWrath = Spell(24275, true, true, true);
        Judgment = Spell(20271, true, true, true);
        JudgmentDebuff = Spell(214222);
        Rebuke = Spell(96231, true, true, true);

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Healing Settings");
        module.AddPage("Cooldowns Settings");
        module.AddPage("Offensive/Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        -- Add options to pages
        module.AddNewOption("General Settings", "Focus Assignation", 230, true, {2, "Main Tank", "Off Tank"}, nil, "Select which Tank slot should be given to the focussed unit.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Beacons (Light + Faith)", 230, true, {3, "Focus + Player", "Main + Focus", "Main + Off", "Main + Player", "Off + Focus", "Off + Player", "Player + Focus"}, nil, "Use Beacons handlers."..C.TOOLTIP_VALUE_1.."Define the two preferred units to use Beacons. If Beacon of Faith is not talented, Only the first unit will have a Beacon and the second unit will be the first fallback. Main and Off refers to the Tanks as they are displayed in the status frame."..C.TOOLTIP_HINT("If option is enabled but a valid target cannot be found to match the selection, the Beacon will fall back to the next unit in the priority. The priorities are: Main Tank, Off Tank, Focus, Player."));
        module.AddNewOption("General Settings", "Cleanse", 232, false, {1, "Auto", "High", "Normal"}, {0.2, 0, 1, 0.1}, "Use Cleanse to Dispel bad debuffs on allied units."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Auto").."Dispel Active Dispel Raid debuffs as High Priority and other not listed debuffs as Normal Priority."..C.TOOLTIP_SUBVALUE("High").."Dispel all debuffs as High Priority even before urgent cooldowns."..C.TOOLTIP_SUBVALUE("Normal").."Dispel all debuffs as Normal Priority after urgent cooldowns."..C.TOOLTIP_VALUE_2.."Define how long you want to wait before dispelling to look more human. This does not apply to Active Dispels Raid debuffs which will always be as soon as Global Cooldown ends."..C.TOOLTIP_HINT("Active Raid Dispels are based on an hardcoded list. Please report of any dispels you may encounter that requires specific strategies so that they can be properly added to the list."));
        module.AddNewOption("General Settings", "Redemption", 210, true, nil, nil, "Enable to use Redemption on dead friendly players while out of combat.");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Hammer Of Justice", 210, true, nil, nil, "Use Hammer of Justice to stun non-boss casting units");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {40, 20, 90, 5, 20}, {60}, "Will use Rebuke to interrupt the target when its cast time meets this % range.");
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range. "..C.TOOLTIP_HINT("Works only if Interrupt between % is enabled."));
        module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Healing Settings", "Common Healing Thresholds", "Green");
        module.AddNewOption("Healing Settings", "Bestow Faith", 222, true, {70, 0, 100, 1}, {50, 0, 100, 1}, "Use Bestow Faith."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Flash Of Light", 222, true, {50, 0, 100, 1}, {35, 0, 100, 1}, "Use Flash of Light."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Holy Light", 222, true, {90, 0, 100, 1}, {80, 0, 100, 1}, "Use Holy Light."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Holy Shock", 222, true, {95, 0, 100, 1}, {90, 0, 100, 1}, "Use Holy Shock."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Holy Prism", 222, true, {4, 1, 5, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Infusion Of Light", 230, false, {2, "Flash Of Light", "Holy Light"}, nil, "Enable to define a favorite spell to use with Infusion of Light procs. Disable to let the profile work as usual regarding of procs."..C.TOOLTIP_VALUE.."Choose which spell you want to use with Infusion of Light procs.");
        module.AddNewOption("Healing Settings", "Light's Hammer", 222, true, {3, 1, 10, 1}, {70, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Light Of Dawn", 222, true, {3, 1, 6, 1}, {92, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Light Of The Martyr", 222, true, {40, 0, 100, 1}, {25, 0, 100, 1}, "Use Light Of The Martyr."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Light Of The Martyr Options", 132, true, {1, "Anytime", "While Moving"}, {55, 0, 100, 1}, "More Light Of The Martyr options."..C.TOOLTIP_VALUE_1.."Define if you want to only use it while moving or anytime."..C.TOOLTIP_VALUE_2.."Player minimum Health threshold.");
        module.AddNewOption("Healing Settings", "Out Of Combat Healing", 210, true, nil, nil, "Allow Healing while Out of Combat.");
        module.AddSection("Healing Settings", "Active Healing", "Green");
        module.AddNewOption("Healing Settings", "Heal Target", 230, false, {1, "Known Unit", "Any Unit"}, nil, "Heal our current target if it is listed to be healed."..C.TOOLTIP_VALUE.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Known Unit").."Allow Heal Target to be used only when we are targetting a unit listed for it."..C.TOOLTIP_SUBVALUE("Any Unit").."Allow Heal Target to be used on any unit.");
        module.AddNewOption("Healing Settings", "Raid Debuffs", 220, true, {30, 0, 100, 1}, nil, "Use Holy Shock/Flash of Light on Debuffed units."..C.TOOLTIP_VALUE.."Helath threshold.");
        module.AddNewOption("Healing Settings", "Tank Debuffs", 220, true, {50, 0, 100, 1}, nil, "Use Holy Shock/Flash of Light on Debuffed tanks."..C.TOOLTIP_VALUE.."Helath threshold.");
        module.AddNewOption("Healing Settings", "Topping Heal", 220, true, {100, 0, 100, 1}, nil, "Use Holy Shock/Flash of Light on units to be topped."..C.TOOLTIP_VALUE.."Helath threshold.");

        module.AddSection("Cooldowns Settings", "Blessings", "Green");
        module.AddNewOption("Cooldowns Settings", "Blessing Of Protection", 232, true, {3, "Anyone", "Anyone Except Tanks", "Healers"}, {30, 1, 100, 1}, "Use Hand of Protection on a unit that has threath on it."..C.TOOLTIP_VALUE_1.."Select if you want to use Hand of Protection on Anyone, Anyone Except Tanks or only on Healers."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Blessing Of Sacrifice", 222, true, {50, 0, 100, 1}, {75, 30, 100, 1}, "Use Blessing of Sacrifice."..C.TOOLTIP_VALUE_1.."Unit Health threshold."..C.TOOLTIP_VALUE_2.."Player minimum Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Blessing Of Sacrifice Options", 133, true, {2, "Any Unit", "Tanks Only"}, {2, "Disabled", "Enabled"}, "More Blessing of Sacrifice options."..C.TOOLTIP_VALUE_1.."Which units should we consider valid for Blessing of Sacrifice."..C.TOOLTIP_VALUE_2.."Enable to sync Divine Protection with Blessing of Sacrifice.");
        module.AddSection("Cooldowns Settings", "Cooldowns", "Green");
        module.AddNewOption("Cooldowns Settings", "Aura Mastery", 222, true, {3, 1, 25, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Avenging Wrath", 222, true, {3, 1, 25, 1}, {60, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Beacon Of Virtue", 222, true, {3, 1, 5, 1}, {90, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Holy Avenger", 222, true, {3, 1, 25, 1}, {70, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Lay On Hands", 222, true, {25, 0, 100, 1}, {15, 0, 100, 1}, "Use Lay on Hands."..C.TOOLTIP_VALUE_1.."Health threshold to use on Tanks."..C.TOOLTIP_VALUE_2.."Health threshold to use on any Raid members.");
        module.AddNewOption("Cooldowns Settings", "Rule Of Law", 222, true, {4, 1, 25, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold. It will also be used without health checks if we have two charges."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Tyr's Deliverance", 222, true, {3, 1, 25, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddSection("Cooldowns Settings", "Common Cooldowns", "Green");
        module.AddNewOption("Cooldowns Settings", "Soft Cooldowns Units", 120, true, {3, 1, 25, 1}, nil, "Number of units that needs to be under thresholds to use Racials and Trinkets with Health.");
        module.AddNewOption("Cooldowns Settings", "Use Racials", 220, true, {80, 0, 100, 1}, nil, "Use Racials."..C.TOOLTIP_VALUE.."Mana threshold under which we want to use Arcane Torrent.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 1", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 1 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always") .." Use Always."..C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 2", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 2 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always") .." Use Always."..C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");

        module.AddSection("Offensive/Defensive Settings", "Offensive DPS", "Green");
        module.AddPresetOption("TargetAttack");
        module.AddNewOption("Offensive/Defensive Settings", "DPS", 220, true, {95, 0, 100, 1}, nil, "Enables DPS options."..C.TOOLTIP_VALUE.."Will only DPS if the Lowest unit is above DPS health treshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Consecration", 222, true, {2, 1, 10, 1}, {1, 1, 10, 1}, "Use Consecration."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be within 8 yards of Player to use as High Priority."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be within 8 yards of Player to use as Low Priority."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Crusader Strike", 210, true, nil, nil, "Use Crusader Strike in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Hammer Of Wrath", 210, false, nil, nil, "Use Hammer Of Wrath in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Holy Prism Damage", 222, true, {3, 1, 5, 1}, {100, 1, 100, 1}, "Use Holy Prism on Player."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be within 15 yards of Player to use.."..C.TOOLTIP_VALUE_2.."Health Threshold to use on player."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Holy Shock Damage", 210, false, nil, nil, "Use Holy shock in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Light's Hammer Damage", 222, true, {3, 1, 10, 1}, {100, 1, 100, 1}, "Use Light's Hammer on Player."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be within 10 yards of Player to use.."..C.TOOLTIP_VALUE_2.."Health Threshold to use on player."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Judgment", 210, true, nil, nil, "Use Judgment in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddSection("Offensive/Defensive Settings", "Offensive Healing", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Crusader's Might", 230, true, {1, "Auto", "High Priority", "Low Priority"}, nil, "Use Crusader Strike to lower remaining Cooldown on Holy Shock and Light of Dawn."..C.TOOLTIP_VALUE_1.."Select High Priority to do this very soon in the rotation or Low Priority to use as filler. Auto will use as High Priority if we have two charges of Crusader Strike and as Low Priority if we have only one charge."..C.TOOLTIP_HINT("This will be used regardless of Offensive DPS settings."));
        module.AddNewOption("Offensive/Defensive Settings", "Judgment Of Light", 233, true, {1, "Auto", "Focus", "Main Tank", "Off Tank", "Target"}, {1, "High Priority", "Low Priority"}, "Use Judgment to apply Judgment of Light."..C.TOOLTIP_VALUE_1.."Select which unit you want to apply Judgment of Light on."..C.TOOLTIP_SUBVALUE("Auto").."Auto will apply Judgment of Light following this priority: Main Tank Target, Off Tank Target, Focus, Target. It will attempt to put it on different target if priority target is already debuffed."..C.TOOLTIP_VALUE_2.."Select High Priority to do this very soon in the rotation or Low Priority to use as filler."..C.TOOLTIP_HINT("This will be used regardless of Offensive DPS settings."));
        module.AddNewOption("Offensive/Defensive Settings", "Judgment Of Light Cycle", 222, true, {6, 1, 10, 1}, {3, 0, 25, 0.1}, "Use Judgment Of Light Cycle."..C.TOOLTIP_VALUE_1.."Amount of debuffs to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddSection("Offensive/Defensive Settings", "Defensive", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Divine Protection", 220, true, {50, 1, 100, 1}, nil, "Use Divine Protection."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Divine Shield", 220, true, {20, 1, 100, 1}, nil, "Use Divine Shield."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Gift Of The Naaru", 220, true, {30, 1, 100, 1}, nil, "Use Gift Of The Naaru on ourself."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Healers Specific
        module.AddOutput("|cFF9A2EFEMain Tank:");
        module.AddOutput("|cFF9A2EFEOff Tank:");
        module.AddOutput("|cFF9A2EFEBad Debuffs:");
        module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:Buff(DraenicChanneledManaPotion) or not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Define Main Tanks
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end


    function Rotation:Defensives ()
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Healing Item") and Player:HealthPercentage() <= module.GetOptionValue("Healing Item") then
            if HealingTonic:IsUsable() then
                Healthstone:Use(Player);
            elseif Healthstone:IsUsable() then
                HealingTonic:Use(Player);
            end
        end
        -- Divine Protection
        if DivineProtection:Exists() and module.IsOptionEnabled("Divine Protection") and Player:CanCast(DivineProtection) and Player:SpecialHealthPercentage() <= module.GetOptionValue("Divine Protection") then
            Player:Cast(DivineProtection);
        end
        -- Divine Shield
        if DivineShield:Exists() and module.IsOptionEnabled("Divine Shield") and Player:CanCast(DivineShield) and Player:SpecialHealthPercentage() <= module.GetOptionValue("Divine Shield") and not Player:DebuffAny(Forbearance) then
            Player:Cast(DivineShield);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        -- Rebuke
        Player:UseInterrupt(nil, ArcaneTorrent);
    end

    -- Hand Of Protection
    local Option1, Option2;
    local function BlessingOfProtectionHandler ()
        if module.IsOptionEnabled("Blessing Of Protection") and not BlessingOfProtection:IsOnCooldown() then
            Option1, Option2 = module.GetOptionValue("Blessing Of Protection"), module.GetSecondOptionValue("Blessing Of Protection");
            for i = 1, #HealUnits do
                ThisUnit = HealUnits[i];
                if ThisUnit:ThreatSituation() == 3 and not ThisUnit:DebuffAny(Forbearance) then
                    if (Option1 == "Anyone" or (Option1 == "Anyone Except Tanks" and not ThisUnit:IsTank()) or (Option1 == "Healers" and ThisUnit:IsHealer())) and ThisUnit:SpecialHealthPercentage() <= Option2 and ThisUnit:CanCast(BlessingOfProtection) then
                        module.Bug("Blessing of Protection on "..ThisUnit:Name());
                        ThisUnit:Cast(BlessingOfProtection);
                        return;
                    end
                end
            end
        end
    end

    -- Active Healing Heal Target handler
    local function HealTarget (ThisUnit)
        -- Holy Shock
        if HolyShock:Exists() and ThisUnit:CanHeal(HolyShock) then
            module.Bug("Heal Target - Holy Shock");
            ThisUnit:Cast(HolyShock);
            return;
        end
        -- Flash of Light
        if FlashOfLight:Exists() and ThisUnit:CanHeal(FlashOfLight) then
            module.Bug("Heal Target - Flash of Light");
            ThisUnit:Cast(FlashOfLight);
            return;
        end
    end

    -- Get Tanks Status
    local TanksStatus, MainTankTanking, OffTankTanking = {Main = {IsTanking = module.GetTime()},Off = {IsTanking = module.GetTime()}};
    local function RefreshTanksStatus ()
        TanksStatus = {
            Main = {IsTanking = MainTank and MainTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Main.IsTanking},
            Off = {IsTanking = OffTank and OffTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Off.IsTanking}
        };
        MainTankTanking = module.GetTime() - TanksStatus.Main.IsTanking < 3 or false;
        OffTankTanking = module.GetTime() - TanksStatus.Off.IsTanking < 3 or false;
    end

    local InvertBeacons, BeaconOfLightFallBack, BeaconOfFaithFallBack;
    local BeaconOption, Unit1, Unit2, Unit3, Unit4;
    local function BeaconsHandler ()
        if not BeaconOfVirtue:Exists() and module.IsOptionEnabled("Beacons (Light + Faith)") then
            InvertBeacons, BeaconOfLightFallBack, BeaconOfFaithFallBack = nil, false, false;
            -- First check The Beacon of Light
            if BeaconOfLight:Exists() and not BeaconOfLight:IsOnCooldown() then
                BeaconOption = module.GetOptionValue("Beacons (Light + Faith)");
                -- Apply Beacon to Unit1 and Unit2, if one of these cannot be found, apply to Unit3 and if no Unit3 then apply to Self
                --"Focus + Player", "Main + Focus", "Main + Off", "Main + Player", "Off + Focus", "Off + Player", "Player + Focus"
                if BeaconOption == "Focus + Player" then
                    Unit1, Unit2, Unit3, Unit4 = Focus, Player, MainTank, OffTank;
                elseif BeaconOption == "Main + Focus" then
                    Unit1, Unit2, Unit3, Unit4 = MainTank, Focus, OffTank, Player;
                elseif BeaconOption == "Main + Off" then
                    Unit1, Unit2, Unit3, Unit4 = MainTank, OffTank, Focus, Player;
                elseif BeaconOption == "Main + Player" then
                    Unit1, Unit2, Unit3, Unit4 = MainTank, Player, Focus, OffTank;
                elseif BeaconOption == "Off + Focus" then
                    Unit1, Unit2, Unit3, Unit4 = OffTank, Focus, MainTank, Player;
                elseif BeaconOption == "Off + Player" then
                    Unit1, Unit2, Unit3, Unit4 = OffTank, Player, MainTank, Focus;
                elseif BeaconOption == "Player + Focus" then
                    Unit1, Unit2, Unit3, Unit4 = Player, Focus, MainTank, OffTank;
                end
                -- Unit1
                if Unit1 and Unit1:CanHeal(FlashOfLight) then
                    InvertBeacons = Unit1:Buff(BeaconOfFaith);
                    if not InvertBeacons and not Unit1:Buff(BeaconOfLight) and Unit1:CanCast(BeaconOfLight) then
                        module.Bug("Beacon of Light - Unit1 (Normal)");
                        Unit1:Cast(BeaconOfLight);
                        return;
                    end
                else
                    BeaconOfLightFallBack = true;
                end
                -- Unit2
                if BeaconOfFaith:Exists() then
                    if Unit2 and Unit2:CanHeal(FlashOfLight) then
                        if InvertBeacons then
                            if not Unit2:Buff(BeaconOfLight) and Unit2:CanCast(BeaconOfLight) then
                                module.Bug("Beacon of Light - Unit2 (Invert Beacons)");
                                Unit2:Cast(BeaconOfLight);
                                return;
                            end
                        else
                            if not Unit2:Buff(BeaconOfFaith) and not Unit2:Buff(BeaconOfLight) and Unit2:CanCast(BeaconOfFaith) then
                                module.Bug("Beacon of Faith - Unit2 (Normal)");
                                Unit2:Cast(BeaconOfFaith);
                                return;
                            end
                        end
                    else
                        BeaconOfFaithFallBack = true;
                    end
                else
                    -- Unit2 Fall Back
                    if Unit2 and Unit2:CanHeal(FlashOfLight) then
                        if BeaconOfLightFallBack then
                            if Unit2:Buff(BeaconOfLight) then
                                BeaconOfLightFallBack = false;
                            else
                                if not Unit2:Buff(BeaconOfLight) and Unit2:CanCast(BeaconOfLight) then
                                    BeaconOfLightFallBack = false;
                                    module.Bug("Beacon of Light - Unit2 (Fall Back)");
                                    Unit2:Cast(BeaconOfLight);
                                    return;
                                end
                            end
                        end
                    end
                end
                -- Unit3 Fall Back
                if Unit3 and Unit3:CanHeal(FlashOfLight) then
                    if BeaconOfLightFallBack then
                        if Unit3:Buff(BeaconOfLight) then
                            BeaconOfLightFallBack = false;
                        else
                            if not Unit3:Buff(BeaconOfLight) and not Unit3:Buff(BeaconOfFaith) and Unit3:CanCast(BeaconOfLight) then
                                BeaconOfLightFallBack = false;
                                module.Bug("Beacon of Light - Unit3 (Fall Back)");
                                Unit3:Cast(BeaconOfLight);
                                return;
                            end
                        end
                    end
                    if BeaconOfFaithFallBack then
                        if Unit3:Buff(BeaconOfFaith) then
                            BeaconOfFaithFallBack = false;
                        else
                            if not Unit3:Buff(BeaconOfFaith) and not Unit3:Buff(BeaconOfLight) and Unit3:CanCast(BeaconOfFaith) then
                                BeaconOfFaithFallBack = false;
                                module.Bug("Beacon of Faith - Unit3 (Fall Back)");
                                Unit3:Cast(BeaconOfFaith);
                                return;
                            end
                        end
                    end
                end
                -- Unit4 Fall Back
                if Unit4 and Unit4:CanHeal(FlashOfLight) then
                    if BeaconOfLightFallBack then
                        if not Unit4:Buff(BeaconOfLight) and not Unit4:Buff(BeaconOfFaith) and Unit4:CanCast(BeaconOfLight) then
                            BeaconOfLightFallBack = false;
                            module.Bug("Beacon of Light - Unit4 (Fall Back)");
                            Unit4:Cast(BeaconOfLight);
                            return;
                        end
                    end
                    if BeaconOfFaithFallBack then
                        if not Unit4:Buff(BeaconOfFaith) and not Unit4:Buff(BeaconOfLight) and Unit4:CanCast(BeaconOfFaith) then
                            BeaconOfLightFallBack = false;
                            module.Bug("Beacon of Faith - Unit4 (Fall Back)");
                            Unit4:Cast(BeaconOfFaith);
                            return;
                        end
                    end
                end
            end
        end
    end


    local function JudgmentOfLightHandler (Priority)
        -- Judgment of Light
        if JudgmentOfLight:Exists() and module.IsOptionEnabled("Judgment Of Light") and not Judgment:IsOnCooldown() and (module.GetSecondOptionValue("Judgment Of Light") == "High Priority" or Priority ~= "High") then
            Option1 = module.GetOptionValue("Judgment Of Light");
            -- Main Tank Target
            if Option1 == "Auto" or Option1 == "Main Tank" then
                if MainTankTarget and MainTankTarget:Exists() and not MainTankTarget:Debuff(JudgmentOfLightDebuff) and MainTankTarget:CanCast(Judgment) then
                    module.Bug("Judgment Of Light - Main Tank Target");
                    MainTankTarget:Cast(Judgment);
                    return;
                end
            end
            -- Off Tank Target
            if Option1 == "Auto" or Option1 == "Off Tank" then
                if OffTankTarget and OffTankTarget:Exists() and not OffTankTarget:Debuff(JudgmentOfLightDebuff) and OffTankTarget:CanCast(Judgment) then
                    module.Bug("Judgment Of Light - Off Tank Target");
                    OffTankTarget:Cast(Judgment);
                    return;
                end
            end
            -- Focus
            if Option1 == "Auto" or Option1 == "Focus" then
                if Focus and Focus:Exists() and not Focus:Debuff(JudgmentOfLightDebuff) and Focus:CanCast(Judgment) then
                    module.Bug("Judgment Of Light - Focus");
                    Focus:Cast(Judgment);
                    return;
                end
            end
            -- Target
            if Option1 == "Auto" or Option1 == "Target" then
                if Target and Target:Exists() and not Target:Debuff(JudgmentOfLightDebuff) and Target:CanCast(Judgment) then
                    module.Bug("Judgment Of Light - Target");
                    Target:Cast(Judgment);
                    return;
                end
            end
            -- Cycle
            if module.IsOptionEnabled("Judgment Of Light Cycle") and JudgmentOfLightUnit and JudgmentOfLightUnit:CanCast(Judgment) then
                module.Bug("Judgment Of Light - Cycle");
                JudgmentOfLightUnit:Cast(Judgment);
                return;
            end
        end
    end

    local function CrusadersMightHandler (Priority)
        if CrusaderStrike:Exists() and CrusadersMight:Exists() and module.IsOptionEnabled("Crusader's Might") and not CrusaderStrike:IsOnCooldown() and (HolyShock:IsOnCooldown() or LightOfDawn:IsOnCooldown()) then
            if module.GetOptionValue("Crusader's Might") == "High Priority" or Priority == "Low" or (module.GetOptionValue("Crusader's Might") == "Auto" and ((Priority == "High" and (CrusaderStrike:Charges() >= 2 or CrusaderStrike:Charges() >= 1 and CrusaderStrike:Recharge() < 1)))) then
                if BestTarget and BestTarget:CanCast(CrusaderStrike) then
                    module.Bug("Crusader Strike - Crusader's Might "..Priority.." Priority");
                    BestTarget:Cast(CrusaderStrike);
                    return;
                end
            end
        end
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
    -- Init + Dispels

        -- Find best unit to attack
        if Target:Exists() and Target:CanCast(CrusaderStrike) then
            BestTarget = Target;
        elseif MainTankTarget and MainTankTarget:CanCast(CrusaderStrike) then
            BestTarget = MainTankTarget;
        elseif OffTankTarget and OffTankTarget:CanCast(CrusaderStrike) then
            BestTarget = OffTankTarget;
        elseif Mouseover:Exists() and Mouseover:CanCast(CrusaderStrike) then
            BestTarget = Mouseover;
        elseif MainTankTarget and MainTankTarget:CanCast(Judgment) then
            BestTarget = MainTankTarget;
        elseif OffTankTarget and OffTankTarget:CanCast(Judgment) then
            BestTarget = OffTankTarget;
        else
            BestTarget = Target;
        end

        -- Refresh tables every 0.5 seconds
        if RefreshTables < module.GetTime() then
            -- Common
            HealUnits = Player:GroupUnitsAvailableForHealing(100, true, 40, true);
            CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits);
            if CurrentBadDebuffs ~= nil then
                module.SetOutput("|cFF9A2EFEBad Debuffs:", #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff);
            end
            DispelUnit = Unit.Dispel(Cleanse);
            Lowest = Unit.Lowest(MainTank, OffTank);
            RefreshTanksStatus();
            -- Profile Specific
            AuraMasteryUnits = AuraMastery:Exists() and not AuraMastery:IsOnCooldown() and #Player:HealUnitsAround(module.GetSecondOptionValue("Aura Mastery"), 10) or 0;
            AvengingWrathUnits = AvengingWrath:Exists() and not AvengingWrath:IsOnCooldown() and #Player:HealUnitsAround(module.GetSecondOptionValue("Avenging Wrath"), 40) or 0;
            BeaconOfVirtueUnit = BeaconOfVirtue:Exists() and module.IsOptionEnabled("Beacon Of Virtue") and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Beacon Of Virtue"), module.GetSecondOptionValue("Beacon Of Virtue"), 30) or nil;
            Enemies_30y = Player:EnemiesWithinDistance(30); -- Judgment Of Light
            Enemies_15y = HolyPrismDamage:Exists() and Player:FilterEnemiesByDistance(Enemies_30y, 15, true) or {}; -- Holy Prism
            Enemies_10y = Player:FilterEnemiesByDistance(Enemies_30y, 10); -- Hammer Of Justice
            Enemies_8y = Player:FilterEnemiesByDistance(Enemies_30y, 8, true); -- Consecration
            HolyAvengerUnits = HolyAvenger:Exists() and not HolyAvenger:IsOnCooldown() and #Player:HealUnitsAround(module.GetSecondOptionValue("Holy Avenger"), 40) or 0;
            HolyPrismUnitsTarget = HolyPrismDamage:Exists() and not HolyPrismDamage:IsOnCooldown() and Target and Target:CanCast(HolyPrismDamage) and #Target:HealUnitsAround(module.GetSecondOptionValue("Holy Prism"), 15) or 0;
            HolyPrismUnitsMainTank = HolyPrismDamage:Exists() and not HolyPrismDamage:IsOnCooldown() and MainTankTarget and MainTankTarget:CanCast(HolyPrismDamage) and #MainTankTarget:HealUnitsAround(module.GetSecondOptionValue("Holy Prism"), 15) or 0;
            HolyPrismUnitsOffTank = HolyPrismDamage:Exists() and not HolyPrismDamage:IsOnCooldown() and OffTankTarget and OffTankTarget:CanCast(HolyPrismDamage) and #OffTankTarget:HealUnitsAround(module.GetSecondOptionValue("Holy Prism"), 15) or 0;
            JudgmentOfLightUnit = JudgmentOfLight:Exists() and not Judgment:IsOnCooldown() and Unit.DotCycle(Enemies_30y, Judgment, JudgmentOfLightDebuff, 40, "Judgment Of Light Cycle", false, true) or nil;
            LightOfDawnUnits = LightOfDawn:Exists() and not LightOfDawn:IsOnCooldown() and #Player:UnitsInFrontCone(BeaconOfTheLightbringer:Exists() and 19 or 15, 90, true, Player:Buff(DivinePurposeDawn) and 95 or module.GetSecondOptionValue("Light Of Dawn")) or 0;
            RuleOfLawUnits = RuleOfLaw:Exists() and not RuleOfLaw:IsOnCooldown() and #Player:HealUnitsAround(module.GetSecondOptionValue("Rule Of Law"), 60) or 0;
            TyrsDeliveranceUnits = TyrsDeliverance:Exists() and not TyrsDeliverance:IsOnCooldown() and #Player:HealUnitsAround(module.GetSecondOptionValue("Tyr's Deliverance"), 40) or 0;
            Trinket1Units = module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 1"), 40) or 0;
            Trinket2Units = module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 2"), 40) or 0;
            -- Bad Debuffs
            RefreshTables = module.GetTime() + 0.5;
        end

        -- Dispels Handling
        Player:DispelHandler(Cleanse, "Cleanse", DispelUnit, CurrentBadDebuffs.Dispel, "High");

        -- Hammer of Justice - Stun Casting
        if HammerOfJustice:Exists() and module.IsOptionEnabled("Hammer Of Justice") and not HammerOfJustice:IsOnCooldown() then
            for i = 1, #Enemies_10y do
                ThisUnit = Enemies_10y[i];
                if not ThisUnit:IsBoss() and not ThisUnit:IsDeadOrGhost() and ThisUnit:IsInCombat() and ThisUnit:CanCast(HammerOfJustice) and ThisUnit:IsCasting() and Player:CanAttack(ThisUnit) then
                    module.Bug("Hammer Of Justice - Interrupt ");
                    ThisUnit:Cast(HammerOfJustice);
                    return;
                end
            end
        end

        -- Beacons
        BeaconsHandler();
        JudgmentOfLightHandler("High");
        if BestTarget then
            -- DPS Management
            if module.IsOptionEnabled("DPS") and (not Lowest or Lowest:HealthPercentage() >= module.GetOptionValue("DPS")) and (not MainTank or MainTank:HealthPercentage() >= module.GetOptionValue("DPS")) and (not OffTank or OffTank:HealthPercentage() >= module.GetOptionValue("DPS")) and BestTarget:IsInCombat() then
                -- Consecration
                if Consecration:Exists() and module.IsOptionEnabled("Consecration") and #Enemies_8y >= module.GetOptionValue("Consecration") and Player:CanCast(Consecration) then
                    module.Bug("DPS - Consecration - High Priority");
                    Player:Cast(Consecration);
                    return;
                end
                -- Holy Prism
                if HolyPrismHeal:Exists() and module.IsOptionEnabled("Holy Prism Damage") and #Enemies_15y >= module.GetOptionValue("Holy Prism Damage") and Player:SpecialHealthPercentage() <= module.GetSecondOptionValue("Holy Prism Damage") and Player:CanCast(HolyPrismHeal) then
                    module.Bug("DPS - Holy Prism");
                    Player:Cast(HolyPrismHeal);
                    return;
                end
                -- Light's Hammer
                if LightsHammer:Exists() and module.IsOptionEnabled("Light's Hammer Damage") and not Player:IsMoving() and not IsFalling() and #Enemies_10y >= module.GetOptionValue("Light's Hammer Damage") and Player:SpecialHealthPercentage() <= module.GetSecondOptionValue("Light's Hammer Damage") and Player:CanCast(LightsHammer) then
                    module.Bug("DPS - Light's Hammer");
                    Player:Cast(LightsHammer);
                    return;
                end
                -- Judgment
                if Judgment:Exists() and module.IsOptionEnabled("Judgment") and BestTarget:CanCast(Judgment) then
                    module.Bug("DPS - Judgment");
                    BestTarget:Cast(Judgment);
                    return;
                end
                -- Hammer Of Wrath
                if HammerOfWrath:Exists() and module.IsOptionEnabled("Hammer Of Wrath") and not BestTarget:Debuff(JudgmentDebuff) and BestTarget:CanCast(HammerOfWrath) then
                    module.Bug("DPS - Hammer Of Wrath");
                    BestTarget:Cast(HammerOfWrath);
                    return;
                end
                -- Holy Shock
                if HolyShockDamage:Exists() and module.IsOptionEnabled("Holy Shock Damage") and BestTarget:CanCast(HolyShockDamage) then
                    module.Bug("DPS - Holy Shock");
                    BestTarget:Cast(HolyShockDamage);
                    return;
                end
                -- Crusader Strike
                if CrusaderStrike:Exists() and module.IsOptionEnabled("Crusader Strike") and (CrusaderStrike:Charges() == 2 or BestTarget:Debuff(JudgmentDebuff) or (CrusaderStrike:Charges() >= 1 and CrusaderStrike:Recharge() < 3)) and BestTarget:CanCast(CrusaderStrike) then
                    module.Bug("DPS - Crusader Strike");
                    BestTarget:Cast(CrusaderStrike);
                    return;
                end
                -- Hammer Of Wrath
                if HammerOfWrath:Exists() and module.IsOptionEnabled("Hammer Of Wrath") and BestTarget:CanCast(HammerOfWrath) then
                    module.Bug("DPS - Hammer Of Wrath");
                    BestTarget:Cast(HammerOfWrath);
                    return;
                end
                -- Consecration - Low Priority
                if Consecration:Exists() and module.IsOptionEnabled("Consecration") and #Enemies_8y >= module.GetSecondOptionValue("Consecration") and Player:CanCast(Consecration) then
                    module.Bug("DPS - Consecration - Low Priority");
                    Player:Cast(Consecration);
                    return;
                end
            end
        end
    -- Cooldowns

        if module.CooldownsAllowed() and Player:IsInCombat() then
            -- Racials with Specific Handlers
            if module.IsOptionEnabled("Use Racials") then
                if ArcaneTorrent:Exists() and Player:PowerPercentage() < module.GetOptionValue("Use Racials") and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent);
                    return;
                end
            end
            -- Trinkets with specific handlers
            if module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 1"), module.GetSecondOptionValue("Use Trinket 1");
                if Option1 == "Always" or (Option1 == "Health" and Trinket1Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 1")) then
                    Trinket1:UseInventory();
                end
            end
            if module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 2"), module.GetSecondOptionValue("Use Trinket 2");
                if Option1 == "Always" or (Option1 == "Health" and Trinket2Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 2")) then
                    Trinket2:UseInventory();
                end
            end

            -- Rule of Law
            if RuleOfLaw:Exists() and module.IsOptionEnabled("Rule Of Law") and RuleOfLaw:TimeSinceCast() >= 10 and (RuleOfLawUnits >= module.GetOptionValue("Rule Of Law") or RuleOfLaw:Charges() >= 2) and Player:CanCast(RuleOfLaw) then
                RuleOfLaw.LastCastTime = module.GetTime();
                Player:Cast(RuleOfLaw);
            end

            -- Avenging Wrath
            if AvengingWrath:Exists() and module.IsOptionEnabled("Avenging Wrath") and AvengingWrathUnits >= module.GetOptionValue("Avenging Wrath") and Player:CanCast(AvengingWrath) then
                Player:Cast(AvengingWrath);
            end

            -- Holy Avenger
            if HolyAvenger:Exists() and module.IsOptionEnabled("Holy Avenger") and HolyAvengerUnits >= module.GetOptionValue("Holy Avenger") and Player:CanCast(HolyAvenger) then
                Player:Cast(HolyAvenger);
            end

            -- Aura Mastery
            if AuraMastery:Exists() and module.IsOptionEnabled("Aura Mastery") and AuraMasteryUnits >= module.GetOptionValue("Aura Mastery") and Player:CanCast(AuraMastery) then
                Player:Cast(AuraMastery);
            end

            -- Lay on Hands
            if LayOnHands:Exists() and module.IsOptionEnabled("Lay On Hands") then
                if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Lay On Hands") and not MainTank:DebuffAny(Forbearance) and MainTank:CanHeal(LayOnHands) then
                    module.Bug("Lay On Hands - MainTank");
                    MainTank:Cast(LayOnHands);
                    return;
                end
                if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Lay On Hands") and not OffTank:DebuffAny(Forbearance) and OffTank:CanHeal(LayOnHands) then
                    module.Bug("Lay On Hands - OffTank");
                    OffTank:Cast(LayOnHands);
                    return;
                end
                if Lowest and Lowest:SpecialHealthPercentage() < module.GetSecondOptionValue("Lay On Hands") and not Lowest:DebuffAny(Forbearance) and Lowest:CanHeal(LayOnHands) then
                    module.Bug("Lay On Hands - Lowest");
                    Lowest:Cast(LayOnHands);
                    return;
                end
            end

            -- Blessing of Sacrifice
            if BlessingOfSacrifice:Exists() and module.IsOptionEnabled("Blessing Of Sacrifice") and Player:SpecialHealthPercentage() >= module.GetSecondOptionValue("Blessing Of Sacrifice") then
                -- Sync with Divine Protection if option is enabled
                local function DivineProtectionHandler ()
                    if module.GetSecondOptionValue("Blessing Of Sacrifice Options") == "Enabled" and Player:CanCast(DivineProtection) then
                        Player:Cast(DivineProtection);
                    end
                end
                -- MainTank
                if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Blessing Of Sacrifice") and not MainTank:BuffAny(BlessingOfFreedom) and not MainTank:BuffAny(BlessingOfProtection) and not MainTank:BuffAny(BlessingOfSacrifice) and MainTank:CanCast(BlessingOfSacrifice) then
                    DivineProtectionHandler();
                    module.Bug("Blessing Of Sacrifice - MainTank");
                    MainTank:Cast(BlessingOfSacrifice);
                    return;
                end
                -- OffTank
                if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Blessing Of Sacrifice") and not OffTank:BuffAny(BlessingOfFreedom) and not OffTank:BuffAny(BlessingOfProtection) and not OffTank:BuffAny(BlessingOfSacrifice) and OffTank:CanCast(BlessingOfSacrifice) then
                    DivineProtectionHandler();
                    module.Bug("Blessing Of Sacrifice - OffTank");
                    OffTank:Cast(BlessingOfSacrifice);
                    return;
                end
                -- Any Unit with option
                if module.GetOptionValue("Blessing Of Sacrifice") == "Any Unit" and Lowest and Lowest:SpecialHealthPercentage() <= module.GetOptionValue("Blessing Of Sacrifice") and not Lowest:BuffAny(BlessingOfFreedom) and not Lowest:BuffAny(BlessingOfProtection) and not Lowest:BuffAny(BlessingOfSacrifice) and Lowest:CanCast(BlessingOfSacrifice) then
                    DivineProtectionHandler();
                    module.Bug("Blessing Of Sacrifice - OffTank");
                    Lowest:Cast(BlessingOfSacrifice);
                    return;
                end
            end

            BlessingOfProtectionHandler();

            -- Tyr's Deliverance
            if TyrsDeliverance:Exists() and module.IsOptionEnabled("Tyr's Deliverance") and TyrsDeliveranceUnits >= module.GetOptionValue("Tyr's Deliverance") and Player:CanCast(TyrsDeliverance) then
                Player:Cast(TyrsDeliverance);
                return;
            end
        end
        -- Dispels Handling
        Player:DispelHandler(Cleanse, "Cleanse", DispelUnit, CurrentBadDebuffs.Dispel, "Normal");

    -- Active Healing
    -- Active Healing Heal Target handler
        if Target:CanHeal(FlashOfLight) and module.IsOptionEnabled("Heal Target") and (module.GetOptionValue("Heal Target") == 2 or (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed())) then
            HealTarget(Target);
            return;
        end
    -- Healing Rotation
        -- Beacon Of Virtue
        if BeaconOfVirtue:Exists() and module.IsOptionEnabled("Beacon Of Virtue") then
            if BeaconOfVirtueUnit and BeaconOfVirtueUnit:CanCast(BeaconOfVirtue) then
                BeaconOfVirtueUnit:Cast(BeaconOfVirtue);
                return;
            end
        end

        -- Divine Purpose - Light Of Dawn - 216413
        if LightOfDawn:Exists() and Player:Buff(DivinePurposeDawn) and module.IsOptionEnabled("Light Of Dawn") and (LightOfDawnUnits >= module.GetOptionValue("Light Of Dawn") or Player:BuffRemains(DivinePurposeDawn) < 3) and Player:CanCast(LightOfDawn) then
            module.Bug("Light of Dawn - Divine Purpose");
            Player:Cast(LightOfDawn);
            return;
        end

        -- Divine Purpose - Holy Shock - 216411
        if HolyShock:Exists() and Player:Buff(DivinePurposeShock) and module.IsOptionEnabled("Holy Shock") and Player:BuffRemains(DivinePurposeShock) < 3 then
            if MainTank and MainTank:SpecialHealthPercentage() <= 95 and MainTank:CanHeal(HolyShock) then
                MainTank:Cast(HolyShock);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= 95 and OffTank:CanHeal(HolyShock) then
                OffTank:Cast(HolyShock);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= 95 and Lowest:CanHeal(HolyShock) then
                Lowest:Cast(HolyShock);
                return;
            end
        end

        -- Holy Prism on Target / MainTank Target / OffTank Target
        if HolyPrismDamage:Exists() and module.IsOptionEnabled("Holy Prism") then
            local BestPrismUnits = HolyPrismUnitsTarget >= HolyPrismUnitsMainTank and HolyPrismUnitsTarget >= HolyPrismUnitsOffTank and HolyPrismUnitsTarget or HolyPrismUnitsMainTank > HolyPrismUnitsTarget and HolyPrismUnitsMainTank >= HolyPrismUnitsOffTank and HolyPrismUnitsMainTank or HolyPrismUnitsOffTank > HolyPrismUnitsTarget and HolyPrismUnitsOffTank >= HolyPrismUnitsMainTank and HolyPrismUnitsOffTank;
            local HolyPrismUnitsValue, HolyPrismHealthValue = module.GetOptionValue("Holy Prism"), module.GetSecondOptionValue("Holy Prism");
            if BestPrismUnits >= module.GetOptionValue("Holy Prism") then
                if HolyPrismUnitsTarget >= BestPrismUnits then
                    Target:Cast(HolyPrismDamage);
                    return;
                elseif MainTankTarget and HolyPrismUnitsMainTank >= BestPrismUnits then
                    MainTankTarget:Cast(HolyPrismDamage);
                    return;
                elseif OffTankTarget and HolyPrismUnitsOffTank >= BestPrismUnits then
                    OffTankTarget:Cast(HolyPrismDamage);
                    return;
                end
            end
        end

        -- Light Of Dawn
        if LightOfDawn:Exists() and module.IsOptionEnabled("Light Of Dawn") and LightOfDawnUnits >= module.GetOptionValue("Light Of Dawn") and Player:CanCast(LightOfDawn) then
            module.Bug("Light of Dawn - Divine Purpose");
            Player:Cast(LightOfDawn);
            return;
        end

        -- Holy Shock
        if HolyShock:Exists() and module.IsOptionEnabled("Holy Shock") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Holy Shock") and MainTank:CanHeal(HolyShock) then
                MainTank:Cast(HolyShock);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Holy Shock") and OffTank:CanHeal(HolyShock) then
                OffTank:Cast(HolyShock);
                return;
            elseif  Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Holy Shock") and Lowest:CanHeal(HolyShock) then
                Lowest:Cast(HolyShock);
                return;
            end
        end

        -- Light Of The Martyr
        if LightOfTheMartyr:Exists() and module.IsOptionEnabled("Light Of The Martyr") and (module.GetOptionValue("Light Of The Martyr Options") == "Anytime" or Player:IsMoving()) and Player:HealthPercentage() >= module.GetSecondOptionValue("Light Of The Martyr Options") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetSecondOptionValue("Light Of The Martyr") and MainTank:GUID() ~= Player:GUID() and MainTank:CanHeal(LightOfTheMartyr) then
                MainTank:Cast(LightOfTheMartyr);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetSecondOptionValue("Light Of The Martyr") and OffTank:GUID() ~= Player:GUID() and OffTank:CanHeal(LightOfTheMartyr) then
                OffTank:Cast(LightOfTheMartyr);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetOptionValue("Light Of The Martyr") and Lowest:GUID() ~= Player:GUID() and Lowest:CanHeal(LightOfTheMartyr) then
                Lowest:Cast(LightOfTheMartyr);
                return;
            end
        end

        -- Bestow Faith
        if BestowFaith:Exists() and module.IsOptionEnabled("Bestow Faith") and not BestowFaith:IsOnCooldown() then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Bestow Faith") and MainTank:CanHeal(BestowFaith) then
                MainTank:Cast(BestowFaith);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Bestow Faith") and OffTank:CanHeal(BestowFaith) then
                OffTank:Cast(BestowFaith);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Bestow Faith") and Lowest:CanHeal(BestowFaith) then
                Lowest:Cast(BestowFaith);
                return;
            end
        end

        CrusadersMightHandler("High");

        -- Light's Hammer
        if LightsHammer:Exists() and module.IsOptionEnabled("Light's Hammer") and Player:CanCast(LightsHammer) then
            local ValueLightsHammer = module.GetSecondOptionValue("Light's Hammer");
            local BestHealUnits = {};
            for i = 1, #HealUnits do
                local ThisUnit = HealUnits[i]
                if ThisUnit:CanHeal(HolyLight) and not ThisUnit:IsMoving() then
                    TheseHealUnits = ThisUnit:GroupUnitsAvailableForHealing(ValueLightsHammer, true, 12, true);
                    if #TheseHealUnits >= module.GetOptionValue("Light's Hammer") and #TheseHealUnits > #BestHealUnits then
                        BestHealUnits = TheseHealUnits;
                    end
                end
            end
            if #BestHealUnits >= module.GetOptionValue("Light's Hammer") then
                Player:CastGroundHeal(LightsHammer, BestHealUnits);
                return;
            end
        end

        JudgmentOfLightHandler("Low");

        -- Flash Of Light
        if FlashOfLight:Exists() and module.IsOptionEnabled("Flash Of Light") then
            ThisSpell = Player:Buff(InfusionOfLight) and module.IsOptionEnabled("Infusion Of Light") and module.GetOptionValue("Infusion Of Light") == "Holy Light" and HolyLight or FlashOfLight;
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Flash Of Light") and MainTank:CanHeal(ThisSpell) then
                MainTank:Cast(ThisSpell);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Flash Of Light") and OffTank:CanHeal(ThisSpell) then
                OffTank:Cast(ThisSpell);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Flash Of Light") and Lowest:CanHeal(ThisSpell) then
                Lowest:Cast(ThisSpell);
                return;
            end
        end

    -- Bad Debuffs - Tank
        if module.IsOptionEnabled("Tank Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            local BestHoTUnit, BestHoTUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Tanks do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Tanks[i], CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(FlashOfLight) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
                if ThisUnit:CanCast(FlashOfLight) and (BestHoTUnit == nil or ThisUnitHealth < BestHoTUnitHealth) then
                    BestHoTUnit, BestHoTUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if module.IsOptionEnabled("Tank Debuffs") and BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Tank Debuffs") then
                if BestUnit:CanCast(HolyShock) and ShouldShock then
                    BestUnit:Cast(HolyShock);
                    module.Bug("Holy Shock on "..BestUnit:Name().." to heal debuff");
                    return;
                end
                if BestUnit:CanCast(FlashOfLight) then
                    BestUnit:Cast(FlashOfLight);
                    module.Bug("Flash Of Light on "..BestUnit:Name().." to heal debuff");
                    return;
                end
            end
        end
    -- Bad Debuffs - Debuffs
        if module.IsOptionEnabled("Raid Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            local BestHoTUnit, BestHoTUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Debuff do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Debuff[i], CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(FlashOfLight) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
                if ThisUnit:CanCast(FlashOfLight) and (BestHoTUnit == nil or ThisUnitHealth < BestHoTUnitHealth) then
                    BestHoTUnit, BestHoTUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if module.IsOptionEnabled("Raid Debuffs") and BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Raid Debuffs") then
                if BestUnit:CanCast(HolyShock) and ShouldShock then
                    BestUnit:Cast(HolyShock);
                    module.Bug("Holy Shock on "..BestUnit:Name().." to heal debuff");
                    return;
                end
                if BestUnit:CanCast(FlashOfLight) then
                    BestUnit:Cast(FlashOfLight);
                    module.Bug("Flash Of Light on "..BestUnit:Name().." to heal debuff");
                    return;
                end
            end
        end

        -- Bad Debuffs - Topping
        if module.IsOptionEnabled("Active Healing") and module.IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Top do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Top[i], CurrentBadDebuffs.Top[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(FlashOfLight) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil then
                if module.IsOptionEnabled("Topping Heal") and BestUnitHealth <= module.GetOptionValue("Topping Heal") then
                    if BestUnit:CanCast(HolyShock) and ShouldShock then
                        BestUnit:Cast(HolyShock);
                        module.Bug("Holy Shock on "..BestUnit:Name().." to top it");
                        return;
                    elseif BestUnit:CanCast(FlashOfLight) then
                        BestUnit:Cast(FlashOfLight);
                        module.Bug("Flash Of Light on "..BestUnit:Name().." to top it");
                        return;
                    end
                end
            end
        end

        CrusadersMightHandler("Low");

        -- Holy Light
        if HolyLight:Exists() and module.IsOptionEnabled("Holy Light") then
            ThisSpell = Player:Buff(InfusionOfLight) and module.IsOptionEnabled("Infusion Of Light") and module.GetOptionValue("Infusion Of Light") == "Flash Of Light" and FlashOfLight or HolyLight;
            if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Holy Light") and Lowest:CanHeal(ThisSpell) then
                Lowest:Cast(ThisSpell);
                return;
            elseif MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Holy Light") and MainTank:CanHeal(ThisSpell) then
                MainTank:Cast(ThisSpell);
                return;
            elseif OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Holy Light") and OffTank:CanHeal(ThisSpell) then
                OffTank:Cast(ThisSpell);
                return;
            end
        end
        SpamPrevention = module.GetTime() + 0.2;
    end



    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Redemption
        if module.IsOptionEnabled("Redemption") and Unit.ResurrectCycle(Redemption) then
            return;
        end
        -- Proving Grounds Food
        if MainTank and MainTank:CreatureID() == 72218 and Player:PowerPercentage() < 95 and not Player:IsMoving() and LukewarmYakRoastBroth:InStock() and not LukewarmYakRoastBroth:IsOnCooldown() then
            LukewarmYakRoastBroth:Use(Player);
        end
        -- Out of Combat Healing
        if module.IsOptionEnabled("Out Of Combat Healing") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Protection Paladin
    local Rotation = {};
    module.SetRotation("_"..66, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local Enemies_30y, Enemies_8y, TargetEnemies_8y, NumEnemies = {}, {}, {}, 0; -- Enemies

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        --Racials
        ArcaneTorrent = Spell(69179, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, resurrect)
        AegisOfLight = Spell(204150);
        ArdentDefender = Spell(31850, false, false, true);
        AvengersShield = Spell(31935, true, true, true);
        AvengingWrath = Spell(31884, false, false, true);
        BastionOfLight = Spell(204035, false, false, true);
        BlessingOfProtection = Spell(1022, false, false, true);
        BlessingOfSacrifice = Spell(6940, false, false, true);
        CleanseToxins = Spell(213644, false, false, true);
        ConsecratedHammer = Spell(203785);
        Consecration = Spell(26573, false, false, true);
        DivineShield = Spell(642, false, false, true);
        EyeOfTyr = Spell(209202, false, false, true);
        FlashOfLight = Spell(19750, false, false, false);
        Forbearance = Spell(25771);
        GuardianOfAncientKings = Spell(86659, false, false, true);
        HammerOfJustice = Spell(853, false, true, true);
        HammerOfTheRighteous = Spell(53595, true, true, true);
        HandOfReckoning = Spell(62124, false, true, true);
        HandOfTheProtector = Spell(213652, false, false, true);
        Judgment = Spell(20271, false, true, true);
        LayOnHands = Spell(633, false, false, true);
        LightOfTheProtector = Spell(184092, false, false, true);
        Rebuke = Spell(96231, true, true, true);
        Redemption = Spell(7328, false, false, false, true);
        ShieldOfTheRighteous = Spell(53600, true, true, true);
        ShieldOfTheRighteousBuff = Spell(132403);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {6, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest", "Untanked"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_SUBVALUE("Untanked").."Integrate tanking logic that will priorise the untaked units."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.TauntManagerOptions("Hand Of Reckoning");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddOption("General Settings", "Redemption", true, "Resurrect dead allies with Redemption while Out of Combat.");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Pummel to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Avenging Wrath", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Avenging Wrath."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Avenger's Shield", 130, true, {4, "Disable", "Interrupt Only", "Normal", "Optimal"}, nil, "Choose Avenger's Shield mode."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Disabled", true).."Never use Avenger's Shield."..C.TOOLTIP_SUBVALUE("Interrupt Only").."Use on the fartest unit that is casting as high priority."..C.TOOLTIP_SUBVALUE("Normal").."Use normally in the rotation but not for interrupts."..C.TOOLTIP_SUBVALUE("Optimal").."Use on the fartest unit that is casting as high priority. If there is no unit casting, use normally in the rotation.");
        module.AddNewOption("Offensive Settings", "Consecration", 220, true, {1, 1, 10, 1}, nil, "Use Consecration."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range.");
        module.AddNewOption("Offensive Settings", "Eye Of Tyr", 220, true, {100, 1, 100, 1}, nil, "Use Eye Of Tyr."..C.TOOLTIP_VALUE.."Health threshold."..C.TOOLTIP_HINT("Set to 100 to use Always."));
        module.AddNewOption("Offensive Settings", "Hammer Of The Righteous", 220, true, {3, 1, 10, 1}, nil, "Use Hammer of the Righteous as high priority."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, true, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddNewOption("Defensive Settings", "Hand Of The Protector", 220, true, {30, 1, 100, 1}, nil, "Use Hand Of The Protector on self."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Light Of The Protector", 220, true, {30, 1, 100, 1}, nil, "Use Light Of The Protector."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Shield Of The Righteous", 232, true, {2, "Normal", "Prevent Capping"}, {40, 1, 100, 1}, "Use Shield of the Righteous."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Normal", true).."Only use when health is lower than threshold."..C.TOOLTIP_SUBVALUE("Prevent Capping", true).."Use automatically as soon as we are at max charges."..C.TOOLTIP_VALUE_2.."Health threshold to use.");
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Ardent Defender", 220, true, {20, 1, 100, 1}, nil, "Use Ardent Defender."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Bastion Of Light", 210, true, nil, nil, "Use Bastion Of Light when we do not have remaining Shield Of The Righteous charges.");
        module.AddNewOption("Defensive Settings", "Guardian Of Ancient Kings", 220, true, {30, 1, 100, 1}, nil, "Use Guardian of Ancient Kings."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Hand of Protection Buff (Auto Cancel)
        HandofProtection = Spell(1022, false, false, true);
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Channeling(AegisOfLight) then
            return;
        end

        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pot BossMod") and Target:Exists() and BMPullTime() < 7 then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Rebuke, ArcaneTorrent);
    end


    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Guardian Of Ancient Kings
        if GuardianOfAncientKings:Exists() and module.IsOptionEnabled("Guardian Of Ancient Kings") and Player:HealthPercentage() <= module.GetOptionValue("Guardian Of Ancient Kings") and Player:CanCast(GuardianOfAncientKings) then
            Player:Cast(GuardianOfAncientKings);
        end
        -- Ardent Defender
        if ArdentDefender:Exists() and module.IsOptionEnabled("Ardent Defender") and Player:HealthPercentage() <= module.GetOptionValue("Ardent Defender") and Player:CanCast(ArdentDefender) then
            Player:Cast(ArdentDefender);
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end


    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(HammerOfTheRighteous, false) or Unit.Target;
        -- Bastion Of Light
        if BastionOfLight:Exists() and module.IsOptionEnabled("Bastion Of Light") and ShieldOfTheRighteous:Charges() == 0 and Player:CanCast(BastionOfLight) then
            Player:Cast(BastionOfLight);
            return;
        end
        -- Shield Of The Righteous
        if ShieldOfTheRighteous:Exists() and ShieldOfTheRighteous:TimeSinceCast() > 2 and (Player:HealthPercentage() <= module.GetSecondOptionValue("Shield Of The Righteous") or (module.GetOptionValue("Shield Of The Righteous") == "Prevent Capping" and ShieldOfTheRighteous:Charges() == 3)) and Player:BuffRemains(ShieldOfTheRighteousBuff) < 1 and Target:CanCast(ShieldOfTheRighteous) then
            Target:Cast(ShieldOfTheRighteous);
            ShieldOfTheRighteous.LastCastTime = module.GetTime();
            return;
        end
        -- Light Of The Protector
        if not HandOfTheProtector:Exists() and LightOfTheProtector:Exists() and module.IsOptionEnabled("Light Of The Protector") and Player:HealthPercentage() <= module.GetOptionValue("Light Of The Protector") and Player:CanCast(LightOfTheProtector) then
            Player:Cast(LightOfTheProtector);
            return;
        end
        -- Hand Of The Protector
        if HandOfTheProtector:Exists() and module.IsOptionEnabled("Hand Of The Protector") and Player:HealthPercentage() <= module.GetOptionValue("Hand Of The Protector") and Player:CanCast(HandOfTheProtector) then
            Player:Cast(HandOfTheProtector);
            return;
        end
    end

    function Rotation:Opening ()
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") then
            if Player:Potion("Armor", Potion) then Potion = true; end
        end
    end

    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then

            -- Enemies Check
            if module.UseAOE() then
                Enemies_30y = Player:EnemiesWithinDistance(40, false);
                Enemies_8y = Player:FilterEnemiesByDistance(Enemies_30y, 8, false);
                TargetEnemies_8y = Target:EnemiesWithinDistance(8, true);
                NumEnemies = #Enemies_8y;
            else
                NumEnemies, Enemies_8y, TargetEnemies_8y = 1, {}, {};
            end

            -- Provoke
            if Player:TauntManager(HandOfReckoning, "Hand Of Reckoning", Target, Enemies_30y) then
                return;
            end
            -- Avenger's Shield - AoE Interrupt
            if (module.GetOptionValue("Avenger's Shield") == "Optimal" or module.GetOptionValue("Avenger's Shield") == "Interrupt Only") and not AvengersShield:IsOnCooldown() then
                local FartestUnit, FartestUnitDistance, ThisUnit = nil, 0, nil;
                for i = 1, #Enemies_30y do
                    ThisUnit = Enemies_30y[i];
                    if not ThisUnit:IsDeadOrGhost() and ThisUnit:IsInCombat() and ThisUnit:IsCasting() and ThisUnit:IsInterruptible() and ThisUnit:CanCast(AvengersShield) and Player:CanAttack(ThisUnit) and (FartestUnit == nil or FartestUnitDistance < Player:DistanceTo(ThisUnit)) then
                        FartestUnit = ThisUnit;
                        FartestUnitDistance = Player:DistanceTo(ThisUnit);
                    end
                end
                if FartestUnit ~= nil then
                    module.Bug("Avenger's Shield - Interrupt");
                    FartestUnit:Cast(AvengersShield);
                    return;
                end
            end

            if Player:IsWithinCastRange(Target, HammerOfTheRighteous) then
                --- Cooldowns ---
                Player:UseTrinkets();
                -- Avenging Wrath
                if AvengingWrath:Exists() and module.IsOptionEnabled("Avenging Wrath") and (module.CooldownsAllowed() or module.GetOptionValue("Avenging Wrath") == "Always") and Player:CanCast(AvengingWrath) then
                    Player:Cast(AvengingWrath);
                    return;
                end
            end

            -- Rotation
            -- Eye Of Tyr
            if EyeOfTyr:Exists() and module.IsOptionEnabled("Eye Of Tyr") and Player:HealthPercentage() <= module.GetOptionValue("Eye Of Tyr") and Player:IsWithinCastRange(Target, ShieldOfTheRighteous) and Player:CanCast(EyeOfTyr) then
                Player:Cast(EyeOfTyr);
                return;
            end
            -- Avenger's Shield
            if AvengersShield:Exists() and (module.GetOptionValue("Avenger's Shield") == "Normal" or module.GetOptionValue("Avenger's Shield") == "Optimal") and Target:CanCast(AvengersShield) then
                Target:Cast(AvengersShield);
                return;
            end
            -- Consecration
            if Consecration:Exists() and module.IsOptionEnabled("Consecration") and NumEnemies >= module.GetOptionValue("Consecration") and Player:IsWithinCastRange(Target, ShieldOfTheRighteous) and Player:CanCast(Consecration) then
                Player:Cast(Consecration);
                return;
            end
            -- Hammer Of The Righteous
            if HammerOfTheRighteous:Exists() and module.IsOptionEnabled("Hammer Of The Righteous") and #TargetEnemies_8y >= module.GetOptionValue("Hammer Of The Righteous") and Target:CanCast(HammerOfTheRighteous) then
                Target:Cast(HammerOfTheRighteous);
                return;
            end
            -- Judgment
            if Judgment:Exists() and Target:CanCast(Judgment) then
                Target:Cast(Judgment);
                return;
            end
            -- Hammer Of The Righteous
            if HammerOfTheRighteous:Exists() and module.IsOptionEnabled("Hammer Of The Righteous") and (ConsecratedHammer:Exists() or HammerOfTheRighteous:Charges() == 2 or (HammerOfTheRighteous:Charges() == 1 and HammerOfTheRighteous:Recharge() < 2)) and Target:CanCast(HammerOfTheRighteous) then
                Target:Cast(HammerOfTheRighteous);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(HammerOfTheRighteous, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Resuscitate
        if module.IsOptionEnabled("Resuscitate") and Unit.ResurrectCycle(Redemption) then
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Retribution Paladin
    local Rotation = {};
    module.SetRotation("_"..70, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local Enemies_8y, WakeOfAshesUnits, NumEnemies = {}, 0, 0; -- Enemies
    local MainTank, MainTankTarget, OffTank, OffTankTarget, Lowest

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        --Racials
        ArcaneTorrent = Spell(69179, false, false, true);
        GiftOfTheNaaru = Spell(59542, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, resurrect)
        AvengingWrath = Spell(31884, false, false, true);
        BladeOfJustice = Spell(184575, true, true, true);
        BladeOfWrath = Spell(202270, true, true, true);
        BlessingOfProtection = Spell(1022, false, false, true);
        CleanseToxins = Spell(213644, false, false, true);
        Consecration = Spell(205228, false, false, true);
        CrusaderStrike = Spell(35395, true, true, true);
        DivineHammer = Spell(198034, false, false, true);
        DivinePurpose = Spell(223819);
        DivineShield = Spell(642, false, false, true);
        DivineStorm = Spell(53385, false, false, true);
        ExecutionSentance = Spell(213757, true, true, true);
        EyeForAnEye = Spell(205191, false, false, true);
        FlashOfLight = Spell(19750, false, false, false);
        Forbearance = Spell(25771);
        GreaterBlessingOfKings = Spell(203538, false, false, true);
        GreaterBlessingOfMight = Spell(203528, false, false, true);
        GreaterBlessingOfWisdom = Spell(203539, false, false, true);
        HammerOfJustice = Spell(853, false, true, true);
        HandOfHindrance = Spell(183218, true, true, true);
        HandOfReckoning = Spell(62124, false, true, true);
        Judgment = Spell(20271, false, true, true);
        JudgmentDebuff = Spell(197277);
        JusticarsVengeance = Spell(215661, true, true, true);
        LayOnHands = Spell(633, false, false, true);
        Rebuke = Spell(96231, true, true, true);
        Redemption = Spell(7328, false, false, false, true);
        SanctifiedWrath = Spell(224668, false, false, true);
        ShieldOfVengeance = Spell(184662, false, false, true);
        TemplarsVerdict = Spell(85256, true, true, true);
        WakeOfAshes = Spell(205273, false, false, true);
        WordOfGlory = Spell(210191, false, false, true);
        Zeal = Spell(217020, true, true, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Greater Blessings", 210, true, nil, nil, "Apply Greater Blessings on ourself while not in combat.");
        module.AddNewOption("General Settings", "Redemption", 210, true, nil, nil, "Resurrect dead allies with Redemption while Out of Combat.");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Pummel to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Avenging Wrath", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Avenging Wrath."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Sanctified Wrath", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Sanctified Wrath."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Consecration", 220, true, {1, 1, 10, 1}, nil, "Use Consecration."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range.");
        module.AddNewOption("Offensive Settings", "Divine Storm", 220, true, {3, 1, 10, 1}, nil, "Use Divine Storm."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range.");
        module.AddNewOption("Offensive Settings", "Wake Of Ashes", 220, true, {1, 1, 10, 1}, nil, "Use Wake Of Ashes."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Flash Of Light Self", 222, true, {30, 1, 100, 1}, {80, 1, 100, 1}, "Use Healing Touch on ourself."..C.TOOLTIP_VALUE_1.."Health threshold while In Combat."..C.TOOLTIP_VALUE_2.."Health threshold while Out of Combat.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, true, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Divine Shield", 220, true, {20, 1, 100, 1}, nil, "Use Divine Shield."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Eye For An Eye", 220, true, {40, 1, 100, 1}, nil, "Use Eye For An Eye."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Lay On Hands", 222, true, {25, 0, 100, 1}, {15, 0, 100, 1}, "Use Lay on Hands." .. C.TOOLTIP_VALUE_1 .. "Health threshold to use on Tanks." .. C.TOOLTIP_VALUE_2 .. "Health threshold to use on any Raid members.");
        module.AddNewOption("Defensive Settings", "Shield Of Vengeance", 220, true, {50, 1, 100, 1}, nil, "Use Shield Of Vengeance."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Word Of Glory", 220, true, {40, 1, 100, 1}, nil, "Use Word Of Glory."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Hand of Protection Buff (Auto Cancel)
        HandofProtection = Spell(1022, false, false, true);
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:InVehicle() or Player:IsEating() then
            return;
        end
        -- Check mounted status and only return if the current mount is not the talent buff.
        if Player:IsMounted() and not Player:Buff(Spell(221883)) and not Player:Buff(Spell(221885)) and not Player:Buff(Spell(221886)) and not Player:Buff(Spell(221887)) then
            return;
        end

        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pot BossMod") and Target:Exists() and BMPullTime() < 7 then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Rebuke, ArcaneTorrent);
    end


    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Divine Shield
        if DivineShield:Exists() and module.IsOptionEnabled("Divine Shield") and Player:HealthPercentage() <= module.GetOptionValue("Divine Shield") and Player:CanCast(DivineShield) then
            Player:Cast(DivineShield);
            return;
        end
        -- Eye For An Eye
        if EyeForAnEye:Exists() and module.IsOptionEnabled("Eye For An Eye") and Player:HealthPercentage() <= module.GetOptionValue("Eye For An Eye") and Player:CanCast(EyeForAnEye) then
            Player:Cast(EyeForAnEye);
            return;
        end
        -- Shield Of Vengeance
        if ShieldOfVengeance:Exists() and module.IsOptionEnabled("Shield Of Vengeance") and Player:HealthPercentage() <= module.GetOptionValue("Shield Of Vengeance") and Player:CanCast(ShieldOfVengeance) then
            Player:Cast(ShieldOfVengeance);
            return;
        end
        -- Word Of Glory
        if WordOfGlory:Exists() and module.IsOptionEnabled("Word Of Glory") and Player:HolyPower() >= 3 and Player:HealthPercentage() <= module.GetOptionValue("Word Of Glory") and Player:CanCast(WordOfGlory) then
            Player:Cast(WordOfGlory);
            return;
        end
        -- Lay on Hands
        if module.IsOptionEnabled("Lay On Hands") then
            MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();
            Lowest = Unit.Lowest(MainTank, OffTank);
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Lay On Hands") and not MainTank:DebuffAny(Forbearance) and MainTank:CanHeal(LayOnHands) then
                module.Bug("Lay On Hands - MainTank");
                MainTank:Cast(LayOnHands);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Lay On Hands") and not OffTank:DebuffAny(Forbearance) and OffTank:CanHeal(LayOnHands) then
                module.Bug("Lay On Hands - OffTank");
                OffTank:Cast(LayOnHands);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() < module.GetSecondOptionValue("Lay On Hands") and not Lowest:DebuffAny(Forbearance) and Lowest:CanHeal(LayOnHands) then
                module.Bug("Lay On Hands - Lowest");
                Lowest:Cast(LayOnHands);
                return;
            end
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end


    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(CrusaderStrike, false) or Unit.Target;
    end

    function Rotation:Opening ()
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") then
            if Player:Potion("Strength", Potion) then Potion = true; end
        end
    end

    local function GreaterBlessings ()
        if module.IsOptionEnabled("Greater Blessings") then
            if GreaterBlessingOfKings:Exists() and Player:BuffRemains(GreaterBlessingOfKings) < 300 and Player:CanCast(GreaterBlessingOfKings) then
                Player:Cast(GreaterBlessingOfKings);
                return;
            end
            if GreaterBlessingOfWisdom:Exists() and Player:BuffRemains(GreaterBlessingOfWisdom) < 300 and Player:CanCast(GreaterBlessingOfWisdom) then
                Player:Cast(GreaterBlessingOfWisdom);
                return;
            end
            if GreaterBlessingOfMight:Exists() and Player:BuffRemains(GreaterBlessingOfMight) < 300 and Player:CanCast(GreaterBlessingOfMight) then
                Player:Cast(GreaterBlessingOfMight);
                return;
            end
        end
    end

    function Rotation:Combat ()
        -- Flash Of Light
        if FlashOfLight:Exists() and Player:Standing() > 1.5 and module.IsOptionEnabled("Flash Of Light Self") and Player:HealthPercentage() <= module.GetOptionValue("Flash Of Light Self") and Player:CanCast(FlashOfLight) then
            Player:Cast(FlashOfLight);
            return;
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then

            -- Enemies Check
            if module.UseAOE() then
                Enemies_8y = Player:EnemiesWithinDistance(8, true);
                WakeOfAshesUnits = module.IsOptionEnabled("Wake Of Ashes") and #Player:UnitsInFrontCone(12, 140) or 0; -- Frontal Cone.
                NumEnemies = #Enemies_8y;
            else
                NumEnemies, Enemies_8y, WakeOfAshesUnits = 1, {}, 1;
            end

            if Player:IsWithinCastRange(Target, CrusaderStrike) then
                --- Cooldowns ---
                Player:UseTrinkets();
                -- Avenging Wrath
                if AvengingWrath:Exists() and not SanctifiedWrath:Exists() and module.IsOptionEnabled("Avenging Wrath") and (module.CooldownsAllowed() or module.GetOptionValue("Avenging Wrath") == "Always") and Player:CanCast(AvengingWrath) then
                    Player:Cast(AvengingWrath);
                    return;
                end
                -- Sanctified Wrath
                if SanctifiedWrath:Exists() and module.IsOptionEnabled("Sanctified Wrath") and (module.CooldownsAllowed() or module.GetOptionValue("Sanctified Wrath") == "Always") and Player:CanCast(SanctifiedWrath) then
                    Player:Cast(SanctifiedWrath);
                    return;
                end
            end
            -- Rotation
            -- Judgment
            if Judgment:Exists() and Target:CanCast(Judgment) and Player:HolyPower() >= 5 then
                Target:Cast(Judgment);
                return;
            end
            if (Target:Debuff(JudgmentDebuff) and Player:HolyPower() >= 3) or Player:HolyPower() >= 5 or Player:Buff(DivinePurpose) or (Player:HolyPower() >= 3 and WakeOfAshes:Exists() and WakeOfAshesUnits >= module.GetOptionValue("Wake Of Ashes") and Player:CanCast(WakeOfAshes)) then

                -- Divine Storm
                if DivineStorm:Exists() and module.IsOptionEnabled("Divine Storm") and NumEnemies >= module.GetOptionValue("Divine Storm") and Player:CanCast(DivineStorm) then
                    Player:Cast(DivineStorm);
                    return;
                -- Execution Sentance
                elseif ExecutionSentance:Exists() and Target:CanCast(ExecutionSentance) then
                    Target:Cast(ExecutionSentance);
                    return;
                -- Justicar's Vengeance
                elseif JusticarsVengeance:Exists() and Player:Buff(DivinePurpose) and Target:CanCast(JusticarsVengeance) then
                    Target:Cast(JusticarsVengeance);
                    return;
                -- Templars Verdict
                elseif TemplarsVerdict:Exists() and Target:CanCast(TemplarsVerdict) then
                    Target:Cast(TemplarsVerdict);
                    return;
                end
            end
            -- Wake Of Ashes
            if WakeOfAshes:Exists() and Player:HolyPower() <= 1 and WakeOfAshesUnits >= module.GetOptionValue("Wake Of Ashes") and Player:CanCast(WakeOfAshes) then
                Player:Cast(WakeOfAshes);
                return;
            end
            -- Blade Of Justice
            if BladeOfJustice:Exists() and not BladeOfWrath:Exists() and not DivineHammer:Exists() and Player:HolyPower() <= 3 and Target:CanCast(BladeOfJustice) then
                Target:Cast(BladeOfJustice);
                return;
            end
            -- Blade Of Wrath
            if BladeOfWrath:Exists() and Player:HolyPower() <= 3 and Target:CanCast(BladeOfWrath) then
                Target:Cast(BladeOfWrath);
                return;
            end
            -- Divine Hammer
            if DivineHammer:Exists() and NumEnemies >= 1 and Player:CanCast(DivineHammer) then
                Player:Cast(DivineHammer);
                return;
            end
            -- Crusader Strike
            if CrusaderStrike:Exists() and not Zeal:Exists() and (CrusaderStrike:Charges() == 2 or (CrusaderStrike:Charges() == 1 and CrusaderStrike:Recharge() < 3)) and Target:CanCast(CrusaderStrike) then
                Target:Cast(CrusaderStrike);
                return;
            end
            -- Zeal
            if Zeal:Exists() and (Zeal:Charges() == 2 or (Zeal:Charges() == 1 and Zeal:Recharge() < 3)) and Target:CanCast(Zeal) then
                Target:Cast(Zeal);
                return;
            end
            -- Crusader Strike
            if CrusaderStrike:Exists() and not Zeal:Exists() and CrusaderStrike:Charges() >= 1 and Target:CanCast(CrusaderStrike) then
                Target:Cast(CrusaderStrike);
                return;
            end
            -- Zeal
            if Zeal:Exists() and Zeal:Charges() >= 1 and Target:CanCast(Zeal) then
                Target:Cast(Zeal);
                return;
            end
            -- Consecration
            if Consecration:Exists() and module.IsOptionEnabled("Consecration") and NumEnemies >= module.GetOptionValue("Consecration") and Player:IsWithinCastRange(Target, CrusaderStrike) and Player:CanCast(Consecration) then
                Player:Cast(Consecration);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(CrusaderStrike, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Blessings
        GreaterBlessings();
        -- Flash Of Light
        if FlashOfLight:Exists() and Player:Standing() > 1.5 and module.IsOptionEnabled("Flash Of Light Self") and Player:HealthPercentage() <= module.GetSecondOptionValue("Flash Of Light Self") and Player:CanCast(FlashOfLight) then
            Player:Cast(FlashOfLight);
            return;
        end
        -- Resuscitate
        if module.IsOptionEnabled("Redemption") and Unit.ResurrectCycle(Redemption) then
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Discipline Priest
    local Rotation = {};
    module.SetRotation("_"..256, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshTables = 0, 0.1, 0; -- Combat Module Throttle
    -- Proving Grounds Handlers
    local Friendlies, LavaUnit, BlastUnit, AquaUnit2, AquaUnit
    -- Healers Specific
    local MainTank, MainTankTarget, OffTank, OffTankTarget, HealUnits, Lowest, CurrentBadDebuffs, BestTarget, DispelWait, DispelUnit;
    -- Trinkets + Racials Handlers
    local Option1, Option2, Trinket1Units, Trinket2Units, RacialsUnits;
    -- Active Healing
    local BestUnit, BestUnitHealth, BestShieldUnit, BestShieldUnitHealth, ThisUnit, ThisUnitHealth = nil, 100, nil, 100, nil, 100;
    -- Profile Specific
    local HaloUnits, HaloEmergencyUnits, CascadeUnits, DivineStarUnits, MendedPlayers, BestHealUnits, BestTank, RaptureUnits;
    local ShieldUnit, ShieldPIUnit, NovaHealingUnits, DispelUnit, PoHNormalUnit, PoHWithEAUnit, PoHWithPIUnit, AtonementUnits;
    local BestAtonementUnit, BestAtonementUnitHealth, RadianceUnits, LightsWrathUnits, AtonedUnits = nil, 100, 0, 0, 0;

    --- Initialize the rotation.
    function Rotation:Initialize ()
        module.UpdateSettings();

        -- ID, Requires Facing, Hostile, Instant
        -- Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);
        GiftOfTheNaaru = Spell(59544, false, false, true);

        -- Items
        DraenicChanneledManaPotion = Spell(156432, false, false, false);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);
        LukewarmYakRoastBroth = Item(120293, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);

        -- Spells
        AngelicFeather = Spell(121536, false, false, true); -- lvl 30 talent
        AngelicFeatherBuff = Spell(121557, false, false, true); -- lvl 30 talent
        Atonement = Spell(194384, false, false, true);
        Barrier = Spell(62618, false, false, true);
        BodyAndSoul = Spell(64129); -- lvl 30 talent
        BodyAndSoulBuff = Spell(65081); -- lvl 30 talent
        ClarityOfWill = Spell(152118, false, false, false);
        DispelMagic = Spell(528, false, false, true);
        DivineStar = Spell(110744, true, false, true); -- lvl 90 talent
        Fade = Spell(586, false, false, true);
        Halo = Spell(120517, false, false, true); -- lvl 90 talent
        LightsWrath = Spell(207946, true, true, false);
        MassDispel =  Spell(32375, false, false, true);
        Mindbender = Spell(123040, false, true, true); -- lvl 60 talent
        Pain = Spell(589, false, true, true);
        PainSuppression = Spell(33206, false, false, true);
        PenanceDamage = Spell(47540, true, true, true);
        PenanceHeal = Spell(47540, false, false, true); -- Requires The Penitent
        Plea = Spell(200829, false, false, true);
        PowerInfusion = Spell(10060, false, false, true); -- lvl 75 talent
        Purify = Spell(527, false, false, true);
        PurgeTheWicked = Spell(204197, true, true, true); -- lvl 100 talent
        PurgeTheWickedDebuff = Spell(204213, false, true, true); -- lvl 100 talent
        Radiance = Spell(194509, false, false, false);
        Rapture = Spell(47536, false, false, true);
        Resurrection = Spell(2006, false, false, false, true);
        Schism = Spell(214621, true, true, false);
        ShadowCovenant = Spell(204065, false, false, false); -- lvl 100 talent
        Shadowfiend = Spell(34433, true, true, true);
        ShadowMend = Spell(186263, false, false, true);
        Shield = Spell(17, false, false, true);
        Smite = Spell(585, true, true, false);
        Solace = Spell(129250, true, true, true); -- lvl 60 talent
        ThePenitent = Spell(200347, false, false, true); -- lvl 15 talent

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Healing Settings");
        module.AddPage("Cooldowns Settings");
        module.AddPage("Offensive/Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        -- Add options to pages
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable for Cooldowns to be saved for Bosses");
        module.AddNewOption("General Settings", "Focus Assignation", 230, true, {2, "Main Tank", "Off Tank"}, nil, "Select which Tank slot should be given to the focussed unit.");
        module.AddNewOption("General Settings", "Purify", 232, false, {1, "Auto", "High", "Normal"}, {0.2, 0, 1, 0.1}, "Use Purify to Dispel bad debuffs on allied units."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Auto").."Dispel Active Dispel Raid debuffs as High Priority and other not listed debuffs as Normal Priority."..C.TOOLTIP_SUBVALUE("High").."Dispel all debuffs as High Priority even before urgent cooldowns."..C.TOOLTIP_SUBVALUE("Normal").."Dispel all debuffs as Normal Priority after urgent cooldowns."..C.TOOLTIP_VALUE_2.."Define how long you want to wait before dispelling to look more human. This does not apply to Active Dispels Raid debuffs which will always be as soon as Global Cooldown ends."..C.TOOLTIP_HINT("Active Raid Dispels are based on an hardcoded list. Please report of any dispels you may encounter that requires specific strategies so that they can be properly added to the list."));
        module.AddNewOption("General Settings", "Resurrection", 220, true, {0.2, 0, 1, 0.1}, nil, "Resurrect dead Target with Resurrection while out of combat.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Angelic Feather", 220, true, {1.5, 0, 10, 0.1}, nil, "Use Angelic Feather on player."..C.TOOLTIP_VALUE.."Time to wait when you start moving to use it.(In seconds)");
        module.AddNewOption("General Settings", "Body And Soul", 220, true, {1.5, 0, 10, 0.1}, nil, "Use Power Word: Shield on player for Body and Soul."..C.TOOLTIP_VALUE.."Time to wait when you start moving to use it.(In seconds)");

        module.AddSection("Healing Settings", "Common Healing Thresholds", "Green");
        module.AddNewOption("Healing Settings", "Atonement", 222, true, {95, 0, 100, 1}, {95, 0, 100, 1}, "Apply Atonement using Power Word: Shield, Plea and Power Word: Radiance."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Atonement Plea", 222, true, {5, 1, 10, 1}, {40, 0, 100, 1}, "Apply Atonement using Plea."..C.TOOLTIP_VALUE_1.."Maximum Atonements before we avoid using Plea as it becomes too expensive."..C.TOOLTIP_VALUE_2.."Threshold to use Plea regardless of Atonement count.");
        module.AddNewOption("Healing Settings", "Clarity Of Will", 222, true, {200, 0, 400, 1}, {30, 0, 100, 1}, "Apply Clarity of Will on the tanking tanks."..C.TOOLTIP_VALUE_1.."Maximum Overshield."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Divine Star", 222, true, {3, 1, 25, 1 }, {90, 0, 100, 1}, "Use Divine Star."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Healing Settings", "Gift Of The Naaru", 222, true, {40, 0, 100, 1}, {25, 0, 100, 1}, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid."..C.TOOLTIP_HINT("Requires The Penitent talent."));
        end
        module.AddNewOption("Healing Settings", "Halo", 222, true, {5, 1, 25, 1}, {90, 0, 100, 1}, "Use Halo."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Healing Settings", "Penance Heal", 222, true, {60, 0, 100, 1}, {40, 0, 100, 1}, "Use Penance to heal."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid."..C.TOOLTIP_HINT("Requires The Penitent talent."));
        module.AddNewOption("Healing Settings", "Power Word: Radiance", 222, true, {3, 1, 25, 1}, {70, 0, 100, 1}, "Use Power Word: Radiance."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Healing Settings", "Shadow Covenant", 222, true, {4, 1, 25, 1}, {85, 0, 100, 1}, "Use Shadow Covenant."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Healing Settings", "Shadow Mend", 222, true, {65, 0, 100, 1}, {50, 0, 100, 1}, "Use Shadow Mend as low priority."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Shadow Mend Emergency", 222, true, {35, 0, 100, 1}, {25, 0, 100, 1}, "Use Shadow Mend."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Out Of Combat Healing", 210, true, nil, nil, "Allow Healing while Out of Combat.");
        module.AddSection("Healing Settings", "Active Healing", "Green");
        module.AddNewOption("Healing Settings", "Heal Target", 220, true, {1, 1, 2, 1}, nil, "Heal our current target if it is listed to be healed. Define Healing mode: 1-Known Units/2-Any Target");
        module.AddNewOption("Healing Settings", "Debuff", 220, true, {90, 0, 100, 1}, nil, "Manage Debuffed units"..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Healing Settings", "Expiration", 220, true, {90, 0, 100, 1}, nil, "Help units that have debuffs that explode on expiration to survive"..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Healing Settings", "Shielding", 220, true, {80, 0, 100, 1}, nil, "Use Shield on Debuffs that prevent healing on units under specified value"..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Healing Settings", "Speed", 220, true, {100, 0, 100, 1}, nil, "Buff players so that they can run quicker"..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Healing Settings", "Tank", 220, true, {40, 0, 100, 1}, nil, "Buff/Save tanks that have important debuffs"..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Healing Settings", "Topping", 220, true, {95, 0, 100, 1}, nil, "Top players to 100 hp to remove bad debuffs"..C.TOOLTIP_VALUE.."Health threshold.");

        module.AddSection("Cooldowns Settings", "Cooldowns", "Green");
        module.AddNewOption("Cooldowns Settings", "Pain Suppression", 222, true, {30, 0, 100, 1}, {15, 0, 100, 1}, "Use Pain Suppression."..C.TOOLTIP_VALUE_1.."Health threshold to use on Tanks."..C.TOOLTIP_VALUE_2.."Health threshold to use on any Raid members.");
        module.AddNewOption("Cooldowns Settings", "Power Infusion", 222, true, {3, 1, 25, 1}, {50, 0, 100, 1}, "Use Power Infusion."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Cooldowns Settings", "Power Word: Barrier", 222, true, {3, 1, 25, 1}, {40, 0, 100, 1}, "Use Power Word: Barrier."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Cooldowns Settings", "Rapture", 222, true, {4, 1, 25, 1}, {60, 1, 100, 1}, "Use Rapture."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Cooldowns Settings", "Rapture Shields Cycle", 210, true, nil, nil, "Apply Atonement via Power Word: Shield to as many units as we can during Rapture.");
        module.AddNewOption("Cooldowns Settings", "Soft Cooldowns Units", 120, true, {3, 1, 25, 1}, nil, "Amount of units that needs to be under thresholds to use Racials and Trinkets with Health.");
        if Berserking:Exists() or BloodFury:Exists() or ArcaneTorrent:Exists() then
            module.AddNewOption("Cooldowns Settings", "Use Racials", 220, true, {80, 0, 100, 1}, nil, "Use Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Berserking and Blood Rage").."Health threshold under which the units must be to be considered damaged. Racials will then be used if the amount of damaged units is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Arcane Torrent").."Mana threshold under which we want to use Arcane Torrent.");
        end
        module.AddNewOption("Cooldowns Settings", "Use Trinket 1", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 1 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always").."Use Always."..C.TOOLTIP_SUBVALUE("Health").."Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana").."Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 2", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 2 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always").."Use Always."..C.TOOLTIP_SUBVALUE("Health").."Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana").."Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");

        module.AddSection("Offensive/Defensive Settings", "DPS Offensive", "Green");
        module.AddPresetOption("TargetAttack");
        module.AddNewOption("Offensive/Defensive Settings", "Divine Star Damage", 220, true, {3, 1, 25, 1}, nil, "Use Divine Star."..C.TOOLTIP_VALUE.."Amount of enemies that needs to be in the effect area."..C.TOOLTIP_HINT("The calculation will also include enemies and also units that need healing from the Healing counterpart options."));
        module.AddNewOption("Offensive/Defensive Settings", "Halo Damage", 220, true, {3, 1, 25, 1}, nil, "Use Halo."..C.TOOLTIP_VALUE.."Amount of enemies that needs to be in the effect area."..C.TOOLTIP_HINT("The calculation will also include enemies and also units that need healing from the Healing counterpart options."));
        module.AddNewOption("Offensive/Defensive Settings", "Penance", 210, true, nil, nil, "Use Penance in the DPS rotation.");
        module.AddNewOption("Offensive/Defensive Settings", "Power Word: Solace", 210, true, { 1, "High", "Normal" }, { 80, 1, 100, 1 }, "Use Power Word: Solace.");
        module.AddNewOption("Offensive/Defensive Settings", "Purge The Wicked", 210, true, nil, nil, "Use Purge The Wicked in the DPS rotation.");
        module.AddNewOption("Offensive/Defensive Settings", "Schism", 210, true, nil, nil, "Use Schism in the DPS rotation.");
        module.AddNewOption("Offensive/Defensive Settings", "Shadow Word: Pain", 210, true, nil, nil, "Use Shadow Word: Pain in the DPS rotation.");
        module.AddNewOption("Offensive/Defensive Settings", "Smite", 210, true, nil, nil, "Use Smite in the DPS rotation.");
        module.AddSection("Offensive/Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Light's Wrath", 222, true, {3, 1, 10, 1}, {80, 0, 100, 1}, "Use Light's Wrath."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Offensive/Defensive Settings", "Light's Wrath For Tanks", 222, true, {1, 1, 5, 1}, {80, 0, 100, 1}, "Use Light's Wrath to save the Tanks."..C.TOOLTIP_VALUE_1.."Minimum amount of Atoned Units."..C.TOOLTIP_VALUE_2.."Threshold health under which the Tank must be.");
        module.AddNewOption("Offensive/Defensive Settings", "Mindbender", 220, true, {80, 0, 100, 1}, nil, "Mana treshold to use Mindbender.");
        module.AddNewOption("Offensive/Defensive Settings", "Shadowfiend", 222, true, {3, 1, 25, 1}, {80, 0, 100, 1}, "Use Shadowfiend."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddSection("Offensive/Defensive Settings", "Defensive", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE .. "Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Fade", 220, true, {50, 1, 100, 1}, nil, "Use Divine Protection." .. C.TOOLTIP_VALUE .. "Health threshold.");

        module.AddOutput("|cFF9A2EFEMain Tank:");
        module.AddOutput("|cFF9A2EFEOff Tank:");
        module.AddOutput("|cFF9A2EFEBad Debuffs:");
        module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);
        module.AddOutput("|cFFFFDE73Atonements:");
        module.SetOutput("|cFFFFDE73Atonements:", 0);

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [ClarityOfWill:ID()] = "Clarity of Will",
            [ShadowMend:ID()] = "Shadow Mend",
            [ShadowCovenant:ID()] = "Shadow Covenant"
        };
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        -- ISCL Spells: Clarity Of Will / Power Word: Radiance / Shadow Covenant
        if Player:Buff(DraenicChanneledManaPotion) or not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end
        -- Define Main Tanks
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();

        if Player:IsInCombat() then
            self:Defensives();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    -- Get Tanks Status
    local TanksStatus, MainTankTanking, OffTankTanking = {Main = {IsTanking = module.GetTime()},Off = {IsTanking = module.GetTime()}};
    local function RefreshTanksStatus ()
        TanksStatus = {
            Main = {IsTanking = MainTank and MainTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Main.IsTanking},
            Off = {IsTanking = OffTank and OffTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Off.IsTanking}
        };
        MainTankTanking = module.GetTime() - TanksStatus.Main.IsTanking < 3 or false;
        OffTankTanking = module.GetTime() - TanksStatus.Off.IsTanking < 3 or false;
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();

        -- Defensive Cooldowns
        -- Fade
        if module.IsOptionEnabled("Fade") and Player:ThreatSituation() == 3 and Player:CanCast(Fade) and Player:IsInGroup() then
            Player:Cast(Fade);
            return;
        end
    end

    -- Active Healing Heal Target handler
    local function HealTarget (ThisUnit)
        -- Penance
        if ThePenitent:Exists() and ThisUnit:CanHeal(PenanceHeal) then
            ThisUnit:Cast(PenanceHeal);
            return;
        end
        -- Shadow Mend
        if not Player:IsMoving() and ThisUnit:CanCast(ShadowMend) then
            ThisUnit:Cast(ShadowMend);
            return;
        end
        -- Power Word: Shield
        if ThisUnit:CanCast(Shield) then
            ThisUnit:Cast(Shield);
            return;
        end
    end

    -- Clarity of Will on tanks
    local function Overshield()
        if ClarityOfWill:Exists() and not Player:IsMoving() and module.IsOptionEnabled("Clarity Of Will") then
            -- Clarity of Will on tanks
            local OvershieldUnits = {MainTank, OffTank};
            for i = 1, #OvershieldUnits do
                local ThisUnit = OvershieldUnits[i];
                if ThisUnit and ThisUnit:CanCast(ClarityOfWill) and (not ThisUnit:Buff(ClarityOfWill) or (ThisUnit:Buff(ClarityOfWill) and (module.GetNumbersForBuff(ThisUnit, ClarityOfWill)[1]*1 < module.GetOptionValue("Clarity Of Will")*1000 or ThisUnit:BuffRemains(ClarityOfWill) < 4.5))) then
                    ThisUnit:Cast(ClarityOfWill);
                    return;
                end
            end
        end
    end

    local function DPSHandler (Comment)
        AlternateDamage = false;
        -- Divine Star
        if DivineStar:Exists() and module.IsOptionEnabled("Divine Star Damage") and DivineStarEnemies + DivineStarUnits >= module.GetOptionValue("Divine Star Damage") and Player:CanCast(DivineStar) then
            module.Bug("DPS - Divine Star " .. Comment);
            Player:Cast(DivineStar);
            return;
        end
        -- Halo
        if Halo:Exists() and module.IsOptionEnabled("Halo Damage") and HaloEnemies + HaloUnits >= module.GetOptionValue("Halo Damage") and Player:CanCast(Halo) then
            module.Bug("DPS - Halo " .. Comment);
            Player:Cast(Halo);
            return;
        end
        -- Schism
        if Schism:Exists() and module.IsOptionEnabled("Schism") and BestTarget:CanCast(Schism) then
            module.Bug("DPS - Schism " .. Comment);
            BestTarget:Cast(Schism);
            return;
        end
        -- Power Word: Solace
        if Solace:Exists() and module.IsOptionEnabled("Power Word: Solace") and BestTarget:CanCast(Solace) then
            module.Bug("DPS - Solace " .. Comment);
            BestTarget:Cast(Solace);
            return;
        end
        -- Shadow Word: Pain
        if not PurgeTheWicked:Exists() and Pain:Exists() and module.IsOptionEnabled("Shadow Word: Pain") and BestTarget:DebuffRemains(Pain) < 5.4 and BestTarget:TimeToDie() > 8 and BestTarget:CanCast(Pain) then
            module.Bug("DPS - Shadow Word: Pain " .. Comment);
            BestTarget:Cast(Pain);
            return;
        end
        -- Purge The Wicked
        if PurgeTheWicked:Exists() and module.IsOptionEnabled("Purge The Wicked") and BestTarget:DebuffRemains(PurgeTheWickedDebuff) < 6 and BestTarget:CanCast(PurgeTheWicked) then
            module.Bug("DPS - Purge The Wicked " .. Comment);
            BestTarget:Cast(PurgeTheWicked);
            return;
        end
        -- Penance
        if PenanceDamage:Exists() and module.IsOptionEnabled("Penance") and BestTarget:CanCast(PenanceDamage) then
            module.Bug("DPS - Penance Damage " .. Comment);
            BestTarget:Cast(PenanceDamage);
            return;
        end
        -- Smite
        if Smite:Exists() and module.IsOptionEnabled("Smite") and BestTarget:CanCast(Smite) then
            module.Bug("DPS - Smite " .. Comment);
            BestTarget:Cast(Smite);
            return;
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Smite, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
    -- Init + Dispels

        -- Find best unit to attack
        if Target:Exists() and Target:CanCast(Smite) then
            BestTarget = Target;
        elseif MainTankTarget and MainTankTarget:CanCast(Smite) then
            BestTarget = MainTankTarget;
        elseif OffTankTarget and OffTankTarget:CanCast(Smite) then
            BestTarget = OffTankTarget;
        elseif Mouseover:Exists() and Mouseover:CanCast(Smite) then
            BestTarget = Mouseover;
        else
            BestTarget = Target;
        end

        if module.GetTime() - RefreshTables > 1 then    HealUnits = Player:HealUnitsAround(100, 40);
            HealUnits = Player:HealUnitsAround(100, 40);
            Lowest = Unit.Lowest(MainTank, OffTank);
            RefreshTanksStatus();
            DivineStarEnemies = DivineStar:Exists() and #Player:UnitsInFrontRectangle(24, 5);
            DivineStarUnits = DivineStar:Exists() and #Player:UnitsInFrontRectangle(24, 5, true, module.GetSecondOptionValue("Divine Star")) or 0;
            HaloEnemies = #Player:EnemiesWithinDistance(30, true);
            HaloUnits = Halo:Exists() and #Player:HealUnitsAround(module.GetSecondOptionValue("Halo"), 30) or 0;
            PowerInfusionUnits = PowerInfusion:Exists() and #Player:GroupUnitsAvailableForHealing(module.GetSecondOptionValue("Power Infusion"), true, 40, true) or 0;
            RaptureUnits = Rapture:Exists() and module.IsOptionEnabled("Rapture") and #Player:HealUnitsAround(module.GetSecondOptionValue("Rapture"), 40) or 0;
            ShadowCovenantUnit = ShadowCovenant:Exists() and module.IsOptionEnabled("Shadow Covenant") and Player:CanCast(ShadowCovenant) and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Shadow Covenant"), module.GetSecondOptionValue("Shadow Covenant") ,30) or nil;
            ShadowfiendUnits = not Mindbender:Exists() and #Player:GroupUnitsAvailableForHealing(module.GetSecondOptionValue("Shadowfiend"), true, 40, true) or 0;
            Trinket1Units = module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 1"), 40) or 0;
            Trinket2Units = module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 2"), 40) or 0;
            RacialsUnits = module.IsOptionEnabled("Use Racials") and ((Berserking:Exists() and Player:CanCast(Berserking)) or (BloodFury:Exists() and Player:CanCast(BloodFury))) and #Player:HealUnitsAround(module.GetOptionValue("Use Racials"), 40) or 0;
            -- Bad Debuffs
            CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits);
            if CurrentBadDebuffs ~= nil then
                module.SetOutput("|cFF9A2EFEBad Debuffs:", #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff + #CurrentBadDebuffs.Tanks + #CurrentBadDebuffs.Speed + #CurrentBadDebuffs.Expiration + #CurrentBadDebuffs.Shield);
            end
            DispelUnit = Unit.Dispel(Purify);
            AtonementUnits = #Player:UnitsWithBuff(HealUnits, Atonement, 0.1);
            module.SetOutput("|cFFFFDE73Atonements:", AtonementUnits);
            RefreshTables = module.GetTime() + 0.5;
        end


        -- Dispels Handling
        Player:DispelHandler(Purify, "Purify", DispelUnit, CurrentBadDebuffs.Dispel, "High");

        -- Cooldowns
        if module.CooldownsAllowed() then
            -- Racials with Specific Handlers
            if module.IsOptionEnabled("Use Racials") then
                if RacialsUnits >= module.GetOptionValue("Soft Cooldowns Units") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                        return;
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                        return;
                    end
                end
                -- Arcane Torrent
                if ArcaneTorrent:Exists() and Player:PowerPercentage() < module.GetOptionValue("Use Racials") and Player:CanCast(ArcaneTorrent) then
                    Player:Cast(ArcaneTorrent);
                    return;
                end
            end
            -- Trinkets with specific handlers
            if module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() then
                Option1, Option2 = module.GetOptionValue("Use Trinket 1"), module.GetSecondOptionValue("Use Trinket 1");
                if Option1 == "Always" or (Option1 == "Health" and Trinket1Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 1")) then
                    Trinket1:UseInventory();
                end
            end
            if module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() then
                Option1, Option2 = module.GetOptionValue("Use Trinket 2"), module.GetSecondOptionValue("Use Trinket 2");
                if Option1 == "Always" or (Option1 == "Health" and Trinket2Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 2")) then
                    Trinket2:UseInventory();
                end
            end
            -- Power Infusion
            if PowerInfusion:Exists() and module.IsOptionEnabled("Power Infusion") and PowerInfusionUnits >= module.GetOptionValue("Power Infusion") and Player:CanCast(PowerInfusion) then
                Player:Cast(PowerInfusion);
            end
            -- Gift Of The Naaru
            if GiftOfTheNaaru:Exists() then
                if module.IsOptionEnabled("Gift Of The Naaru") and GiftOfTheNaaru:Exists() then
                    if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and MainTank:CanCast(GiftOfTheNaaru) then
                        MainTank:Cast(GiftOfTheNaaru);
                        return;
                    end
                    if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and OffTank:CanCast(GiftOfTheNaaru) then
                        OffTank:Cast(GiftOfTheNaaru);
                        return;
                    end
                    if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Gift Of The Naaru") and Lowest:CanCast(GiftOfTheNaaru) then
                        Lowest:Cast(GiftOfTheNaaru);
                        return;
                    end
                end
            end
            -- Pain Suppression
            if PainSuppression:Exists() and module.IsOptionEnabled("Pain Suppression") then
                if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Pain Suppression") and MainTank:CanHeal(PainSuppression) then
                    MainTank:Cast(PainSuppression);
                    return;
                end
                if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Pain Suppression") and OffTank:CanHeal(PainSuppression) then
                    OffTank:Cast(PainSuppression);
                    return;
                end
                if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Pain Suppression") and Lowest:CanCast(PainSuppression) then
                    Lowest:Cast(PainSuppression);
                    return;
                end
            end
            -- Shadowfiend
            if not Mindbender:Exists() and module.IsOptionEnabled("Shadowfiend") and BestTarget:Exists() and BestTarget:CanCast(Shadowfiend) and BestTarget:TimeToDie() > 12 and ShadowfiendUnits >= module.GetOptionValue("Shadowfiend") then
                BestTarget:Cast(Shadowfiend);
                return;
            end
            -- Rapture
            if RaptureUnits >= module.GetOptionValue("Rapture") and Player:CanCast(Rapture) then
                Player:Cast(Rapture);
                return;
            end
        end

        -- Rapture Cycle
        if Rapture:Exists() and Player:Buff(Rapture) and module.IsOptionEnabled("Rapture") then
            if MainTank and not MainTank:Buff(Atonement) and MainTank:CanHeal(Shield) then
                MainTank:Cast(Shield);
                return;
            end
            if OffTank and not OffTank:Buff(Atonement) and OffTank:CanHeal(Shield) then
                OffTank:Cast(Shield);
                return;
            end
            BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #HealUnits do
                ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage();
                if not ThisUnit:Buff(Atonement) and ThisUnit:CanCast(Shield) then
                    if not BestUnit or ThisUnitHealth < BestUnitHealth then
                        BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                    end
                end
            end
            if BestUnit then
                module.Bug("Power Word: Shield on " .. BestUnit:Name() .. " via Rapture Cycle.");
                BestUnit:Cast(Shield);
                return;
            end
        end
        -- Dispels Handling
        Player:DispelHandler(Purify, "Purify", DispelUnit, CurrentBadDebuffs.Dispel, "Normal");

        -- Active Healing Heal Target handler
        if Target:CanHeal(Heal) and module.IsOptionEnabled("Heal Target") and (module.GetOptionValue("Heal Target") == 2 or (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed())) then
            HealTarget(Target);
            return;
        end
        -- Mindbender
        if Mindbender:Exists() and module.IsOptionEnabled("Mindbender") and Player:PowerPercentage() <= module.GetOptionValue("Mindbender") and BestTarget:Exists() and BestTarget:CanCast(Mindbender) and BestTarget:TimeToDie() > 12 then
            BestTarget:Cast(Mindbender);
            return;
        end
        -- Force Pet To attack something
        if UnitExists("playerpet") and UnitName("playerpettarget") == nil and BestTarget:Exists() then
            RunMacroText("/petattack "..BestTarget.UnitID);
        end
        -- Angelic Feather
        if AngelicFeather:Exists() and module.IsOptionEnabled("Angelic Feather") and Player:Moving() > module.GetOptionValue("Angelic Feather") and not IsFalling() and Player:BuffRemains(AngelicFeatherBuff) < .5 and Player:CanCast(AngelicFeather) then
            Player:Cast(AngelicFeather);
            return;
        end
        -- Body And Soul
        if BodyAndSoul:Exists() and module.IsOptionEnabled("Body And Soul") and Player:Moving() > module.GetOptionValue("Body And Soul") and not Player:Buff(BodyAndSoulBuff) and Player:CanCast(Shield) and not Player:Buff(Shield) then
            Player:Cast(Shield);
            return;
        end
        -- Halo
        if Halo:Exists() and module.IsOptionEnabled("Halo") and Player:CanCast(Halo) and HaloUnits >= module.GetOptionValue("Halo") then
            Player:Cast(Halo);
            return;
        end
        -- Divine Star
        if DivineStar:Exists() and module.IsOptionEnabled("Divine Star") and Player:CanCast(DivineStar) and DivineStarUnits >= module.GetOptionValue("Divine Star") then
            Player:Cast(DivineStar);
            return;
        end
        -- Alternate DPS and Atonements
        if AlternateDamage then
            DPSHandler("(Alternate Damage)");
        end
    -- Bad Debuffs - Expiration
        if module.IsOptionEnabled("Expiration") and CurrentBadDebuffs and #CurrentBadDebuffs.Expiration > 0 and not Shield:IsOnCooldown() then
            BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Expiration do
                ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Expiration[i], CurrentBadDebuffs.Expiration[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Shield) and not ThisUnit:BuffAny(Shield) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil then
                if module.IsOptionEnabled("Expiration") and BestUnit:CanCast(Shield) and BestUnitHealth <= module.GetOptionValue("Expiration") then
                    BestUnit:Cast(Shield);
                    module.Bug("Power Word: Shield on " .. BestUnit:Name() .. " to mitigate expiring debuff");
                    return;
                end
            end
        end

    -- Bad Debuffs - Tank
        if module.IsOptionEnabled("Tank") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            BestUnit, BestUnitHealth = nil, 100;
            BestShieldUnit, BestShieldUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Tanks do
                ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Tanks[i], CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage();
                if not ThisUnit:Buff(Atonement) and ThisUnit:CanCast(Plea) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth <= module.GetOptionValue("Tank") then
                if BestUnit:CanCast(Shield) then
                    AlternateDamage = true;
                    BestUnit:Cast(Shield);
                    module.Bug("Power Word: Shield on " .. BestUnit:Name() .. " to apply Atonement on it (Tank Debuff)");
                    return;
                end
                if not BestUnit:Buff(Atonement) and BestUnit:CanCast(Plea) then
                    AlternateDamage = true;
                    BestUnit:Cast(Plea);
                    module.Bug("Plea on " .. BestUnit:Name() .. " to apply Atonement on it (Tank Debuff)");
                    return;
                end
            end
        end

    -- Bad Debuffs - Debuffs
        if module.IsOptionEnabled("Debuff") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            BestUnit, BestUnitHealth = nil, 100;
            BestShieldUnit, BestShieldUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Debuff do
                ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Debuff[i], CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage();
                if not ThisUnit:Buff(Atonement) and ThisUnit:CanCast(Plea) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth <= module.GetOptionValue("Debuff") then
                if BestUnit:CanCast(Shield) then
                    AlternateDamage = true;
                    BestUnit:Cast(Shield);
                    module.Bug("Power Word: Shield on " .. BestUnit:Name() .. " to apply Atonement on it (Debuff)");
                    return;
                end
                if not BestUnit:Buff(Atonement) and BestUnit:CanCast(Plea) then
                    AlternateDamage = true;
                    BestUnit:Cast(Plea);
                    module.Bug("Plea on " .. BestUnit:Name() .. " to apply Atonement on it (Debuff)");
                    return;
                end
            end
        end

    -- Bad Debuffs - Shielding
        if module.IsOptionEnabled("Shielding") and CurrentBadDebuffs and #CurrentBadDebuffs.Shield > 0 and not Shield:IsOnCooldown() then
            -- Cycle units to find the most injured
            BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Shield do
                ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Shield[i], CurrentBadDebuffs.Shield[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Shield) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil then
                if module.IsOptionEnabled("Shielding") and not BestUnit:BuffAny(Shield) and BestUnit:CanCast(Shield) and BestUnitHealth <= module.GetOptionValue("Shielding") then
                    AlternateDamage = true;
                    BestUnit:Cast(Shield);
                    module.Bug("Power Word: Shield on " .. BestUnit:Name() .. " as it have a healing immunity debuff");
                    return;
                end
            end
        end

    -- Bad Debuffs - Speed method
        if module.IsOptionEnabled("Active Healing") and module.IsOptionEnabled("Speed") and CurrentBadDebuffs and #CurrentBadDebuffs.Speed > 0 and (BodyAndSoul:Exists() or AngelicFeather:Exists()) then
            -- Cycle units to find the most injured
            BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Speed do
                ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Speed[i], CurrentBadDebuffs.Speed[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Shield) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil then
                if BodyAndSoul:Exists() and BestUnit:CanCast(Shield) and BestUnitHealth <= module.GetOptionValue("Speed") then
                    BestUnit:Cast(Shield);
                    module.Bug("Power Word: Shield on " .. BestUnit:Name() .. " to help it run away");
                    return;
                end
                if AngelicFeather:Exists() and AngelicFeather:Charges() >= 1 and BestUnit:CanCast(AngelicFeather) and BestUnitHealth <= module.GetOptionValue("Speed") then
                    BestUnit:Cast(AngelicFeather);
                    module.Bug("Angelic Feather on " .. BestUnit:Name() .. " to help it run away");
                    return;
                end
            end
        end

    -- Bad Debuffs - Topping
        if module.IsOptionEnabled("Active Healing") and module.IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            BestUnit, BestUnitHealth = nil, 100;
            BestShieldUnit, BestShieldUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Top do
                ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Top[i], CurrentBadDebuffs.Top[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Plea) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth <= module.GetOptionValue("Topping") then
                if not BestUnit:Buff(Atonement) and BestUnit:CanCast(Shield) then
                    AlternateDamage = true;
                    BestUnit:Cast(Shield);
                    module.Bug("Power Word: Shield on on " .. BestUnit:Name() .. " to top it");
                    return;
                end
                if not BestUnit:Buff(Atonement) and BestUnit:CanCast(Plea) then
                    AlternateDamage = true;
                    BestUnit:Cast(Plea);
                    module.Bug("Plea on " .. BestUnit:Name() .. " to top it");
                    return;
                end
            end
        end

        -- Power Word: Barrier
        if Barrier:Exists() and module.IsOptionEnabled("Power Word: Barrier") and Player:CanCast(Barrier) then
            Option1 = module.GetSecondOptionValue("Power Word: Barrier");
            BestHealUnits = {};
            for i = 1, #HealUnits do
                ThisUnit = HealUnits[i]
                if ThisUnit:CanHeal(Plea) and not ThisUnit:IsMoving() then
                    ThisHealUnits = ThisUnit:HealUnitsAround(Option1, 13);
                    if #ThisHealUnits >= module.GetOptionValue("Power Word: Barrier") and #ThisHealUnits > #BestHealUnits then
                        BestHealUnits = ThisHealUnits;
                    end
                end
            end
            if #BestHealUnits >= module.GetOptionValue("Power Word: Barrier") then
                Player:CastGroundHeal(Barrier, BestHealUnits);
                return;
            end
        end
        -- Atonement Handling
        -- 1) Look for best unit to Atone
        -- 2) Calc how many need Atonement for Radiance
        -- 3) Calc how many have Atonement for Light's Wrath
        BestAtonementUnit, BestAtonementUnitHealth, RadianceUnits, LightsWrathUnits, AtonedUnits = nil, 100, 0, 0, 0;
        for i = 1, #HealUnits do
            ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage();
            if ThisUnit:BuffRemains(Atonement) < 3 then
                if ThisUnit:CanCast(Plea) and ThisUnit:SpecialHealthPercentage() < module.GetOptionValue("Atonement") then
                    RadianceUnits = ThisUnit:SpecialHealthPercentage() < module.GetSecondOptionValue("Power Word: Radiance") and RadianceUnits + 1 or RadianceUnits;
                    if (BestAtonementUnit == nil or ThisUnitHealth < BestAtonementUnitHealth) then
                        BestAtonementUnit, BestAtonementUnitHealth = ThisUnit, ThisUnitHealth;
                    end
                end
            else
                AtonedUnits = AtonedUnits + 1;
                if ThisUnit:SpecialHealthPercentage() < module.GetSecondOptionValue("Light's Wrath") then
                    LightsWrathUnits = LightsWrathUnits + 1;
                end
            end
        end
        -- Light's Wrath
        if LightsWrath:Exists() and BestTarget:TimeToDie() > 4 and BestTarget:CanCast(LightsWrath) then
            if module.IsOptionEnabled("Light's Wrath") and LightsWrathUnits >= module.GetOptionValue("Light's Wrath") then
                module.Bug("Light's Wrath for Raid");
                BestTarget:Cast(LightsWrath);
                return;
            end
            if module.IsOptionEnabled("Light's Wrath For Tanks") then
                if MainTank and MainTank:SpecialHealthPercentage() < module.GetSecondOptionValue("Light's Wrath For Tanks") and AtonedUnits >= module.GetOptionValue("Light's Wrath For Tanks") then
                    module.Bug("Light's Wrath for Main Tank");
                    BestTarget:Cast(LightsWrath);
                    return;
                end
                if OffTank and OffTank:SpecialHealthPercentage() < module.GetSecondOptionValue("Light's Wrath For Tanks") and AtonedUnits >= module.GetOptionValue("Light's Wrath For Tanks") then
                    module.Bug("Light's Wrath for Off Tank");
                    BestTarget:Cast(LightsWrath);
                    return;
                end
            end
        end

        -- Shadow Covenant
        if ShadowCovenant:Exists() and ShadowCovenantUnit and ShadowCovenantUnit:CanCast(ShadowCovenant) and ShadowCovenant:TimeSinceCast() >= 4 then
            ShadowCovenantUnit:Cast(ShadowCovenant);
            ShadowCovenant.LastCastTime = module.GetTime();
            return;
        end

        -- Penance Healing
        if ThePenitent:Exists() and PenanceHeal:Exists() and module.IsOptionEnabled("Penance Heal") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Penance Heal") and MainTank:CanHeal(PenanceHeal) then
                MainTank:Cast(PenanceHeal);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Penance Heal") and OffTank:CanHeal(PenanceHeal) then
                OffTank:Cast(PenanceHeal);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Penance Heal") and Lowest:CanCast(PenanceHeal) then
                Lowest:Cast(PenanceHeal);
                return;
            end
        end

        -- Shadow Mend
        if ShadowMend:Exists() and module.IsOptionEnabled("Shadow Mend Emergency") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Shadow Mend Emergency") and MainTank:CanHeal(ShadowMend) then
                MainTank:Cast(ShadowMend);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Shadow Mend Emergency") and OffTank:CanHeal(ShadowMend) then
                OffTank:Cast(ShadowMend);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Shadow Mend Emergency") and Lowest:CanCast(ShadowMend) then
                Lowest:Cast(ShadowMend);
                return;
            end
        end

    -- Atonement
        -- Shield Tanks
        if Shield:Exists() and module.IsOptionEnabled("Atonement") and not Shield:IsOnCooldown() then
            BestTank = MainTank and (MainTank:SpecialHealthPercentage() < module.GetOptionValue("Atonement") or MainTankTanking) and MainTank:BuffRemains(Shield) < 5 and MainTank:CanCast(Shield) and MainTank or OffTank and (OffTank:SpecialHealthPercentage() < module.GetOptionValue("Atonement") or OffTankTanking) and OffTank:BuffRemains(Shield) < 5 and OffTank:CanCast(Shield) and OffTank;
            if BestTank then
                AlternateDamage = true;
                BestTank:Cast(Shield);
                return;
            end
        end
        -- Power Word: Radiance
        if Radiance:Exists() and module.IsOptionEnabled("Power Word: Radiance") and RadianceUnits >= module.GetOptionValue("Power Word: Radiance") and BestAtonementUnit and BestAtonementUnit:CanCast(Radiance) then
            AlternateDamage = true;
            module.Bug("Radiance - Atonement");
            BestAtonementUnit:Cast(Radiance);
            return;
        end
        -- Apply Atonements
        if BestAtonementUnit then
            if BestAtonementUnit:CanCast(Plea) then
                if Player:Buff(Rapture) and BestAtonementUnit:CanCast(Shield) then
                    AlternateDamage = true;
                    module.Bug("Power Word: Shield (Rapture) - Atonement");
                    BestAtonementUnit:Cast(Shield);
                    return;
                elseif AtonementUnits < module.GetOptionValue("Atonement Plea") then
                    AlternateDamage = true;
                    module.Bug("Plea - Atonement");
                    BestAtonementUnit:Cast(Plea);
                    return;
                end
            end
        end

    -- DPS Management
        -- Penance Healing Filler
        if ThePenitent:Exists() and PenanceHeal:Exists() and module.IsOptionEnabled("Penance Heal") then
            if MainTank and MainTank:SpecialHealthPercentage() <= 80 and MainTank:CanHeal(PenanceHeal) then
                MainTank:Cast(PenanceHeal);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= 80 and OffTank:CanHeal(PenanceHeal) then
                OffTank:Cast(PenanceHeal);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= 80 and Lowest:CanCast(PenanceHeal) then
                Lowest:Cast(PenanceHeal);
                return;
            end
        end
        -- Shadow Mend
        if ShadowMend:Exists() and module.IsOptionEnabled("Shadow Mend") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Shadow Mend") and MainTank:CanHeal(ShadowMend) then
                AlternateDamage = true;
                MainTank:Cast(ShadowMend);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Shadow Mend") and OffTank:CanHeal(ShadowMend) then
                AlternateDamage = true;
                OffTank:Cast(ShadowMend);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Shadow Mend") and Lowest:CanCast(ShadowMend) then
                AlternateDamage = true;
                Lowest:Cast(ShadowMend);
                return;
            end
        end
        DPSHandler("(Filler)");
        Overshield();
        -- Plea Filler
        if MainTank and MainTank:BuffRemains(Atonement) < 3 and (MainTank:SpecialHealthPercentage() < module.GetSecondOptionValue("Atonement Plea") or (MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Atonement") and AtonementUnits < module.GetOptionValue("Atonement Plea"))) and MainTank:CanCast(Plea) then
            AlternateDamage = true;
            MainTank:Cast(Plea);
            return;
        end
        if OffTank and OffTank:BuffRemains(Atonement) < 3 and (OffTank:SpecialHealthPercentage() < module.GetSecondOptionValue("Atonement Plea") or (OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Atonement") and AtonementUnits < module.GetOptionValue("Atonement Plea"))) and OffTank:CanCast(Plea) then
            AlternateDamage = true;
            OffTank:Cast(Plea);
            return;
        end
        if Lowest and Lowest:BuffRemains(Atonement) < 3 and (Lowest:SpecialHealthPercentage() < module.GetSecondOptionValue("Atonement Plea") or (Lowest:SpecialHealthPercentage() <= module.GetOptionValue("Atonement") and AtonementUnits < module.GetOptionValue("Atonement Plea"))) and Lowest:CanCast(Plea) then
            AlternateDamage = true;
            Lowest:Cast(Plea);
            return;
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Clarity of Will on tanks
        Overshield();
        -- Power Word: Shield Main Tank In Combat
        if Shield:Exists() and MainTank and module.IsOptionEnabled("Power Word: Shield") and not MainTank:Buff(Atonement) and MainTank:IsInCombat() and not MainTank:Buff(Shield) and MainTank:CanHeal(Shield) then
            MainTank:Cast(Shield);
            return;
        end
        -- Penance Top Off
        if PenanceHeal:Exists() and ThePenitent:Exists() and Lowest and Lowest:SpecialHealthPercentage() < 90 and Lowest:CanHeal(PenanceHeal) then
            Lowest:Cast(PenanceHeal);
            return;
        end
        -- Angelic Feather
        if AngelicFeather:Exists() and module.IsOptionEnabled("Angelic Feather") and Player:Moving() > module.GetOptionValue("Angelic Feather") and not IsFalling() and Player:BuffRemains(AngelicFeatherBuff) < .5 and Player:CanCast(AngelicFeather) then
            Player:Cast(AngelicFeather);
            return;
        end
        -- Body And Soul
        if BodyAndSoul:Exists() and module.IsOptionEnabled("Body And Soul") and Player:Moving() > module.GetOptionValue("Body And Soul") and not Player:Buff(BodyAndSoulBuff) and Player:CanCast(Shield) and not Player:Buff(Shield) then
            Player:Cast(Shield);
            return;
        end
        -- Resurrect Deads
        if Resurrection:Exists() and module.IsOptionEnabled("Resurrection") and Unit.ResurrectCycle(Resurrection) then
            return;
        end
        -- Proving Grounds Food
        if MainTank and MainTank:CreatureID() == 72218 and Player:PowerPercentage() < 95 and not Player:IsMoving() and LukewarmYakRoastBroth:InStock() and not LukewarmYakRoastBroth:IsOnCooldown() then
            LukewarmYakRoastBroth:Use(Player);
        end
        if module.IsOptionEnabled("Out Of Combat Healing") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Holy Priest
    local Rotation = {};
    module.SetRotation("_"..257, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshTables = 0, 0.1, 0; -- Combat Module Throttle
    -- Healers Specific
    local MainTank, MainTankTarget, OffTank, OffTankTarget, HealUnits, Lowest, CurrentBadDebuffs, BestTarget, DispelUnit;
    local Trinket1Units, Trinket2Units, RacialsUnits;
    -- Profile Specific
    local CascadeUnit, PoHUnit, CoHUnit, HolyNovaUnits = nil, nil, nil, 0; -- Best Heal Units per spell
    local DivineStarUnits, HaloUnits, DivineHymnUnits, MendingUnits = 0, 0, 0, 0; -- Units Counts

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        LukewarmYakRoastBroth = Item(120293, false, false, true);
        DraenicChanneledManaPotion = Spell(156432, false, false, false);
        --Racials
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33697, false, false, true);
        ArcaneTorrent = Spell(28730, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        AngelicFeather = Spell(121536, false, false, true);
        AngelicFeatherBuff = Spell(121557);
        BindingHeal = Spell(32546, false, false, true);
        BodyAndMind = Spell(214121, false, false, true);
        CircleOfHealing = Spell(204883, false, false, false);
        DesperatePrayer = Spell(19236, false, false, true);
        DispelMagic = Spell(528, false, false, true);
        DivineHymn = Spell(64843, false, false, false);
        DivineStar = Spell(110744, false, false, true);
        Fade = Spell(586, false, false, true);
        FlashHeal = Spell(2061, false, false, false);
        GiftOfTheNaaru = Spell(59544, false, false, true);
        GuardianSpirit = Spell(47788, false, false, true);
        Halo = Spell(120517, false, false, true);
        Heal = Spell(2060, false, false, false);
        HolyFire = Spell(14914, false, true, true);
        HolyNova = Spell(132157, false, false, true);
        HolyWordChastise = Spell(88625, true, true, true);
        HolyWordSanctify = Spell(34861, false, false, true);
        HolyWordSerenity = Spell(2050, false, false, true);
        LightOfTuure = Spell(208065, false, false, true);
        PrayerOfHealing = Spell(596, false, false, false);
        PrayerOfMending = Spell(33076, false, false, true);
        PrayerOfMendingBuff = Spell(41635, false, false, true);
        Purify = Spell(527, false, false, true);
        Renew = Spell(139, false, false, true);
        Resurrection = Spell(2006, false, false, false, true);
        SpiritOfRedemption = Spell(27827, false, false, true);
        SurgeOfLight = Spell(114255);
        Smite = Spell(585, true, true, false);

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Healing Settings");
        module.AddPage("Cooldowns Settings");
        module.AddPage("Offensive/Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Focus Assignation", 230, true, {2, "Main Tank", "Off Tank"}, nil, "Select which Tank slot should be given to the focussed unit.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Purify", 232, false, {1, "Auto", "High", "Normal"}, {0.2, 0, 1, 0.1}, "Use Purify to Dispel bad debuffs on allied units."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Auto").."Dispel Active Dispel Raid debuffs as High Priority and other not listed debuffs as Normal Priority."..C.TOOLTIP_SUBVALUE("High").."Dispel all debuffs as High Priority even before urgent cooldowns."..C.TOOLTIP_SUBVALUE("Normal").."Dispel all debuffs as Normal Priority after urgent cooldowns."..C.TOOLTIP_VALUE_2.."Define how long you want to wait before dispelling to look more human. This does not apply to Active Dispels Raid debuffs which will always be as soon as Global Cooldown ends."..C.TOOLTIP_HINT("Active Raid Dispels are based on an hardcoded list. Please report of any dispels you may encounter that requires specific strategies so that they can be properly added to the list."));
        module.AddNewOption("General Settings", "Resurrection", 210, true, nil, nil, "Resurrect dead Target with Resurrection while out of combat.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Angelic Feather", 220, true, {1.5, 0, 10, 0.1}, nil, "Use Angelic Feather on player."..C.TOOLTIP_VALUE.."Select desired time to wait when you start moving to use it.(seconds)");
        module.AddNewOption("General Settings", "Body And Mind", 220, true, {1.5, 0, 10, 0.1}, nil, "Use Body and Mind on player."..C.TOOLTIP_VALUE.."Select desired time to wait when you start moving to use it.(seconds)");

        module.AddSection("Healing Settings", "Common Healing Thresholds", "Green");
        module.AddNewOption("Healing Settings", "Binding Heal", 222, true, {90, 0, 100, 1}, {80, 0, 100, 1}, "Use Binding Heal when our health is under 100%."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Circle Of Healing", 222, true, {3, 1, 5, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Flash Heal", 222, true, {70, 0, 100, 1}, {35, 0, 100, 1}, "Use Flash Heal."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Flash Heal Surge Of Light", 222, true, {80, 0, 100, 1}, {55, 0, 100, 1}, "Use Flash Heal with Surge Of Light procs."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Heal", 222, true, {90, 0, 100, 1}, {80, 0, 100, 1}, "Use Heal."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Renew", 222, true, {95, 0, 100, 1}, {92, 0, 100, 1}, "Use Renew."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Prayer Of Healing", 222, true, {3, 1, 5, 1}, {70, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Prayer Of Mending", 222, true, {1, 1, 5, 1}, {95, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Out Of Combat Healing", 210, true, nil, nil, "Allow Healing while Out of Combat.");
        module.AddSection("Healing Settings", "Active Healing", "Green");
        module.AddNewOption("Healing Settings", "Heal Target", 230, true, {1, "Known Unit", "Any Unit"}, nil, "Heal our current target if it is listed to be healed."..C.TOOLTIP_VALUE.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Known Unit").."Allow Heal Target to be used only when we are targetting a unit listed for it."..C.TOOLTIP_SUBVALUE("Any Unit").."Allow Heal Target to be used on any unit.");
        module.AddNewOption("Healing Settings", "Raid Debuffs", 220, true, {40, 0, 100, 1}, nil, "Use Renew on Debuffed units."..C.TOOLTIP_VALUE.."Helath threshold.");
        module.AddNewOption("Healing Settings", "Tank Debuffs", 220, true, {50, 0, 100, 1}, nil, "Use Renew on Debuffed tanks."..C.TOOLTIP_VALUE.."Helath threshold.");
        module.AddNewOption("Healing Settings", "Topping", 220, true, {100, 0, 100, 1}, nil, "Use Renew/Flash Heal on units to be topped."..C.TOOLTIP_VALUE.."Helath threshold.");

        module.AddSection("Cooldowns Settings", "Cooldowns", "Green");
        module.AddNewOption("Cooldowns Settings", "Divine Hymn", 222, true, {3, 1, 25, 1}, {70, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Divine Star", 222, true, {2, 1, 25, 1}, {90, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Guardian Spirit", 222, true, {30, 0, 100, 1}, {0, 0, 100, 1}, "Use Guardian Spirit."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Cooldowns Settings", "Halo", 222, true, {4, 1, 25, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Holy Word: Sanctify", 222, true, {3, 1, 10, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold." .. C.TOOLTIP_VALUE_1 .. "Number of Units." .. C.TOOLTIP_VALUE_2 .. "Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Holy Word: Serenity", 222, true, {50, 0, 100, 1}, {30, 0, 100, 1}, "Use Holy Word Serenity."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Cooldowns Settings", "Light Of T'uure", 222, true, {60, 0, 100, 1}, {40, 0, 100, 1}, "Use Light Of T'uure."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddSection("Cooldowns Settings", "Common Cooldowns", "Green");
        module.AddNewOption("Cooldowns Settings", "Soft Cooldowns Units", 120, true, {3, 1, 25, 1}, nil, "Number of units that needs to be under thresholds to use Racials and Trinkets with Health.");
        module.AddNewOption("Cooldowns Settings", "Use Racials", 220, true, {80, 0, 100, 1}, nil, "Use Racials. \n\n|cFF0088FFArcane Torrent:|r Mana threshold under which we want to use Arcane Torrent.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 1", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 1 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always") .." Use Always."..C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 2", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 2 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always") .." Use Always."..C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");

        module.AddSection("Offensive/Defensive Settings", "DPS Offensive", "Green");
        module.AddPresetOption("TargetAttack");
        module.AddNewOption("Offensive/Defensive Settings", "DPS", 220, true, {95, 0, 100, 1}, nil, "Enables DPS options."..C.TOOLTIP_VALUE.."Will only DPS if the Lowest unit is above DPS health treshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Holy Fire", 210, true, nil, nil, "Use Holy Fire in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Holy Nova", 220, true, {3, 1, 10, 1}, nil, "Use Holy Nova in the DPS rotation."..C.TOOLTIP_VALUE.."Amount of units required to be in 12 yards of Player to use."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Smite", 210, true, nil, nil, "Use Smite in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddSection("Offensive/Defensive Settings", "Defensive", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Desperate Prayer", 220, true, {30, 1, 100, 1}, nil, "Use Desperate Prayer."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Fade", 220, true, {20, 1, 100, 1}, nil, "Use Fade when there is threath on us."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Offensive/Defensive Settings", "Gift Of The Naaru", 222, true, {65, 0, 100, 1}, {55, 0, 100, 1}, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        end
        module.AddSection("Offensive/Defensive Settings", "Spirit Of Redemption Abilities", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Spirit Circle Of Healing", 222, true, {2, 1, 5, 1}, {90, 0, 100, 1}, "Use Circle Of Healing during Spirit of Redemption."..C.TOOLTIP_VALUE_1.."Number of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Offensive/Defensive Settings", "Spirit Prayer Of Healing", 222, true, {2, 1, 5, 1}, {90, 0, 100, 1}, "Use Prayer Of Healing during Spirit of Redemption."..C.TOOLTIP_VALUE_1.."Number of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Offensive/Defensive Settings", "Spirit Divine Hymn", 222, true, {3, 1, 25, 1}, {80, 0, 100, 1}, "Use Divine Hymn during Spirit of Redemption."..C.TOOLTIP_VALUE_1.."Number of units that needs to be under threshold."..C.TOOLTIP_VALUE_2.."Threshold health under which the units must be.");
        module.AddNewOption("Offensive/Defensive Settings", "Spirit Guardian Spirit", 222, true, {30, 0, 100, 1}, {0, 0, 100, 1}, "Use Guardian Spirit during Spirit of Redemption."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Offensive/Defensive Settings", "Spirit Guardian Spirit Before Expiration", 210, true, nil, nil, "Will use Guardian Spirit on the Lowest Tank before Spirit of Redemption buff fades");
        module.AddNewOption("Offensive/Defensive Settings", "Spirit Flash Heal", 222, true, {75, 0, 100, 1}, {65, 0, 100, 1}, "Use Flash Heal during Spirit of Redemption."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Offensive/Defensive Settings", "Spirit Renew", 220, true, {95, 0, 100, 1}, nil, "Use Renew during Spirit of Redemption."..C.TOOLTIP_VALUE.."Health Threshold.");

        -- Healers Specific
        module.AddOutput("|cFF9A2EFEMain Tank:");
        module.AddOutput("|cFF9A2EFEOff Tank:");
        module.AddOutput("|cFF9A2EFELowest:");
        module.AddOutput("|cFF9A2EFEBad Debuffs:");
        module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [Heal:ID()] = "Heal",
            [FlashHeal:ID()] = "Flash Heal"
        };
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:Channeling(DivineHymn) or Player:Buff(DraenicChanneledManaPotion) or not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Define Main Tanks
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();

        if Player:IsInCombat() then
            self:Defensives();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Fade
        if module.IsOptionEnabled("Fade") and Player:ThreatSituation() == 3 and Player:CanCast(Fade) and Player:IsInGroup() then
            Player:Cast(Fade);
            return;
        end
        --Desperate Prayer
        if DesperatePrayer:Exists() and module.IsOptionEnabled("Desperate Prayer") and Player:HealthPercentage() <= module.GetOptionValue("Desperate Prayer") and Player:CanCast(DesperatePrayer) then
            Player:Cast(DesperatePrayer);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and MainTank:CanHeal(GiftOfTheNaaru) then
                MainTank:Cast(GiftOfTheNaaru);
                return;
            elseif MainTank and OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and OffTank:CanHeal(GiftOfTheNaaru) then
                OffTank:Cast(GiftOfTheNaaru);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Gift Of The Naaru") and Lowest:CanHeal(GiftOfTheNaaru) then
                Lowest:Cast(GiftOfTheNaaru);
                return;
            end
        end
    end

    -- Get Tanks Status
    local TanksStatus, MainTankTanking, OffTankTanking = {Main = {IsTanking = module.GetTime()},Off = {IsTanking = module.GetTime()}};
    local function RefreshTanksStatus ()
        TanksStatus = {
            Main = {IsTanking = MainTank and MainTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Main.IsTanking},
            Off = {IsTanking = OffTank and OffTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Off.IsTanking}
        };
        MainTankTanking = module.GetTime() - TanksStatus.Main.IsTanking < 3 or false;
        OffTankTanking = module.GetTime() - TanksStatus.Off.IsTanking < 3 or false;
    end

    -- Active Healing Heal Target handler
    local function HealTarget (ThisUnit)
        -- Renew
        if ThisUnit:CanCast(Renew) and ThisUnit:BuffRemains(Renew) < 2 then
            ThisUnit:Cast(Renew);
            return;
        end
        if not Player:IsMoving() then
            -- Flash Heal
            if ThisUnit:CanCast(FlashHeal) and ThisUnit:SpecialHealthPercentage() < 100 then
                ThisUnit:Cast(FlashHeal);
                return;
            end
            -- Heal
            if ThisUnit:CanCast(Heal) then
                ThisUnit:Cast(Heal);
                return;
            end
        end
    end

    local function SpiritRotation ()
        -- Guardian Spirit
        if module.IsOptionEnabled("Spirit Guardian Spirit") then
            if MainTank and MainTank:HealthPercentage() <= module.GetOptionValue("Spirit Guardian Spirit") and MainTank:CanHeal(GuardianSpirit) then
                MainTank:Cast(GuardianSpirit);
                return;
            elseif OffTank and OffTank:HealthPercentage() <= module.GetOptionValue("Spirit Guardian Spirit") and OffTank:CanHeal(GuardianSpirit) then
                OffTank:Cast(GuardianSpirit);
                return;
            end
        end
        if module.IsOptionEnabled("Spirit Guardian Spirit Before Expiration") and Player:BuffRemains(SpiritOfRedemption) < 3 then
            local BestGuardianUnit = nil;
            if MainTank and MainTank:CanHeal(GuardianSpirit) then
                BestGuardianUnit = MainTank;
            elseif OffTank and OffTank:CanHeal(GuardianSpirit) and OffTank:SpecialHealthPercentage() <= MainTank:SpecialHealthPercentage() then
                BestGuardianUnit = OffTank;
            end
            if BestGuardianUnit then
                BestGuardianUnit:Cast(GuardianSpirit);
                return;
            end
        end
        -- Divine Hymn
        if module.IsOptionEnabled("Spirit Divine Hymn") and Player:CanCast(DivineHymn) and #Player:HealUnitsAround(module.GetSecondOptionValue("Spirit Divine Hymn"), 40) >= module.GetOptionValue("Spirit Divine Hymn") then
            Player:Cast(DivineHymn);
            return;
        end

        -- Dispels Handling
        Player:DispelHandler(Purify, "Purify", DispelUnit, CurrentBadDebuffs.Dispel, "Normal");

        -- Circle of Healing
        if module.IsOptionEnabled("Spirit Circle Of Healing") and Player:CanCast(CircleOfHealing) then
            if CircleUnit and CircleUnit:CanCast(CircleOfHealing) then
                CircleUnit:Cast(CircleOfHealing);
                return;
            end
        end
        -- Prayer of Healing
        if PrayerOfHealing:Exists() and module.IsOptionEnabled("Spirit Prayer Of Healing") and PoHUnit and PoHUnit:CanCast(PrayerOfHealing) then
            PoHUnit:Cast(PrayerOfHealing);
            return;
        end

        -- Cast Flash Heal
        if module.IsOptionEnabled("Spirit Flash Heal") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Spirit Flash Heal") and MainTank:CanHeal(FlashHeal) then
                MainTank:Cast(FlashHeal);
                return;
            elseif MainTank and OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Spirit Flash Heal") and OffTank:CanHeal(FlashHeal) then
                OffTank:Cast(FlashHeal);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Spirit Flash Heal") and Lowest:CanHeal(FlashHeal) then
                Lowest:Cast(FlashHeal);
                return;
            end
        end

        -- Renew Cycle
        if module.IsOptionEnabled("Spirit Renew") and HealUnits then
            local BestUnit = nil;
            local BestUnitHealth = 101;
            for i = 1, #HealUnits do
                local ThisUnit = HealUnits[i]
                local ThisUnitHealth = ThisUnit:SpecialHealthPercentage()
                if ThisUnit:CanCast(Renew) and ThisUnitHealth <= module.GetOptionValue("Spirit Renew") and ThisUnit:BuffRemains(Renew) <= 3 and ThisUnitHealth < BestUnitHealth then
                    BestUnitHealth = ThisUnitHealth;
                    BestUnit = ThisUnit;
                end
            end
            if BestUnit then
                BestUnit:Cast(Renew);
                return;
            end
        end
    end


    --- Run the beta rotation's healing logic.
    function Rotation:Combat ()
        -- Find best unit to attack
        if Target:Exists() and Target:CanCast(Smite) then
            BestTarget = Target;
        elseif MainTankTarget and MainTankTarget:CanCast(Smite) then
            BestTarget = MainTankTarget;
        elseif OffTankTarget and OffTankTarget:CanCast(Smite) then
            BestTarget = OffTankTarget;
        elseif Mouseover:Exists() and Mouseover:CanCast(Smite) then
            BestTarget = Mouseover;
        else
            BestTarget = Target;
        end

        -- Refresh tables every 0.5 seconds
        if RefreshTables < module.GetTime() then
            DispelUnit = Unit.Dispel(Purify);
            HealUnits = Player:HealUnitsAround(100, 40);
            Lowest = Unit.Lowest(MainTank, OffTank);
            module.SetOutput("|cFF9A2EFELowest:", Lowest and Lowest:Name() or "");
            RefreshTanksStatus();
            -- Units Counts
            CoHUnit = CircleOfHealing:Exists() and Player:Buff(SpiritOfRedemption) and module.IsOptionEnabled("Spirit Circle Of Healing") and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Spirit Circle Of Healing"), module.GetSecondOptionValue("Spirit Circle Of Healing"), 30) or CircleOfHealing:Exists() and module.IsOptionEnabled("Circle Of Healing") and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Circle Of Healing"), module.GetSecondOptionValue("Circle Of Healing"), 30) or nil;
            DivineStarUnits = DivineStar:Exists() and module.IsOptionEnabled("Divine Star") and #Player:UnitsInFrontRectangle(24, 5, true, module.GetSecondOptionValue("Divine Star")) or 0;
            DivineHymnUnits = DivineHymn:Exists() and module.IsOptionEnabled("Divine Hymn") and #Player:HealUnitsAround(module.GetSecondOptionValue("Divine Hymn"), 40) or 0;
            HaloUnits = Halo:Exists() and module.IsOptionEnabled("Halo") and #Player:HealUnitsAround(module.GetSecondOptionValue("Halo"), 30) or 0;
            HolyNovaUnits = HolyNova:Exists() and module.IsOptionEnabled("Holy Nova") and #Player:EnemiesWithinDistance(12) or 0;
            MendingUnits = PrayerOfMending:Exists() and module.IsOptionEnabled("Prayer Of Mending") and #Player:HealUnitsAround(module.GetSecondOptionValue("Prayer Of Mending"), 40) or 0;
            PoHUnit = PrayerOfHealing:Exists() and Player:Buff(SpiritOfRedemption) and module.IsOptionEnabled("Spirit Prayer Of Healing") and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Spirit Prayer Of Healing"), module.GetSecondOptionValue("Spirit Prayer Of Healing"), 20) or PrayerOfHealing:Exists() and module.IsOptionEnabled("Prayer Of Healing") and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Prayer Of Healing"), module.GetSecondOptionValue("Prayer Of Healing"), 20) or nil;
            RacialsUnits = module.IsOptionEnabled("Use Racials") and ((Berserking:Exists() and Player:CanCast(Berserking)) or (BloodFury:Exists() and Player:CanCast(BloodFury))) and #Player:HealUnitsAround(module.GetOptionValue("Use Racials"), 40) or 0;
            Trinket1Units = module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 1"), 40) or 0;
            Trinket2Units = module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 2"), 40) or 0;
            -- Bad Debuffs Output
            CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits);
            if CurrentBadDebuffs ~= nil then
                module.SetOutput("|cFF9A2EFEBad Debuffs:", #CurrentBadDebuffs.Tanks + #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff);
            end
            RefreshTables = module.GetTime() + 0.5;
        end

        -- Dispels Handling
        Player:DispelHandler(Purify, "Purify", DispelUnit, CurrentBadDebuffs.Dispel, "High");

        -- Active Healing Heal Target handler
        if Target:CanHeal(Heal) and module.IsOptionEnabled("Heal Target") and (module.GetOptionValue("Heal Target") == 2 or (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed())) then
            HealTarget(Target);
            return;
        end

        -- Spirit Of Redemption support
        if Player:Buff(SpiritOfRedemption) then
            SpiritRotation();
            return;
        end

        -- Trinkets with specific handlers
        if module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() then
            local Option1, Option2 = module.GetOptionValue("Use Trinket 1"), module.GetSecondOptionValue("Use Trinket 1");
            if Option1 == "Always" or (Option1 == "Health" and Lowest and Lowest:SpecialHealthPercentage() <= Option2) or (Option1 == "Mana" and Player:PowerPercentage() < Option2) then
                Trinket1:UseInventory();
            end
        end
        if module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() then
            local Option1, Option2 = module.GetOptionValue("Use Trinket 2"), module.GetSecondOptionValue("Use Trinket 2");
            if Option1 == "Always" or (Option1 == "Health" and Lowest and Lowest:SpecialHealthPercentage() <= Option2) or (Option1 == "Mana" and Player:PowerPercentage() < Option2) then
                Trinket2:UseInventory();
            end
        end
    -- Cooldowns
        -- Only use DPS and Cooldowns during combat
        if Player:IsInCombat() then
            -- DPS
            if BestTarget and module.IsOptionEnabled("DPS") and Lowest:HealthPercentage() >= module.GetOptionValue("DPS") and (not MainTank or MainTank:HealthPercentage() >= module.GetOptionValue("DPS")) and (not OffTank or OffTank:HealthPercentage() >= module.GetOptionValue("DPS")) and BestTarget:IsInCombat() then
                -- Holy Fire
                if HolyFire:Exists() and module.IsOptionEnabled("Holy Fire") and BestTarget:CanCast(HolyFire) then
                    BestTarget:Cast(HolyFire);
                    return;
                end
                -- Holy Nova
                if HolyNova:Exists() and HolyNovaUnits >= module.GetOptionValue("Holy Nova") and Player:CanCast(HolyNova) then
                    Player:Cast(HolyNova);
                    return;
                end
                -- Smite
                if Smite:Exists() and module.IsOptionEnabled("Smite") and BestTarget:CanCast(Smite) then
                    BestTarget:Cast(Smite);
                    return;
                end
                -- Find New Target
                if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
                    local NewTargetUnit = Unit.AutoTarget(Smite, module.GetOptionValue("Target | Attack"));
                    if NewTargetUnit then
                        NewTargetUnit:Attack();
                        return;
                    end
                end
            end
            -- Racials with Specific Handlers
            if module.IsOptionEnabled("Use Racials") then
                if RacialsUnits >= module.GetOptionValue("Soft Cooldowns Units") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                        return;
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                        return;
                    end
                end
            end
            -- Trinkets with specific handlers
            if module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 1"), module.GetSecondOptionValue("Use Trinket 1");
                if Option1 == "Always" or (Option1 == "Health" and Trinket1Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 1")) then
                    Trinket1:UseInventory();
                end
            end
            if module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 2"), module.GetSecondOptionValue("Use Trinket 2");
                if Option1 == "Always" or (Option1 == "Health" and Trinket2Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 2")) then
                    Trinket2:UseInventory();
                end
            end
            -- Guardian Spirit - used on Tanks when they fall under life treshold.
            if GuardianSpirit:Exists() and module.IsOptionEnabled("Guardian Spirit") then
                if MainTank and MainTank:HealthPercentage() <= module.GetOptionValue("Guardian Spirit") and MainTank:CanHeal(GuardianSpirit) then
                    MainTank:Cast(GuardianSpirit);
                    return;
                elseif OffTank and OffTank:HealthPercentage() <= module.GetOptionValue("Guardian Spirit") and OffTank:CanHeal(GuardianSpirit) then
                    OffTank:Cast(GuardianSpirit);
                    return;
                end
            end
            -- Divine Hymn - Used when # of people under treshold exceed desired number of units
            if DivineHymn:Exists() and module.IsOptionEnabled("Divine Hymn") and Player:Standing() > 1 and Player:CanCast(DivineHymn) and DivineHymnUnits >= module.GetOptionValue("Divine Hymn") then
                Player:Cast(DivineHymn);
                return;
            end
        end

        -- Dispels Handling
        Player:DispelHandler(Purify, "Purify", DispelUnit, CurrentBadDebuffs.Dispel, "Normal");

        -- Angelic Feather - when we run more than choosen time
        if AngelicFeather:Exists() and module.IsOptionEnabled("Angelic Feather") and Player:Moving() > module.GetOptionValue("Angelic Feather") and not IsFalling() and Player:BuffRemains(AngelicFeatherBuff) < .5 and Player:CanCast(AngelicFeather) then
            Player:Cast(AngelicFeather);
            return;
        end
        -- Body And Mind - when we run more than choosen time
        if BodyAndMind:Exists() and module.IsOptionEnabled("Body And Mind") and Player:Moving() > module.GetOptionValue("Body And Mind") and not Player:Buff(BodyAndMind) and Player:CanCast(BodyAndMind) then
            Player:Cast(BodyAndMind);
            return;
        end
    -- High Priority Healing
        -- Light Of T'uure
        if LightOfTuure:Exists() and module.IsOptionEnabled("Light Of T'uure") then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Light Of T'uure") and not MainTank:Buff(LightOfTuure) and MainTank:CanHeal(LightOfTuure) then
                module.Bug("Light Of T'uure - MainTank");
                MainTank:Cast(LightOfTuure);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Light Of T'uure") and not OffTank:Buff(LightOfTuure) and OffTank:CanHeal(LightOfTuure) then
                module.Bug("Light Of T'uure - OffTank");
                OffTank:Cast(LightOfTuure);
                return;
            end
        end
        -- Holy Word Serenity
        if HolyWordSerenity:Exists() and module.IsOptionEnabled("Holy Word: Serenity") then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Holy Word: Serenity") and MainTank:CanHeal(HolyWordSerenity) then
                module.Bug("Holy Word Serenity - MainTank");
                MainTank:Cast(HolyWordSerenity);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Holy Word: Serenity") and OffTank:CanHeal(HolyWordSerenity) then
                module.Bug("Holy Word Serenity - OffTank");
                OffTank:Cast(HolyWordSerenity);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() < module.GetSecondOptionValue("Holy Word: Serenity") and Lowest:CanHeal(HolyWordSerenity) then
                module.Bug("Holy Word Serenity - Lowest");
                Lowest:Cast(HolyWordSerenity);
                return;
            end
        end
        -- Circle of Healing - with number of units damaged in 30 yards of best unit
        if CircleOfHealing:Exists() and CoHUnit and CoHUnit:CanCast(CircleOfHealing) then
            CoHUnit:Cast(CircleOfHealing);
            return;
        end
        -- Holy Word: Sanctify
        if HolyWordSanctify:Exists() and module.IsOptionEnabled("Holy Word: Sanctify") and Player:CanCast(HolyWordSanctify) then
            local HealthThreshold = module.GetSecondOptionValue("Holy Word: Sanctify");
            local BestHealUnits = {};
            for i = 1, #HealUnits do
                local ThisUnit = HealUnits[i]
                if ThisUnit:CanHeal(Heal) then
                    local TheseHealUnits = ThisUnit:HealUnitsAround(HealthThreshold, 10);
                    if #TheseHealUnits >= module.GetOptionValue("Holy Word: Sanctify") and #TheseHealUnits > #BestHealUnits then
                        BestHealUnits = TheseHealUnits;
                    end
                end
            end
            if #BestHealUnits >= module.GetOptionValue("Holy Word: Sanctify") then
                Player:CastGroundHeal(HolyWordSanctify, BestHealUnits);
                return;
            end
        end
        -- Prayer of Healing
        if PrayerOfHealing:Exists() and module.IsOptionEnabled("Prayer Of Healing") and PoHUnit and PoHUnit:CanCast(PrayerOfHealing) then
            PoHUnit:Cast(PrayerOfHealing);
            return;
        end
        -- Renew on Tanks
        if Renew:Exists() and module.IsOptionEnabled("Renew") then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Renew") and not MainTank:Buff(Renew) and MainTank:CanHeal(Renew) then
                module.Bug("Renew - MainTank");
                MainTank:Cast(Renew);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Renew") and not OffTank:Buff(Renew) and OffTank:CanHeal(Renew) then
                module.Bug("Renew - OffTank");
                OffTank:Cast(Renew);
                return;
            end
        end
        -- Flash Heal
        if FlashHeal:Exists() and module.IsOptionEnabled("Flash Heal") and not Player:IsMoving() then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Flash Heal") and MainTank:CanHeal(FlashHeal) then
                module.Bug("Flash Heal - MainTank");
                MainTank:Cast(FlashHeal);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Flash Heal") and OffTank:CanHeal(FlashHeal) then
                module.Bug("Flash Heal - OffTank");
                OffTank:Cast(FlashHeal);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() < module.GetSecondOptionValue("Flash Heal") and Lowest:CanHeal(FlashHeal) then
                module.Bug("Flash Heal - Lowest");
                Lowest:Cast(FlashHeal);
                return;
            end
        end
        -- Flash Heal - Surge Of Light
        if FlashHeal:Exists() and Player:Buff(SurgeOfLight) and module.IsOptionEnabled("Flash Heal Surge Of Light") and not Player:IsMoving() then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Flash Heal Surge Of Light") and MainTank:CanHeal(FlashHeal) then
                module.Bug("Flash Heal Surge Of Light - MainTank");
                MainTank:Cast(FlashHeal);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Flash Heal Surge Of Light") and OffTank:CanHeal(FlashHeal) then
                module.Bug("Flash Heal Surge Of Light - OffTank");
                OffTank:Cast(FlashHeal);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() < module.GetSecondOptionValue("Flash Heal Surge Of Light") and Lowest:CanHeal(FlashHeal) then
                module.Bug("Flash Heal Surge Of Light - Lowest");
                Lowest:Cast(FlashHeal);
                return;
            end
        end
        -- Prayer Of Mending
        if PrayerOfMending:Exists() and MendingUnits >= module.GetOptionValue("Prayer Of Mending") then
            if MainTank and MainTank:CanHeal(PrayerOfMending) and not MainTank:Buff(PrayerOfMendingBuff) then
                MainTank:Cast(PrayerOfMending)
                return;
            elseif OffTank and OffTank:CanHeal(PrayerOfMending) and not OffTank:Buff(PrayerOfMendingBuff) then
                OffTank:Cast(PrayerOfMending)
                return;
            elseif Lowest and Lowest:CanCast(PrayerOfMending) and not Lowest:Buff(PrayerOfMendingBuff) then
                Lowest:Cast(PrayerOfMending)
                return;
            end
        end
        -- Divine Star
        if DivineStar:Exists() and DivineStarUnits >= module.GetOptionValue("Divine Star") and Player:CanCast(DivineStar) then
            Player:Cast(DivineStar);
            return;
        end
        -- Halo
        if Halo:Exists() and HaloUnits >= module.GetOptionValue("Halo") and Player:CanCast(Halo) then
            Player:Cast(Halo);
            return;
        end
    -- Bad Debuffs - Tank
        if Renew:Exists() and module.IsOptionEnabled("Tank Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Tanks do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Tanks[i], CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage();
                if ThisUnit:CanHeal(Renew) and not ThisUnit:Buff(Renew) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Tank Debuffs") then
                module.Bug("Renew on " .. BestUnit:Name() .. " to heal tank debuff");
                BestUnit:Cast(Renew);
                return;
            end
        end
    -- Bad Debuffs - Debuffs
        if Renew:Exists() and module.IsOptionEnabled("Raid Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Debuff do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Debuff[i], CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage();
                if ThisUnit:CanHeal(Renew) and not ThisUnit:Buff(Renew) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Raid Debuffs") then
                module.Bug("Renew on " .. BestUnit:Name() .. " to mitigate debuff");
                BestUnit:Cast(Renew);
                return;
            end
        end
    -- Bad Debuffs - Topping
        if module.IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Top do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Top[i], CurrentBadDebuffs.Top[i]:SpecialHealthPercentage();
                if ThisUnit:CanHeal(FlashHeal) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil then
                if Renew:Exists() and BestUnitHealth <= module.GetOptionValue("Topping") and BestUnit:CanHeal(Renew) and not BestUnit:Buff(Renew) then
                    module.Bug("Renew on " .. BestUnit:Name() .. " to top it");
                    BestUnit:Cast(Renew);
                    return;
                end
                if FlashHeal:Exists() and BestUnitHealth <= module.GetOptionValue("Topping") and BestUnit:CanHeal(FlashHeal) then
                    module.Bug("Flash Heal on " .. BestUnit:Name() .. " to top it");
                    BestUnit:Cast(FlashHeal);
                    return;
                end
            end
        end
    -- Low Priority Healing
        -- Binding Heal
        if BindingHeal:Exists() and module.IsOptionEnabled("Binding Heal") and Player:SpecialHealthPercentage() < 95 then
            if MainTank and MainTank:HealthPercentage() <= module.GetOptionValue("Binding Heal") and MainTank:CanHeal(BindingHeal) then
                MainTank:Cast(BindingHeal);
                return;
            elseif OffTank and OffTank:HealthPercentage() <= module.GetOptionValue("Binding Heal") and MainTank:CanHeal(BindingHeal) then
                OffTank:Cast(BindingHeal);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetOptionValue("Binding Heal") and Lowest:CanHeal(BindingHeal) and not Lowest:Equals(Player) then
                Lowest:Cast(BindingHeal);
                return;
            end
        end
        -- Renew Cycle
        if Renew:Exists() and module.IsOptionEnabled("Renew") then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #HealUnits do
                local ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage();
                if ThisUnitHealth <= BestUnitHealth and ThisUnit:CanHeal(Renew) and ThisUnit:BuffRemains(Renew) < 3 then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit and BestUnitHealth <= module.GetSecondOptionValue("Renew") then
                module.Bug("Renew - Cycle");
                BestUnit:Cast(Renew);
                return;
            end
        end
        -- Heal Tanks/Lowest
        if Heal:Exists() and module.IsOptionEnabled("Heal") then
            if MainTank and MainTank:CanHeal(Heal) and MainTank:SpecialHealthPercentage() <= module.GetSecondOptionValue("Heal") then
                MainTank:Cast(Heal);
                return;
            end
            if OffTank and OffTank:CanHeal(Heal) and OffTank:SpecialHealthPercentage() <= module.GetSecondOptionValue("Heal") then
                OffTank:Cast(Heal);
                return;
            end
            if Lowest and Lowest:CanHeal(Heal) and Lowest:SpecialHealthPercentage() <= module.GetOptionValue("Heal") then
                Lowest:Cast(Heal);
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Resurrect Deads
        if module.IsOptionEnabled("Resurrection") and Unit.ResurrectCycle(Resurrection) then
            return;
        end
        -- Angelic Feather - when we run more than choosen time
        if module.IsOptionEnabled("Angelic Feather") and AngelicFeather:Exists() and Player:Moving() > module.GetOptionValue("Angelic Feather") and not IsFalling() and Player:BuffRemains(AngelicFeatherBuff) < .5 and Player:CanCast(AngelicFeather) then
            Player:Cast(AngelicFeather);
            return;
        end
        -- Body And Mind - when we run more than choosen time
        if module.IsOptionEnabled("Body And Mind") and BodyAndMind:Exists() and Player:Moving() > module.GetOptionValue("Body And Mind") and not Player:Buff(BodyAndMind) and Player:CanCast(BodyAndMind) then
            Player:Cast(BodyAndMind);
            return;
        end
        if module.IsOptionEnabled("Out Of Combat Healing") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Shadow Priest
    local Rotation = {};
    module.SetRotation("_"..258, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local TargetEnemies_10y, NumEnemies, Enemies, DeathThreshold, DeathUnit = {}, 0, {}, 20, nil;
    local CurrentInsanityDrain, GCDMax, Insanity;

    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicIntellect = Item(109218, false, false, true);
        DraenicIntellectBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);
        GiftOfTheNaaru = Spell(59544, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        BodyAndSoul = Spell(64129);
        BodyAndSoulBuff = Spell(65081);
        Death = Spell(32379, true, true, true);
        DeathReaper = Spell(199911, true, true, true);
        Dispersion = Spell(47585, false, false, true);
        Fade = Spell(586, false, false, true);
        LegacyOfTheVoid = Spell(193225);
        Mindbender = Spell(200174, true, true, true);
        MindBlast = Spell(8092, true, true, false);
        MindFlay = Spell(15407, true, true, false);
        MindSear = Spell(48045, true, true, false);
        MindSpike = Spell(73510, true, true, false);
        Pain = Spell(589, false, true, true);
        PowerInfusion = Spell(10060, false, false, true);
        PurifyDisease = Spell(213634, false, false, true);
        ReaperOfSouls = Spell(199853);
        Resurrection = Spell(2006, false, false, false, true);
        ShadowCrash = Spell(205385, false, true, true);
        ShadowMend = Spell(186263, false, false, false);
        Shadowfiend = Spell(34433, true, true, true);
        Shield = Spell(17, false, false, true);
        Silence = Spell(15487, true, true, true);
        SurrenderToMadness = Spell(193223, false, false, true);
        VampiricEmbrace = Spell(15286, false, false, true);
        VampiricTouch = Spell(34914, false, true, false);
        Void = Spell(205351, true, true, false);
        VoidBolt = Spell(205448, true, true, true);
        VoidEruptionDamage = Spell(228260, true, true, true);
        VoidEruption = Spell(228260, false, false, true);
        VoidForm = Spell(194249, false, false, true);
        VoidRay = Spell(205371);
        VoidRayBuff = Spell(205372);
        VoidTorrent = Spell(205065, true, true, false);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, { 4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest" }, { 2, "Disabled", "Enabled" }, "|cffFF0044Target (Left Box)|r \nAutomatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode. \n|cFF0088FFClosest:|r Target the closest enemy. \n|cFF0088FFLeast HP:|r Target the enemy with the least health remaining. \n|cFF0088FFMost HP:|r Target the enemy with the most health remaining. \n|cFF0088FFTarget Closest:|r Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining. \n\n|cffFF0044Attack (Right Box)|r \nUse /startattack when you changes target. Good for melee classes.");
        module.AddOption("General Settings", "Cooldowns Only On Bosses", false, "Only cast CD's on boss targets.");
        module.AddSection("General Settings", "Utility", "Green");
        --module.AddNewOption("General Settings", "Purify Disease", 220, true, {0.2, 0, 1, 0.1}, nil, "Use Purify to remove debuffs."..C.TOOLTIP_VALUE.."Wait up to 1 second before Purify to look more human");
        module.AddNewOption("General Settings", "Resurrection", 210, true, nil, nil, "Resurrect dead Target with Resurrection while out of combat.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Body And Soul", 220, true, {1.5, 0, 10, 0.1}, nil, "Use Power Word: Shield on player for Body and Soul."..C.TOOLTIP_VALUE.."Time to wait when you start moving to use it.(In seconds)");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Silence to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Mind Blast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Mindbender", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Mindbender with >= 10 Void Form stacks. On cooldown if we have T18 2 pieces."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Power Infusion", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Power Infusion."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Shadowfiend", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Shadowfiend with >= 15 Void Form stacks."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Void Torrent", 232, true, {2, "Always", "Cooldown Only"}, {35, 1, 100, 1}, "Use Void Torrent."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Used when Insanity fall under this threshold.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Dispersion", 210, true, nil, nil, "Use Dispersion during Void Form.");
        module.AddNewOption("Offensive Settings", "Mind Sear", 220, true, {2, 1, 25, 1}, nil, "Use Mind Sear."..C.TOOLTIP_VALUE.."Amount of enemies that must be in 10 yards around our target to use.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Shadow Word: Pain", 222, true, {6, 1, 10, 1}, {3, 0, 25, 0.1}, "Multi-Dot Shadow Word: Pain Cycle."..C.TOOLTIP_VALUE_1.."Amount of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Vampiric Touch", 222, true, {3, 1, 10, 1}, {3, 0, 25, 0.1}, "Multi-Dot Vampiric Touch Cycle."..C.TOOLTIP_VALUE_1.."Amount of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Void Bolt", 210, true, nil, nil, "Multi-Dot Void Bolt Cycle. This will try to maintain dots on as many target as possible.");
        module.AddNewOption("Offensive Settings", "Shadow Crash", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {2, 1, 25, 1}, "Use Shadow Crash."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Target").."Always use on the current target."..C.TOOLTIP_SUBVALUE("Target Standing").."Always use on the current target. Target must be standing still."..C.TOOLTIP_SUBVALUE("Centered").."Use centered on a cluster of enemies."..C.TOOLTIP_SUBVALUE("Centered Standing").."Use centered on a cluster of enemies. Enemies must be standing still."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Shadow Word: Death Any", 210, true, nil, nil, "Enable Shadow Word: Death on any targets that are availabe."..C.TOOLTIP_HINT("Will still use on target if unchecked."));
        module.AddNewOption("Offensive Settings", "Void Eruption", 122, true, {85, 70, 100, 1}, {0, 0, 1.25, 0.05}, "Void Eruption and Void Bolt options."..C.TOOLTIP_VALUE_1.."How much Insanity should we pool before using Void Eruption."..C.TOOLTIP_VALUE_2.."How long should we wait for Void Bolt if it is almost ready.");
        module.AddNewOption("Offensive Settings", "Void Ray", 210, true, nil, nil, "Maintain Void Ray as much as possible.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Defensive Dispersion", 220, true, {30, 1, 100, 1}, nil, "Use Dispersion."..C.TOOLTIP_VALUE.."Health threshold."..C.TOOLTIP_HINT("Never used during Surrender To Madness."));
        module.AddNewOption("Defensive Settings", "Fade", 220, true, {70, 1, 100, 1}, nil, "Use Fade."..C.TOOLTIP_VALUE.."Health threshold."..C.TOOLTIP_HINT("Will only be used if we have high threat situation. Never used during Surrender To Madness."));
        module.AddNewOption("Defensive Settings", "Power Word: Shield", 220, true, {50, 1, 100, 1}, nil, "Use Power Word: Shield on ourself."..C.TOOLTIP_VALUE.."Health threshold."..C.TOOLTIP_HINT("Never used during Surrender To Madness."));
        module.AddNewOption("Defensive Settings", "Shadow Mend", 222, true, {25, 1, 100, 1}, {85, 1, 100, 1}, "Use Shadow Mend on ouself."..C.TOOLTIP_VALUE_1.."In Combat health threshold."..C.TOOLTIP_VALUE_2.."Out of Combat health threshold."..C.TOOLTIP_HINT("Never used during Surrender To Madness."));
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {40, 1, 100, 1}, nil, "Use Gift Of The Naaru on self."..C.TOOLTIP_VALUE.."Health threshold.");
        end

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [VampiricTouch:ID()] = "Vampiric Touch",
            [Void:ID()] = "Shadow Word: Void"
        };
    end

    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Channeling(VoidTorrent) then
            return;
        end

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end
        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        -- Potion
        if module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + MindBlast:CastTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) and Player:IsWithinCastRange(Target, MindBlast) then
            if Player:Potion("Intellect", Potion) then module.Bug("Pre-Pull - Intellect Potion"); Potion = true; end
        end
        -- Mind Blast
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + MindBlast:CastTime() and Target:CanCast(MindBlast) then
            module.Bug("Pre-Pull - MindBlast");
            Target:Cast(MindBlast);
            return;
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Silence, ArcaneTorrent);
    end


    function Rotation:OffGCDAbilities ()

    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        if not Player:Buff(SurrenderToMadness) then
            -- Dispersion
            if Dispersion:Exists() and module.IsOptionEnabled("Defensive Dispersion") and Player:HealthPercentage() <= module.GetOptionValue("Defensive Dispersion") and Player:CanCast(Dispersion) then
                SpellStopCasting();
                Player:Cast(Dispersion);
                return;
            end
            -- Fade
            if Fade:Exists() and module.IsOptionEnabled("Fade") and Target:Exists() and Player:ThreatSituation() == 3 and Player:HealthPercentage() <= module.GetOptionValue("Fade") and Player:CanCast(Fade) then
                Player:Cast(Fade);
                return;
            end
            -- ShadowMend
            if ShadowMend:Exists() and module.IsOptionEnabled("Shadow Mend") and Player:HealthPercentage() <= module.GetOptionValue("Shadow Mend") and Player:CanCast(ShadowMend) then
                Player:Cast(ShadowMend);
                return;
            end
            -- Shield
            if Shield:Exists() and module.IsOptionEnabled("Power Word: Shield") and not Player:BuffAny(Shield) and Player:HealthPercentage() <= module.GetOptionValue("Power Word: Shield") and Player:CanCast(Shield) then
                Player:Cast(Shield);
                return;
            end
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    local function MindFillers ()
        if MindSear:Exists() and not Player:IsMoving() and module.IsOptionEnabled("Mind Sear") and NumEnemies >= module.GetOptionValue("Mind Sear") and not Player:Channeling(MindSear) and Target:CanCast(MindSear) then
            Target:Cast(MindSear);
            return;
        elseif not (MindSear:Exists() and module.IsOptionEnabled("Mind Sear") and NumEnemies >= module.GetOptionValue("Mind Sear") and not Player:IsMoving() and Player:Channeling(MindSear)) then
            if not MindSpike:Exists() then
                -- Mind Flay
                if not Player:Channeling(MindFlay) and Target:CanCast(MindFlay) then
                    Target:Cast(MindFlay);
                    return;
                end
            else
                -- Mind Spike
                if Target:CanCast(MindSpike) then
                    Target:Cast(MindSpike);
                    return;
                end
            end
        end
    end

    local function ShadowWordDeath ()
        if Target:HealthPercentage() <= DeathThreshold and Target:CanCast(Death) then
            Target:Cast(Death);
            return;
        end
        if module.IsOptionEnabled("Shadow Word: Death Any") then
            if DeathUnit and DeathUnit:CanCast(Death, true, true) then
                DeathUnit:Cast(Death);
                return;
            end
        end
    end

    local function VoidBoltCycle ()
        if module.IsOptionEnabled("Multi-Dot Void Bolt") then
            local ThisUnit, BestUnit, BestUnitPainDuration, BestUnitHasVamp = nil, nil, 14, nil;
            for i = 1, #Enemies do
                ThisUnit = Enemies[i];
                if Player:IsFacing(ThisUnit) and ThisUnit:Debuff(Pain) and ThisUnit:DebuffRemains(Pain) > 1.5 and ThisUnit:CanCast(VoidBolt) then
                    if BestUnit == nil or (BestUnitHasVamp == nil and ThisUnit:Debuff(VampiricTouch)) or BestUnitPainDuration > ThisUnit:DebuffRemains(Pain) then
                        BestUnit, BestUnitPainDuration, BestUnitHasVamp = ThisUnit, ThisUnit:DebuffRemains(Pain), ThisUnit:Debuff(VampiricTouch);
                    end
                end
            end
            if BestUnit then
                BestUnit:Cast(VoidEruptionDamage);
                return;
            end
        end
    end

    function Rotation:Combat ()
        -- Common values for SimC Calculations
        CurrentInsanityDrain, GCDMax, Insanity = Player:Buff(VoidForm) and 7.5 + Player:BuffCount(VoidForm)*0.5 or 0, Player:GCD(), Player:Insanity();
        if Target:Exists() and Player:CanAttack(Target) then
            -- Body And Soul
            if not Player:Buff(SurrenderToMadness) and BodyAndSoul:Exists() and module.IsOptionEnabled("Body And Soul") and Player:Moving() > module.GetOptionValue("Body And Soul") and not Player:Buff(BodyAndSoulBuff) and Player:CanCast(Shield) then
                Player:Cast(Shield);
                return;
            end

            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                Enemies = Player:EnemiesWithinDistance(40); -- 40 yards for Dots.
                Enemies_10y = Target:EnemiesWithinDistance(10); -- 10 yards for Mind Sear.
                NumEnemies = #Enemies_10y;
                PainUnit = Unit.DotCycle(Enemies, Pain, Pain, 14, "Multi-Dot Shadow Word: Pain");
                VampUnit = Unit.DotCycle(Enemies, VampiricTouch, VampiricTouch, 18, "Multi-Dot Vampiric Touch");
                DeathThreshold = ReaperOfSouls:Exists() and 35 or 20;
                DeathUnit = Unit.LightEnemyAvailableForSpellHP(Enemies, Death, DeathThreshold);
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- actions=call_action_list,name=s2m,if=buff.voidform.up&buff.surrender_to_madness.up
            if Player:Buff(VoidForm) and Player:Buff(SurrenderToMadness) then
                if Player:IsWithinCastRange(Target, MindBlast) and Insanity >= 40 then
                    Player:UseTrinkets();
                end
                -- actions.s2m=shadow_crash,if=talent.shadow_crash.enabled
                if ShadowCrash:Exists() and module.IsOptionEnabled("Shadow Crash") and Target:CanCast(ShadowCrash) then
                    if Target:CastGroundSpell(ShadowCrash, "Shadow Crash", 8) then return; end
                end
                -- actions.s2m+=/mindbender,if=talent.mindbender.enabled
                if Mindbender:Exists() and module.IsOptionEnabled("Mindbender") and (module.CooldownsAllowed() or module.GetOptionValue("Mindbender") == "Always") and Target:CanCast(Mindbender) then
                    Target:Cast(Mindbender);
                    return;
                end
                -- actions.s2m+=/dispersion,if=!buff.power_infusion.up&!buff.berserking.up&!buff.bloodlust.up
                if Dispersion:Exists() and module.IsOptionEnabled("Dispersion") and not Player:Buff(PowerInfusion) and not Player:Buff(Berserking) and not Player:HasHero() and Player:CanCast(Dispersion) then
                    Player:Cast(Dispersion);
                    return;
                end
                -- actions.s2m+=/power_infusion,if=buff.voidform.stack>=10
                if PowerInfusion:Exists() and module.IsOptionEnabled("Power Infusion") and (module.CooldownsAllowed() or module.GetOptionValue("Power Infusion") == "Always") and Player:BuffCount(VoidForm) >= 10 and Player:CanCast(PowerInfusion) then
                    Player:Cast(PowerInfusion);
                end
                -- actions.s2m+=/berserking,if=buff.voidform.stack>=10
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:BuffCount(VoidForm) >= 10 then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                end
                -- actions.s2m+=/void_bolt,if=dot.shadow_word_pain.remains<3.5*gcd,cycle_targets=1
                VoidBoltCycle();
                -- actions.s2m+=/void_bolt
                if Target:CanCast(VoidBolt) then
                    Target:Cast(VoidEruptionDamage);
                    return;
                end
                -- actions.s2m+=/void_torrent
                if VoidTorrent:Exists() and module.IsOptionEnabled("Void Torrent") and (module.CooldownsAllowed() or module.GetOptionValue("Void Torrent") == "Always") and Insanity < module.GetSecondOptionValue("Void Torrent")and Target:CanCast(VoidTorrent) then
                    Target:Cast(VoidTorrent);
                    return;
                end
                -- actions.s2m+=/shadow_word_death,if=!talent.reaper_of_souls.enabled&current_insanity_drain*gcd.max>insanity&(insanity-(current_insanity_drain*gcd.max)+30)<100
                if Death:Exists() and not ReaperOfSouls:Exists() and CurrentInsanityDrain * GCDMax > Insanity and (Insanity - (CurrentInsanityDrain * GCDMax) + 30) < 100 then
                    ShadowWordDeath();
                end
                -- actions.s2m+=/shadow_word_death,if=talent.reaper_of_souls.enabled&current_insanity_drain*gcd.max>insanity&(insanity-(current_insanity_drain*gcd.max)+90)<100
                if Death:Exists() and ReaperOfSouls:Exists() and CurrentInsanityDrain * GCDMax > Insanity and (Insanity - (CurrentInsanityDrain * GCDMax) + 75) < 100 then
                    ShadowWordDeath();
                end
                -- actions.s2m+=/mind_blast
                if MindBlast:Exists() and Target:CanCast(MindBlast) then
                    Target:Cast(MindBlast);
                    return;
                end
                -- actions.s2m+=/shadow_word_death,if=cooldown.shadow_word_death.charges=2
                if Death:Exists() and (Death:Charges() == 2 or (Death:Charges() == 1 and Death:Recharge() < 3)) then
                    ShadowWordDeath();
                end
                -- actions.s2m+=/shadowfiend,if=!talent.mindbender.enabled,if=buff.voidform.stack>15
                if Shadowfiend:Exists() and module.IsOptionEnabled("Shadowfiend") and (module.CooldownsAllowed() or module.GetOptionValue("Shadowfiend") == "Always") and Player:BuffCount(VoidForm) >= 15 and Target:CanCast(Shadowfiend) then
                    Target:Cast(Shadowfiend);
                    return;
                end
                -- actions.s2m+=/shadow_word_void,if=(insanity-(current_insanity_drain*gcd.max)+75)<100
                if Void:Exists() and (Insanity - (CurrentInsanityDrain * GCDMax) + 75) < 100 and Target:CanCast(Void) then
                    Target:Cast(Void);
                    return;
                end
                -- actions.s2m+=/shadow_word_pain,if=!ticking,cycle_targets=1
                if Pain:Exists() and module.IsOptionEnabled("Multi-Dot Shadow Word: Pain") and PainUnit then
                    PainUnit:Cast(Pain);
                    return;
                end
                -- actions.s2m+=/vampiric_touch,if=!ticking,cycle_targets=1
                if VampiricTouch:Exists() and module.IsOptionEnabled("Multi-Dot Vampiric Touch") and VampUnit then
                    VampUnit:Cast(VampiricTouch);
                    return;
                end
                -- actions.s2m+=/wait,sec=cooldown.void_bolt.remains,if=cooldown.void_bolt.remains<(gcd.max*0.75)
                if VoidBolt:Cooldown() < module.GetSecondOptionValue("Void Eruption") then
                    module.Bug("Erruption in " .. VoidBolt:Cooldown());
                    return;
                end
                -- actions.s2m+=/mind_flay,if=!talent.mind_spike.enabled,interrupt=1,chain=1
                -- actions.s2m+=/mind_spike,if=talent.mind_spike.enabled
                MindFillers();
                -- actions.s2m+=/shadow_word_pain


            -- actions+=/call_action_list,name=vf,if=buff.voidform.up
            elseif Player:Buff(VoidForm) then
                if Player:IsWithinCastRange(Target, MindBlast) and Insanity >= 40 then
                    Player:UseTrinkets();
                end
                -- actions.vf=surrender_to_madness,if=talent.surrender_to_madness.enabled&insanity>=25&(cooldown.void_bolt.up|cooldown.void_torrent.up|cooldown.shadow_word_death.up|buff.shadowy_insight.up)&target.time_to_die<=90+((raw_haste_pct*100)*2)-buff.insanity_drain_stacks.stack
                -- actions.vf+=/shadow_crash,if=talent.shadow_crash.enabled
                if ShadowCrash:Exists() and module.IsOptionEnabled("Shadow Crash") and Target:CanCast(ShadowCrash) then
                    if Target:CastGroundSpell(ShadowCrash, "Shadow Crash", 8) then return; end
                end
                -- actions.vf+=/mindbender,if=talent.mindbender.enabled
                if Mindbender:Exists() and module.IsOptionEnabled("Mindbender") and (module.CooldownsAllowed() or module.GetOptionValue("Mindbender") == "Always") and Target:CanCast(Mindbender) then
                    Target:Cast(Mindbender);
                    return;
                end
                -- actions.vf+=/dispersion,if=!buff.power_infusion.up&!buff.berserking.up&!buff.bloodlust.up
                if Dispersion:Exists() and module.IsOptionEnabled("Dispersion") and not Player:Buff(PowerInfusion) and not Player:Buff(Berserking) and not Player:HasHero() and Player:CanCast(Dispersion) then
                    Player:Cast(Dispersion);
                    return;
                end
                -- actions.vf+=/power_infusion,if=buff.voidform.stack>=10&buff.insanity_drain_stacks.stack<=30
                if PowerInfusion:Exists() and module.IsOptionEnabled("Power Infusion") and (module.CooldownsAllowed() or module.GetOptionValue("Power Infusion") == "Always") and Player:BuffCount(VoidForm) >= 10 and Player:CanCast(PowerInfusion) then
                    Player:Cast(PowerInfusion);
                end
                -- actions.vf+=/berserking,if=buff.voidform.stack>=10&buff.insanity_drain_stacks.stack<=20
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:BuffCount(VoidForm) >= 10 then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                end
                -- actions.vf+=/void_bolt,if=dot.shadow_word_pain.remains<3.5*gcd,cycle_targets=1
                VoidBoltCycle();
                -- actions.vf+=/void_bolt
                if Target:CanCast(VoidBolt) then
                    Target:Cast(VoidEruptionDamage);
                    return;
                end
                -- actions.vf+=/void_torrent
                if VoidTorrent:Exists() and module.IsOptionEnabled("Void Torrent") and (module.CooldownsAllowed() or module.GetOptionValue("Void Torrent") == "Always") and Insanity < module.GetSecondOptionValue("Void Torrent")and Target:CanCast(VoidTorrent) then
                    Target:Cast(VoidTorrent);
                    return;
                end
                -- actions.vf+=/shadow_word_death,if=!talent.reaper_of_souls.enabled&current_insanity_drain*gcd.max>insanity&(insanity-(current_insanity_drain*gcd.max)+10)<100
                if Death:Exists() and not ReaperOfSouls:Exists() and CurrentInsanityDrain * GCDMax > Insanity  and (Insanity - (CurrentInsanityDrain * GCDMax) + 10) < 100 then
                    ShadowWordDeath();
                end
                -- actions.vf+=/shadow_word_death,if=talent.reaper_of_souls.enabled&current_insanity_drain*gcd.max>insanity&(insanity-(current_insanity_drain*gcd.max)+30)<100
                if Death:Exists() and ReaperOfSouls:Exists() and CurrentInsanityDrain * GCDMax > Insanity  and (Insanity - (CurrentInsanityDrain * GCDMax) + 30) < 100 then
                    ShadowWordDeath();
                end
                -- actions.vf+=/mind_blast
                if MindBlast:Exists() and Target:CanCast(MindBlast) then
                    Target:Cast(MindBlast);
                    return;
                end
                -- actions.vf+=/shadow_word_death,if=cooldown.shadow_word_death.charges=2
                if Death:Exists() and (Death:Charges() == 2 or (Death:Charges() == 1 and Death:Recharge() < 3)) then
                    ShadowWordDeath();
                end
                -- actions.vf+=/shadowfiend,if=!talent.mindbender.enabled,if=buff.voidform.stack>15
                if Shadowfiend:Exists() and module.IsOptionEnabled("Shadowfiend") and (module.CooldownsAllowed() or module.GetOptionValue("Shadowfiend") == "Always") and Player:BuffCount(VoidForm) >= 15 and Target:CanCast(Shadowfiend) then
                    Target:Cast(Shadowfiend);
                    return;
                end
                -- actions.vf+=/shadow_word_void,if=(insanity-(current_insanity_drain*gcd.max)+25)<100
                if Void:Exists() and (Insanity - (CurrentInsanityDrain * GCDMax) + 25) < 100 and Target:CanCast(Void) then
                    Target:Cast(Void);
                    return;
                end
                -- actions.vf+=/shadow_word_pain,if=!ticking,cycle_targets=1
                if Pain:Exists() and module.IsOptionEnabled("Multi-Dot Shadow Word: Pain") and PainUnit then
                    PainUnit:Cast(Pain);
                    return;
                end
                -- actions.vf+=/vampiric_touch,if=!ticking,cycle_targets=1
                if VampiricTouch:Exists() and module.IsOptionEnabled("Multi-Dot Vampiric Touch") and VampUnit then
                    VampUnit:Cast(VampiricTouch);
                    return;
                end
                -- actions.vf+=/wait,sec=cooldown.void_bolt.remains,if=cooldown.void_bolt.remains<(gcd.max*0.75)
                if VoidBolt:Cooldown() < module.GetSecondOptionValue("Void Eruption") then
                    module.Bug("Erruption in " .. VoidBolt:Cooldown());
                    return;
                end
                -- actions.vf+=/mind_flay,if=!talent.mind_spike.enabled,interrupt=1,chain=1
                -- actions.vf+=/mind_spike,if=talent.mind_spike.enabled
                MindFillers();
                -- actions.vf+=/shadow_word_pain


            -- actions+=/call_action_list,name=main
            else
                -- actions.main=surrender_to_madness,if=talent.surrender_to_madness.enabled&target.time_to_die<=90+((raw_haste_pct*100)*2)
                -- actions.main+=/mindbender,if=talent.mindbender.enabled
                if Mindbender:Exists() and module.IsOptionEnabled("Mindbender") and (module.CooldownsAllowed() or module.GetOptionValue("Mindbender") == "Always") and Target:CanCast(Mindbender) then
                    Target:Cast(Mindbender);
                    return;
                end
                -- actions.main+=/shadow_word_pain,if=dot.shadow_word_pain.remains<(3+(4%3))*gcd
                if Pain:Exists() and Target:DebuffRemains(Pain) < 4.2 and Target:CanCast(Pain) then
                    Target:Cast(Pain);
                    return;
                end
                -- actions.main+=/vampiric_touch,if=dot.vampiric_touch.remains<(4+(4%3))*gcd
                if VampiricTouch:Exists() and Target:DebuffRemains(VampiricTouch) < 5.4 and not VampiricTouch:WasLastCastOnUnit(Target) and Target:CanCast(VampiricTouch) then
                    Target:Cast(VampiricTouch);
                    return;
                end
                -- actions.main+=/void_eruption,if=insanity>=85|(talent.auspicious_spirits.enabled&insanity>=(80-shadowy_apparitions_in_flight*4))
                if VoidEruption:Exists() and Insanity >= module.GetOptionValue("Void Eruption") and Player:CanCast(VoidEruption) then
                    Player:Cast(VoidEruption);
                    return;
                end
                -- actions.main+=/shadow_crash,if=talent.shadow_crash.enabled
                if ShadowCrash:Exists() and module.IsOptionEnabled("Shadow Crash") and Target:CanCast(ShadowCrash) then
                    if Target:CastGroundSpell(ShadowCrash, "Shadow Crash", 8) then return; end
                end
                -- actions.main+=/mindbender,if=talent.mindbender.enabled&set_bonus.tier18_2pc
                if Mindbender:Exists() and module.IsOptionEnabled("Mindbender") and (module.CooldownsAllowed() or module.GetOptionValue("Mindbender") == "Always") and module.HasT18_2Pc and Target:CanCast(Mindbender) then
                    Target:Cast(Mindbender);
                    return;
                end
                -- actions.main+=/shadow_word_pain,if=!ticking&talent.legacy_of_the_void.enabled&insanity>=70,cycle_targets=1
                if Pain:Exists() and not LegacyOfTheVoid:Exists() and module.IsOptionEnabled("Multi-Dot Shadow Word: Pain") and PainUnit then
                    PainUnit:Cast(Pain);
                    return;
                end
                -- actions.main+=/vampiric_touch,if=!ticking&talent.legacy_of_the_void.enabled&insanity>=70,cycle_targets=1
                if VampiricTouch:Exists() and not LegacyOfTheVoid:Exists() and module.IsOptionEnabled("Multi-Dot Vampiric Touch") and VampUnit then
                    VampUnit:Cast(VampiricTouch);
                    return;
                end
                -- actions.main+=/shadow_word_death,if=!talent.reaper_of_souls.enabled&cooldown.shadow_word_death.charges=2&insanity<=90
                if Death:Exists() and not ReaperOfSouls:Exists() and Death:Charges() >= 2 and Insanity < 90 then
                    ShadowWordDeath();
                end
                -- actions.main+=/shadow_word_death,if=talent.reaper_of_souls.enabled&cooldown.shadow_word_death.charges=2&insanity<=70
                if Death:Exists() and ReaperOfSouls:Exists() and Death:Charges() >= 2 and Insanity < 70 then
                    ShadowWordDeath();
                end
                -- actions.main+=/mind_blast,if=talent.legacy_of_the_void.enabled&(insanity<=81|(insanity<=75.2&talent.fortress_of_the_mind.enabled))
                if MindBlast:Exists() and LegacyOfTheVoid:Exists() and (Insanity <= 81 or (Insanity <= 75.2 and FortressOfTheMind:Exists())) and Target:CanCast(MindBlast) then
                    Target:Cast(MindBlast);
                    return;
                end
                -- actions.main+=/mind_blast,if=!talent.legacy_of_the_void.enabled|(insanity<=96|(insanity<=95.2&talent.fortress_of_the_mind.enabled))
                if MindBlast:Exists() and not LegacyOfTheVoid:Exists() and (Insanity <= 96 or (Insanity <= 95.2 and FortressOfTheMind:Exists())) and Target:CanCast(MindBlast) then
                    Target:Cast(MindBlast);
                    return;
                end
                -- actions.main+=/shadow_word_pain,if=!ticking,cycle_targets=1
                if Pain:Exists() and module.IsOptionEnabled("Multi-Dot Shadow Word: Pain") and PainUnit then
                    PainUnit:Cast(Pain);
                    return;
                end
                -- actions.main+=/vampiric_touch,if=!ticking,cycle_targets=1
                if VampiricTouch:Exists() and module.IsOptionEnabled("Multi-Dot Vampiric Touch") and VampUnit then
                    VampUnit:Cast(VampiricTouch);
                    return;
                end
                -- actions.main+=/shadow_word_void,if=(insanity<=70&talent.legacy_of_the_void.enabled)|(insanity<=85&!talent.legacy_of_the_void.enabled)
                if Void:Exists() and ((Insanity <= 70 and LegacyOfTheVoid:Exists()) or (Insanity <= 85 and not LegacyOfTheVoid:Exists())) and Target:CanCast(Void) then
                    Target:Cast(Void);
                    return;
                end
                -- actions.main+=/mind_flay,if=!talent.mind_spike.enabled,interrupt=1,chain=1
                -- actions.main+=/mind_spike,if=talent.mind_spike.enabled
                MindFillers();
                -- actions.main+=/shadow_word_pain
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(MindBlast, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Resurrect Deads
        if Resurrection:Exists() and module.IsOptionEnabled("Resurrection") and Unit.ResurrectCycle(Resurrection) then
            return;
        end
        -- ShadowMend
        if ShadowMend:Exists() and module.IsOptionEnabled("Shadow Mend") and Player:HealthPercentage() <= module.GetSecondOptionValue("Shadow Mend") and Player:CanCast(ShadowMend) then
            Player:Cast(ShadowMend);
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() -- Leveling Assassination Rogue Rotation
    local Rotation = {};
    module.SetRotation("_"..259, Rotation);

    --- Localization
    -- Core
    local Enemies_10y, Enemies_5y, NumEnemies = {}, {}, 1; -- Enemies
    local SpamPrevention, TPSTime = 0, 0.1; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local StealthAllowed, CombatStealthAllowed = false, true; -- Stealth Handler
    local MaxComboPoint, DurationThreshold = 5, 12.6; -- Combo Points Variables
    local PoisonLethal, PoisonNonLethal, PoisonMinDuration, PoisonCastTime = nil, nil, nil, nil; -- Poison Handler
    local Rupt = {BestUnit, BestUnitTTD}; -- Rupture Cycling Variables
    local Muti = {BestUnit, BestUnit2, BestUnit3, BestUnit4}; -- Mutilate Cycling Variables
    local Hemo = {BestUnit, BestUnitTTD}; -- Hemorrhage Cycling Variables

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        --- Spells
        -- (ID, RequiresFacing, Hostile, Instant)
        -- Racials
        ArcaneTorrent = Spell(25046, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);
        -- Items
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Abilities
        Anticipation = Spell(114015, false, false, true);
        CheapShot = Spell(1833, true, true, true);
        DeathFromAbove = Spell(152150, true, true, true);
        DeeperStrategem = Spell(193531, false, false, true);
        ElaboratePlanning = Spell(193640, false, false, false);
        ElaboratePlanningBuff = Spell(193641, false, false, false);
        Envenom = Spell(32645, true, true, true);
        Exsanguinate = Spell(200806, true, true, true);
        FanOfKnives = Spell(51723, false, false, true);
        Garrote = Spell(703, true, true, true);
        Hemorrhage = Spell(16511, true, true, true);
        Kick = Spell(1766, true, true, true);
        KidneyShot = Spell(408, true, true, true);
        MarkedForDeath = Spell(137619, false, true, true);
        Mutilate = Spell(1329, true, true, true);
        PickPocket = Spell(921, true, true, true);
        PoisonedKnife = Spell(185565, true, true, true);
        Rupture = Spell(1943, true, true, true);
        ShadowFocus = Spell(108209, false, false, true);
        Subterfuge = Spell(108208, false, false, true);
        Stealth = Spell(1784, false, false, true);
        TricksoftheTrade = Spell(57934, false, false, true);
        Vanish = Spell(1856, false, false, true);
        -- Offensive Cooldowns
        Kingsbane = Spell(192759, true, true, true);
        Vendetta = Spell(79140, true, true, true);
        -- Defensive Cooldowns
        CloakofShadows = Spell(31224, false, false, true);
        CrimsonVial = Spell(185311, false, false, true);
        Feint = Spell(1966, false, false, true);
        Evasion = Spell(5277, false, false, true);
        -- Poisons
        AgonizingPoison = Spell(200802, false, false, false);
        AgonizingPoisonDebuff = Spell(200803, false, true, false);
        CripplingPoison = Spell(3408, false, false, false);
        DeadlyPoison = Spell(2823, false, false, false);
        DeadlyPoisonDebuff = Spell(2818, false, true, true);
        LeechingPoison = Spell(108211, false, false, false);
        WoundPoison = Spell(8679, false, false, false);

        --- GUI Frame
        -- Pages
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Kick to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddNewOption("General Settings", "Tricks of the Trade on Focus", 230, false, {2, "Always", "On Aggro"}, nil, "Will use Tricks of the Trade on your focus if he's allied."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Everytime it is available."..C.TOOLTIP_SUBVALUE("On Aggro").."Only if you have the aggro of something.");
        module.AddSection("General Settings", "Poisons", "Green");
        module.AddNewOption("General Settings", "Lethal | Non-Lethal", 233, true, {1, "Agonizing", "Deadly", "Wound"}, {1, "Leeching", "Crippling"}, "Choose your Poisons"..C.TOOLTIP_VALUE_1.."Choose your Lethal Poison."..C.TOOLTIP_VALUE_2.."Choose your Non-Lethal Poison. "..C.TOOLTIP_HINT("If you choose Agonizing and/or Leeching but you don't have the talent it will put Deadly and/or Crippling."));
        module.AddNewOption("General Settings", "Min Duration Poison", 120, true, {15, 0, 60, 1}, nil, "Set the minimun duration to have on Poisons in minutes before starting the combat.");
        module.AddSection("General Settings", "Solo", "Green");
        module.AddNewOption("General Settings", "Kidney Shot", 210, false, nil, nil, "Enable for the automatic usage of Kidney Shot."..C.TOOLTIP_HINT("Useful if you're having hard time while soloing."));
        module.AddNewOption("General Settings", "Cheap Shot", 210, false, nil, nil, "Enable for the automatic usage of Cheap Shot."..C.TOOLTIP_HINT("Useful if you're having hard time while soloing."));
        module.AddNewOption("General Settings", "Pick Pocket", 210, false, nil, nil, "Will PickPocket your target before engaging it."..C.TOOLTIP_HINT("Enabling Pick Pocket will turn on Auto-Loot."));

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddNewOption("Offensive Settings", "Stealth", 230, true, {1, "Always", "Near Target"}, nil, "Enable for the automatic usage of Stealth."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Everytime it is available."..C.TOOLTIP_SUBVALUE("Near Target").."When approaching your target.");
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Exsanguinate", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Exsanguinate."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Marked For Death", 233, true, {2, "Target", "Adds"}, {1, "Always", "Cooldown Only"}, "Enable for the automatic usage of Marked for Death."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Target", true).."Only on your target with 1 or less CP."..C.TOOLTIP_SUBVALUE("Adds").."On every units available."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Vanish", 233, true, {1, "Always", "Not Tanking"}, {2, "Always", "Cooldown Only"}, "Enable for the automatic usage of Vanish."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will 'Always' use Vanish no matter if you're tanking or not."..C.TOOLTIP_SUBVALUE("Not Tanking").."Will only use Vanish if you're 'Not Tanking' the target (Mostly for Solo)."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Kingsbane", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Kingsbane."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Vendetta", 210, true, nil, nil, "Enable for the automatic usage of Vendetta.");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Arcane Torrent, Berserking, Bloodfury are supported."));
        end
        module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Disabled", "Enabled"}, {2, "Disabled", "Enabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Poisoned Knife", 220, true, {75, 40, 150, 1}, nil, "Enable to auto use Throw while not being in melee range and not being stealthed."..C.TOOLTIP_VALUE.."Set the minimum energy to start using it.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Health Percentage to use Healing Belt / Healing Pot / Healthstone.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Crimson Vial", 220, true, {65, 1, 100, 1}, nil, "Health Percentage to use Crimson Vial.");
        module.AddNewOption("Defensive Settings", "Feint", 220, false, {55, 1, 100, 1}, nil, "Health Percentage to use Feint."..C.TOOLTIP_HINT("Put 100 to maintain 100% uptime."));
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, false, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Evasion", 220, true, {25, 1, 100, 1}, nil, "Health Percentage to use Evasion.");
        module.AddNewOption("Defensive Settings", "Cloak of Shadows", 220, true, {45, 1, 100, 1}, nil, "Health Percentage to use Cloak of Shadows.");
        module.AddNewOption("Defensive Settings", "Vanish Defensive", 220, false, {10, 1, 100, 1}, nil, "Health Percentage to use Vanish defensively.");

        --- Misc
        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated
        Player:SetCommonMeleeStatus();
        -- Reset the target for the Auto Re-Target Option
        Target = module.Unit.Target;
        -- Combo Points Variables
        MaxComboPoint = Anticipation:Exists() and 8 or DeeperStrategem:Exists() and 6 or 5;
        DurationThreshold = DeeperStrategem:Exists() and 8.4 or 7.2;
        -- Stealth Handler
        CombatStealthAllowed = Vanish:TimeSinceCast() > 0.5;
        Stealth = Subterfuge:Exists() and Spell(115191, false, false, true) or Spell(1784, false, false, true); -- w/ or w/o Subterfuge Talent

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Vanish Defensive") and VanishAllowed and not Player:IsStealthed(true) and Player:HealthPercentage() <= module.GetOptionValue("Vanish Defensive") and Shadowmeld:TimeSinceCast() > 0.5 and Player:CanCast(Vanish) then
            Player:Cast(Vanish);
            Vanish.LastCastTime = module.GetTime();
            return;
        end
        if module.IsOptionEnabled("Evasion") and not Player:Buff(Evasion) and Player:HealthPercentage() <= module.GetOptionValue("Evasion") and Player:CanCast(Evasion) then
            Player:Cast(Evasion);
        end
        if module.IsOptionEnabled("Cloak of Shadows") and Player:HealthPercentage() <= module.GetOptionValue("Cloak of Shadows") and Player:CanCast(CloakofShadows) then
            Player:Cast(CloakofShadows);
        end
        -- Defensive Abilities
        if module.IsOptionEnabled("Feint") and Player:HealthPercentage() <= module.GetOptionValue("Feint") and not Player:Buff(Feint) and Player:CanCast(Feint) then
            Player:Cast(Feint);
            return;
        end
        if module.IsOptionEnabled("Crimson Vial") and Player:HealthPercentage() <= module.GetOptionValue("Crimson Vial") and Player:CanCast(CrimsonVial) then
            Player:Cast(CrimsonVial);
            return;
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Kick, ArcaneTorrent);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Tricks of the Trade on Focus
        if module.IsOptionEnabled("Tricks of the Trade on Focus") and (module.GetOptionValue("Tricks of the Trade on Focus") == "Always" or (Player:ThreatSituation() and Player:ThreatSituation() >= 1)) and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
            Focus:Cast(TricksoftheTrade);
        end
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Marked for Death Handler for Adds
        if Player:UseMarkedForDeath(MarkedForDeath, Player:ComboPointsDeficit()) then
            return;
        end
        -- Auto Target
        Target = Player:ReTarget(Mutilate, false) or Unit.Target;
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Enemies Check
            if module.UseAOE() then
                Enemies_10y = Player:EnemiesWithinDistance(10, true); -- Using 10y (real range) for Fan of Knives and true as they are PlayerCenteredAoE Spells.
                Enemies_5y = Player:FilterEnemiesByDistance(Enemies_10y, 5, false); -- This table is used for Melee Range Cycling Abilities (like Rupture, Hemorrhage, ...).
                NumEnemies = #Enemies_10y;
            else
                NumEnemies = 1;
            end
            -- Cooldowns
            if Player:IsWithinCastRange(Target, Mutilate) then
                if module.CooldownsAllowed() then
                    -- potion,name=draenic_agility,if=buff.bloodlust.react|target.time_to_die<30|cooldown.vendetta.remains<10
                    -- TODO

                    -- vendetta,if=((!artifact.urge_to_kill.enabled&dot.rupture.ticking)|(energy%energy.max)<0.4)&(time<10|cooldown.exsanguinate.remains<5)
                    -- TODO Add Urge to Kill
                    if module.IsOptionEnabled("Vendetta") and not Target:Debuff(Vendetta) and (Target:Debuff(Rupture) or (Player:Energy()/Player:EnergyMax() < 0.4 and (CombatTime() < 10 or not Exsanguinate:Exists() or Exsanguinate:Cooldown() < 5))) and Target:CanCast(Vendetta) then
                        Target:Cast(Vendetta);
                    end
                    -- use_item,slot=x,if=buff.bloodlust.react|target.time_to_die<20|debuff.vendetta.up
                    if Player:HasHero() or Target:TimeToDie() < 20 or Target:Debuff(Vendetta) then
                        Player:UseTrinkets();
                    end
                end
                if (BloodFury:Exists() or Berserking:Exists() or ArcaneTorrent:Exists()) and module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:IsWithinCastRange(Target, Mutilate) and Target:Debuff(Vendetta) then
                    -- blood_fury,if=debuff.vendetta.up
                    if Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- berserking,if=debuff.vendetta.up
                    if Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                    -- arcane_torrent,if=debuff.vendetta.up&energy.deficit>50
                    if Player:CanCast(ArcaneTorrent) and Player:EnergyDeficit() > 50 then
                        Player:Cast(ArcaneTorrent);
                    end
                end
                -- exsanguinate,if=prev_gcd.rupture&dot.rupture.remains>20
                if module.IsOptionEnabled("Exsanguinate") and (module.CooldownsAllowed() or module.GetOptionValue("Exsanguinate") == "Always") and Exsanguinate:Exists() and Target:DebuffRemains(Rupture) > 20 and Target:CanCast(Exsanguinate) then
                    Target:Cast(Exsanguinate);
                    return;
                end
                if not Player:IsStealthed(true, true) and CombatStealthAllowed then
                    -- vanish,if=cooldown.exsanguinate.remains<2&combo_points>4+talent.deeper_stratagem.enabled
                    if module.IsOptionEnabled("Vanish") and (module.CooldownsAllowed() or module.GetSecondOptionValue("Vanish") == "Always") and (not Player:IsTanking(Target) or module.GetOptionValue("Vanish") == "Always") and (Exsanguinate:Cooldown() < 2 or not Exsanguinate:Exists()) and Player:ComboPoints() > 4+(DeeperStrategem:Exists() and 1 or 0) and Player:CanCast(Vanish) then
                        Player:Cast(Vanish);
                        Vanish.LastCastTime = module.GetTime();
                        return;
                    end
                end
            end
            -- Kidney Shot
            if module.IsOptionEnabled("Kidney Shot") and not Target:IsBoss() and Target:DebuffRemains(CheapShot) < 1 and Target:CanCast(KidneyShot) then
                Target:Cast(KidneyShot);
                return;
            end
            -- rupture,if=(combo_points>4+talent.deeper_stratagem.enabled&(cooldown.exsanguinate.remains<1|!exsanguinated&refreshable))|(time<4&dot.hemorrhage.remains>10&dot.garrote.remains>8)
            if ((Player:ComboPoints() > 4+(DeeperStrategem:Exists() and 1 or 0) and (Exsanguinate:Cooldown() < 1 or (not module.Exsanguinated(Target, "Rupture") and Target:DebuffRefreshable(Rupture)))) or (CombatTime() < 4 and Target:DebuffRemains(Hemorrhage) > 10 and Target:DebuffRemains(Garrote) > 8)) and Target:CanCast(Rupture) then
                Target:Cast(Rupture);
                return;
            end
            -- rupture,if=spell_targets.fan_of_knives>1&!ticking&combo_points>4
            if NumEnemies > 1 and Player:ComboPoints() > 4+(DeeperStrategem:Exists() and 1 or 0) and not Target:Debuff(Rupture) and Target:CanCast(Rupture) then
                Target:Cast(Rupture);
                return;
            end
            -- rupture,cycle_targets=1,target_if=max:target.time_to_die,max_cycle_targets=6,if=spell_targets.fan_of_knives>1&!ticking&combo_points>4
            if NumEnemies > 1 and Player:ComboPoints() > 4+(DeeperStrategem:Exists() and 1 or 0) then
                local Count = 0;
                local ThisUnit;
                for i = 1, #Enemies_5y do
                    ThisUnit = Enemies_5y[i];
                    if ThisUnit:Debuff(Rupture) then
                        Count = Count + 1;
                    end
                end
                if Count <= 6 then
                    Rupt.BestUnit, Rupt.BestUnitTTD = nil, 4;
                    -- TTD Units Handler.
                    local ThisUnitTTD;
                    for i = 1, #Enemies_5y do
                        ThisUnit = Enemies_5y[i];
                        ThisUnitTTD = ThisUnit:TimeToDie(10);
                        if ThisUnitTTD < 5000 and not ThisUnit:Debuff(Rupture) and ThisUnitTTD > Rupt.BestUnitTTD and ThisUnit:CanCast(Rupture) then
                            Rupt.BestUnit, Rupt.BestUnitTTD = ThisUnit, ThisUnitTTD;
                        end
                    end
                    -- Cast Rupture if we got an unit.
                    if Rupt.BestUnit then
                        Rupt.BestUnit:Cast(Rupture);
                        return;
                    end
                end
            end
            -- death_from_above,if=combo_points>4
            if DeathFromAbove:Exists() and Player:ComboPoints() > 4 and Target:CanCast(DeathFromAbove) then
                Target:Cast(DeathFromAbove);
                return;
            end
            -- envenom,if=combo_points>3+talent.deeper_stratagem.enabled&(energy.deficit<40|dot.rupture.exsanguinated)&buff.envenom.remains<(1+combo_points)*0.3&buff.elaborate_planning.remains<2
            if Player:ComboPoints() > 3+(DeeperStrategem:Exists() and 1 or 0) and (Player:EnergyDeficit() < 40 or module.Exsanguinated(Target, "Rupture")) and Player:BuffRemains(Envenom) < (1+Player:ComboPoints())*0.3 and Player:BuffRemains(ElaboratePlanningBuff) < 2 and Target:CanCast(Envenom) then
                Target:Cast(Envenom);
                return;
            end
            -- marked_for_death,cycle_targets=1,target_if=min:target.time_to_die,if=combo_points.deficit>=4+talent.deeper_stratagem.enabled
            if module.IsOptionEnabled("Marked For Death") and module.GetOptionValue("Marked For Death") == "Target" and (module.CooldownsAllowed() or module.GetSecondOptionValue("Marked For Death") == "Always") and MarkedForDeath:Exists() and Player:ComboPointsDeficit() >= 4+(DeeperStrategem:Exists() and 1 or 0) and Target:CanCast(MarkedForDeath) then
                Target:Cast(MarkedForDeath);
                return;
            end
            -- rupture,cycle_targets=1,target_if=max:target.time_to_die,max_cycle_targets=6,if=combo_points>4&refreshable&spell_targets.fan_of_knives>1
            if NumEnemies > 1 and Player:ComboPoints() > 4 and Target:DebuffRefreshable(Rupture) and Target:CanCast(Rupture) then
                Target:Cast(Rupture);
                return;
            end
            if NumEnemies > 1 and Player:ComboPoints() > 4+(DeeperStrategem:Exists() and 1 or 0) then
                local Count = 0;
                local ThisUnit;
                for i = 1, #Enemies_5y do
                    ThisUnit = Enemies_5y[i];
                    if ThisUnit:Debuff(Rupture) then
                        Count = Count + 1;
                    end
                end
                if Count <= 6 then
                    Rupt.BestUnit, Rupt.BestUnitTTD = nil, 4;
                    -- TTD Units Handler.
                    local ThisUnitTTD;
                    for i = 1, #Enemies_5y do
                        ThisUnit = Enemies_5y[i];
                        ThisUnitTTD = ThisUnit:TimeToDie(10);
                        if ThisUnitTTD < 5000 and ThisUnit:DebuffRemains(Rupture) <= DurationThreshold and ThisUnitTTD > Rupt.BestUnitTTD and ThisUnit:CanCast(Rupture) then
                            Rupt.BestUnit, Rupt.BestUnitTTD = ThisUnit, ThisUnitTTD;
                        end
                    end
                    -- Cast Rupture if we got an unit.
                    if Rupt.BestUnit then
                        Rupt.BestUnit:Cast(Rupture);
                        return;
                    end
                end
            end
            -- mutilate,if=prev_gcd.exsanguinate
            if Exsanguinate:Exists() and Exsanguinate:Cooldown() > 43.5 and Target:CanCast(Mutilate) then
                Target:Cast(Mutilate);
                return;
            end
            -- kingsbane,if=time>6
            if module.IsOptionEnabled("Kingsbane") and (module.CooldownsAllowed() or module.GetOptionValue("Kingsbane") == "Always") and Kingsbane:Exists() and CombatTime() > 6 and Target:CanCast(Kingsbane) then
                Target:Cast(Kingsbane);
                return;
            end
            if not AgonizingPoison:Exists() and NumEnemies > 1 and NumEnemies < 3 then
                -- mutilate,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4
                if Target:DebuffRemains(DeadlyPoisonDebuff) < 4 and Target:CanCast(Mutilate) then
                    Target:Cast(Mutilate);
                    return;
                end
                -- mutilate,cycle_targets=1,target_if=min:dot.deadly_poison_dot.remains,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4&dot.rupture.ticking&dot.garrote.ticking
                -- mutilate,cycle_targets=1,target_if=min:dot.deadly_poison_dot.remains,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4&dot.rupture.ticking
                -- mutilate,cycle_targets=1,target_if=min:dot.deadly_poison_dot.remains,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4&dot.garrote.ticking
                -- mutilate,cycle_targets=1,target_if=min:dot.deadly_poison_dot.remains,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4
                Muti.BestUnit, Muti.BestUnit2, Muti.BestUnit3, Muti.BestUnit4 = nil, nil, nil, nil;
                -- TTD Units Handler.
                local ThisUnit;
                for i = 1, #Enemies_5y do
                    ThisUnit = Enemies_5y[i];
                    if ThisUnit:DebuffRemains(DeadlyPoisonDebuff) < 4 and ThisUnit:CanCast(Mutilate) then
                        if ThisUnit:Debuff(Rupture) and ThisUnit:Debuff(Garrote) then
                            Muti.BestUnit = ThisUnit;
                        end
                        if ThisUnit:Debuff(Rupture) then
                            Muti.BestUnit2 = ThisUnit;
                        end
                        if ThisUnit:Debuff(Garrote) then
                            Muti.BestUnit3 = ThisUnit;
                        end
                        Muti.BestUnit4 = ThisUnit;
                    end
                end
                -- Cast Rupture if we got an unit.
                if Muti.BestUnit then
                    Muti.BestUnit:Cast(Mutilate);
                    return;
                elseif Muti.BestUnit2 then
                    Muti.BestUnit2:Cast(Mutilate);
                    return;
                elseif Muti.BestUnit3 then
                    Muti.BestUnit3:Cast(Mutilate);
                    return;
                elseif Muti.BestUnit4 then
                    Muti.BestUnit4:Cast(Mutilate);
                    return;
                end
            end
            -- hemorrhage,cycle_targets=1,target_if=max:target.time_to_die,max_cycle_targets=3,if=combo_points.deficit>=1&spell_targets.fan_of_knives>1&!ticking&dot.rupture.remains>6
            if Hemorrhage:Exists() and NumEnemies > 1 and Player:ComboPointsDeficit() >= 1 then
                if not Target:Debuff(Hemorrhage) and Target:DebuffRemains(Rupture) > 6 and Target:CanCast(Hemorrhage) then
                    Target:Cast(Hemorrhage);
                    return;
                end
                if module.UseAOE() then
                    local Count = 0;
                    local ThisUnit;
                    for i = 1, #Enemies_5y do
                        ThisUnit = Enemies_5y[i];
                        if ThisUnit:Debuff(Hemorrhage) then
                            Count = Count + 1;
                        end
                    end
                    if Count <= 3 then
                        Hemo.BestUnit, Hemo.BestUnitTTD = nil, 4;
                        -- TTD Units Handler.
                        local ThisUnit, ThisUnitTTD;
                        for i = 1, #Enemies_5y do
                            ThisUnit = Enemies_5y[i];
                            ThisUnitTTD = ThisUnit:TimeToDie(10);
                            if ThisUnitTTD < 5000 and ThisUnitTTD > Hemo.BestUnitTTD and not ThisUnit:Debuff(Hemorrhage) and ThisUnit:DebuffRemains(Rupture) >= 6 and ThisUnit:CanCast(Hemorrhage) then
                                Hemo.BestUnit, Hemo.BestUnitTTD = ThisUnit, ThisUnitTTD;
                            end
                        end
                        -- Cast Hemorrhage if we got an unit.
                        if Hemo.BestUnit then
                            Hemo.BestUnit:Cast(Hemorrhage);
                            return;
                        end
                    end
                end
            end
            -- fan_of_knives,if=combo_points.deficit>=1&(spell_targets>3|(poisoned_enemies<3&spell_targets>2))
            if Player:ComboPointsDeficit() >= 1 and Player:CanCast(FanOfKnives) then
                local Count = 0;
                local ThisUnit;
                for i = 1, #Enemies_5y do
                    ThisUnit = Enemies_5y[i];
                    if ThisUnit:Debuff(AgonizingPoisonDebuff) or ThisUnit:Debuff(DeadlyPoisonDebuff) then
                        Count = Count + 1;
                    end
                end
                if NumEnemies > 3 or (Count < 3 and NumEnemies > 2) then
                    Player:Cast(FanOfKnives);
                    return;
                end
            end
            -- mutilate,if=(combo_points.deficit>=2&cooldown.garrote.remains>1&(!dot.hemorrhage.refreshable|!talent.hemorrhage.enabled))
            if Player:ComboPointsDeficit() >= 2 and Garrote:Cooldown() > 1 and (not Hemorrhage:Exists() or not Target:DebuffRefreshable(Hemorrhage)) and Target:CanCast(Mutilate) then
                Target:Cast(Mutilate);
                return;
            end
            -- garrote,if=combo_points.deficit>=1&refreshable&!dot.garrote.exsanguinated
            if Player:ComboPointsDeficit() >= 1 and Target:DebuffRefreshable(Garrote) and not module.Exsanguinated(Target, "Garrote") and Target:CanCast(Garrote) then
                Target:Cast(Garrote);
                return;
            end
            -- hemorrhage,if=combo_points.deficit>=1&(refreshable|(cooldown.exsanguinate.remains<2|dot.rupture.refreshable))
            if Hemorrhage:Exists() and Player:Energy() > 60 and Player:ComboPointsDeficit() >= 1 and (Target:DebuffRefreshable(Hemorrhage) or (Exsanguinate:Exists() and Exsanguinate:Cooldown() < 2) or Target:DebuffRefreshable(Rupture)) and Target:CanCast(Hemorrhage) then
                Target:Cast(Hemorrhage);
                return;
            end
            -- Poisoned Knife Out of Range
            if module.IsOptionEnabled("Poisoned Knife") and not Player:IsWithinCastRange(Target, Mutilate) and not Player:IsStealthed(true) and Player:Energy() > module.GetOptionValue("Poisoned Knife") and (Player:ComboPoints() < MaxComboPoint or Player:PowerTimeToMax() <= 1.5) and Target:CanCast(PoisonedKnife) then
                Target:Cast(PoisonedKnife);
                return;
            end
            return;
        end
        -- potion,name=draenic_agility,if=buff.bloodlust.react|target.time_to_die<30|cooldown.vendetta.remains<10
        -- use_item,slot=finger1,if=buff.bloodlust.react|target.time_to_die<20|debuff.vendetta.up
        -- blood_fury,if=debuff.vendetta.up
        -- berserking,if=debuff.vendetta.up
        -- arcane_torrent,if=debuff.vendetta.up&energy.deficit>50
        -- vendetta,if=((!artifact.urge_to_kill.enabled&dot.rupture.ticking)|(energy%energy.max)<0.4)&(time<10|cooldown.exsanguinate.remains<5)
        -- exsanguinate,if=prev_gcd.rupture&dot.rupture.remains>20
        -- vanish,if=cooldown.exsanguinate.remains<2&combo_points>4+talent.deeper_stratagem.enabled
        -- rupture,if=(combo_points>4+talent.deeper_stratagem.enabled&(cooldown.exsanguinate.remains<1|!exsanguinated&refreshable))|(time<4&dot.hemorrhage.remains>10&dot.garrote.remains>8)
        -- rupture,if=spell_targets.fan_of_knives>1&!ticking&combo_points>4
        -- rupture,cycle_targets=1,target_if=max:target.time_to_die,max_cycle_targets=6,if=spell_targets.fan_of_knives>1&!ticking&combo_points>4
        -- death_from_above,if=combo_points>4
        -- envenom,if=combo_points>3+talent.deeper_stratagem.enabled&(energy.deficit<40|dot.rupture.exsanguinated)&buff.envenom.remains<(1+combo_points)*0.3&buff.elaborate_planning.remains<2
        -- marked_for_death,cycle_targets=1,target_if=min:target.time_to_die,if=combo_points.deficit>=4+talent.deeper_stratagem.enabled
        -- rupture,cycle_targets=1,target_if=max:target.time_to_die,max_cycle_targets=6,if=combo_points>4&refreshable&spell_targets.fan_of_knives>1
        -- mutilate,if=prev_gcd.exsanguinate
        -- kingsbane,if=time>6
        -- mutilate,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4
        -- mutilate,cycle_targets=1,target_if=min:dot.deadly_poison_dot.remains,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4&dot.rupture.ticking&dot.garrote.ticking
        -- mutilate,cycle_targets=1,target_if=min:dot.deadly_poison_dot.remains,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4&dot.rupture.ticking
        -- mutilate,cycle_targets=1,target_if=min:dot.deadly_poison_dot.remains,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4&dot.garrote.ticking
        -- mutilate,cycle_targets=1,target_if=min:dot.deadly_poison_dot.remains,if=!talent.agonizing_poison.enabled&combo_points.deficit>=2&spell_targets.fan_of_knives>1&spell_targets.fan_of_knives<3&dot.deadly_poison_dot.remains<4
        -- hemorrhage,cycle_targets=1,target_if=max:target.time_to_die,max_cycle_targets=3,if=combo_points.deficit>=1&spell_targets.fan_of_knives>1&!ticking&dot.rupture.remains>6
        -- fan_of_knives,if=combo_points.deficit>=1&(spell_targets>3|(poisoned_enemies<3&spell_targets>2))
        -- mutilate,if=(combo_points.deficit>=2&cooldown.garrote.remains>1&(!dot.hemorrhage.refreshable|!talent.hemorrhage.enabled))
        -- garrote,if=combo_points.deficit>=1&refreshable&!dot.garrote.exsanguinated
        -- hemorrhage,if=combo_points.deficit>=1&(refreshable|(cooldown.exsanguinate.remains<2|dot.rupture.refreshable))
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Disable Stealth if the Loot Window is open, we are interacting with an NPC or combat has just ended. (Also used for PickPocket)
        StealthAllowed = GetNumLootItems() == 0 and not UnitExists("npc") and OutOfCombatTime() > 1 and true or false;
        -- PickPocket Handler Init
        if module.IsOptionEnabled("Pick Pocket") and not module.PickPocketInitialized then
            Player:PickPocketInit();
        end
        -- Poisons
        if not Player:IsMoving() and module.IsOptionEnabled("Lethal | Non-Lethal") then
            PoisonLethal = module.GetOptionValue("Lethal | Non-Lethal");
            PoisonNonLethal = module.GetSecondOptionValue("Lethal | Non-Lethal");
            PoisonMinDuration = module.GetOptionValue("Min Duration Poison")*60;
            PoisonCastTime = 3.3; -- Changing from 1.5s to 3s each 2 patches so I keep this variable for now.
            -- Lethal Poison
            if ((not AgonizingPoison:Exists() and PoisonLethal == "Agonizing") or PoisonLethal == "Deadly") and Player:BuffRemains(DeadlyPoison) <= PoisonMinDuration and DeadlyPoison:TimeSinceCast() > PoisonCastTime and Player:CanCast(DeadlyPoison) then
                Player:Cast(DeadlyPoison);
                DeadlyPoison.LastCastTime = module.GetTime();
                return;
            elseif PoisonLethal == "Wound" and Player:BuffRemains(WoundPoison) <= PoisonMinDuration and WoundPoison:TimeSinceCast() > PoisonCastTime and Player:CanCast(WoundPoison) then
                Player:Cast(WoundPoison);
                WoundPoison.LastCastTime = module.GetTime();
                return;
            elseif PoisonLethal == "Agonizing" and AgonizingPoison:Exists() and Player:BuffRemains(AgonizingPoison) <= PoisonMinDuration and AgonizingPoison:TimeSinceCast() > PoisonCastTime and Player:CanCast(AgonizingPoison) then
                Player:Cast(AgonizingPoison);
                AgonizingPoison.LastCastTime = module.GetTime();
                return;
            end
            -- Non-Lethal Poison
            if (not LeechingPoison:Exists() or PoisonNonLethal == "Crippling") and Player:BuffRemains(CripplingPoison) <= PoisonMinDuration and CripplingPoison:TimeSinceCast() > PoisonCastTime and Player:CanCast(CripplingPoison) then
                Player:Cast(CripplingPoison);
                CripplingPoison.LastCastTime = module.GetTime();
                return;
            elseif PoisonNonLethal == "Leeching" and LeechingPoison:Exists() and Player:BuffRemains(LeechingPoison) <= PoisonMinDuration and LeechingPoison:TimeSinceCast() > PoisonCastTime and Player:CanCast(LeechingPoison) then
                Player:Cast(LeechingPoison);
                LeechingPoison.LastCastTime = module.GetTime();
                return;
            end
        end
        -- Stealth
        if module.IsOptionEnabled("Stealth") and module.GetOptionValue("Stealth") == "Always" and StealthAllowed and not Player:IsStealthed(true) and Stealth:TimeSinceCast() > 0.4 and Player:CanCast(Stealth) then
            Player:Cast(Stealth);
            Stealth.LastCastTime = module.GetTime();
            return;
        end
        -- Crimson Vial
        if module.IsOptionEnabled("Crimson Vial") and Player:HealthPercentage() <= module.GetOptionValue("Crimson Vial") and Player:CanCast(CrimsonVial) then
            Player:Cast(CrimsonVial);
            return;
        end
        -- Pre Trick of the Trade
        if module.IsOptionEnabled("Tricks of the Trade on Focus") and BMPullTime() <= 1.5 and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
            Focus:Cast(TricksoftheTrade);
        end
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Stealth
            if module.IsOptionEnabled("Stealth") and Player:DistanceTo(Target) < 25 and StealthAllowed and not Player:IsStealthed(true) and Stealth:TimeSinceCast() > 0.4 and Player:CanCast(Stealth) then
                Player:Cast(Stealth);
                Stealth.LastCastTime = module.GetTime();
                return;
            end
            if Player:IsStealthed(true) and Player:HealthPercentage() > module.GetOptionValue("Vanish Defensive") then
                if module.IsOptionEnabled("Tricks of the Trade on Focus") and Player:DistanceTo(Target) < 10 and BMPullTime() == 60 and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
                    Focus:Cast(TricksoftheTrade);
                end
                if module.IsOptionEnabled("Pick Pocket") and not module.PickPocketed[Target:GUID()] then
                    if Target:CanCast(PickPocket) then
                        Target:Cast(PickPocket);
                        module.PickPocketTarget = Target:GUID();
                        module.PickPocketAttempt = module.GetTime();
                    end
                    return;
                end
                if module.IsOptionEnabled("Cheap Shot") and not Target:IsBoss() and Target:CanCast(CheapShot) then
                    Target:Cast(CheapShot);
                    return;
                end
                if Target:CanCast(Mutilate) then
                    Target:Cast(Mutilate);
                    return;
                end
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Outlaw Rogue Rotation
    local Rotation = {};
    module.SetRotation("_"..260, Rotation);

    --- Localization
    -- Core
    local Enemies_8y, NumEnemies = {}, 1; -- Enemies
    local SpamPrevention, TPSTime = 0, 0.1; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local StealthAllowed, CombatStealthAllowed = false, true; -- Stealth Handler
    local MaxComboPoint, CPDiff, DurationThreshold = 5, 0, 12.6; -- Combo Points Variables
    local ShadowmeldStanding = 0.7; -- Time to Stand before casting Shadowmeld (because movements cancel it)
    local EnemiesTimer, EnemiesReset = 0, nil; -- Blade Flurry Handler

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        --- Spells
        -- (ID, RequiresFacing, Hostile, Instant)
        -- Racials
        ArcaneTorrent = Spell(25046, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);
        Shadowmeld = Spell(58984, false, false, true);
        -- Items
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Abilities
        Ambush = Spell(8676, true, true, true);
        Anticipation = Spell(114015, false, false, true);
        BetweentheEyes = Spell(199804, true, true, true);
        BladeFlurry = Spell(13877, false, false, true);
        CannonballBarrage = Spell(185767, false, true, true);
        CheapShot = Spell(1833, true, true, true);
        DeathFromAbove = Spell(152150, true, true, true);
        DeeperStrategem = Spell(193531, false, false, true);
        GhostlyStrike = Spell(196937, true, true, true);
        Kick = Spell(1766, true, true, true);
        KillingSpree = Spell(51690, false, true, true);
        MarkedForDeath = Spell(137619, false, true, true);
        Opportunity = Spell(195627, false, false, true);
        PickPocket = Spell(921, true, true, true);
        PistolShot = Spell(185763, true, true, true);
        QuickDraw = Spell(196938, false, false, true);
        RolltheBones = Spell(193316, false, false, true);
        RunThrough = Spell(2098, true, true, true);
        SaberSlash = Spell(193315, true, true, true);
        SliceAndDice = Spell(5171, false, false, true);
        Sprint = Spell(2983, false, false, true);
        Stealth = Spell(1784, false, false, true);
        TricksoftheTrade = Spell(57934, false, false, true);
        Vanish = Spell(1856, false, false, true);
        -- Offensive Cooldowns
        AdrenalineRush = Spell(13750, false, false, true);
        CurseoftheDreadblades = Spell(202665, false, false, true);
        -- Defensive Cooldowns
        CloakofShadows = Spell(31224, false, false, true);
        CrimsonVial = Spell(185311, false, false, true);
        Feint = Spell(1966, false, false, true);
        Riposte = Spell(199754, false, false, true);
        -- Roll the Bones
        JollyRoger = Spell(199603, false, false, true); -- Heal
        TrueBearing = Spell(193359, false, false, true); -- Reduc CD
        SharkInfestedWaters = Spell(193357, false, false, true); -- 40% Crit
        BuriedTreasure = Spell(199600, false, false, true); -- Energy Regen
        GrandMelee = Spell(193358, false, false, true); -- Attacks Faster
        Broadsides = Spell(193356, false, false, true); -- Attacks Faster

        --- GUI Frame
        -- Pages
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Kick to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddNewOption("General Settings", "Tricks of the Trade on Focus", 230, false, {2, "Always", "On Aggro"}, nil, "Will use Tricks of the Trade on your focus if he's allied."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Everytime it is available."..C.TOOLTIP_SUBVALUE("On Aggro").."Only if you have the aggro of something.");
        module.AddSection("General Settings", "Solo", "Green");
        module.AddNewOption("General Settings", "Cheap Shot", 210, false, nil, nil, "Enable for the automatic usage of Cheap Shot."..C.TOOLTIP_HINT("Useful if you're having hard time while soloing."));
        module.AddNewOption("General Settings", "Pick Pocket", 210, false, nil, nil, "Will PickPocket your target before engaging it."..C.TOOLTIP_HINT("Enabling Pick Pocket will turn on Auto-Loot."));

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddNewOption("Offensive Settings", "Stealth", 230, true, {1, "Always", "Near Target"}, nil, "Enable for the automatic usage of Stealth."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Everytime it is available."..C.TOOLTIP_SUBVALUE("Near Target").."When approaching your target.");
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Marked For Death", 233, true, {2, "Target", "Adds"}, {1, "Always", "Cooldown Only"}, "Enable for the automatic usage of Marked for Death."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Target", true).."Only on your target with 1 or less CP."..C.TOOLTIP_SUBVALUE("Adds").."On every units available."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Vanish", 233, true, {1, "Always", "Not Tanking"}, {2, "Always", "Cooldown Only"}, "Enable for the automatic usage of Vanish."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will 'Always' use Vanish no matter if you're tanking or not."..C.TOOLTIP_SUBVALUE("Not Tanking").."Will only use Vanish if you're 'Not Tanking' the target (Mostly for Solo)."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Curse of the Dreadblades", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Curse of the Dreadblades."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "CB | KS", 223, true, {1, 1, 3, 1}, {2, "Always", "Cooldown Only"}, "Enable for the automatic usage of Cannonball Barrage | Killing Spree."..C.TOOLTIP_VALUE_1.."Set the number of unit around you required in order to use Cannonball Barrage."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Adrenaline Rush", 210, true, nil, nil, "Enable for the automatic usage of Adrenaline Rush.");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() or Shadowmeld:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Arcane Torrent, Berserking, Bloodfury and Shadowmeld are supported."));
        end
        module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Disabled", "Enabled"}, {2, "Disabled", "Enabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Reroll Jolly Roger", 210, true, nil, nil, "Enable to cast again Roll the Bones if it only gives Jolly Roger as buff."..C.TOOLTIP_HINT("You may want to disable this for Solo Content."));
        module.AddNewOption("Offensive Settings", "Blade Flurry", 220, true, {1, 0, 9, 1}, nil, "Enable for the automatic usage of Blade Flurry."..C.TOOLTIP_VALUE.."Set the timer to keep the Blade Flurry active after having only 1 enemy."..C.TOOLTIP_HINT("Useful on fight where units jump in and out."));
        module.AddNewOption("Offensive Settings", "Pistol Shot OOR", 220, true, {75, 40, 150, 1}, nil, "Enable to auto use Pistol Shot while not being in melee range and not being stealthed."..C.TOOLTIP_VALUE.."Set the minimum energy to start using it.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Health Percentage to use Healing Belt / Healing Pot / Healthstone.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Crimson Vial", 220, true, {65, 1, 100, 1}, nil, "Health Percentage to use Crimson Vial.");
        module.AddNewOption("Defensive Settings", "Feint", 220, false, {55, 1, 100, 1}, nil, "Health Percentage to use Feint."..C.TOOLTIP_HINT("Put 100 to maintain 100% uptime."));
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, false, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Riposte", 220, true, {25, 1, 100, 1}, nil, "Health Percentage to use Riposte.");
        module.AddNewOption("Defensive Settings", "Cloak of Shadows", 220, true, {45, 1, 100, 1}, nil, "Health Percentage to use Cloak of Shadows.");
        module.AddNewOption("Defensive Settings", "Cloak of Shadows w/ Killing Spree", 210, false, nil, nil, "Enable for the automatic usage of Cloak of Shadows if not in CD before using Kiling Spree.");
        module.AddNewOption("Defensive Settings", "Vanish Defensive", 220, false, {10, 1, 100, 1}, nil, "Health Percentage to use Vanish defensively.");

        --- Misc
        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated
        Player:SetCommonMeleeStatus();
        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;
        -- Combo Points Variables
        MaxComboPoint = Anticipation:Exists() and 8 or DeeperStrategem:Exists() and 6 or 5;
        CPDiff = MaxComboPoint-Player:ComboPoints();
        DurationThreshold = DeeperStrategem:Exists() and 12.6 or 10.8;
        -- Stealth Handler
        CombatStealthAllowed = Vanish:TimeSinceCast() > 0.5 and Shadowmeld:TimeSinceCast() > 0.5;

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Vanish Defensive") and not Player:IsStealthed(true) and CombatStealthAllowed and Player:HealthPercentage() <= module.GetOptionValue("Vanish Defensive") and Player:CanCast(Vanish) then
            Player:Cast(Vanish);
            Vanish.LastCastTime = module.GetTime();
            return;
        end
        if module.IsOptionEnabled("Riposte") and not Player:Buff(Riposte) and Player:HealthPercentage() <= module.GetOptionValue("Riposte") and Player:CanCast(Riposte) then
            Player:Cast(Riposte);
        end
        if module.IsOptionEnabled("Cloak of Shadows") and Player:HealthPercentage() <= module.GetOptionValue("Cloak of Shadows") and Player:CanCast(CloakofShadows) then
            Player:Cast(CloakofShadows);
        end
        -- Defensive Abilities
        if module.IsOptionEnabled("Feint") and Player:HealthPercentage() <= module.GetOptionValue("Feint") and not Player:Buff(Feint) and Player:CanCast(Feint) then
            Player:Cast(Feint);
            return;
        end
        if module.IsOptionEnabled("Crimson Vial") and Player:HealthPercentage() <= module.GetOptionValue("Crimson Vial") and Player:CanCast(CrimsonVial) then
            Player:Cast(CrimsonVial);
            return;
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Kick, ArcaneTorrent);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Tricks of the Trade on Focus
        if module.IsOptionEnabled("Tricks of the Trade on Focus") and (module.GetOptionValue("Tricks of the Trade on Focus") == "Always" or (Player:ThreatSituation() and Player:ThreatSituation() >= 1)) and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
            Focus:Cast(TricksoftheTrade);
        end
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Marked for Death Handler for Adds
        if Player:UseMarkedForDeath(MarkedForDeath, CPDiff) then
            return;
        end
        -- Auto Target
        Target = Player:ReTarget(SaberSlash, false) or Unit.Target;
    end

    -- Run the rotation's beta combat logic.
    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Enemies Check
            if module.UseAOE() then
                Enemies_8y = Player:EnemiesWithinDistance(6.5, true); -- Using 6.5y (real range, not 8y) for Blade Flurry and true as they are PlayerCenteredAoE Spells.
                NumEnemies = #Enemies_8y;
            else
                NumEnemies = 1;
            end
            if NumEnemies == 1 and EnemiesReset then EnemiesTimer, EnemiesReset = module.GetTime() + module.GetOptionValue("Blade Flurry"), false; elseif NumEnemies > 1 then EnemiesReset = true; end

            -- Blade Flurry
            if module.IsOptionEnabled("Blade Flurry") and ((NumEnemies >= 2 and not Player:Buff(BladeFlurry) and Player:CanCast(BladeFlurry)) or (NumEnemies < 2 and Player:Buff(BladeFlurry) and module.GetTime() > EnemiesTimer)) then
                Player:Cast(BladeFlurry);
            end
            -- Cooldowns
            if Player:IsWithinCastRange(Target, SaberSlash) then
                if module.CooldownsAllowed() then
                    -- Adrenaline Rush
                    if module.IsOptionEnabled("Adrenaline Rush") and not Player:Buff(AdrenalineRush) and Player:CanCast(AdrenalineRush) then
                        Player:Cast(AdrenalineRush);
                        AdrenalineRush.LastCastTime = module.GetTime();
                    end
                    -- Trinkets
                    if Trinket1:IsUsableInventory() and module.GetOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket1:UseInventory();
                    end
                    if Trinket2:IsUsableInventory() and module.GetSecondOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket2:UseInventory();
                    end
                end
                -- Racials
                if (BloodFury:Exists() or Berserking:Exists() or ArcaneTorrent:Exists()) and module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:IsWithinCastRange(Target, SaberSlash) then
                    -- Blood Fury
                    if Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                    -- Arcane Torrent
                    if Player:CanCast(ArcaneTorrent) and Player:Power() < 60 then
                        Player:Cast(ArcaneTorrent);
                    end
                end
                -- Curse of the Dreadblades
                if module.IsOptionEnabled("Curse of the Dreadblades") and CurseoftheDreadblades:Exists() and (module.CooldownsAllowed() or module.GetOptionValue("Curse of the Dreadblades") == "Always") and not Player:Debuff(CurseoftheDreadblades) and Player:CanCast(CurseoftheDreadblades) then
                    Player:Cast(CurseoftheDreadblades);
                    return;
                end
            end
            if Player:IsWithinCastRange(Target, SaberSlash) and CombatStealthAllowed and not Player:IsStealthed(true) and (not Player:IsTanking(Target) or module.GetOptionValue("Vanish") == "Always") then
                -- Vanish
                if module.IsOptionEnabled("Vanish") and (module.CooldownsAllowed() or module.GetSecondOptionValue("Vanish") == "Always") and CPDiff >= 2 and Player:CanCast(Vanish) then
                    if Player:Power() < 60 then
                        return;
                    end
                    if Player:Power() >= 60 then
                        Player:Cast(Vanish);
                        Vanish.LastCastTime = module.GetTime();
                        return;
                    end
                end
                -- Shadowmeld
                if Shadowmeld:Exists() and module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:Standing() >= ShadowmeldStanding and CPDiff >= 2 and Player:CanCast(Shadowmeld) then
                    if Player:Power() < 60 then
                        return;
                    end
                    if Player:Power() >= 60 then
                        Player:Cast(Shadowmeld);
                        Shadowmeld.LastCastTime = module.GetTime();
                        return;
                    end
                end
            end
            -- Ambush
            if Player:IsStealthed(true) or not CombatStealthAllowed then
                if not Ambush:IsUsable() then
                    return;
                end
                if Target:CanCast(Ambush) then
                    Target:Cast(Ambush);
                    return;
                end
            end
            if SliceAndDice:Exists() then
                -- Slice and Dice
                if ((Player:BuffRemains(SliceAndDice) < DurationThreshold and Player:ComboPoints() >= 5+(DeeperStrategem:Exists() and 1 or 0)) or Player:BuffRemains(SliceAndDice) < 6) and Player:BuffRemains(SliceAndDice) < Target:TimeToDie() and Player:CanCast(SliceAndDice) then
                    Player:Cast(SliceAndDice);
                    return;
                end
            else
                -- Roll the Bones
                if Player:ComboPoints() >= 5+(DeeperStrategem:Exists() and 1 or 0) and (module.IsOptionEnabled("Reroll Jolly Roger") or Player:BuffRemains(JollyRoger) < DurationThreshold) and Player:BuffRemains(TrueBearing) < DurationThreshold and Player:BuffRemains(SharkInfestedWaters) < DurationThreshold and Player:BuffRemains(BuriedTreasure) < DurationThreshold and Player:BuffRemains(GrandMelee) < DurationThreshold and Player:BuffRemains(Broadsides) < DurationThreshold and Player:CanCast(RolltheBones) then
                    Player:Cast(RolltheBones);
                    return;
                end
            end
            if module.IsOptionEnabled("CB | KS") and (module.CooldownsAllowed() or module.GetSecondOptionValue("CB | KS") == "Always") then
                -- Killing Spree
                if KillingSpree:Exists() and AdrenalineRush:TimeSinceCast() > 2 and Player:PowerTimeToMax() > 5 and Target:CanCast(KillingSpree) then
                    if module.IsOptionEnabled("Cloak of Shadows w/ Killing Spree") and Player:CanCast(CloakofShadows) then
                        Player:Cast(CloakofShadows);
                    end
                    Target:Cast(KillingSpree);
                    return;
                end
                -- Cannonball Barrage
                if CannonballBarrage:Exists() and NumEnemies >= module.GetOptionValue("CB | KS") and Target:CanCast(CannonballBarrage) and Player:CastGround(CannonballBarrage, 2, 6, 30, true) then
                    return;
                end
            end
            -- Marked for Death Single Target
            if module.IsOptionEnabled("Marked For Death") and module.GetOptionValue("Marked For Death") == "Target" and (module.CooldownsAllowed() or module.GetSecondOptionValue("Marked For Death") == "Always") and MarkedForDeath:Exists() and CPDiff >= 4 and Target:CanCast(MarkedForDeath) then
                Target:Cast(MarkedForDeath);
                return;
            end
            -- Finisher
            if Player:ComboPoints() >= 5+(DeeperStrategem:Exists() and 1 or 0) then
                -- Death From Above
                if DeathFromAbove:Exists() and Target:CanCast(DeathFromAbove) then
                    Target:Cast(DeathFromAbove);
                    return;
                end
                -- Between the Eyes
                if Target:CanCast(BetweentheEyes) and Player:ComboPoints() >= 5+(DeeperStrategem:Exists() and 1 or 0) then
                    Target:Cast(BetweentheEyes);
                    return;
                end
                -- Run Through
                if (not DeathFromAbove:Exists() or DeathFromAbove:IsOnCooldown()) and Target:CanCast(RunThrough) then
                    Target:Cast(RunThrough);
                    return;
                end
                return;
            end
            -- Generator
            if Player:ComboPoints() < 5+(DeeperStrategem:Exists() and 1 or 0) then
                -- Ghostly Strike
                if GhostlyStrike:Exists() and Target:DebuffRemains(GhostlyStrike) < 4.5 and Target:CanCast(GhostlyStrike) then
                    Target:Cast(GhostlyStrike);
                    return;
                end
                -- Pistol Shot Free Proc
                if Player:Buff(Opportunity) and Target:CanCast(PistolShot) then
                    Target:Cast(PistolShot);
                    return;
                end
                -- Saber Slash
                if Target:CanCast(SaberSlash) then
                    Target:Cast(SaberSlash);
                    return;
                end
            end
            -- Pistol Shot Out of Range
            if module.IsOptionEnabled("Pistol Shot OOR") and not Player:IsWithinCastRange(Target, SaberSlash) and not Player:IsStealthed(true) and Player:Power() > module.GetOptionValue("Pistol Shot OOR") and (Player:ComboPoints() < MaxComboPoint or Player:PowerTimeToMax() <= 1.5) and Target:CanCast(PistolShot) then
                Target:Cast(PistolShot);
                return;
            end
            return;
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Disable Stealth if the Loot Window is open, we are interacting with an NPC or combat has just ended. (Also used for PickPocket)
        StealthAllowed = GetNumLootItems() == 0 and not UnitExists("npc") and OutOfCombatTime() > 1 and true or false;
        -- PickPocket Handler Init
        if module.IsOptionEnabled("Pick Pocket") and not module.PickPocketInitialized then
            Player:PickPocketInit();
        end
        -- Stealth
        if module.IsOptionEnabled("Stealth") and module.GetOptionValue("Stealth") == "Always" and StealthAllowed and not Player:IsStealthed(true) and Stealth:TimeSinceCast() > 0.4 and Player:CanCast(Stealth) then
            Player:Cast(Stealth);
            Stealth.LastCastTime = module.GetTime();
            return;
        end
        -- Crimson Vial
        if module.IsOptionEnabled("Crimson Vial") and Player:HealthPercentage() <= module.GetOptionValue("Crimson Vial") and Player:CanCast(CrimsonVial) then
            Player:Cast(CrimsonVial);
            return;
        end
        -- Pre Trick of the Trade
        if module.IsOptionEnabled("Tricks of the Trade on Focus") and BMPullTime() <= 1.5 and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
            Focus:Cast(TricksoftheTrade);
        end
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Stealth
            if module.IsOptionEnabled("Stealth") and Player:DistanceTo(Target) < 25 and StealthAllowed and not Player:IsStealthed(true) and Stealth:TimeSinceCast() > 0.4 and Player:CanCast(Stealth) then
                Player:Cast(Stealth);
                Stealth.LastCastTime = module.GetTime();
                return;
            end
            if Player:IsStealthed(true) and Player:HealthPercentage() > module.GetOptionValue("Vanish Defensive") then
                if module.IsOptionEnabled("Tricks of the Trade on Focus") and Player:DistanceTo(Target) < 10 and BMPullTime() == 60 and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
                    Focus:Cast(TricksoftheTrade);
                end
                if module.IsOptionEnabled("Pick Pocket") and not module.PickPocketed[Target:GUID()] then
                    if Target:CanCast(PickPocket) then
                        Target:Cast(PickPocket);
                        module.PickPocketTarget = Target:GUID();
                        module.PickPocketAttempt = module.GetTime();
                    end
                    return;
                end
                if module.IsOptionEnabled("Cheap Shot") and not Target:IsBoss() and Target:CanCast(CheapShot) then
                    Target:Cast(CheapShot);
                    return;
                end
                if Target:CanCast(Ambush) then
                    Target:Cast(Ambush);
                    return;
                end
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Subtlety Rogue Rotation
    local Rotation = {};
    module.SetRotation("_"..261, Rotation);

    --- Localization
    -- Core
    local Enemies_10y, Enemies_8y, Enemies_5y, NumEnemies = {}, {}, {}, 1; -- Enemies
    local SpamPrevention, TPSTime = 0, 0.1; -- Combat Module Throttle
    local HandofProtectionName = nil; -- HandofProtection Spell Name (to use /cancelaura)
    -- Rotation Specific
    local StealthAllowed, CombatStealthAllowed = false, true; -- Stealth Handler
    local DurationThreshold = 12.6; -- Combo Points Variables
    local ShadowmeldStanding = 0.7; -- Time to Stand before casting Shadowmeld (because movements cancel it)

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        --- Spells
        -- (ID, RequiresFacing, Hostile, Instant, Resurrect)
        -- Racials
        ArcaneTorrent = Spell(25046, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);
        Shadowmeld = Spell(58984, false, false, true);
        -- Items
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        -- Various
        HandofProtection = Spell(1022, false, false, true); -- Hand of Protection Buff (Auto Cancel)
        -- Abilities
        Anticipation = Spell(114015, false, false, true);
        Backstab = Spell(53, true, true, true);
        CheapShot = Spell(1833, true, true, true);
        Death = Spell(227151, false, false, false);
        DeathFromAbove = Spell(152150, true, true, true);
        DeeperStrategem = Spell(193531, false, false, true);
        EnvelopingShadows = Spell(206237, false, false, true);
        Eviscerate = Spell(196819, true, true, true);
        Gloomblade = Spell(200758, true, true, true);
        Kick = Spell(1766, true, true, true);
        KidneyShot = Spell(408, true, true, true);
        MarkedForDeath = Spell(137619, false, true, true);
        MasterofShadows = Spell(196976, false, false, true);
        MasterOfSubtlety = Spell(31223, false, false, true);
        MasterOfSubtletyBuff = Spell(31665, false, false, false);
        Nightblade = Spell(195452, true, true, true);
        PickPocket = Spell(921, true, true, true);
        Premeditation = Spell(196979, false, false, false);
        PrecisionStrike = Spell(197235, false, false, false);
        ShadowFocus = Spell(108209, false, false, true);
        Shadowstrike = Spell(185438, false, true, true);
        ShurikenStorm = Spell(197835, false, false, true);
        ShurikenToss = Spell(114014, true, true, true);
        Sprint = Spell(2983, false, false, true);
        Stealth = Spell(1784, false, false, true);
        Subterfuge = Spell(108208, false, false, true);
        SymbolsofDeath = Spell(212283, false, false, true);
        TricksoftheTrade = Spell(57934, false, false, true);
        Vanish = Spell(1856, false, false, true);
        -- Offensive Cooldowns
        ShadowBlades = Spell(121471, false, false, true);
        ShadowDance = Spell(185313, false, false, true);
        GoremawsBite = Spell(209782, false, true, true);
        -- Defensive Cooldowns
        CloakofShadows = Spell(31224, false, false, true);
        CrimsonVial = Spell(185311, false, false, true);
        Feint = Spell(1966, false, false, true);
        Evasion = Spell(5277, false, false, true);

        --- GUI Frame
        -- Pages
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");

        -- Options
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Kick to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddNewOption("General Settings", "Tricks of the Trade on Focus", 230, false, {2, "Always", "On Aggro"}, nil, "Will use Tricks of the Trade on your focus if he's allied."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Everytime it is available."..C.TOOLTIP_SUBVALUE("On Aggro").."Only if you have the aggro of something.");
        module.AddSection("General Settings", "Solo", "Green");
        module.AddNewOption("General Settings", "Kidney Shot", 210, false, nil, nil, "Enable for the automatic usage of Kidney Shot."..C.TOOLTIP_HINT("Useful if you're having hard time while soloing."));
        module.AddNewOption("General Settings", "Cheap Shot", 210, false, nil, nil, "Enable for the automatic usage of Cheap Shot."..C.TOOLTIP_HINT("Useful if you're having hard time while soloing."));
        module.AddNewOption("General Settings", "Pick Pocket", 210, false, nil, nil, "Will PickPocket your target before engaging it."..C.TOOLTIP_HINT("Enabling Pick Pocket will turn on Auto-Loot."));

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Enable for the automatic usage of Potion when the BossMod timer will met the timer set."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddNewOption("Offensive Settings", "Stealth", 230, true, {1, "Always", "Near Target"}, nil, "Enable for the automatic usage of Stealth."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Everytime it is available."..C.TOOLTIP_SUBVALUE("Near Target").."When approaching your target.");
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Marked For Death", 233, true, {2, "Target", "Adds"}, {1, "Always", "Cooldown Only"}, "Enable for the automatic usage of Marked for Death."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Target", true).."Only on your target with 1 or less CP."..C.TOOLTIP_SUBVALUE("Adds").."On every units available."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Vanish", 233, true, {1, "Always", "Not Tanking"}, {2, "Always", "Cooldown Only"}, "Enable for the automatic usage of Vanish."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will 'Always' use Vanish no matter if you're tanking or not."..C.TOOLTIP_SUBVALUE("Not Tanking").."Will only use Vanish if you're 'Not Tanking' the target (Mostly for Solo)."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Goremaw's Bite", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Goremaw's Bite."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Shadow Dance", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Shadow Dance."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Shadow Blades", 210, true, nil, nil, "Enable for the automatic usage of Shadow Blades.");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() or Shadowmeld:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_HINT("Arcane Torrent, Berserking, Bloodfury are supported.\nAs of Build 21531 Shadowstrike doesn't work with Shadowmeld."));
        end
        module.AddNewOption("Offensive Settings", "Trinket: 1 | 2", 133, true, {2, "Disabled", "Enabled"}, {2, "Disabled", "Enabled"}, "Enable for the automatic usage of Trinkets."..C.TOOLTIP_VALUE_1.."Enable Trinket Slot 1."..C.TOOLTIP_VALUE_2.."Enable Trinket Slot 2.");
        module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Nightblade Cycling", 220, false, {12, 6, 24, 1}, nil, "Cycle Nightblade on available units and set the minimum TTD."..C.TOOLTIP_HINT("It will always cast on the unit available with the Highest TTD."));
        module.AddNewOption("Offensive Settings", "Shadowstrike Range", 122, true, {10, 5, 25, 1}, {10, 5, 25, 1}, "Set the range from the target to use Shadowstrike."..C.TOOLTIP_VALUE_1.."While being In Combat."..C.TOOLTIP_VALUE_2.."While being Out of Combat.");
        module.AddNewOption("Offensive Settings", "Shuriken Toss", 220, true, {75, 40, 150, 1}, nil, "Enable to auto use Throw while not being in melee range and not being stealthed."..C.TOOLTIP_VALUE.."Set the minimum energy to start using it.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Health Percentage to use Healing Belt / Healing Pot / Healthstone.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Crimson Vial", 220, true, {65, 1, 100, 1}, nil, "Health Percentage to use Crimson Vial.");
        module.AddNewOption("Defensive Settings", "Feint", 220, false, {55, 1, 100, 1}, nil, "Health Percentage to use Feint."..C.TOOLTIP_HINT("Put 100 to maintain 100% uptime."));
        module.AddNewOption("Defensive Settings", "Hand of Protection Cancel", 220, false, {1, 0, 3, 0.1}, nil, "Enable this option to auto cancel Hand of Protection after the amount of time set."..C.TOOLTIP_HINT("Useful when you're trolled by your Paladins."));
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Evasion", 220, true, {25, 1, 100, 1}, nil, "Health Percentage to use Evasion.");
        module.AddNewOption("Defensive Settings", "Cloak of Shadows", 220, true, {45, 1, 100, 1}, nil, "Health Percentage to use Cloak of Shadows.");
        module.AddNewOption("Defensive Settings", "Vanish Defensive", 220, false, {10, 1, 100, 1}, nil, "Health Percentage to use Vanish defensively.");

        --- Misc
        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Combat's Local Functions
    local function Finisher ()
        -- kidney_shot
        if module.IsOptionEnabled("Kidney Shot") and not Target:IsBoss() and Target:DebuffRemains(CheapShot) < 1 and Target:CanCast(KidneyShot) then
            Target:Cast(KidneyShot);
            return;
        end
        -- death_from_above,if=spell_targets.death_from_above>=10
        if DeathFromAbove:Exists() and #Enemies_8y >= 10 and Target:CanCast(DeathFromAbove) then
            Target:Cast(DeathFromAbove);
            return;
        end
        -- nightblade,if=!dot.nightblade.ticking|dot.nightblade.remains<(6+(2*combo_points))*0.3
        if Target:DebuffRemains(Nightblade) <= (6+(2*Player:ComboPoints()))*0.3 and Target:TimeToDie(10) > 6 and Target:CanCast(Nightblade) then
            Target:Cast(Nightblade);
            return;
        end
        -- nightblade,cycle_targets=1,target_if=max:target.time_to_die,if=active_dot.nightblade<6&target.time_to_die>6&(!dot.nightblade.ticking|dot.nightblade.remains<(6+(2*combo_points))*0.3)
        if module.IsOptionEnabled("Nightblade Cycling") and module.UseAOE() then
            -- TTD Units Handler.
            local BestUnit, BestUnitTTD = nil, module.GetOptionValue("Nightblade Cycling");
            local ThisUnit, ThisUnitTTD;
            for i = 1, #Enemies_5y do
                ThisUnit = Enemies_5y[i];
                ThisUnitTTD = ThisUnit:TimeToDie(20);
                if ThisUnitTTD > 6 and ThisUnitTTD < 5000 and ThisUnitTTD > BestUnitTTD and ThisUnit:DebuffRemains(Nightblade) <= (6+(2*Player:ComboPoints()))*0.3 and ThisUnit:CanCast(Nightblade) then
                    BestUnit, BestUnitTTD = ThisUnit, ThisUnitTTD;
                end
            end
            -- Cast Nightblade if we got an unit.
            if BestUnit then
                BestUnit:Cast(Nightblade);
                return;
            end
        end
        -- death_from_above
        if DeathFromAbove:Exists() and Target:CanCast(DeathFromAbove) then
            Target:Cast(DeathFromAbove);
            return;
        end
        -- eviscerate
        if Target:CanCast(Eviscerate) then
            Target:Cast(Eviscerate);
            return;
        end
        return;
    end
    local function Generator ()
        -- shuriken_storm,if=spell_targets.shuriken_storm>=2
        if NumEnemies >= 2 and Player:CanCast(ShurikenStorm) then
            Player:Cast(ShurikenStorm);
            return;
        end
        if Gloomblade:Exists() then
            -- gloomblade,if=energy.time_to_max<2.5
            if Player:EnergyTimeToMax() < 2.5 and Target:CanCast(Gloomblade) then
                Target:Cast(Gloomblade);
                return;
            end
        else
            -- backstab,if=energy.time_to_max<2.5
            if Player:EnergyTimeToMax() < 2.5 and Target:CanCast(Backstab) then
                Target:Cast(Backstab);
                return;
            end
        end
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated
        Player:SetCommonMeleeStatus();
        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;
        -- Combo Points Variables
        DurationThreshold = DeeperStrategem:Exists() and 12.6 or 10.8;
        -- Stealth Handler
        CombatStealthAllowed = ShadowDance:TimeSinceCast() > 0.5 and Vanish:TimeSinceCast() > 0.5 and Shadowmeld:TimeSinceCast() > 0.5;
        Stealth = Subterfuge:Exists() and Spell(115191, false, false, true) or Spell(1784, false, false, true); -- w/ or w/o Subterfuge Talent

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Vanish Defensive") and VanishAllowed and not Player:IsStealthed(true) and Player:HealthPercentage() <= module.GetOptionValue("Vanish Defensive") and Shadowmeld:TimeSinceCast() > 0.5 and Player:CanCast(Vanish) then
            Player:Cast(Vanish);
            Vanish.LastCastTime = module.GetTime();
            return;
        end
        if module.IsOptionEnabled("Evasion") and not Player:Buff(Evasion) and Player:HealthPercentage() <= module.GetOptionValue("Evasion") and Player:CanCast(Evasion) then
            Player:Cast(Evasion);
        end
        if module.IsOptionEnabled("Cloak of Shadows") and Player:HealthPercentage() <= module.GetOptionValue("Cloak of Shadows") and Player:CanCast(CloakofShadows) then
            Player:Cast(CloakofShadows);
        end
        -- Defensive Abilities
        if module.IsOptionEnabled("Feint") and Player:HealthPercentage() <= module.GetOptionValue("Feint") and not Player:Buff(Feint) and Player:CanCast(Feint) then
            Player:Cast(Feint);
            return;
        end
        if module.IsOptionEnabled("Crimson Vial") and Player:HealthPercentage() <= module.GetOptionValue("Crimson Vial") and Player:CanCast(CrimsonVial) then
            Player:Cast(CrimsonVial);
            return;
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Kick, ArcaneTorrent);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Tricks of the Trade on Focus
        if module.IsOptionEnabled("Tricks of the Trade on Focus") and (module.GetOptionValue("Tricks of the Trade on Focus") == "Always" or (Player:ThreatSituation() and Player:ThreatSituation() >= 1)) and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
            Focus:Cast(TricksoftheTrade);
        end
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Marked for Death Handler for Adds
        if Player:UseMarkedForDeath(MarkedForDeath, Player:ComboPointsDeficit()) then
            return;
        end
        -- Auto Target
        Target = Player:ReTarget(Backstab, false) or Unit.Target;
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Enemies Check
            if module.UseAOE() then
                Enemies_10y = Player:EnemiesWithinDistance(10, true); -- Using 10y (real range) for Shuriken Storm and true as it is a PlayerCenteredAoE Spell.
                Enemies_8y = Player:FilterEnemiesByDistance(Enemies_10y, 8, true); -- Using 8y (real range) for Death from Above and true as it is a PlayerCenteredAoE Spell.
                Enemies_5y = Player:FilterEnemiesByDistance(Enemies_8y, 5, false); -- This table is used for Melee Range Cycling Abilities (like Nightblade).
                NumEnemies = #Enemies_10y;
            else
                NumEnemies = 1;
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, Backstab) then
                if module.CooldownsAllowed() then
                    -- shadow_blades,if=!buff.shadow_blades.up&energy.deficit<20&(buff.shadow_dance.up|buff.vanish.up)
                    if module.IsOptionEnabled("Shadow Blades") and not Player:Buff(ShadowBlades) and Player:EnergyMax()-Player:Energy() < 20 and Player:IsStealthed(true) and Player:CanCast(ShadowBlades) then
                        Player:Cast(ShadowBlades);
                    end
                    -- Trinkets
                    if Trinket1:IsUsableInventory() and module.GetOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket1:UseInventory();
                    end
                    if Trinket2:IsUsableInventory() and module.GetSecondOptionValue("Trinket: 1 | 2") == "Enabled" then
                        Trinket2:UseInventory();
                    end
                end
                -- Racials
                if (BloodFury:Exists() or Berserking:Exists() or ArcaneTorrent:Exists()) and module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") and Player:IsWithinCastRange(Target, Backstab) then
                    if Player:Buff(ShadowDance) then
                        -- blood_fury,if=buff.shadow_dance.up
                        if Player:CanCast(BloodFury) then
                            Player:Cast(BloodFury);
                        end
                        -- berserking,if=buff.shadow_dance.up
                        if Player:CanCast(Berserking) then
                            CastSpellByID(26297, "player")
                        end
                    end
                    -- arcane_torrent,if=energy.deficit>15&(buff.shadow_dance.up|buff.vanish.up)
                    if Player:CanCast(ArcaneTorrent) and Player:EnergyDeficit() > 15 and Player:IsStealthed(true) then
                        Player:Cast(ArcaneTorrent);
                    end
                end
                -- goremaws_bite,if=(combo_points.max-combo_points>=2&energy.deficit>55&time<10)|(combo_points.max-combo_points>=4&energy.deficit>45)|target.time_to_die<8
                if module.IsOptionEnabled("Goremaw's Bite") and (module.CooldownsAllowed() or module.GetSecondOptionValue("Goremaw's Bite") == "Always") and ((Player:ComboPointsDeficit() >= 2 and Player:EnergyMax()-Player:Energy() > 55 and CombatTime() < 10) or (Player:ComboPointsDeficit() >= 4 and Player:EnergyMax()-Player:Energy() > 45) or Target:TimeToDie() < 8) and Target:CanCast(GoremawsBite) then
                    Target:Cast(GoremawsBite);
                    return;
                end
            end
            if Player:IsStealthed(true) or not CombatStealthAllowed then
                -- symbols_of_death,if=buff.symbols_of_death.remains<target.time_to_die-4&buff.symbols_of_death.remains<=10.5
                if Player:BuffRemains(SymbolsofDeath) < Target:TimeToDie() and Player:BuffRemains(SymbolsofDeath) <= 10.5 then
                    if not SymbolsofDeath:IsUsable() then
                        return;
                    end
                    if Player:CanCast(SymbolsofDeath) then
                        Player:Cast(SymbolsofDeath);
                    end
                end
                -- shuriken_storm,if=buff.stealth.up&talent.premeditation.enabled&artifact.precision_strike.rank<=3&combo_points.max-combo_points>=3&spell_targets.shuriken_storm>=7
                if Premeditation:Exists() and NumEnemies >= 7 and Player:ComboPointsDeficit() >= 3 and PrecisionStrike:ArtifactRank() <= 3 and Player:CanCast(ShurikenStorm) then
                    Player:Cast(ShurikenStorm);
                    return;
                end
                -- shuriken_storm,if=buff.stealth.up&!buff.death.up&combo_points.max-combo_points>=2&((!talent.premeditation.enabled&((artifact.precision_strike.rank<=3&spell_targets.shuriken_storm>=4)|spell_targets.shuriken_storm>=5))|spell_targets.shuriken_storm>=8)
                if not Player:Buff(Death) and Player:ComboPointsDeficit() >= 2 and (NumEnemies >= 8 or (not Premeditation:Exists() and (NumEnemies >= 4 or (PrecisionStrike:ArtifactRank() <= 3 and NumEnemies >= 3)))) and Player:CanCast(ShurikenStorm) then
                    Player:Cast(ShurikenStorm);
                    return;
                end
                -- shadowstrike,if=combo_points.max-combo_points>=2
                if Player:ComboPointsDeficit() >= 2 and Player:DistanceTo(Target) < module.GetOptionValue("Shadowstrike Range") and Target:CanCast(Shadowstrike) then
                    Target:Cast(Shadowstrike);
                    return;
                end
            end
            if not Player:IsStealthed(true) and CombatStealthAllowed and Player:IsWithinCastRange(Target, Backstab) then
                -- pool_resource,for_next=1,extra_amount=energy.max-talent.master_of_shadows.enabled*30
                -- vanish,if=energy.deficit<talent.master_of_shadows.enabled*30&combo_points.max-combo_points>=3&cooldown.shadow_dance.charges<2|target.time_to_die<8
                if module.IsOptionEnabled("Vanish") and (module.CooldownsAllowed() or module.GetSecondOptionValue("Vanish") == "Always") and (not Player:IsTanking(Target) or module.GetOptionValue("Vanish") == "Always") and Player:ComboPointsDeficit() >= 3 and ShadowDance:Charges() < 2 and Player:CanCast(Vanish) then
                    if Player:Energy() < Player:EnergyMax()-5-(MasterofShadows:Exists() and 30 or 0) then
                        return;
                    end
                    if Player:Energy() >= Player:EnergyMax()-5-(MasterofShadows:Exists() and 30 or 0) then
                        Player:Cast(Vanish);
                        Vanish.LastCastTime = module.GetTime();
                        return;
                    end
                end
                -- pool_resource,for_next=1,extra_amount=energy.max-talent.master_of_shadows.enabled*30
                -- shadow_dance,if=combo_points.max-combo_points>=2&((cooldown.vanish.remains&buff.symbols_of_death.remains<=10.5&energy.deficit<talent.master_of_shadows.enabled*30)|cooldown.shadow_dance.charges>=2|target.time_to_die<25)
                if module.IsOptionEnabled("Shadow Dance") and (module.CooldownsAllowed() or module.GetOptionValue("Shadow Dance") == "Always") and (((not Vanish:Exists() or Vanish:IsOnCooldown() or not module.IsOptionEnabled("Vanish") or (Player:IsTanking(Target) and module.GetOptionValue("Vanish") == "Not Tanking")) and Player:BuffRemains(SymbolsofDeath) <= 10.5 and Player:EnergyMax()-Player:Energy() < (MasterofShadows:Exists() and 30 or 0)) or ShadowDance:Charges() >= 2 or Target:TimeToDie() < 25) and Player:ComboPointsDeficit() >= 2 and Player:CanCast(ShadowDance) then
                    if Player:Energy() < Player:EnergyMax()-5-(MasterofShadows:Exists() and 30 or 0) then
                        return;
                    else
                        Player:Cast(ShadowDance);
                        ShadowDance.LastCastTime = module.GetTime();
                        return;
                    end
                end
            end
            -- enveloping_shadows,if=buff.enveloping_shadows.remains<target.time_to_die&((buff.enveloping_shadows.remains<=10.8+talent.deeper_strategem.enabled*1.8&combo_points>=5+talent.deeper_strategem.enabled)|buff.enveloping_shadows.remains<=6)
            if EnvelopingShadows:Exists() and ((Player:BuffRemains(EnvelopingShadows) < DurationThreshold and Player:ComboPoints() >= 5+(DeeperStrategem:Exists() and 1 or 0)) or Player:BuffRemains(EnvelopingShadows) < 6) and Player:BuffRemains(EnvelopingShadows) < Target:TimeToDie() and Player:CanCast(EnvelopingShadows) then
                Player:Cast(EnvelopingShadows);
                return;
            end
            -- marked_for_death,cycle_targets=1,target_if=min:target.time_to_die,if=combo_points.max-combo_points>=4
            if module.IsOptionEnabled("Marked For Death") and module.GetOptionValue("Marked For Death") == "Target" and (module.CooldownsAllowed() or module.GetSecondOptionValue("Marked For Death") == "Always") and MarkedForDeath:Exists() and Player:ComboPointsDeficit() >= 4 and Target:CanCast(MarkedForDeath) then
                Target:Cast(MarkedForDeath);
                return;
            end
            -- run_action_list,name=finisher,if=combo_points>=5
            if Player:ComboPoints() >= 5 then
                Finisher();
            end
            -- run_action_list,name=generator,if=combo_points<5
            if Player:ComboPoints() < 5 then
                Generator();
            end
            -- Shuriken Toss Out of Range
            if module.IsOptionEnabled("Shuriken Toss") and not Player:IsWithinCastRange(Target, Backstab) and not Player:IsStealthed(true) and Player:Energy() > module.GetOptionValue("Shuriken Toss") and (Player:ComboPoints() < Player:ComboPointsMax() or Player:EnergyTimeToMax() <= 1.5) and Target:CanCast(ShurikenToss) then
                Target:Cast(ShurikenToss);
                return;
            end
            return;
        end
        -- potion,name=draenic_agility,if=buff.bloodlust.react|target.time_to_die<40
        -- blood_fury,if=buff.shadow_dance.up
        -- berserking,if=buff.shadow_dance.up
        -- arcane_torrent,if=energy.deficit>15&(buff.shadow_dance.up|buff.vanish.up)
        -- shadow_blades,if=!buff.shadow_blades.up&energy.deficit<20&(buff.shadow_dance.up|buff.vanish.up)
        -- goremaws_bite,if=(combo_points.max-combo_points>=2&energy.deficit>55&time<10)|(combo_points.max-combo_points>=4&energy.deficit>45)|target.time_to_die<8
        -- symbols_of_death,if=buff.symbols_of_death.remains<target.time_to_die-4&buff.symbols_of_death.remains<=10.5
        -- shuriken_storm,if=buff.stealth.up&talent.premeditation.enabled&artifact.precision_strike.rank<=3&combo_points.max-combo_points>=3&spell_targets.shuriken_storm>=7
        -- shuriken_storm,if=buff.stealth.up&!buff.death.up&combo_points.max-combo_points>=2&((!talent.premeditation.enabled&((artifact.precision_strike.rank<=3&spell_targets.shuriken_storm>=4)|spell_targets.shuriken_storm>=5))|spell_targets.shuriken_storm>=8)
        -- shadowstrike,if=combo_points.max-combo_points>=2
        -- pool_resource,for_next=1,extra_amount=energy.max-talent.master_of_shadows.enabled*30
        -- vanish,if=energy.deficit<talent.master_of_shadows.enabled*30&combo_points.max-combo_points>=3&cooldown.shadow_dance.charges<2|target.time_to_die<8
        -- pool_resource,for_next=1,extra_amount=energy.max-talent.master_of_shadows.enabled*30
        -- shadow_dance,if=combo_points.max-combo_points>=2&((cooldown.vanish.remains&buff.symbols_of_death.remains<=10.5&energy.deficit<talent.master_of_shadows.enabled*30)|cooldown.shadow_dance.charges>=2|target.time_to_die<25)
        -- enveloping_shadows,if=buff.enveloping_shadows.remains<target.time_to_die&((buff.enveloping_shadows.remains<=10.8+talent.deeper_strategem.enabled*1.8&combo_points>=5+talent.deeper_strategem.enabled)|buff.enveloping_shadows.remains<=6)
        -- marked_for_death,cycle_targets=1,target_if=min:target.time_to_die,if=combo_points.max-combo_points>=4
        -- run_action_list,name=finisher,if=combo_points>=5
        -- run_action_list,name=generator,if=combo_points<5

        -- death_from_above,if=spell_targets.death_from_above>=10
        -- nightblade,if=!dot.nightblade.ticking|dot.nightblade.remains<(6+(2*combo_points))*0.3
        -- nightblade,cycle_targets=1,target_if=max:target.time_to_die,if=active_dot.nightblade<6&target.time_to_die>6&(!dot.nightblade.ticking|dot.nightblade.remains<(6+(2*combo_points))*0.3)
        -- death_from_above
        -- eviscerate

        -- shuriken_storm,if=spell_targets.shuriken_storm>=2
        -- gloomblade,if=energy.time_to_max<2.5
        -- backstab,if=energy.time_to_max<2.5
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Disable Stealth if the Loot Window is open, we are interacting with an NPC or combat has just ended. (Also used for PickPocket)
        StealthAllowed = GetNumLootItems() == 0 and not UnitExists("npc") and OutOfCombatTime() > 1 and true or false;
        -- PickPocket Handler Init
        if module.IsOptionEnabled("Pick Pocket") and not module.PickPocketInitialized then
            Player:PickPocketInit();
        end
        -- Stealth
        if module.IsOptionEnabled("Stealth") and module.GetOptionValue("Stealth") == "Always" and StealthAllowed and not Player:IsStealthed(true) and Stealth:TimeSinceCast() > 0.4 and Player:CanCast(Stealth) then
            Player:Cast(Stealth);
            Stealth.LastCastTime = module.GetTime();
            return;
        end
        -- Crimson Vial
        if module.IsOptionEnabled("Crimson Vial") and Player:HealthPercentage() <= module.GetOptionValue("Crimson Vial") and Player:CanCast(CrimsonVial) then
            Player:Cast(CrimsonVial);
            return;
        end
        -- Pre Trick of the Trade
        if module.IsOptionEnabled("Tricks of the Trade on Focus") and BMPullTime() <= 1.5 and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
            Focus:Cast(TricksoftheTrade);
        end
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        -- Symbols of Death
        if SymbolsofDeath:TimeSinceCast() > 0.5 and Player:CanCast(SymbolsofDeath) then
            Player:Cast(SymbolsofDeath);
            SymbolsofDeath.LastCastTime = module.GetTime();
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Stealth
            if module.IsOptionEnabled("Stealth") and Player:DistanceTo(Target) < 25 and StealthAllowed and not Player:IsStealthed(true) and Stealth:TimeSinceCast() > 0.4 and Player:CanCast(Stealth) then
                Player:Cast(Stealth);
                Stealth.LastCastTime = module.GetTime();
                return;
            end
            if Player:IsStealthed(true) and Player:HealthPercentage() > module.GetOptionValue("Vanish Defensive") then
                if module.IsOptionEnabled("Tricks of the Trade on Focus") and Player:DistanceTo(Target) < module.GetSecondOptionValue("Shadowstrike Range")+5 and BMPullTime() == 60 and Focus:Exists() and Focus:IsInParty() and not Focus:Equals(Player) and Focus:CanCast(TricksoftheTrade) then
                    Focus:Cast(TricksoftheTrade);
                end
                if module.IsOptionEnabled("Pick Pocket") and not module.PickPocketed[Target:GUID()] then
                    if Target:CanCast(PickPocket) then
                        Target:Cast(PickPocket);
                        module.PickPocketTarget = Target:GUID();
                        module.PickPocketAttempt = module.GetTime();
                    end
                    return;
                end
                if module.IsOptionEnabled("Cheap Shot") and not Target:IsBoss() and Target:CanCast(CheapShot) then
                    Target:Cast(CheapShot);
                    return;
                end
                if Player:DistanceTo(Target) < module.GetSecondOptionValue("Shadowstrike Range") and Target:CanCast(Shadowstrike) then
                    Target:Cast(Shadowstrike);
                    return;
                end
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Elemental Shaman
    local Rotation = {};
    module.SetRotation("_"..262, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local Enemies, NumEnemies, TargetEnemies_10y = {}, 0, {};

    -- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicIntellect = Item(109218, false, false, true);
        DraenicIntellectBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);
        GiftOfTheNaaru = Spell(59548, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        AncestralGuidance = Spell(108281, false, false, true);
        AncestralSwiftness = Spell(192087, false, false, true);
        Ascendance = Spell(114050, false, false, true);
        AstralShift = Spell(108271, false, false, true);
        ChainLightning = Spell(188443, true, true, true);
        EchoOfTheElements = Spell(108283);
        EarthElemental = Spell(198103, false, false, true);
        EarthquakeTotem = Spell(61882, false, true, true);
        EarthShock = Spell(8042, true, true, true);
        ElementalBlast = Spell(117014, true, true, false);
        ElementalFusion = Spell(192235);
        ElementalMastery = Spell(16166, false, false, true);
        EmberTotem = Spell(210658);
        FlameShock = Spell(188389, true, true, true);
        FrostShock = Spell(196840, true, true, true);
        FireElemental = Spell(198067, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);
        HealingSurge = Spell(8004, false, false, false);
        IceFury = Spell(210714, true, true, false);
        LavaBeam = Spell(114074, true, true, true);
        LavaBurst = Spell(51505, true, true, true);
        LightningBolt = Spell(188196, true, true, true);
        LiquidMagma = Spell(192222, false, true, true);
        PrimalElementalist = Spell(117013);
        StormElemental = Spell(192249, false, false, true);
        StormKeeper = Spell(205495, false, false, true);
        Thunderstorm = Spell(51490, false, false, true);
        TotemMastery = Spell(210643, false, false, true);
        WindShear = Spell(57994, true, true, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, { 4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest" }, { 2, "Disabled", "Enabled" }, "|cffFF0044Target (Left Box)|r \nAutomatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode. \n|cFF0088FFClosest:|r Target the closest enemy. \n|cFF0088FFLeast HP:|r Target the enemy with the least health remaining. \n|cFF0088FFMost HP:|r Target the enemy with the most health remaining. \n|cFF0088FFTarget Closest:|r Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining. \n\n|cffFF0044Attack (Right Box)|r \nUse /startattack when you changes target. Good for melee classes.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Only cast CD's on boss targets.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Ancestral Spirit", 210, true, nil, nil, "Resurrect dead Target with Ancestral Spirit while out of combat");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Wind Shear to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Ascendance", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Ascendance."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Earth Elemental", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Earth Elemental."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Elemental Mastery", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Elemental Mastery."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Fire Elemental", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Fire Elemental."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Storm Elemental", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Storm Elemental."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Chain Lightning", 220, true, {2, 1, 5, 1}, nil, "Use Chain Lightning."..C.TOOLTIP_VALUE.."Define minimum number of units that needs to be in 10 yards around the target.");
        module.AddNewOption("Offensive Settings", "Earthquake Totem", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {2, 1, 25, 1}, "Use Earthquake Totem."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Target").."Always use on the current target."..C.TOOLTIP_SUBVALUE("Target Standing").."Always use on the current target. Target must be standing still."..C.TOOLTIP_SUBVALUE("Centered").."Use centered on a cluster of enemies."..C.TOOLTIP_SUBVALUE("Centered Standing").."Use centered on a cluster of enemies. Enemies must be standing still."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Lava Beam", 220, true, {2, 1, 5, 1}, nil, "Use Lava Beam."..C.TOOLTIP_VALUE.."Define minimum number of units that needs to be in 10 yards around the target.");
        module.AddNewOption("Offensive Settings", "Liquid Magma Totem", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {2, 1, 25, 1}, "Use Liquid Magma Totem."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Target").."Always use on the current target."..C.TOOLTIP_SUBVALUE("Target Standing").."Always use on the current target. Target must be standing still."..C.TOOLTIP_SUBVALUE("Centered").."Use centered on a cluster of enemies."..C.TOOLTIP_SUBVALUE("Centered Standing").."Use centered on a cluster of enemies. Enemies must be standing still."..C.TOOLTIP_VALUE_2.."Amount of enemies that must be in the spell effect to use.");


        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Astral Shift", 220, true, {50, 1, 100, 1}, nil, "Use Astral Shift."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Ancestral Guidance", 220, true, {40, 1, 100, 1}, nil, "Use Ancestral Guidance."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {40, 1, 100, 1}, nil, "Use Gift Of The Naaru on self."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Healing Surge", 222, true, { 20, 0, 95, 5 }, { 90, 0, 95, 5 }, "Use Healing Surge."..C.TOOLTIP_VALUE_1.."Health threshold while in combat."..C.TOOLTIP_VALUE_2.."Health threshold while out of combat.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end
        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        local OpenerSpell = ElementalBlast:Exists() and ElementalBlast or LightningBolt;
        -- Potion
        if module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) and Player:IsWithinCastRange(Target, OpenerSpell) then
            if Player:Potion("Intellect", Potion) then module.Bug("Pre-Pull - Intellect Potion"); Potion = true; end
        end
        -- Totem Mastery
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + 1.5 and TotemMastery:Exists() and (not Player:Buff(EmberTotem) or TotemMastery:TotemDuration() < 10) and Player:CanCast(TotemMastery) then
            Player:Cast(TotemMastery);
            return;
        end
        -- Opener Spell
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() and Target:CanCast(OpenerSpell) then
            Target:Cast(OpenerSpell);
            return;
        end
        -- Flame Shock
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") and not Target:Debuff(FlameShock) and Target:CanCast(FlameShock) then
            Target:Cast(FlameShock);
            return;
        end
    end

    function Rotation:Interrupts ()
        Player:UseInterrupt(WindShear);
    end

    function Rotation:OffGCDAbilities ()

    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Cooldowns
        if module.IsOptionEnabled("Shamanistic Rage") and Player:CanCast(ShamanisticRage) and module.Player:HealthPercentage() <= module.GetOptionValue("Shamanistic Rage") then
            Player:Cast(ShamanisticRage);
        end
        -- Ancestral Guidance
        if AncestralGuidance:Exists() and module.IsOptionEnabled("Ancestral Guidance") and Player:CanCast(AncestralGuidance) and Player:HealthPercentage() <= module.GetOptionValue("Ancestral Guidance") then
            Player:Cast(AncestralGuidance);
        end
        -- Astral Shift
        if AstralShift:Exists() and module.IsOptionEnabled("Astral Shift") and Player:CanCast(AstralShift) and Player:HealthPercentage() <= module.GetOptionValue("Astral Shift") then
            Player:Cast(AstralShift);
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    function Rotation:Combat ()
        -- Healing Surge on ourself
        if module.IsOptionEnabled("Healing Surge") and not Player:IsMoving() and Player:CanCast(HealingSurge) and Player:HealthPercentage() <= module.GetOptionValue("Healing Surge") then
            Player:Cast(HealingSurge);
            return;
        end
        if Target:Exists() and Player:CanAttack(Target) then

            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                Enemies = module.UseAOE() and Player:EnemiesWithinDistance(40) or {}; -- 40 yards.
                TargetEnemies_10y = module.UseAOE() and Target:EnemiesWithinDistance(10) or {}; -- 10 yards of Target for Chain Lightning.
                NumEnemies = #TargetEnemies_10y;
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, LightningBolt) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Ascendance
                if Ascendance:Exists() and module.IsOptionEnabled("Ascendance") and (module.CooldownsAllowed() or module.GetOptionValue("Ascendance") == "Always") and not Player:Buff(Ascendance) and Player:CanCast(Ascendance) then
                    Player:Cast(Ascendance);
                    return;
                end
                -- Storm Elemental Totem
                if StormElemental:Exists() and module.IsOptionEnabled("Storm Elemental") and (module.CooldownsAllowed() or module.GetOptionValue("Storm Elemental") == "Always") and Player:CanCast(StormElemental) then
                    Player:Cast(StormElemental);
                    return;
                end
                -- Fire Elemental Totem
                if not StormElemental:Exists() and FireElemental:Exists() and module.IsOptionEnabled("Fire Elemental") and (module.CooldownsAllowed() or module.GetOptionValue("Fire Elemental") == "Always") and Player:CanCast(FireElemental) then
                    Player:Cast(FireElemental);
                    return;
                end
                -- Earth Elemental Totem
                if EarthElemental:Exists() and module.IsOptionEnabled("Earth Elemental") and (module.CooldownsAllowed() or module.GetOptionValue("Earth Elemental") == "Always") and Player:CanCast(EarthElemental) then
                    Player:Cast(EarthElemental);
                    return;
                end
                -- ElementalMastery
                if ElementalMastery:Exists() and module.IsOptionEnabled("Elemental Mastery") and (module.CooldownsAllowed() or module.GetOptionValue("Elemental Mastery") == "Always") and Player:CanCast(ElementalMastery) then
                    Player:Cast(ElementalMastery);
                    return;
                end
            end
            -- Rotation
            -- Liquid Magma Totem
            if module.UseAOE() and LiquidMagma:Exists() and module.IsOptionEnabled("Liquid Magma Totem") and Target:CanCast(LiquidMagma) then
                if Target:CastGroundSpell(LiquidMagma, "Liquid Magma Totem", 8) then return; end
            end
            -- Totem Mastery
            if TotemMastery:Exists() and TotemMastery:TimeSinceCast() > 5 and (not Player:Buff(EmberTotem) or TotemMastery:TotemDuration() < 3) and Player:CanCast(TotemMastery) then
                TotemMastery.LastCastTime = module.GetTime();
                Player:Cast(TotemMastery);
                return;
            end
            -- Flame Shock
            if FlameShock:Exists() and (Player:Maelstrom() >= 20 or Target:DebuffRemains(FlameShock) < LavaBurst:CastTime()) and Target:DebuffRemains(FlameShock) < 3 and Target:CanCast(FlameShock) then
                Target:Cast(FlameShock);
                return;
            end
            -- Earthquake Totem
            if module.UseAOE() and EarthquakeTotem:TimeSinceCast() >= 9 and EarthquakeTotem:Exists() and module.IsOptionEnabled("Earthquake Totem") and Target:CanCast(EarthquakeTotem) then
                if Target:CastGroundSpell(EarthquakeTotem, "Earthquake Totem", 8) then
                    EarthquakeTotem.LastCastTime = module.GetTime();
                    module.Bug("Earthquake Totem");
                    return;
                end
            end
            if Player:Maelstrom() >= 90 then
                -- Earth Shock
                if EarthShock:Exists() and Target:CanCast(EarthShock) then
                    Target:Cast(EarthShock);
                    return;
                end
            end
            -- Lava Beam
            if module.UseAOE() and Player:Buff(Ascendance) and ChainLightning:Exists() and NumEnemies >= module.GetOptionValue("Lava Beam") and Target:CanCast(ChainLightning) then
                Target:Cast(ChainLightning);
                return;
            end
            -- Lava Burst
            if LavaBurst:Exists() and Target:Debuff(FlameShock) and Target:CanCast(LavaBurst) then
                Target:Cast(LavaBurst);
                return;
            end
            -- Ice Fury
            if IceFury:Exists() and Target:CanCast(IceFury) then
                Target:Cast(IceFury);
                return;
            end
            -- Frost Shock
            if IceFury:Exists() and Player:Buff(IceFury) and Player:Maelstrom() >= 50 and Target:CanCast(FrostShock) then
                Target:Cast(FrostShock);
                return;
            end
            -- Earth Shock
            if EarthShock:Exists() and Player:Maelstrom() >= 70 and Target:CanCast(EarthShock) then
                Target:Cast(EarthShock);
                return;
            end
            -- Elemental Blast
            if ElementalBlast:Exists() and Target:CanCast(ElementalBlast) then
                Target:Cast(ElementalBlast);
                return;
            end
            -- Totem Mastery
            if TotemMastery:Exists() and TotemMastery:TimeSinceCast() > 5 and TotemMastery:TotemDuration() < 10 and Player:CanCast(TotemMastery) then
                TotemMastery.LastCastTime = module.GetTime();
                Player:Cast(TotemMastery);
                return;
            end
            -- Storm Keeper
            if StormKeeper:Exists() and Player:CanCast(StormKeeper) then
                Player:Cast(StormKeeper);
                return;
            end
            -- Chain Lightning
            if module.UseAOE() and ChainLightning:Exists() and NumEnemies >= module.GetOptionValue("Chain Lightning") and Target:CanCast(ChainLightning) then
                Target:Cast(ChainLightning);
                return;
            end
            -- Lightning Bolt
            if LightningBolt:Exists() and Target:CanCast(LightningBolt) then
                Target:Cast(LightningBolt);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(LightningBolt, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end
    function Rotation:OutOfCombat ()
        -- Healing Surge on ourself
        if module.IsOptionEnabled("Healing Surge") and not Player:IsMoving() and Player:CanCast(HealingSurge) and Player:HealthPercentage() <= module.GetSecondOptionValue("Healing Surge") then
            Player:Cast(HealingSurge);
            return;
        end
        -- AncestralSpirit
        if module.IsOptionEnabled("Ancestral Spirit") and Unit.ResurrectCycle(AncestralSpirit) then
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Enhancement Shaman
    local Rotation = {};
    module.SetRotation("_"..263, Rotation);

    --- Localization
    -- Core
    local Enemies_30y = {};
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local CrashEnemies, SunderingEnemies, NumEnemies, HealUnits = {}, {}, 1, {}; -- Enemies


    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);
        DraenicAgility = Item(109217, false, false, true);
        DraenicAgilityBuff = Spell(156423, false, false, true);
        --Racials
        BloodFury = Spell(33697, false, false, true);
        Berserking = Spell(26297, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        AncestralSpirit = Spell(2008, false, false, false, true);
        Ascendance = Spell(114051, false, false, true);
        AstralShift = Spell(108271, false, false, true);
        Boulderfist = Spell(201897, true, true, true);
        BoulderfistBuff = Spell(218825, false, false, true);
        CrashingStorm = Spell(192246);
        CrashLightning = Spell(187874, true, true, true);
        CrashLightningBuff = Spell(187878, false, false, true);
        DoomWinds = Spell(204945, true, true, true);
        EarthenSpike = Spell(188089, true, true, true);
        FeralLunge = Spell(196884, true, true, true);
        FeralSpirit = Spell(51533, false, false, true);
        FeralSpiritArtifact = Spell(198506, false, false, true);
        Flametongue = Spell(193796, true, true, true);
        FlametongueBuff = Spell(194084, false, false, true);
        Frostbrand = Spell(196834, true, true, true);
        FrostbrandBuff = Spell(196834, false, false, true);
        FuryOfAir = Spell(197211, false, false, true);
        GhostWolf = Spell(2645, false, false, true);
        HealingSurge = Spell(188070, false, false, true);
        HotHand = Spell(215785, false, false, true);
        LavaLash = Spell(60103, true, true, true);
        LightningBolt = Spell(187837, true, true, false);
        LightningShield = Spell(192106, false, false, true);
        Overcharge = Spell(210727, false, false, true);
        Purge = Spell(370, true, true, true);
        Rainfall = Spell(215864, false, false, true);
        Rockbiter = Spell(193786, true, true, true);
        Stormstrike = Spell(17364, true, true, true);
        Sundering = Spell(197214, false, false, true);
        WindShear = Spell(57994, true, true, true);
        Windsong = Spell(201898, false, true, true);
        Windstrike = Spell(115356, true, true, true);

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        -- Add options to pages
        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {1, "Disabled", "Enabled"}, "|cffFF0044Target (Left Box)|r\nAutomatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\n|cFF0088FFClosest:|r Target the closest enemy.\n|cFF0088FFLeast HP:|r Target the enemy with the least health remaining.\n|cFF0088FFMost HP:|r Target the enemy with the most health remaining.\n|cFF0088FFTarget Closest:|r Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining.\n\n|cffFF0044Attack (Right Box)|r\nUse /startattack when you changes target. Good for melee classes.");
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range.\n\n|cffFF0044Mode (Left Box)|r\n|cFF0088FFKeep:|r Cast on the new unit but keep your target the same.\n|cFF0088FFSwitch:|r Cast on the new unit and change your target to this unit.\n\n|cffFF0044Range (Right Box)|r\nSet the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Feral Lunge", 133, true, {1, "Disabled", "Enabled"}, {1, "Disabled", "Enabled"}, "Use Feral Lunge to close the gap between you and your target. \n\n|cFF0088FFValue 1:|r In Combat. \n\n|cFF0088FFValue 2:|r Out of Combat.");
        module.AddNewOption("General Settings", "Purge", 230, false, { 1, "Any Target", "Target" }, nil, "Remove known magic buffs from the Target or Any Target.");
        module.AddNewOption("General Settings", "Ancestral Spirit", 210, true, nil, nil, "Resurrect dead Target with Ancestral Spirit while out of combat");
        module.AddNewOption("General Settings", "Lightning Shield", 210, true, nil, nil, "Maintain Lightning Shield on us.");
        module.AddNewOption("General Settings", "Ghost Wolf", 210, true, nil, nil, "Use Ghost Wolf while out of combat.");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {40, 20, 90, 5, 20}, {60}, "Will use Wind Shear to interrupt the target when its cast time meets this % range.");
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range.\n(Works only if Interrupt between % is enabled).");
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 220, false, {1.5, 1, 5, 0.5}, nil, "Will use Potion when the BossMod (Support DBM & BW) timer will met the timer set.");
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions (only if your target is a Boss).");
        module.AddNewOption("Offensive Settings", "Ascendance", 230, true, {2, "Always", "With Cooldowns"}, nil, "Use Ascendance. \n\n|cFF0088FFValue:|r Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Doom Winds", 230, true, {2, "Always", "With Cooldowns"}, nil, "Use Doom Winds. \n\n|cFF0088FFValue:|r Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Feral Spirit", 230, true, {2, "Always", "With Cooldowns"}, nil, "Use Feral Spirit. \n\n|cFF0088FFValue:|r Define if you want to always use the ability or only with cooldowns.");
        module.AddNewOption("Offensive Settings", "Windsong", 230, true, {2, "Always", "With Cooldowns"}, nil, "Use Windsong. \n\n|cFF0088FFValue:|r Define if you want to always use the ability or only with cooldowns.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Crash Lightning", 220, true, {2, 1, 5, 1}, nil, "Use Crash Lightning. \n\n|cFF0088FFValue:|r Units needed to be in Crash Lightning effect zone to use it. (Recommanded 2)");
        module.AddNewOption("Offensive Settings", "Fury Of Air", 220, true, {2, 1, 5, 1}, nil, "Use Fury of Air. \n\n|cFF0088FFValue 1:|r Minimum units in 8 yards around the player to active it. Fury of Air will be triggered off when ther are less than the units count.");
        module.AddNewOption("Offensive Settings", "Lightning Shield", 210, true, nil, nil, "Maintain Lightning Shield on us.");
        module.AddNewOption("Offensive Settings", "Sundering", 220, true, {1, 1, 10, 1}, nil, "Use Sundering. \n\n|cFF0088FFValue:|r Units needed to be in Sundering effect zone to use it.");
        module.AddNewOption("Offensive Settings", "Weapon Imbue", 230, true, {2, "Both", "Flametongue", "Frostbrand", "None"}, nil, "Use Weapon imbue. \n\n|cFF0088FFValue:|r Which weapon imbue(s) should we use.");


        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Health Percentage to use Healing Belt / Healing Pot / Healthstone.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Healing Surge", 222, true, {25, 0, 100, 1}, {85, 0, 100, 1}, "Use Healing Surge. \n\n|cFF0088FFValue 1:|r In Combat health threshold. \n\n|cFF0088FFValue 2:|r Out of Combat health threshold.");
        module.AddNewOption("Defensive Settings", "Rainfall", 222, true, { 3, 1, 10, 1 }, { 70, 0, 100, 1 }, "Use Rainfall. \n\n|cFF0088FFValue 1:|r Number of units that needs to be under threshold.\n\n|cFF0088FFValue 2:|r Threshold health under which the units must be.");
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Astral Shift", 220, true, {30, 0, 100, 1}, nil, "Use Astral Shift.");
        module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 0, 100, 1}, nil, "Use Gift Of The Naaru on ourself.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- Status Frame
        Player:AddCommonMeleeStatus();
        FuryOfAirName = GetSpellInfo(197211);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        -- Put the Outputs here that we wait to keep updated
        Player:SetCommonMeleeStatus();
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end
        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end


    function Rotation:Defensives ()
        -- Defensive Cooldowns
        if module.IsOptionEnabled("Healing Item") and Player:HealthPercentage() <= module.GetOptionValue("Healing Item") then
            if HealingTonic:IsUsable() then
                Healthstone:Use(Player);
            elseif Healthstone:IsUsable() then
                HealingTonic:Use(Player);
            end
        end
        -- Astral Shift
        if AstralShift:Exists() and module.IsOptionEnabled("Astral Shift") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Astral Shift") and Player:CanCast(AstralShift) then
            Player:Cast(AstralShift);
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    function Rotation:Interrupts ()
        Player:UseInterrupt(WindShear);
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(Stormstrike, false) or Unit.Target;
    end

    -- Remove Enrages
    local function PurgeCycle ()
        if module.GetOptionValue("Purge") == "Any Target" then
            for i = 1, #Enemies_30y do
                local ThisUnit = Enemies_30y[i];
                if ThisUnit:IsMagicBuffed() and ThisUnit:CanCast(Purge) then
                    module.Bug("Purge - Any on " .. ThisUnit:Name());
                    ThisUnit:Cast(Purge);
                    return;
                end
            end
        else
            if Target:IsMagicBuffed() and Target:CanCast(Purge) then
                module.Bug("Purge - Target");
                Target:Cast(Purge);
                return;
            end
        end
    end

    --- Run the rotation's combat logic.
    function Rotation:Combat ()

        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and Player:IsFacing(Target) then
            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                HealUnits = Player:HealUnitsAround(100, 12);
                Enemies_30y = Player:EnemiesWithinDistance(30, true, false); -- Enemies in 30 yards for Purge
                Enemies_8y = Player:FilterEnemiesByDistance(Enemies_30y, 8, true); -- Enemies in 8 yards for Fury of Air
                CrashEnemies = Player:UnitsInFrontConeAroundUnit(Target, 5, 100);
                SunderingEnemies = Sundering:Exists() and Player:UnitsInFrontRectangle(10, 5) or {};
                NumEnemies = #CrashEnemies;
                RefreshEnemies = module.GetTime() + 0.2;
            end
            -- Lightning Shield
            if LightningShield:Exists() and module.IsOptionEnabled("Lightning Shield") and Player:BuffRemains(LightningShield) < 900 and Player:CanCast(LightningShield) then
                Player:Cast(LightningShield);
                return;
            end
            -- Purge
            if Purge:Exists() and module.IsOptionEnabled("Purge") and not Purge:IsOnCooldown() then
                PurgeCycle();
            end
            -- Healing Surge
            if HealingSurge:Exists() and module.IsOptionEnabled("Healing Surge") and Player:CanCast(HealingSurge, true) and Player:HealthPercentage() <= module.GetOptionValue("Healing Surge") then
                if Player:Maelstrom() >= 20 then
                    Player:Cast(HealingSurge);
                    return;
                elseif not Player:IsMoving() then
                    Player:Cast(HealingSurge);
                    return;
                end
            end
            if not Player:Buff(GhostWolf) and Target:InCastRange(LightningBolt) then

                -- Cooldowns
                if Player:IsWithinCastRange(Target, Stormstrike) then
                    Player:UseTrinkets();
                    if module.CooldownsAllowed() then
                        -- Racials
                        if module.IsOptionEnabled("Offensive Racials") then
                            -- Blood Fury
                            if BloodFury:Exists() and Player:CanCast(BloodFury) then
                                Player:Cast(BloodFury);
                            end
                            -- Berserking
                            if Berserking:Exists() and Player:CanCast(Berserking) then
                                CastSpellByID(26297, "player")
                            end
                        end
                    end
                    -- Feral Spirit
                    if FeralSpirit:Exists() and module.IsOptionEnabled("Feral Spirit") and (module.CooldownsAllowed() or module.GetOptionValue("Feral Spirit") == "Always") and Target:TimeToDie() >= 20 then
                        if not FeralSpiritArtifact:IsOnCooldown() and not FeralSpirit:IsOnCooldown() and Player:CanCast(FeralSpirit) then
                            Player:Cast(FeralSpirit);
                            return;
                        end
                    end
                    -- Ascendance
                    if Ascendance:Exists() and module.IsOptionEnabled("Ascendance") and (module.CooldownsAllowed() or module.GetOptionValue("Ascendance") == "Always") and Target:TimeToDie() >= 20 and Player:CanCast(Ascendance) then
                        Player:Cast(Ascendance);
                        return;
                    end
                    -- Windsong
                    if Windsong:Exists() and module.IsOptionEnabled("Windsong") and (module.CooldownsAllowed() or module.GetOptionValue("Windsong") == "Always") and Target:TimeToDie() >= 10 and Target:CanCast(Windsong) then
                        Target:Cast(Windsong);
                        return;
                    end
                else
                    -- Feral Lunge
                    if FeralLunge:Exists() and module.GetOptionValue("Feral Lunge") == "Enabled" and Player:DistanceTo(Target) >= 9 and Player:DistanceTo(Target) <= 24 and Target:CanCast(FeralLunge) then
                        Target:Cast(FeralLunge);
                        return;
                    end
                end


                -- Rotation
                if DoomWinds:Exists() and module.IsOptionEnabled("Doom Winds") and (module.CooldownsAllowed() or module.GetOptionValue("Doom Winds") == "Always") and Target:CanCast(DoomWinds) then
                    Target:Cast(DoomWinds);
                    return;
                end
                -- Earthen Spike
                if EarthenSpike:Exists() and Target:CanCast(EarthenSpike) then
                    Target:Cast(EarthenSpike);
                    return;
                end
                -- Boulderfist buff/dump
                if Boulderfist:Exists() and (Boulderfist:Charges() >= 2 or not Player:Buff(BoulderfistBuff)) and Target:CanCast(Boulderfist) then
                    Target:Cast(Boulderfist);
                    return;
                end
                -- Fury of Air
                if FuryOfAir:Exists() and module.IsOptionEnabled("Fury Of Air") then
                    if #Enemies_8y >= module.GetOptionValue("Fury Of Air") and not Player:Buff(FuryOfAir) and Player:CanCast(FuryOfAir) then
                        Player:Cast(FuryOfAir);
                        return;
                    end
                    if #Enemies_8y < module.GetOptionValue("Fury Of Air") and Player:Buff(FuryOfAir) then
                        RunMacroText("/cancelaura " .. FuryOfAirName);
                    end
                end
                -- Crash Lightning buffer
                if CrashLightning:Exists() and (CrashingStorm:Exists() or not Player:Buff(CrashLightningBuff)) and module.IsOptionEnabled("Crash Lightning") and #CrashEnemies >= module.GetOptionValue("Crash Lightning") and Target:CanCast(CrashLightning) then
                    Target:Cast(CrashLightning);
                    return;
                end
                if module.IsOptionEnabled("Weapon Imbue") then
                    -- Flametonge
                    if Flametongue:Exists() and (module.GetOptionValue("Weapon Imbue") == "Flametongue" or module.GetOptionValue("Weapon Imbue") == "Both") and Player:BuffRemains(FlametongueBuff) <= 2 and Target:CanCast(Flametongue) then
                        Target:Cast(Flametongue);
                        return;
                    end
                    -- Frostbrand
                    if Frostbrand:Exists() and (module.GetOptionValue("Weapon Imbue") == "Frostbrand" or module.GetOptionValue("Weapon Imbue") == "Both") and Player:BuffRemains(FrostbrandBuff) <= 2 and Target:CanCast(Frostbrand) then
                        Target:Cast(Frostbrand);
                        return;
                    end
                end
                -- Lava Lash - Hot Hand
                if LavaLash:Exists() and Player:Buff(HotHand) and Target:CanCast(LavaLash) then
                    Target:Cast(LavaLash);
                    return;
                end
                -- Sundering
                if Sundering:Exists() and module.IsOptionEnabled("Sundering") and #SunderingEnemies >= module.GetOptionValue("Sundering") and Player:CanCast(Sundering) then
                    Player:Cast(Sundering);
                    return;
                end
                -- Stormstrike/Windstrike
                if Stormstrike:Exists() and Target:CanCast(Stormstrike) then
                    Target:Cast(Stormstrike);
                    return;
                end
                -- Lightning Bolt Overcharge
                if Overcharge:Exists() and LightningBolt:Exists() and Player:Maelstrom() >= 50 and Target:CanCast(LightningBolt) then
                    Target:Cast(LightningBolt);
                    return;
                end
                -- Crash Lightning filler
                if CrashLightning:Exists() and not Player:Buff(CrashLightningBuff) and module.IsOptionEnabled("Crash Lightning") and #CrashEnemies >= module.GetOptionValue("Crash Lightning") and Target:CanCast(CrashLightning) then
                    Target:Cast(CrashLightning);
                    return;
                end
                -- Boulderfist filler
                if Boulderfist:Exists() and (Boulderfist:Charges() >= 2 or not Player:Buff(BoulderfistBuff) or Player:Maelstrom() < 70) and Target:CanCast(Boulderfist) then
                    Target:Cast(Boulderfist);
                    return;
                end
                -- Lava Lash
                if LavaLash:Exists() and Player:Maelstrom() >= 70 and Target:CanCast(LavaLash) then
                    Target:Cast(LavaLash);
                    return;
                end
                -- Rainfall
                if module.IsOptionEnabled("Rainfall") and Player:CanCast(Rainfall) then
                    local HealthThreashold = module.GetSecondOptionValue("Rainfall");
                    local BestHealUnits = {};
                    for i = 1, #HealUnits do
                        local ThisUnit = HealUnits[i]
                        if ThisUnit:CanHeal(HealingSurge) and not ThisUnit:IsMoving() then
                            TheseHealUnits = ThisUnit:HealUnitsAround(HealthThreashold, 12);
                            if #TheseHealUnits >= module.GetOptionValue("Rainfall") and #TheseHealUnits > #BestHealUnits then
                                BestHealUnits = TheseHealUnits;
                            end
                        end
                    end

                    if #BestHealUnits >= module.GetOptionValue("Rainfall") then
                        Player:CastGroundHeal(Rainfall, BestHealUnits);
                        return;
                    end
                end
                -- Rockbiter
                if Rockbiter:Exists() and Target:CanCast(Rockbiter) then
                    Target:Cast(Rockbiter);
                    return;
                end
                -- Lightning Bolt
                if LightningBolt:Exists() and not Player:IsWithinCastRange(Target, Stormstrike) and Target:CanCast(LightningBolt) then
                    Target:Cast(LightningBolt);
                    return;
                end
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Stormstrike, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- PrePot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicAgilityBuff) and DraenicAgility:InStock() and not DraenicAgility:IsOnCooldown() then
            if Player:Potion("Agility", Potion) then Potion = true; end
        end
        -- Healing Surge
        if HealingSurge:Exists() and module.IsOptionEnabled("Healing Surge") and Player:CanCast(HealingSurge, true) and Player:HealthPercentage() <= module.GetSecondOptionValue("Healing Surge") then
            if Player:Maelstrom() > 20 then
                Player:Cast(HealingSurge);
                return;
            elseif not Player:IsMoving() then
                Player:Cast(HealingSurge);
                return;
            end
        end
        -- Lightning Shield
        if LightningShield:Exists() and module.IsOptionEnabled("Lightning Shield") and Player:BuffRemains(LightningShield) < 900 and Player:CanCast(LightningShield) then
            Player:Cast(LightningShield);
            return;
        end
        -- AncestralSpirit
        if AncestralSpirit:Exists() and module.IsOptionEnabled("Ancestral Spirit") and Unit.ResurrectCycle(AncestralSpirit) then
            return;
        end
        -- Feral Lunge
        if FeralLunge:Exists() and module.GetSecondOptionValue("Feral Lunge") == "Enabled" and Player:DistanceTo(Target) >= 9 and Player:DistanceTo(Target) <= 24 and Target:CanCast(FeralLunge) then
            Target:Cast(FeralLunge);
            return;
        end
        -- Ghost Wolf
        if GhostWolf:Exists() and module.IsOptionEnabled("Ghost Wolf") and not Player:Buff(GhostWolf) and Player:CanCast(GhostWolf) then
            if not module.ShouldGhost then
                module.ShouldGhost = module.GetTime() + math.random(2, 3);
            elseif module.ShouldGhost < module.GetTime() then
                module.ShouldGhost = nil;
                Player:Cast(GhostWolf);
                return;
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Restoration Shaman
    local Rotation = {};
    module.SetRotation("_"..264, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshTables = 0, 0.1, 0; -- Combat Module Throttle
    -- Healers Specific
    local MainTank, MainTankTarget, OffTank, OffTankTarget, HealUnits, Lowest, CurrentBadDebuffs, BestTarget, DispelUnit;
    local Trinket1Units, Trinket2Units, RacialsUnits;
    -- Profile Specific
    local GiftOfTheQueenCount, GiftOfTheQueenUnits = 0, {};
    local HealingRainCount, HealingRainUnits = 0, {};
    local SpiritLinkRaidCount,SpiritLinkRaidUnits = 0, {};
    local AscendanceCount, AncestralGuidanceCount, ChainHealUnit = 0, 0, nil;
    local CloudBurstTotemCount, HealingStreamTotemCount, HealingTideTotemCount, WellspringCount = 0, 0, 0, 0;

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        Trinket1 = Item(13, false, false, true);
        Trinket2 = Item(14, false, false, true);
        LukewarmYakRoastBroth = Item(120293, false, false, true);
        DraenicChanneledManaPotion = Spell(156432, false, false, false);
        --Racials
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33697, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, Resurrect)
        AncestralGuidance = Spell(108281, false, false, true);
        AncestralProtectionTotem = Spell(207399, false, false, true);
        AncestralSpirit = Spell(2008, false, false, false);
        AncestralVision = Spell(212048, false, false, false);
        Ascendance = Spell(114052, false, false, true);
        AstralShift = Spell(108271, false, false, true);
        ChainHeal = Spell(1064, false, false, false);
        ChainLightning = Spell(421, true, true, false);
        CloudBurstTotem = Spell(157153, false, false, true);
        EchoOfTheElements = Spell(108283);
        EarthenShieldTotem = Spell(198838, false, false, true);
        FlameShock = Spell(188838, true, true, true);
        GhostWolf = Spell(2645, false, false, true);
        GiftOfTheQueen = Spell(207778, false, false, true);
        HealingRain = Spell(73920, false, false, false);
        HealingStreamTotem = Spell(5394, false, false, true);
        HealingSurge = Spell(8004, false, false, false);
        HealingTideTotem = Spell(108280, false, false, true);
        HealingWave = Spell(77472, false, false, false);
        LavaBurst = Spell(51505, true, true, false);
        LightningBolt = Spell(403, true, true, false);
        Purge = Spell(370, true, true, true);
        PurifySpirit = Spell(77130, false, false, true);
        Riptide = Spell(61295, false, false, true);
        SpiritLinkTotem = Spell(98008, false, false, true);
        SpiritwalkersGrace = Spell(79206, false, false, true);
        TidalWave = Spell(53390);
        UnleashLife = Spell(73685, false, false, true);
        Wellspring = Spell(197995, false, false, false);
        WindShear = Spell(57994, true, true, true);

        -- GUI Frame
        module.AddPage("General Settings");
        module.AddPage("Healing Settings");
        module.AddPage("Cooldowns Settings");
        module.AddPage("Offensive/Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Focus Assignation", 230, true, {2, "Main Tank", "Off Tank"}, nil, "Select which Tank slot should be given to the focussed unit.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Purify Spirit", 232, false, {1, "Auto", "High", "Normal"}, {0.2, 0, 1, 0.1}, "Use Purify Spirit to Dispel bad debuffs on allied units."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Auto").."Dispel Active Dispel Raid debuffs as High Priority and other not listed debuffs as Normal Priority."..C.TOOLTIP_SUBVALUE("High").."Dispel all debuffs as High Priority even before urgent cooldowns."..C.TOOLTIP_SUBVALUE("Normal").."Dispel all debuffs as Normal Priority after urgent cooldowns."..C.TOOLTIP_VALUE_2.."Define how long you want to wait before dispelling to look more human. This does not apply to Active Dispels Raid debuffs which will always be as soon as Global Cooldown ends."..C.TOOLTIP_HINT("Active Raid Dispels are based on an hardcoded list. Please report of any dispels you may encounter that requires specific strategies so that they can be properly added to the list."));
        module.AddNewOption("General Settings", "Ancestral Spirit", 210, true, nil, nil, "Resurrect dead Target with Ancestral Spirit while out of combat.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Ghost Wolf", 232, true, {3, "Always", "In Combat", "Out Of Combat"}, {2.5, 0, 10, 0.1}, "Use Ghost Wolf on player."..C.TOOLTIP_VALUE_1.."When should we use Ghost Wolf."..C.TOOLTIP_VALUE_2.."Select desired time to wait when you start moving to use it.(seconds)");
        module.AddSection("General Settings", "Interrupts", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Wind Shear to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");

        module.AddSection("Healing Settings", "Common Healing Thresholds", "Green");
        module.AddNewOption("Healing Settings", "Chain Heal", 222, true, {3, 1, 5, 1}, {70, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Gift Of The Queen", 222, true, {1, 1, 5, 1}, {95, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Healing Rain", 222, true, {3, 1, 5, 1}, {70, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Healing Surge", 222, true, {70, 0, 100, 1}, {35, 0, 100, 1}, "Use Healing Surge."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Healing Wave", 222, true, {90, 0, 100, 1}, {80, 0, 100, 1}, "Use Healing Wave."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Riptide", 222, true, {95, 0, 100, 1}, {92, 0, 100, 1}, "Use Riptide."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Unleash Life", 222, true, {70, 0, 100, 1}, {35, 0, 100, 1}, "Use Riptide."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        module.AddNewOption("Healing Settings", "Wellspring", 222, true, {3, 1, 5, 1}, {80, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Healing Settings", "Out Of Combat Healing", 210, true, nil, nil, "Allow Healing while Out of Combat.");
        module.AddSection("Healing Settings", "Active Healing", "Green");
        module.AddNewOption("Healing Settings", "Heal Target", 230, true, {1, "Known Unit", "Any Unit"}, nil, "Heal our current target if it is listed to be healed."..C.TOOLTIP_VALUE.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Known Unit").."Allow Heal Target to be used only when we are targetting a unit listed for it."..C.TOOLTIP_SUBVALUE("Any Unit").."Allow Heal Target to be used on any unit.");
        module.AddNewOption("Healing Settings", "Raid Debuffs", 220, true, {40, 0, 100, 1}, nil, "Use Renew on Debuffed units."..C.TOOLTIP_VALUE.."Helath threshold.");
        module.AddNewOption("Healing Settings", "Tank Debuffs", 220, true, {50, 0, 100, 1}, nil, "Use Renew on Debuffed tanks."..C.TOOLTIP_VALUE.."Helath threshold.");
        module.AddNewOption("Healing Settings", "Topping", 220, true, {100, 0, 100, 1}, nil, "Use Renew/Flash Heal on units to be topped."..C.TOOLTIP_VALUE.."Helath threshold.");

        module.AddSection("Cooldowns Settings", "Cooldowns", "Green");
        module.AddNewOption("Cooldowns Settings", "Ancestral Protection", 220, true, {15, 0, 100, 1}, nil, "Use on a dieing Tank."..C.TOOLTIP_VALUE.."Tank Health threshold."..C.TOOLTIP_HINT("The spell will normally always be used on as many units as possible around the Tank."));
        module.AddNewOption("Cooldowns Settings", "Ancestral Guidance", 222, true, {3, 1, 25, 1}, {60, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Ascendance", 222, true, {3, 1, 25, 1}, {60, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Cloud Burst Totem", 222, true, {1, 1, 25, 1}, {65, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Earthen Shield Totem", 220, true, {15, 0, 100, 1}, nil, "Use on a dieing Tank."..C.TOOLTIP_VALUE.."Tank Health threshold."..C.TOOLTIP_HINT("The spell will normally always be used on as many units as possible around the Tank."));
        module.AddNewOption("Cooldowns Settings", "Healing Stream Totem", 222, true, {2, 1, 25, 1}, {90, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Healing Tide Totem", 222, true, {3, 1, 25, 1}, {70, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Spirit Link Emergency", 222, true, {3, 1, 25, 1}, {25, 0, 100, 1}, "Use when selected number of units are around a dieing Tank."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Tank Health threshold.");
        module.AddNewOption("Cooldowns Settings", "Spirit Link Raid", 222, true, {3, 1, 25, 1}, {50, 0, 100, 1}, "Use when selected number of units are under health threshold."..C.TOOLTIP_VALUE_1.."Number of Units."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddSection("Cooldowns Settings", "Trinkets And Racials", "Green");
        module.AddNewOption("Cooldowns Settings", "Soft Cooldowns Units", 120, true, {3, 1, 25, 1}, nil, "Number of units that needs to be under thresholds to use Racials and Trinkets with Health.");
        module.AddNewOption("Cooldowns Settings", "Use Racials", 220, true, {80, 0, 100, 1}, nil, "Use Racials."..C.TOOLTIP_VALUE.."Use when number of units under threshold is greater or equal to Soft Cooldowns Units value.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 1", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 1 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always") .." Use Always."..C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");
        module.AddNewOption("Cooldowns Settings", "Use Trinket 2", 232, true, {2, "Always", "Health", "Mana"}, {90, 0, 100, 1}, "Use Trinket 2 with selected values."..C.TOOLTIP_VALUE_1.."Choose preferred mode."..C.TOOLTIP_SUBVALUE("Always") .." Use Always."..C.TOOLTIP_SUBVALUE("Health") .." Use when number of units under threshold is greater or equal to Soft Cooldowns Units value."..C.TOOLTIP_SUBVALUE("Mana") .." Use when your mana fall under selected threshold."..C.TOOLTIP_VALUE_2.."Define Health or Mana threshold.");

        module.AddSection("Offensive/Defensive Settings", "DPS Offensive", "Green");
        module.AddPresetOption("TargetAttack");
        module.AddNewOption("Offensive/Defensive Settings", "DPS", 220, true, {95, 0, 100, 1}, nil, "Enables DPS options."..C.TOOLTIP_VALUE.."Will only DPS if the Lowest unit is above DPS health treshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Chain Lightning", 220, true, {3, 1, 10, 1}, nil, "Use Chain Lightning in the DPS rotation."..C.TOOLTIP_VALUE.."Amount of units required to be in 12 yards of Player to use."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Flame Shock", 210, true, nil, nil, "Use Flame Shock in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Lava Burst", 210, true, nil, nil, "Use Lava Burst in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddNewOption("Offensive/Defensive Settings", "Lightning Bolt", 210, true, nil, nil, "Use Lightning Bolt in the DPS rotation."..C.TOOLTIP_HINT("Only used when the Lowest unit's health is higher than the DPS health threshold"));
        module.AddSection("Offensive/Defensive Settings", "Defensive", "Green");
        module.AddNewOption("Offensive/Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone.".. C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Offensive/Defensive Settings", "Astral Shift", 220, true, {30, 1, 100, 1}, nil, "Use Astral Shift."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Offensive/Defensive Settings", "Gift Of The Naaru", 222, true, {65, 0, 100, 1}, {55, 0, 100, 1}, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE_1.."Threshold to use on the Tanks."..C.TOOLTIP_VALUE_2.."Threshold to use on the Raid.");
        end

        -- Healers Specific
        module.AddOutput("|cFF9A2EFEMain Tank:");
        module.AddOutput("|cFF9A2EFEOff Tank:");
        module.AddOutput("|cFF9A2EFELowest:");
        module.AddOutput("|cFF9A2EFEBad Debuffs:");
        module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- New Improved Spell Casting Logic
        module.ISCL = {
            [HealingSurge:ID()] = "Healing Surge",
            [HealingWave:ID()] = "Healing Wave",
            [ChainHeal:ID()] = "Chain Heal"
        };
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Define Main Tanks
        MainTank, MainTankTarget, OffTank, OffTankTarget = Unit.GetMainTanks();

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            module.SetOutput("|cFF9A2EFEBad Debuffs:", 0);
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(WindShear);
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Astral Shift
        if AstralShift:Exists() and module.IsOptionEnabled("Astral Shift") and Player:HealthPercentage() <= module.GetOptionValue("Astral Shift") and Player:CanCast(AstralShift) then
            Player:Cast(AstralShift);
            return;
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and MainTank:CanCast(GiftOfTheNaaru) then
                MainTank:Cast(GiftOfTheNaaru);
                return;
            elseif MainTank and OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and OffTank:CanCast(GiftOfTheNaaru) then
                OffTank:Cast(GiftOfTheNaaru);
                return;
            elseif Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Gift Of The Naaru") and Lowest:CanCast(GiftOfTheNaaru) then
                Lowest:Cast(GiftOfTheNaaru);
                return;
            end
        end
    end

    -- Get Tanks Status
    local TanksStatus, MainTankTanking, OffTankTanking = {Main = {IsTanking = module.GetTime()},Off = {IsTanking = module.GetTime()}};
    local function RefreshTanksStatus ()
        TanksStatus = {
            Main = {IsTanking = MainTank and MainTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Main.IsTanking},
            Off = {IsTanking = OffTank and OffTank:ThreatSituation() == 3 and module.GetTime() or TanksStatus.Off.IsTanking}
        };
        MainTankTanking = module.GetTime() - TanksStatus.Main.IsTanking < 3 or false;
        OffTankTanking = module.GetTime() - TanksStatus.Off.IsTanking < 3 or false;
    end

    -- Active Healing Heal Target handler
    local function HealTarget (ThisUnit)
        -- Riptide
        if ThisUnit:CanCast(Riptide) and ThisUnit:BuffRemains(Riptide) < 2 then
            ThisUnit:Cast(Riptide);
            return;
        end
        if not Player:IsMoving() and ThisUnit:CanCast(HealingSurge) then
            -- Healing Surge
            if ThisUnit:CanCast(HealingSurge) and ThisUnit:SpecialHealthPercentage() < 100 then
                ThisUnit:Cast(HealingSurge);
                return;
            end
            -- Healing Wave
            if ThisUnit:CanCast(HealingWave) then
                ThisUnit:Cast(HealingWave);
                return;
            end
        end
    end

    --- Run the beta rotation's healing logic.
    function Rotation:Combat ()
        -- Find best unit to attack
        if Target:Exists() and Target:CanCast(LightningBolt) then
            BestTarget = Target;
        elseif MainTankTarget and MainTankTarget:CanCast(LightningBolt) then
            BestTarget = MainTankTarget;
        elseif OffTankTarget and OffTankTarget:CanCast(LightningBolt) then
            BestTarget = OffTankTarget;
        elseif Mouseover:Exists() and Mouseover:CanCast(LightningBolt) then
            BestTarget = Mouseover;
        else
            BestTarget = Target;
        end

        -- Refresh tables every 0.5 seconds
        if RefreshTables < module.GetTime() then
            DispelUnit = Unit.Dispel(PurifySpirit);
            HealUnits = Player:HealUnitsAround(100, 40);
            Lowest = Unit.Lowest(MainTank, OffTank);
            module.SetOutput("|cFF9A2EFELowest:", Lowest and Lowest:Name() or "");
            RefreshTanksStatus();
            TargetEnemies_10y = module.UseAOE() and BestTarget:Exists() and BestTarget:EnemiesWithinDistance(10) or {}; -- 10 yards of Target for Chain Lightning.
            AscendanceCount = Ascendance:Exists() and #Player:HealUnitsAround(module.GetSecondOptionValue("Ascendance"), 40) or 0;
            AncestralGuidanceCount = AncestralGuidance:Exists() and #Player:HealUnitsAround(module.GetSecondOptionValue("Ancestral Guidance"), 40) or 0;
            ChainHealUnit = ChainHeal:Exists() and module.IsOptionEnabled("Chain Heal") and Player:BestClusterOfAlliesToHeal(module.GetOptionValue("Chain Heal"), module.GetSecondOptionValue("Chain Heal"), 20) or nil;
            CloudBurstTotemCount = CloudBurstTotem:Exists() and module.IsOptionEnabled("Cloud Burst Totem") and #Player:HealUnitsAround(module.GetSecondOptionValue("Cloud Burst Totem"), 40) or 0;
            HealingStreamTotemCount = HealingStreamTotem:Exists() and module.IsOptionEnabled("Healing Stream Totem") and #Player:HealUnitsAround(module.GetSecondOptionValue("Healing Stream Totem"), 40) or 0;
            HealingTideTotemCount = HealingTideTotem:Exists() and module.IsOptionEnabled("Healing Tide Totem") and #Player:HealUnitsAround(module.GetSecondOptionValue("Healing Tide Totem"), 40) or 0;
            RacialsUnits = module.IsOptionEnabled("Use Racials") and ((Berserking:Exists() and Player:CanCast(Berserking)) or (BloodFury:Exists() and Player:CanCast(BloodFury))) and #Player:HealUnitsAround(module.GetOptionValue("Use Racials"), 40) or 0;
            Trinket1Units = module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 1"), 40) or 0;
            Trinket2Units = module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() and #Player:HealUnitsAround(module.GetSecondOptionValue("Use Trinket 2"), 40) or 0;
            WellspringCount = Wellspring:Exists() and #Player:UnitsInFrontCone(30, 160, true, module.GetSecondOptionValue("Wellspring")) or 0;
            if GiftOfTheQueen:Exists() and module.IsOptionEnabled("Gift Of The Queen") and not GiftOfTheQueen:IsOnCooldown() then
                GiftOfTheQueenCount, GiftOfTheQueenUnits = Player:BestGroundHealUnits(HealUnits, module.GetSecondOptionValue("Gift Of The Queen"), 12);
            else
                GiftOfTheQueenCount, GiftOfTheQueenUnits = 0, {};
            end
            if HealingRain:Exists() and module.IsOptionEnabled("Healing Rain") and not HealingRain:IsOnCooldown() then
                HealingRainCount, HealingRainUnits = Player:BestGroundHealUnits(HealUnits, module.GetSecondOptionValue("Healing Rain"), 10)
            else
                HealingRainCount, HealingRainUnits = 0, {};
            end
            if SpiritLinkTotem:Exists() and module.IsOptionEnabled("Spirit Link Raid") and not SpiritLinkTotem:IsOnCooldown() then
                SpiritLinkRaidCount, SpiritLinkRaidUnits = Player:BestGroundHealUnits(HealUnits, module.GetSecondOptionValue("Spirit Link Raid"), 10)
            else
                SpiritLinkRaidCount, SpiritLinkRaidUnits = 0, {};
            end
            -- Bad Debuffs Output
            CurrentBadDebuffs = Player:GetRaidDebuffs(HealUnits);
            if CurrentBadDebuffs ~= nil then
                module.SetOutput("|cFF9A2EFEBad Debuffs:", #CurrentBadDebuffs.Tanks + #CurrentBadDebuffs.Top + #CurrentBadDebuffs.Debuff);
            end
            RefreshTables = module.GetTime() + 0.5;
        end

        -- Dispels Handling
        Player:DispelHandler(PurifySpirit, "Purify Spirit", DispelUnit, CurrentBadDebuffs.Dispel, "High");

        -- Active Healing Heal Target handler
        if Target:CanCast(HealingWave) and module.IsOptionEnabled("Heal Target") and (module.GetOptionValue("Heal Target") == 2 or (Target:ShouldBeHealed() ~= 0 and Target:HealthPercentage() < Target:ShouldBeHealed())) then
            HealTarget(Target);
            return;
        end

    -- Cooldowns
        -- Only use DPS and Cooldowns during combat
        if Player:IsInCombat() then
            -- DPS
            if module.IsOptionEnabled("DPS") and BestTarget and (not Lowest or Lowest:HealthPercentage() >= module.GetOptionValue("DPS")) and (not MainTank or MainTank:HealthPercentage() >= module.GetOptionValue("DPS")) and (not OffTank or OffTank:HealthPercentage() >= module.GetOptionValue("DPS")) and BestTarget:IsInCombat() then
                -- Flame Shock
                if FlameShock:Exists() and module.IsOptionEnabled("Flame Shock") and BestTarget:DebuffRemains(FlameShock) < 3 and BestTarget:CanCast(FlameShock) then
                    BestTarget:Cast(FlameShock);
                    return;
                end
                -- Lava Burst
                if LavaBurst:Exists() and BestTarget:Debuff(FlameShock) and BestTarget:CanCast(LavaBurst) then
                    BestTarget:Cast(LavaBurst);
                    return;
                end
                -- Chain Lightning
                if ChainLightning:Exists() and #TargetEnemies_10y >= module.GetOptionValue("Chain Lightning") and BestTarget:CanCast(ChainLightning) then
                    BestTarget:Cast(ChainLightning);
                    return;
                end
                -- Lightning Bolt
                if LightningBolt:Exists() and module.IsOptionEnabled("Lightning Bolt") and BestTarget:CanCast(LightningBolt) then
                    BestTarget:Cast(LightningBolt);
                    return;
                end
                -- Find New Target
                if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
                    local NewTargetUnit = Unit.AutoTarget(LightningBolt, module.GetOptionValue("Target | Attack"));
                    if NewTargetUnit then
                        NewTargetUnit:Attack();
                        return;
                    end
                end
            end
            -- Spirit Link Totem
            if SpiritLinkTotem:Exists() and Player:CanCast(SpiritLinkTotem) then
                -- MainTank Emergency
                if MainTank and module.IsOptionEnabled("Spirit Link Emergency") and not MainTank:IsMoving() and MainTank:SpecialHealthPercentage() < module.GetSecondOptionValue("Spirit Link Emergency") and MainTank:CanCast(HealingWave) then
                    local TheseHealUnits = MainTank:HealUnitsAround(100, 10);
                    if #TheseHealUnits >= module.GetOptionValue("Spirit Link Emergency") then
                        module.Bug("Spirit Link Emergency on Main Tank.");
                        Player:CastGroundHeal(SpiritLinkTotem, TheseHealUnits);
                        return;
                    end
                end
                -- OffTank Emergency
                if OffTank and module.IsOptionEnabled("Spirit Link Emergency") and not OffTank:IsMoving() and OffTank:SpecialHealthPercentage() < module.GetSecondOptionValue("Spirit Link Emergency") and OffTank:CanCast(HealingWave) then
                    local TheseHealUnits = OffTank:HealUnitsAround(100, 10);
                    if #TheseHealUnits >= module.GetOptionValue("Spirit Link Emergency") then
                        module.Bug("Spirit Link Emergency on Off Tank.");
                        Player:CastGroundHeal(SpiritLinkTotem, TheseHealUnits);
                        return;
                    end
                end
                -- Raid
                if SpiritLinkRaidCount >= module.GetOptionValue("Spirit Link Raid") then
                    module.Bug("Spirit Link Raid " .. " Count:" .. SpiritLinkRaidCount .. " Units:" .. #SpiritLinkRaidUnits);
                    module.Bug("Spirit Link Raid");
                    Player:CastGroundHeal(SpiritLinkTotem, SpiritLinkRaidUnits);
                    return;
                end
            end
            -- Ancestral Protection Totem
            if AncestralProtectionTotem:Exists() and Player:CanCast(AncestralProtectionTotem) then
                -- MainTank Emergency
                if MainTank and module.IsOptionEnabled("Ancestral Protection") and not MainTank:IsMoving() and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Ancestral Protection") and MainTank:CanCast(AncestralProtection) then
                    local TheseHealUnits = MainTank:HealUnitsAround(100, 10);
                    module.Bug("Ancestral Protection on Main Tank.");
                    Player:CastGroundHeal(AncestralProtectionTotem, TheseHealUnits);
                    return;
                end
                -- OffTank Emergency
                if OffTank and module.IsOptionEnabled("Ancestral Protection") and not OffTank:IsMoving() and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Ancestral Protection") and OffTank:CanCast(AncestralProtection) then
                    local TheseHealUnits = OffTank:HealUnitsAround(100, 10);
                    module.Bug("Ancestral Protection on Off Tank.");
                    Player:CastGroundHeal(AncestralProtectionTotem, TheseHealUnits);
                    return;
                end
            end
            -- Earthen Shield Totem
            if EarthenShieldTotem:Exists() and Player:CanCast(EarthenShieldTotem) then
                -- MainTank Emergency
                if MainTank and module.IsOptionEnabled("Ancestral Protection") and not MainTank:IsMoving() and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Earthen Shield Totem") and MainTank:CanCast(EarthenShieldTotem) then
                    local TheseHealUnits = MainTank:HealUnitsAround(100, 10);
                    module.Bug("Earthen Shield Totem on Main Tank.");
                    Player:CastGroundHeal(EarthenShieldTotem, TheseHealUnits);
                    return;
                end
                -- OffTank Emergency
                if OffTank and module.IsOptionEnabled("Ancestral Protection") and not OffTank:IsMoving() and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Earthen Shield Totem") and OffTank:CanCast(EarthenShieldTotem) then
                    local TheseHealUnits = OffTank:HealUnitsAround(100, 10);
                    module.Bug("Earthen Shield Totem on Off Tank.");
                    Player:CastGroundHeal(EarthenShieldTotem, TheseHealUnits);
                    return;
                end
            end
            -- Healing Tide - Used when # of people under treshold exceed desired number of units
            if HealingTideTotem:Exists() and module.IsOptionEnabled("Healing Tide Totem") and HealingTideTotemCount >= module.GetOptionValue("Healing Tide Totem") and Player:CanCast(HealingTideTotem) then
                Player:Cast(HealingTideTotem);
                return;
            end
            -- Healing Stream - Used when # of people under treshold exceed desired number of units
            if HealingStreamTotem:Exists() and module.IsOptionEnabled("Healing Stream Totem") and HealingStreamTotem:TimeSinceCast() >= 12 and HealingStreamTotemCount >= module.GetOptionValue("Healing Stream Totem") and Player:CanCast(HealingStreamTotem) then
                Player:Cast(HealingStreamTotem);
                HealingStreamTotem.LastCastTime = module.GetTime();
                return;
            end
            -- Cloud Burst - Used when # of people under treshold exceed desired number of units
            if CloudBurstTotem:Exists() and module.IsOptionEnabled("Cloud Burst Totem") and CloudBurstTotemCount >= module.GetOptionValue("Cloud Burst Totem") and Player:CanCast(CloudBurstTotem) then
                Player:Cast(CloudBurstTotem);
                return;
            end
            -- Racials with Specific Handlers
            if module.IsOptionEnabled("Use Racials") then
                if RacialsUnits >= module.GetOptionValue("Soft Cooldowns Units") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                        return;
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                        return;
                    end
                end
            end
            -- Trinkets with specific handlers
            if module.IsOptionEnabled("Use Trinket 1") and Trinket1:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 1"), module.GetSecondOptionValue("Use Trinket 1");
                if Option1 == "Always" or (Option1 == "Health" and Trinket1Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 1")) then
                    Trinket1:UseInventory();
                end
            end
            if module.IsOptionEnabled("Use Trinket 2") and Trinket2:IsUsableInventory() then
                local Option1, Option2 = module.GetOptionValue("Use Trinket 2"), module.GetSecondOptionValue("Use Trinket 2");
                if Option1 == "Always" or (Option1 == "Health" and Trinket2Units >= module.GetOptionValue("Soft Cooldowns Units")) or (Option1 == "Mana" and Player:PowerPercentage() < module.GetSecondOptionValue("Use Trinket 2")) then
                    Trinket2:UseInventory();
                end
            end
            -- Ascendance
            if Ascendance:Exists() and module.IsOptionEnabled("Ascendance") and AscendanceCount >= module.GetOptionValue("Ascendance") and Player:CanCast(Ascendance) then
                Player:Cast(Ascendance);
                return;
            end
            -- Ancestral Guidance
            if AncestralGuidance:Exists() and module.IsOptionEnabled("Ancestral Guidance") and AncestralGuidanceCount >= module.GetOptionValue("Ancestral Guidance") and Player:CanCast(AncestralGuidance) then
                Player:Cast(AncestralGuidance);
                return;
            end
        end
        -- Dispels Handling
        Player:DispelHandler(PurifySpirit, "Purify Spirit", DispelUnit, CurrentBadDebuffs.Dispel, "Normal");
    -- High Priority Healing
        -- Wellspring
        if Wellspring:Exists() and module.IsOptionEnabled("Wellspring") and WellspringCount >= module.GetOptionValue("Wellspring") and Player:CanCast(Wellspring) then
            Player:Cast(Wellspring);
            return;
        end
        -- Gift Of The Queen
        if GiftOfTheQueen:Exists() and GiftOfTheQueenCount >= module.GetOptionValue("Gift Of The Queen") and Player:CanCast(GiftOfTheQueen) then
            -- module.Bug("Gift Of The Queen " .. " Count:" .. GiftOfTheQueenCount .. " Units:" .. #GiftOfTheQueenUnits);
            Player:CastGroundHeal(GiftOfTheQueen, GiftOfTheQueenUnits);
            return;
        end
        -- Healing Rain
        if HealingRain:Exists() and HealingRainCount >= module.GetOptionValue("Healing Rain") and Player:CanCast(HealingRain) then
            -- module.Bug("Healing Rain " .. " Count:" .. HealingRainCount .. " Units:" .. #HealingRainUnits);
            Player:CastGroundHeal(HealingRain, HealingRainUnits);
            return;
        end
        -- Unleash Life
        if UnleashLife:Exists() and module.IsOptionEnabled("Unleash Life") then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Unleash Life") and MainTank:CanCast(UnleashLife) then
                MainTank:Cast(UnleashLife);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Unleash Life") and OffTank:CanCast(UnleashLife) then
                OffTank:Cast(UnleashLife);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Unleash Life") and Lowest:CanCast(UnleashLife) then
                Lowest:Cast(UnleashLife);
                return;
            end
        end
        -- Riptide on Tanks
        if Riptide:Exists() and module.IsOptionEnabled("Riptide") then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Riptide") and (MainTank:BuffRemains(Riptide) <= 5 or MainTank:SpecialHealthPercentage() < 30) and MainTank:CanCast(Riptide) then
                MainTank:Cast(Riptide);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Riptide") and (OffTank:BuffRemains(Riptide) <= 5 or MainTank:SpecialHealthPercentage() < 30) and OffTank:CanCast(Riptide) then
                OffTank:Cast(Riptide);
                return;
            end
        end
        -- Riptide Cycle
        if Player:IsInCombat() and Riptide:Exists() and module.IsOptionEnabled("Riptide") and (not EchoOfTheElements:Exists() or Riptide:Charges() >= 2 or (Riptide:Charges() >= 1 and Riptide:Recharge() < 2)) and (Player:BuffRemains(TidalWave) < 3 or Player:BuffCount(TidalWave) < 2) then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #HealUnits do
                local ThisUnit, ThisUnitHealth = HealUnits[i], HealUnits[i]:SpecialHealthPercentage();
                if ThisUnitHealth <= BestUnitHealth and ThisUnit:CanCast(Riptide) and ThisUnit:BuffRemains(Riptide) < 3 then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit then
                BestUnit:Cast(Riptide);
                return;
            end
        end
        -- Healing Surge - Tanks
        if HealingSurge:Exists() and module.IsOptionEnabled("Healing Surge") and not Player:IsMoving() then
            if MainTank and MainTank:SpecialHealthPercentage() < module.GetOptionValue("Healing Surge") and MainTank:CanCast(HealingSurge) then
                MainTank:Cast(HealingSurge);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() < module.GetOptionValue("Healing Surge") and OffTank:CanCast(HealingSurge) then
                OffTank:Cast(HealingSurge);
                return;
            end
        end
        -- Chain Heal
        if module.IsOptionEnabled("Chain Heal") and ChainHealUnit and ChainHealUnit:CanCast(ChainHeal) then
            ChainHealUnit:Cast(ChainHeal);
            return;
        end
        -- Healing Surge - Raid
        if HealingSurge:Exists() and module.IsOptionEnabled("Healing Surge") and not Player:IsMoving() then
            if Lowest and Lowest:SpecialHealthPercentage() < module.GetSecondOptionValue("Healing Surge") and Lowest:CanCast(HealingSurge) then
                Lowest:Cast(HealingSurge);
                return;
            end
        end
    -- Bad Debuffs - Tank
        if Riptide:Exists() and module.IsOptionEnabled("Tank Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Tanks > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Tanks do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Tanks[i], CurrentBadDebuffs.Tanks[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Riptide) and not ThisUnit:Buff(Riptide) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Tank Debuffs") then
                module.Bug("Riptide on " .. BestUnit:Name() .. " to heal tank debuff");
                BestUnit:Cast(Riptide);
                return;
            end
        end
    -- Bad Debuffs - Debuffs
        if Riptide:Exists() and module.IsOptionEnabled("Raid Debuffs") and CurrentBadDebuffs and #CurrentBadDebuffs.Debuff > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Debuff do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Debuff[i], CurrentBadDebuffs.Debuff[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(Riptide) and not ThisUnit:Buff(Riptide) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil and BestUnitHealth < module.GetOptionValue("Raid Debuffs") then
                module.Bug("Riptide on " .. BestUnit:Name() .. " to mitigate debuff");
                BestUnit:Cast(Riptide);
                return;
            end
        end
    -- Bad Debuffs - Topping
        if module.IsOptionEnabled("Topping") and CurrentBadDebuffs and #CurrentBadDebuffs.Top > 0 then
            local BestUnit, BestUnitHealth = nil, 100;
            for i = 1, #CurrentBadDebuffs.Top do
                local ThisUnit, ThisUnitHealth = CurrentBadDebuffs.Top[i], CurrentBadDebuffs.Top[i]:SpecialHealthPercentage();
                if ThisUnit:CanCast(HealingSurge) and (BestUnit == nil or ThisUnitHealth < BestUnitHealth) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit ~= nil then
                if Riptide:Exists() and BestUnitHealth <= module.GetOptionValue("Topping") and BestUnit:CanCast(Riptide) and not BestUnit:Buff(Riptide) then
                    module.Bug("Riptide on " .. BestUnit:Name() .. " to top it");
                    BestUnit:Cast(Riptide);
                    return;
                end
                if HealingSurge:Exists() and BestUnitHealth <= module.GetOptionValue("Topping") and BestUnit:CanCast(HealingSurge) then
                    module.Bug("Healing Surge on " .. BestUnit:Name() .. " to top it");
                    BestUnit:Cast(HealingSurge);
                    return;
                end
            end
        end
    -- Low Priority Healing
        -- Healing Wave Tanks/Lowest
        if HealingWave:Exists() and module.IsOptionEnabled("Healing Wave") then
            if MainTank and MainTank:SpecialHealthPercentage() <= module.GetOptionValue("Healing Wave") and MainTank:CanCast(HealingWave) then
                MainTank:Cast(HealingWave);
                return;
            end
            if OffTank and OffTank:SpecialHealthPercentage() <= module.GetOptionValue("Healing Wave") and OffTank:CanCast(HealingWave) then
                OffTank:Cast(HealingWave);
                return;
            end
            if Lowest and Lowest:SpecialHealthPercentage() <= module.GetSecondOptionValue("Healing Wave") and Lowest:CanCast(HealingWave) then
                Lowest:Cast(HealingWave);
                return;
            end
        end
        -- Ghost Wolf - when we run more than choosen time
        if GhostWolf:Exists() and module.IsOptionEnabled("Ghost Wolf") and (module.GetOptionValue("Ghost Wolf") == "Always" or (module.GetOptionValue("Ghost Wolf") == "In Combat" and Player:IsInCombat()) or (module.GetOptionValue("Ghost Wolf") == "Out Of Combat" and not Player:IsInCombat())) and Player:Moving() > module.GetSecondOptionValue("Ghost Wolf") and not IsFalling() and not Player:Buff(GhostWolf) and Player:CanCast(GhostWolf) then
            Player:Cast(GhostWolf);
            return;
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Resurrect Deads
        if module.IsOptionEnabled("Ancestral Spirit") and Unit.ResurrectCycle(AncestralSpirit) then
            return;
        end
        if module.IsOptionEnabled("Out Of Combat Healing") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Affliction Warlock
    local Rotation = {};
    module.SetRotation("_"..265, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local MainTank, OffTank, MainTankResDelay, OffTankResDelay = nil, nil, nil, nil; -- Battle Resurection timers
    local Enemies_40y, TargetEnemies_10y, NumEnemies = {}, {}, 0; -- Enemies Table
    local AgonyUnit, CorruptionUnit, SiphonLifeUnit, UnstableAfflictionUnit; -- Dots units
    -- Pet Manager
    local PetTimer, SacrificeRandomDelay = 0, nil;
    -- Effigy Handling
    local CurrentTarget, PreviousTarget

    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicIntellect = Item(109218, false, false, true);
        DraenicIntellectBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, resurrect)
        AbsoluteCorruption = Spell(196103);
        Agony = Spell(980, false, true, true);
        Corruption = Spell(172, false, true, true);
        CorruptionDebuff = Spell(146739);
        CreateHealthstone = Spell(6201, false, false, false);
        DarkPact = Spell(108416, false, false, true);
        DeadwindHarvester = Spell(216708);
        DrainLife = Spell(689, true, true, false);
        DrainSoul = Spell(198590, true, true, false);
        GuardianDoomguard = Spell(18540, false, true, true);
        GuardianInfernal = Spell(1122, false, true, true);
        GrimoreOfSacrifice = Spell(108503, false, false, true);
        GrimoreOfSacrificeBuff = Spell(196099);
        GrimoreOfService = Spell(108501, false, false, true);
        GrimoreOfSupremacy = Spell(152107, false, true, true);
        GrimoreOfImp = Spell(111859, false, true, true);
        GrimoreOfVoid = Spell(111895, false, true, true);
        GrimoreOfSuccubus = Spell(111896, false, true, true);
        GrimoreOfFelHunter = Spell(111897, false, true, true);
        Haunt = Spell(48181, true, true, false);
        HealthFunnel = Spell(755, false, false, false);
        LifeTap = Spell(1454, false, false, true);
        ManaTap = Spell(196104, false, false, true);
        MortalCoil = Spell(6789, false, true, true);
        PhantomSingularity = Spell(205179, false, true, true);
        ReapSouls = Spell(216698, false, false, true);
        SeedOfCorruption = Spell(27243, false, true, false);
        ShadowLock = Spell(171138, true, true, true);
        SiphonLife = Spell(63106, false, true, true);
        SoulEffigy = Spell(205178, false, true, true);
        SoulHarvest = Spell(196098, false, false, true);
        Soulstone = Spell(20707, false, false, false, true);
        SowTheSeeds = Spell(196226);
        SpellLock = Spell(19647, false, true, true);
        SummonDoomguard = Spell(157757, false, false, false);
        SummonFelhunter = Spell(691, false, false, false);
        SummonImp = Spell(688, false, false, false);
        SummonInfernal = Spell(157898, false, false, false);
        SummonSuccubus = Spell(712, false, false, false);
        SummonVoidwalker = Spell(697, false, false, false);
        TormentedSouls = Spell(216695);
        UnendingBreath = Spell(5697, false, false, true);
        UnendingResolve = Spell(104773, false, false, true);
        UnstableAffliction = Spell(30108, false, true, false);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddPresetOption("TargetAttack");
        module.AddPresetOption("BossCD");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Shadow Lock/Spell Lock to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddSection("General Settings", "Demons Management", "Green");
        module.AddNewOption("General Settings", "Demon Manager", 230, true, {3, "Doomguard", "Felhunter", "Imp", "Infernal", "Succubus", "Voidwalker"}, nil, "Enable pet management."..C.TOOLTIP_VALUE.."Choose demon to use.")
        module.AddNewOption("General Settings", "Health Funnel", 220, true, {25, 1, 100, 5}, nil, "Use Health Funnel to heal our demon."..C.TOOLTIP_VALUE.."Health threshold.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Doomguard", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Doomguard."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Grimoire Of Service", 233, true, {1, "Always", "Cooldown Only"}, {2, "Felhunter", "Imp", "Succubus", "Voidwalker"}, "Enable Grimoire of Service."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Choose demon to use.")
        module.AddNewOption("Offensive Settings", "Grimoire Of Sacrifice", 210, true, nil, nil, "Automatic Grimoire Of Sacrifice usage.");
        module.AddNewOption("Offensive Settings", "Infernal", 230, false, {2, "Always", "Cooldown Only"}, nil, "Use Infernal."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Mana Tap", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Mana Tap."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Soul Harvest", 232, true, {1, "Always", "Cooldown Only"}, {1, 0, 3, 1}, "Use Soul Harvest."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Phantom Singularity", 232, true, {1, "Always", "Cooldown Only"}, {1, 0, 3, 1}, "Use Phantom Singularity."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.AddPresetOption("Trinket");
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "SoC AoE", 220, true, {4, 1, 10, 1}, nil, "Use AoE rotation. Apply Dots to current target and spam Seed of Corruption."..C.TOOLTIP_VALUE.."Amount of units needed within 10 yards around our target.");
        module.AddNewOption("Offensive Settings", "Soul Effigy", 232, true, {1, "Auto", "Agony + Corruption"}, {3, 0, 25, 0.1}, "Use Soul Effigy on the current target."..C.TOOLTIP_VALUE.."Minimum health our target must have to use Soul Effigy.")
        module.AddSection("Offensive Settings", "Multi-Dots", "Green");
        module.AddNewOption("Offensive Settings", "Multi-Dot Agony", 222, true, {6, 1, 10, 1}, {3, 0, 25, 0.1}, "Multi-Dot Agony Cycle."..C.TOOLTIP_VALUE_1.."Amount of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Corruption", 222, true, {6, 1, 10, 1}, {3, 0, 25, 0.1}, "Multi-Dot Corruption Cycle."..C.TOOLTIP_VALUE_1.."Amount of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Siphon Life", 222, false, {6, 1, 10, 1}, {3, 0, 25, 0.1}, "Multi-Dot Siphon Life Cycle."..C.TOOLTIP_VALUE_1.."Amount of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Multi-Dot UA", 222, false, {3, 1, 10, 1}, {3, 0, 25, 0.1}, "Multi-Dot Unstable Affliction Cycle."..C.TOOLTIP_VALUE_1.."Amount of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply."..C.TOOLTIP_HINT("Multi-Dot Unstable Affliction will only be used if we have at least 4 Soul Shards."));

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Create Healthstones", 210, true, nil, nil, "Will create you a new healthstone if you have none in your bags and are out of combat.");
        module.AddPresetOption("HealingItem");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Dark Pact", 220, true, {40, 1, 100, 1}, nil, "Use Dark Bargain."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Drain Life", 220, true, {20, 1, 75, 1}, nil, "Use Drain Life."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Mortal Coil", 220, true, {50, 1, 100, 1}, nil, "Use Mortal Coil."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Unending Resolve", 220, true, {40, 1, 100, 1}, nil, "Use Dark Unending Resolve."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [UnstableAffliction:ID()] = "Unstable Affliction"
        };
    end
    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end
        DrainFiller = not Player:Channeling(DrainSpell) and false or DrainFiller;

        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end
        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        local OpenerSpell = not GrimoreOfSupremacy:Exists() and module.IsOptionEnabled("Doomguard") and GuardianDoomguard:Cooldown() == 0 and GuardianDoomguard or UnstableAffliction;
        -- 2) Potion
        if module.IsOptionEnabled("Pre-Pull BossMod") and not Potion and module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and Player:IsWithinCastRange(Target, UnstableAffliction) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + OpenerSpell:TravelTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) then
            if Player:Potion("Intellect", Potion) then Potion = true; end
        end
        -- 3) Doomguard/Shadowbolt/Demonbolt
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + OpenerSpell:TravelTime() and Target:CanCast(OpenerSpell) then
            Target:Cast(OpenerSpell);
            return;
        end
    end

    function Rotation:Interrupts ()
        local PetInterrupt = (SpellLock:PetKnown() and SpellLock) or (ShadowLock:PetKnown() and ShadowLock) or nil;
        if PetInterrupt then
            Player:UseInterrupt(PetInterrupt, ArcaneTorrent, true);
        end
    end

    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(Corruption, true) or Unit.Target;
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Mortal Coil
        if MortalCoil:Exists() and module.IsOptionEnabled("Mortal Coil") and Target:Exists() and Target:CanCast(MortalCoil) and Player:HealthPercentage() <= module.GetOptionValue("Mortal Coil") then
            Target:Cast(MortalCoil);
        end
        -- Dark Pact
        if DarkPact:Exists() and module.IsOptionEnabled("Dark Pact") and Player:CanCast(DarkPact) and Player:HealthPercentage() <= module.GetOptionValue("Dark Pact") then
            Player:Cast(DarkPact);
            return;
        end
        -- Unending Resolve
        if UnendingResolve:Exists() and module.IsOptionEnabled("Unending Resolve") and Player:CanCast(UnendingResolve) and Player:HealthPercentage() <= module.GetOptionValue("Unending Resolve") then
            Player:Cast(UnendingResolve);
            return;
        end
        -- Drain Life
        if module.IsOptionEnabled("Drain Life") and not Player:IsMoving() and not DrainFiller then
            DrainSpell = DrainSoul:Exists() and DrainSoul or DrainLife:Exists() and DrainLife;
            if Player:Channeling(DrainSpell) and Player:HealthPercentage() > module.GetOptionValue("Drain Life") + 15 then
                module.Bug("Stop Chanelling Drain Life as Health threshold was reach.")
                SpellStopCasting();
            end
            if Player:Channeling(DrainSpell) then
                return;
            end
            if Player:HealthPercentage() < module.GetOptionValue("Drain Life") and Target:CanCast(DrainSpell) then
                Target:Cast(DrainSpell);
                return;
            end
        end
    end

    local function PetsManager ()
        -- Grimoire of Sacrifice with random delay
        if module.IsOptionEnabled("Grimoire Of Sacrifice") and GrimoreOfSacrifice:Exists() and not Player:Buff(GrimoreOfSacrificeBuff) then
            if UnitExists("PlayerPet") and Player:CanCast(GrimoreOfSacrifice) then
                if SacrificeRandomDelay then
                    if SacrificeRandomDelay < module.GetTime() then
                        Player:Cast(GrimoreOfSacrifice);
                        module.PetTimer = module.GetTime() + 4;
                        SacrificeRandomDelay = nil;
                        return;
                    end
                else
                    SacrificeRandomDelay = module.GetTime() + math.random(2, 6);
                end
            end
        end
        if not (GrimoreOfSacrifice:Exists() and Player:Buff(GrimoreOfSacrificeBuff)) then
            -- Resurrect Pet
            if not Player:IsMoving() and module.IsOptionEnabled("Demon Manager") and (not PlayerPet:Exists() or PlayerPet:IsDeadOrGhost()) and Player:SoulShards() >= 1 then
                local SelectedPet = module.GetOptionValue("Demon Manager");
                local SelectedPetSpell = SelectedPet == "Doomguard" and GrimoreOfSupremacy:Exists() and SummonDoomguard or SelectedPet == "Felhunter" and SummonFelhunter:Exists() and SummonFelhunter or SelectedPet == "Infernal" and GrimoreOfService:Exists() and SummonInfernal or SelectedPet == "Succubus" and SummonSuccubus:Exists() and SummonSuccubus or SelectedPet == "Voidwalker" and SummonVoidwalker:Exists() and SummonVoidwalker or SummonImp;
                if module.GetTime() - PetTimer >= 1 and Player:CanCast(SelectedPetSpell) then
                    Player:Cast(SelectedPetSpell);
                    PetTimer = module.GetTime() + 2.5;
                end
            end
            -- Health Funnel
            if module.IsOptionEnabled("Health Funnel") and PlayerPet:Exists() and not PlayerPet:IsDeadOrGhost() and Player:Standing() > 0.25 and PlayerPet:HealthPercentage() < module.GetOptionValue("Health Funnel") and Player:CanCast(HealthFunnel) then
                Player:Cast(HealthFunnel);
                return;
            end
        end
    end

    local function ServicePet ()
        local SelectedGrimoire = module.GetSecondOptionValue("Grimoire Of Service");
        local SelectedGrimoireSpell = SelectedGrimoire == "Felhunter" and GrimoreOfFelHunter or SelectedGrimoire == "Imp" and GrimoreOfImp or SelectedGrimoire == "Succubus" and GrimoreOfSuccubus or SelectedGrimoire == "Voidwalker" and GrimoreOfVoid;
        if Target:CanCast(SelectedGrimoireSpell) then
            Target:Cast(SelectedGrimoireSpell);
            return;
        end
    end

    function Rotation:Combat ()
        -- Combat Res Tanks
        MainTank = Unit.MainTank();
        OffTank = Unit.OffTank();
        if MainTank and MainTank:Exists() and not MainTank:IsDeadOrGhost() then MainTankResDelay = nil; end
        if OffTank and OffTank:Exists() and not OffTank:IsDeadOrGhost() then OffTankResDelay = nil; end
        if module.IsOptionEnabled("Instant Soulstone Tank") then
            if MainTank and MainTank:Exists() and MainTank:IsDeadOrGhost() and MainTank:IsPlayer() and MainTank:CanCast(Soulstone) then
                if not MainTankResDelay then MainTankResDelay = module.GetTime(); end
                if module.GetTime()-MainTankResDelay >= module.GetOptionValue("Instant Soulstone Tank") then
                    MainTankResDelay = nil;
                    MainTank:Cast(Soulstone);
                    return;
                end
            elseif OffTank and OffTank:Exists() and OffTank:IsDeadOrGhost() and OffTank:IsPlayer() and OffTank:CanCast(Soulstone) then
                if not OffTankResDelay then OffTankResDelay = module.GetTime(); end
                if module.GetTime()-OffTankResDelay >= module.GetOptionValue("Instant Soulstone Tank") then
                    OffTankResDelay = nil;
                    OffTank:Cast(Soulstone);
                    return;
                end
            end
        end
        if module.IsOptionEnabled("Soulstone") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and Target:IsPlayer() and Target:CanCast(Soulstone) then
            Target:Cast(Soulstone);
            return;
        end

        PetsManager();

        if Target:Exists() and Player:CanAttack(Target) then
            if module.IsOptionEnabled("Soul Effigy") then
                -- Keep tracking of previous target for the Soul Effigy
                if Target:GUID() ~= CurrentTarget then
                    PreviousTarget = CurrentTarget;
                    CurrentTarget = Target:GUID();
                end
                -- When we target the Soul Effigy, we focus it then we swap back to target
                if Target:CreatureID() == 103679 then
                    RunMacroText("/focus");
                    for i = 1, #module.EnemyUnits do
                        local ThisEnemy = module.EnemyUnits[i];
                        if ThisEnemy.UnitID == PreviousTarget then
                            ThisFocusUnit = ThisEnemy;
                            break;
                        end
                    end
                    ThisFocusUnit:Attack();
                end
            end
            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                Enemies_40y = Player:EnemiesWithinDistance(40);
                TargetEnemies_10y = Target:EnemiesWithinDistance(10, true);
                NumEnemies = #TargetEnemies_10y;
                AgonyUnit = Unit.DotCycle(Enemies_40y, Agony, Agony, 18, "Multi-Dot Agony");
                CorruptionUnit = Unit.DotCycle(Enemies_40y, Corruption, CorruptionDebuff, 18, "Multi-Dot Corruption", false, AbsoluteCorruption:Exists());
                SiphonLifeUnit = Unit.DotCycle(Enemies_40y, SiphonLife, SiphonLife, 15, "Multi-Dot Siphon Life");
                UnstableAfflictionUnit = Unit.DotCycle(Enemies_40y, UnstableAffliction, UnstableAffliction, 8, "Multi-Dot UA");
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, Corruption) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Grimoire Of Service
                if GrimoreOfService:Exists() and module.IsOptionEnabled("Grimoire Of Service") and (module.CooldownsAllowed() or module.GetOptionValue("Grimoire Of Service") == "Always") and Target:CanCast(GrimoreOfImp) then
                    ServicePet();
                end
                -- Doomguard
                if not GrimoreOfSupremacy:Exists() and GuardianDoomguard:Exists() and module.IsOptionEnabled("Doomguard") and (module.CooldownsAllowed() or module.GetOptionValue("Doomguard") == "Always") and Target:CanCast(GuardianDoomguard) then
                    Target:Cast(GuardianDoomguard);
                    return;
                end
                -- Infernal
                if not GrimoreOfSupremacy:Exists() and GuardianInfernal:Exists() and module.IsOptionEnabled("Infernal") and (module.CooldownsAllowed() or module.GetOptionValue("Infernal") == "Always") and Target:CanCast(GuardianInfernal) then
                    Target:Cast(GuardianInfernal);
                    return;
                end
                -- Mana Tap
                if ManaTap:Exists() and module.IsOptionEnabled("Mana Tap") and (module.CooldownsAllowed() or module.GetOptionValue("Mana Tap") == "Always") and Player:BuffRemains(ManaTap) < 3 and Player:CanCast(ManaTap) then
                    Player:Cast(ManaTap);
                    return;
                end
            end
            -- Rotation
            -- Reap Souls
            if ReapSouls:Exists() and Player:BuffCount(TormentedSouls) >= 3 and Player:BuffRemains(DeadwindHarvester) < 2 and Player:CanCast(ReapSouls) then
                Player:Cast(ReapSouls);
                return;
            end
            if module.UseAOE() and NumEnemies >= module.GetOptionValue("SoC AoE") then
                -- Unstable Affliction - Target
                if not SowTheSeeds:Exists() and UnstableAffliction:Exists() and Target:DebuffRemains(UnstableAffliction) < 3 and Target:CanCast(UnstableAffliction) then
                    Target:Cast(UnstableAffliction);
                    return;
                end
                -- Agony - Target
                if Agony:Exists() and Target:DebuffRemains(Agony) < 3 and Target:CanCast(Agony) then
                    Target:Cast(Agony);
                    return;
                end
                -- Haunt
                if Haunt:Exists() and Target:CanCast(Haunt) then
                    Target:Cast(Haunt);
                    return;
                end
                -- Agony
                if Agony:Exists() and module.IsOptionEnabled("Multi-Dot Agony") and AgonyUnit and AgonyUnit:DebuffRemains(Agony) < 4 then
                    AgonyUnit:Cast(Agony);
                    return;
                end
                -- Life Tap
                if LifeTap:Exists() and Player:PowerPercentage() <= 40 and Player:HealthPercentage() >= 60 and Player:CanCast(LifeTap) then
                    Player:Cast(LifeTap);
                    return;
                end
                if Player:IsWithinCastRange(Target, Corruption) then
                    -- Soul Harvest
                    if SoulHarvest:Exists() and module.IsOptionEnabled("Soul Harvest") and (module.CooldownsAllowed() or module.GetOptionValue("Soul Harvest") == "Always") and Player:CanCast(SoulHarvest) then
                        Player:Cast(SoulHarvest);
                        return;
                    end
                    -- Phantom Singularity
                    if PhantomSingularity:Exists() and module.IsOptionEnabled("Phantom Singularity") and (module.CooldownsAllowed() or module.GetOptionValue("Phantom Singularity") == "Always") and Target:CanCast(PhantomSingularity) then
                        Target:Cast(PhantomSingularity);
                        return;
                    end
                end
                -- Seed of Corruption - Target
                if SeedOfCorruption:Exists() and Target:CanCast(SeedOfCorruption) then
                    Target:Cast(SeedOfCorruption);
                    return;
                end
                return;
            end
            -- Agony - Target
            if Agony:Exists() and Target:DebuffRemains(Agony) < 3 and Target:CanCast(Agony) then
                Target:Cast(Agony);
                return;
            end
            -- Haunt
            if Haunt:Exists() and Target:CanCast(Haunt) then
                Target:Cast(Haunt);
                return;
            end
            -- Soul Effigy
            if SoulEffigy:Exists() and (not Focus:Exists() or not Target:Debuff(SoulEffigy) or not Player:IsWithinCastRange(Focus, Corruption)) and module.IsOptionEnabled("Soul Effigy") and SoulEffigy:TimeSinceCast() > 5 and Target:Health() >= module.GetSecondOptionValue("Soul Effigy")*1000000 and Target:CanCast(SoulEffigy) then
                SoulEffigy.LastCastTime = module.GetTime();
                Target:Cast(SoulEffigy);
                return;
            end
            -- Agony - Focus
            if Agony:Exists() and module.IsOptionEnabled("Soul Effigy") and Focus:Exists() and Focus:DebuffRemains(Agony) < 3 and Focus:CanCast(Agony) then
                Focus:Cast(Agony);
                return;
            end
            -- Agony
            if Agony:Exists() and module.IsOptionEnabled("Multi-Dot Agony") and AgonyUnit and AgonyUnit:DebuffRemains(Agony) < 4 then
                AgonyUnit:Cast(Agony);
                return;
            end
            if Player:IsWithinCastRange(Target, Corruption) then
                -- Soul Harvest
                if SoulHarvest:Exists() and module.IsOptionEnabled("Soul Harvest") and (module.CooldownsAllowed() or module.GetOptionValue("Soul Harvest") == "Always") and Player:CanCast(SoulHarvest) then
                    Player:Cast(SoulHarvest);
                    return;
                end
                -- Phantom Singularity
                if PhantomSingularity:Exists() and module.IsOptionEnabled("Phantom Singularity") and (module.CooldownsAllowed() or module.GetOptionValue("Phantom Singularity") == "Always") and Target:CanCast(PhantomSingularity) then
                    Target:Cast(PhantomSingularity);
                    return;
                end
            end
            -- Unstable Affliction - Target
            if UnstableAffliction:Exists() and Target:DebuffRemains(UnstableAffliction) < 3 and Target:CanCast(UnstableAffliction) then
                Target:Cast(UnstableAffliction);
                return;
            end
            -- Life Tap
            if LifeTap:Exists() and Player:PowerPercentage() <= 40 and Player:HealthPercentage() >= 60 and Player:CanCast(LifeTap) then
                Player:Cast(LifeTap);
                return;
            end
            -- Corruption - Target
            if Corruption:Exists() and ((AbsoluteCorruption:Exists() and not Target:Debuff(CorruptionDebuff)) or (not AbsoluteCorruption:Exists() and Target:DebuffRemains(CorruptionDebuff) < 3)) and Target:CanCast(Corruption) then
                Target:Cast(Corruption);
                return;
            end
            -- Unstable Affliction - Focus
            if UnstableAffliction:Exists() and Focus:Exists() and module.IsOptionEnabled("Soul Effigy") and module.GetOptionValue("Soul Effigy") == "Auto" and Player:SoulShards() >= 4 and Focus:DebuffRemains(UnstableAffliction) < 3 and Focus:CanCast(UnstableAffliction) then
                Focus:Cast(UnstableAffliction);
                return;
            end
            -- Corruption - Focus
            if Corruption:Exists() and module.IsOptionEnabled("Soul Effigy") and Focus:Exists() and ((AbsoluteCorruption:Exists() and not Focus:Debuff(CorruptionDebuff)) or (not AbsoluteCorruption:Exists() and Focus:DebuffRemains(CorruptionDebuff) < 3)) and Focus:CanCast(Corruption) then
                Focus:Cast(Corruption);
                return;
            end
            -- Unstable Affliction - Cycle
            if UnstableAffliction:Exists() and module.IsOptionEnabled("Multi-Dot UA") and Player:SoulShards() >= 4 and UnstableAfflictionUnit and UnstableAfflictionUnit:DebuffRemains(UnstableAffliction) < 8*0.3 and UnstableAfflictionUnit:CanCast(UnstableAffliction) then
                UnstableAfflictionUnit:Cast(UnstableAffliction);
                return;
            end
            -- Corruption - Cycle
            if Corruption:Exists() and module.IsOptionEnabled("Multi-Dot Corruption") and CorruptionUnit and CorruptionUnit:DebuffRemains(Corruption) < 14*0.3 and CorruptionUnit:CanCast(Corruption) then
                CorruptionUnit:Cast(Corruption);
                return;
            end
            -- Life Tap
            if LifeTap:Exists() and Player:PowerPercentage() <= 65 and Player:HealthPercentage() >= 60 and Player:CanCast(LifeTap) then
                Player:Cast(LifeTap);
                return;
            end
            -- Siphon Life - Target
            if SiphonLife:Exists() and Target:DebuffRemains(SiphonLife) < 3 and Target:CanCast(SiphonLife) then
                Target:Cast(SiphonLife);
                return;
            end
            -- Siphon Life - Focus
            if SiphonLife:Exists() and module.IsOptionEnabled("Soul Effigy") and Focus:Exists() and Focus:DebuffRemains(SiphonLife) < 3 and Focus:CanCast(SiphonLife) then
                Focus:Cast(SiphonLife);
                return;
            end
            -- Siphon Life - Cycle
            if SiphonLife:Exists() and module.IsOptionEnabled("Multi-Dot Siphon Life") and SiphonLifeUnit and SiphonLifeUnit:DebuffRemains(SiphonLife) < 15*0.3 and SiphonLifeUnit:CanCast(SiphonLife) then
                SiphonLifeUnit:Cast(SiphonLife);
                return;
            end
            -- Drain Life
            DrainSpell = DrainSoul:Exists() and DrainSoul or DrainLife:Exists() and DrainLife;
            if Player:Channeling(DrainSpell) then
                return;
            end
            if not Player:IsMoving() and Target:CanCast(DrainSpell) then
                DrainFiller = true;
                Target:Cast(DrainSpell);
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        PetsManager();
        -- Create Healthstones
        if module.IsOptionEnabled("Create Healthstones") and Player:Standing() > 0.25 then
            if not Healthstone:InStock() and CreateHealthstone:TimeSinceCast() >= module.GetTime() + 5 and Player:CanCast(CreateHealthstone) then
                Player:Cast(CreateHealthstone);
                CreateHealthstone.LastCastTime = module.GetTime();
                return;
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Demonology Warlock
    local Rotation = {};
    module.SetRotation("_"..266, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local MainTank, OffTank, MainTankResDelay, OffTankResDelay = nil, nil, nil, nil; -- Battle Resurection timers
    local Enemies = {};
    -- Pet Manager
    local PetTimer = 0;
    local DemonicEmpowermentSwitch, InstantShadowboltSwitch;

    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicIntellect = Item(109218, false, false, true);
        DraenicIntellectBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, resurrect)
        CallDreadstalkers = Spell(104316, false, true, false);
        ChaosWave = Spell(129346, false, true, true);
        CreateHealthstone = Spell(6201, false, false, false);
        DarkPact = Spell(108416, false, false, true);
        Demonwrath = Spell(193440, false, false, true);
        DrainLife = Spell(689, false, true, false);
        Demonbolt = Spell(157695, false, true, false);
        DemonboltInstant = Spell(157695, false, true, true);
        DemonicCalling = Spell(205146);
        DemonicEmpowerment = Spell(193396, false, false, false);
        Doom = Spell(603, false, true, true);
        Felstorm = Spell(89751, false, true, true);
        GuardianDoomguard = Spell(18540, false, true, true);
        GuardianInfernal = Spell(157898, false, true, true);
        GrimoreOfService = Spell(108501, false, false, true);
        GrimoreOfSupremacy = Spell(152107, false, true, true);
        GrimoreOfSynergy = Spell(171975, false, true, true);
        GrimoreOfImp = Spell(111859, false, true, true);
        GrimoreOfVoid = Spell(111895, false, true, true);
        GrimoreOfSuccubus = Spell(111896, false, true, true);
        GrimoreOfFelHunter = Spell(111897, false, true, true);
        GrimoreOfFelguard = Spell(111898, false, true, true);
        HandOfGuldan = Spell(105174, false, true, false);
        HealthFunnel = Spell(755, false, false, false);
        Implosion = Spell(196277, false, true, true);
        LifeTap = Spell(1454, false, false, true);
        MortalCoil = Spell(6789, false, true, true);
        ShadowBolt = Spell(686, true, true, false);
        ShadowBoltInstant = Spell(686, true, true, true);
        Shadowflame = Spell(205181, false, true, true);
        ShadowLock = Spell(171138, false, true, true);
        ShadowyInspiration = Spell(196606);
        SoulHarvest = Spell(196098, false, false, true);
        Soulstone = Spell(20707, false, false, false, true);
        SpellLock = Spell(19647, false, true, true);
        SummonDarkGlare = Spell(205180, false, false, true);
        SummonDoomguard = Spell(157757, false, false, false);
        SummonFelguard = Spell(30146, false, false, false);
        SummonFelhunter = Spell(691, false, false, false);
        SummonImp = Spell(688, false, false, false);
        SummonInfernal = Spell(157898, false, false, false);
        SummonSuccubus = Spell(712, false, false, false);
        SummonVoidwalker = Spell(697, false, false, false);
        ThalkielsConsumption = Spell(211714, false, true, true);
        UnendingBreath = Spell(5697, false, false, true);
        UnendingResolve = Spell(104773, false, false, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddPresetOption("TargetAttack");
        module.AddPresetOption("BossCD");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Shadow Lock/Spell Lock to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddSection("General Settings", "Demons Management", "Green");
        module.AddNewOption("General Settings", "Demon Manager", 230, true, {2, "Doomguard", "Felguard", "Felhunter", "Imp", "Infernal", "Succubus", "Voidwalker"}, nil, "Enable pet management."..C.TOOLTIP_VALUE.."Choose demon to use.")
        module.AddNewOption("General Settings", "Health Funnel", 220, true, {35, 1, 100, 5}, nil, "Use Health Funnel to heal our demon."..C.TOOLTIP_VALUE.."Health threshold.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Dark Glare", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Dark Glare."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Doomguard", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Doomguard."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Grimoire Of Service", 233, true, {1, "Always", "Cooldown Only"}, {2, "Felguard", "Felhunter", "Imp", "Succubus", "Voidwalker"}, "Enable Grimoire of Service."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Choose demon to use.")
        module.AddNewOption("Offensive Settings", "Infernal", 230, false, {2, "Always", "Cooldown Only"}, nil, "Use Infernal."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Soul Harvest", 232, true, {1, "Always", "Cooldown Only"}, {1, 0, 3, 1}, "Use Soul Harvest."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Only use when we have this amount of Soul Shards or less.");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.AddPresetOption("Trinket");
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Call Dreadstalkers", 210, true, nil, nil, "Use Call Dreadstalkers.");
        module.AddNewOption("Offensive Settings", "Demonwrath", 232, true, {1, "Always", "While Moving"}, {6, 1, 12, 1}, "Use Demonwrath."..C.TOOLTIP_VALUE.."Amount of demons needed to use.");
        module.AddNewOption("Offensive Settings", "Felstorm", 232, true, {1, "Always", "Cooldown Only"}, {1, 1, 5, 1}, "Use Felstorm."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be in range to use.");
        module.AddNewOption("Offensive Settings", "Hand Of Gul'dan", 220, true, {3, 1, 4, 1}, nil, "Use Hand Of Gul'dan."..C.TOOLTIP_VALUE.."How many Soul Shard we want to have before using.");
        module.AddNewOption("Offensive Settings", "Implosion", 222, true, {3, 1, 10, 1}, {8, 1, 10, 1}, "Use Implosion."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be in range of the target to use before Imps disappear."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be in range of the target to use anytime as soon as there are imps.");
        module.AddNewOption("Offensive Settings", "Thal'kiel's Consumption", 220, true, {6, 1, 12, 1}, nil, "Use Thal'kiel's Consumption."..C.TOOLTIP_VALUE.."Amount of demons needed to use.");
        module.AddSection("Offensive Settings", "Multi-Dots", "Green");
        module.AddNewOption("Offensive Settings", "Doom", 222, false, { 6, 1, 10, 1 }, { 5, 0, 25, 0.1 }, "Multi-Dot Doom Cycle. \n\n|cFF0088FFValue 1:|r Number of dots to apply. \n\n|cFF0088FFValue 2:|r Minimum health (in million) to apply.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Create Healthstones", 210, true, nil, nil, "Will create you a new healthstone if you have none in your bags and are out of combat.");
        module.AddPresetOption("HealingItem");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Dark Pact", 220, true, {40, 1, 100, 1}, nil, "Use Dark Bargain."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Drain Life", 220, true, {20, 1, 75, 1}, nil, "Use Drain Life."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Mortal Coil", 220, true, {50, 1, 100, 1}, nil, "Use Mortal Coil."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Unending Resolve", 220, true, {40, 1, 100, 1}, nil, "Use Dark Unending Resolve."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        module.AddOutput("Dreadstalkers / Imps:");
        module.SetOutput("Dreadstalkers / Imps:", "0 / 0");
        function Player:DemonsCount()
            return module.TotalDreadStalkers + module.TotalImps;
        end
        function Player:ImpsCount()
            return module.TotalImps;
        end

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [CallDreadstalkers:ID()] = "Call Dreadstalkers",
            [Demonbolt:ID()] = "Demonbolt",
            [DemonicEmpowerment:ID()] = "Demonic Empowerment",
            [HandOfGuldan:ID()] = "Hand of Gul'dan",
            [ShadowBolt:ID()] = "Shadow Bolt"
        };
    end
    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end
        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        local OpenerSpell = not GrimoreOfSupremacy:Exists() and module.IsOptionEnabled("Doomguard") and GuardianDoomguard:Cooldown() == 0 and GuardianDoomguard or Demonbolt:Exists() and Demonbolt or ShadowBolt;
        -- 2) Potion
        if module.IsOptionEnabled("Pre-Pull BossMod") and not Potion and module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and Player:IsWithinCastRange(Target, ShadowBolt) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + OpenerSpell:TravelTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) then
            if Player:Potion("Intellect", Potion) then Potion = true; end
        end
        -- 3) Doomguard/Shadowbolt/Demonbolt
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + OpenerSpell:TravelTime() and Target:CanCast(OpenerSpell) then
            Target:Cast(OpenerSpell);
            return;
        end
        -- 1) Demonic Empowerment
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + OpenerSpell:TravelTime() + DemonicEmpowerment:CastTime() and Player:CanCast(DemonicEmpowerment) then
            Player:Cast(DemonicEmpowerment);
            return;
        end
    end

    function Rotation:Interrupts ()
        local PetInterrupt = (SpellLock:PetKnown() and SpellLock) or (ShadowLock:PetKnown() and ShadowLock) or nil;
        if PetInterrupt then
            Player:UseInterrupt(PetInterrupt, ArcaneTorrent, true);
        end
    end

    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(HandOfGuldan, true) or Unit.Target;
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Mortal Coil
        if MortalCoil:Exists() and module.IsOptionEnabled("Mortal Coil") and Target:Exists() and Target:CanCast(MortalCoil) and Player:HealthPercentage() <= module.GetOptionValue("Mortal Coil") then
            Target:Cast(MortalCoil);
        end
        -- Dark Pact
        if DarkPact:Exists() and module.IsOptionEnabled("Dark Pact") and Player:CanCast(DarkPact) and Player:HealthPercentage() <= module.GetOptionValue("Dark Pact") then
            Player:Cast(DarkPact);
            return;
        end
        -- Unending Resolve
        if UnendingResolve:Exists() and module.IsOptionEnabled("Unending Resolve") and Player:CanCast(UnendingResolve) and Player:HealthPercentage() <= module.GetOptionValue("Unending Resolve") then
            Player:Cast(UnendingResolve);
            return;
        end
        -- Drain Life
        if DrainLife:Exists() and module.IsOptionEnabled("Drain Life") then
            if Player:HealthPercentage() < module.GetOptionValue("Drain Life") and Target:CanCast(DrainLife) then
                Target:Cast(DrainLife);
                return;
            end
            if Player:Channeling(DrainLife) and Player:HealthPercentage() > module.GetOptionValue("Drain Life") + 15 then
                module.Bug("Stop Chanelling Drain Life as Health threshold was reach.")
                SpellStopCasting();
            end
            if Player:Channeling(DrainLife) then
                return;
            end
        end
    end

    local function PetsManager ()
        -- Resurrect Pet
        if not Player:IsMoving() and module.IsOptionEnabled("Demon Manager") and (not PlayerPet:Exists() or PlayerPet:IsDeadOrGhost()) and Player:SoulShards() >= 1 then
            local SelectedPet = module.GetOptionValue("Demon Manager");
            local SelectedPetSpell = SelectedPet == "Doomguard" and GrimoreOfSupremacy:Exists() and SummonDoomguard or SelectedPet == "Felhunter" and SummonFelhunter:Exists() and SummonFelhunter or SelectedPet == "Imp" and SummonImp:Exists() and SummonImp or SelectedPet == "Infernal" and GrimoreOfService:Exists() and SummonInfernal or SelectedPet == "Succubus" and SummonSuccubus:Exists() and SummonSuccubus or SelectedPet == "Voidwalker" and SummonVoidwalker:Exists() and SummonVoidwalker or SummonFelguard;
            if module.GetTime() - PetTimer >= 1 and Player:CanCast(SelectedPetSpell) then
                Player:Cast(SelectedPetSpell);
                PetTimer = module.GetTime() + 2.5;
            end
        end
        -- Health Funnel
        if module.IsOptionEnabled("Health Funnel") and PlayerPet:Exists() and not PlayerPet:IsDeadOrGhost() and Player:Standing() > 0.25 and PlayerPet:HealthPercentage() < module.GetOptionValue("Health Funnel") and Player:CanCast(HealthFunnel) then
            Player:Cast(HealthFunnel);
            return;
        end
    end

    local function ServicePet ()
        local SelectedGrimoire = module.GetSecondOptionValue("Grimoire Of Service");
        local SelectedGrimoireSpell = SelectedGrimoire == "Felguard" and GrimoreOfFelguard or SelectedGrimoire == "Felhunter" and GrimoreOfFelHunter or SelectedGrimoire == "Imp" and GrimoreOfImp or SelectedGrimoire == "Succubus" and GrimoreOfSuccubus or SelectedGrimoire == "Voidwalker" and GrimoreOfVoid;
        if Target:CanCast(SelectedGrimoireSpell) then
            Target:Cast(SelectedGrimoireSpell);
            return;
        end
    end

    function Rotation:Combat ()
        -- Combat Res Tanks
        MainTank = Unit.MainTank();
        OffTank = Unit.OffTank();
        if MainTank and MainTank:Exists() and not MainTank:IsDeadOrGhost() then MainTankResDelay = nil; end
        if OffTank and OffTank:Exists() and not OffTank:IsDeadOrGhost() then OffTankResDelay = nil; end
        if module.IsOptionEnabled("Instant Soulstone Tank") then
            if MainTank and MainTank:Exists() and MainTank:IsDeadOrGhost() and MainTank:IsPlayer() and MainTank:CanCast(Soulstone) then
                if not MainTankResDelay then MainTankResDelay = module.GetTime(); end
                if module.GetTime()-MainTankResDelay >= module.GetOptionValue("Instant Soulstone Tank") then
                    MainTankResDelay = nil;
                    MainTank:Cast(Soulstone);
                    return;
                end
            elseif OffTank and OffTank:Exists() and OffTank:IsDeadOrGhost() and OffTank:IsPlayer() and OffTank:CanCast(Soulstone) then
                if not OffTankResDelay then OffTankResDelay = module.GetTime(); end
                if module.GetTime()-OffTankResDelay >= module.GetOptionValue("Instant Soulstone Tank") then
                    OffTankResDelay = nil;
                    OffTank:Cast(Soulstone);
                    return;
                end
            end
        end
        if module.IsOptionEnabled("Soulstone") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and Target:IsPlayer() and Target:CanCast(Soulstone) then
            Target:Cast(Soulstone);
            return;
        end

        PetsManager();

        if Target:Exists() and Player:CanAttack(Target) then

            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                Enemies_40y = Player:EnemiesWithinDistance(40);
                Enemies_8y = Target:EnemiesWithinDistance(8, true);
                FelstormEnemies = module.IsOptionEnabled("Felstorm") and #PlayerPet:EnemiesWithinDistance(8, true) or 0;
                NumEnemies = #Enemies_8y;
                DoomUnit = Unit.DotCycle(Enemies_40y, Doom, Doom, 0, "Doom");
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- Shadowflame - Clip
            if Shadowflame:Exists() and Target:Debuff(Shadowflame) and (Target:DebuffRemains(Shadowflame) < 2.5 or Target:DebuffCount(Shadowflame) >= 2) and Target:CanCast(Shadowflame) then
                Target:Cast(Shadowflame);
                return;
            end

            if Player:Channeling(Demonwrath) then
                return;
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, HandOfGuldan) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Felstorm/Wrathstorm is in the Short Cooldowns Category and react with the "Felstorm/Wrathstorm" option.
                if PlayerPet:Exists() and module.IsOptionEnabled("Felstorm") and (module.CooldownsAllowed() or module.GetOptionValue("Felstorm") == "Always") and FelstormEnemies >= module.GetSecondOptionValue("Felstorm") and Target:PetCanCast(Felstorm) then
                    Target:Cast(Felstorm);
                end
                -- Grimoire Of Service
                if GrimoreOfService:Exists() and module.IsOptionEnabled("Grimoire Of Service") and (module.CooldownsAllowed() or module.GetOptionValue("Grimoire Of Service") == "Always") and Target:CanCast(GrimoreOfImp) then
                    ServicePet();
                end
                -- Dark Glare
                if SummonDarkGlare:Exists() and Player:DemonsCount() >= 4 and module.IsOptionEnabled("Dark Glare") and (module.CooldownsAllowed() or module.GetOptionValue("Dark Glare") == "Always") and Player:CanCast(SummonDarkGlare) then
                    Player:Cast(SummonDarkGlare);
                    return;
                end
                -- Doomguard
                if not GrimoreOfSupremacy:Exists() and GuardianDoomguard:Exists() and module.IsOptionEnabled("Doomguard") and (module.CooldownsAllowed() or module.GetOptionValue("Doomguard") == "Always") and Target:CanCast(GuardianDoomguard) then
                    Target:Cast(GuardianDoomguard);
                    return;
                end
                -- Infernal
                if not GrimoreOfSupremacy:Exists() and GuardianInfernal:Exists() and module.IsOptionEnabled("Infernal") and (module.CooldownsAllowed() or module.GetOptionValue("Infernal") == "Always") and Target:CanCast(GuardianInfernal) then
                    Target:Cast(GuardianInfernal);
                    return;
                end
                -- Soul Harvest
                if SoulHarvest:Exists() and module.IsOptionEnabled("Soul Harvest") and (module.CooldownsAllowed() or module.GetOptionValue("Soul Harvest") == "Always") and Player:SoulShards() <= module.GetSecondOptionValue("Soul Harvest") and Player:CanCast(SoulHarvest) then
                    Player:Cast(SoulHarvest);
                    return;
                end
            end
            -- Rotation
            -- Implosion
            if Implosion:Exists() and module.IsOptionEnabled("Implosion") and ImplosionReady and ((#Enemies_8y >= module.GetOptionValue("Implosion") and ImplosionReady < module.GetTime()) or #Enemies_8y >= module.GetSecondOptionValue("Implosion")) and Target:CanCast(Implosion) then
                Target:Cast(Implosion);
                ImplosionReady = nil;
                return;
            end
            -- Call Dreadstalkers
            if CallDreadstalkers:Exists() and module.IsOptionEnabled("Call Dreadstalkers") and (Player:SoulShards() >= 2 or Player:Buff(DemonicCalling)) and Target:CanCast(CallDreadstalkers) then
                Target:Cast(CallDreadstalkers);
                CallDreadstalkers.LastCastTime = module.GetTime();
                return;
            end
            --Hand Of Gul'Dan
            if HandOfGuldan:Exists() and not InstantShadowboltSwitch and module.IsOptionEnabled("Hand Of Gul'dan") and Player:SoulShards() >= module.GetOptionValue("Hand Of Gul'dan") and HandOfGuldan:TimeSinceCast() > 1 and Target:CanCast(HandOfGuldan) then
                Target:Cast(HandOfGuldan);
                DemonicEmpowermentSwitch = true;
                HandOfGuldan.LastCastTime = module.GetTime();
                return;
            end
            -- Demonic Empowerment
            if DemonicEmpowerment:Exists() and (Player:DemonsCount() >= 3 or DemonicEmpowermentSwitch) and (not SummonDarkGlare:Exists() or SummonDarkGlare:Cooldown() > 8) and (PlayerPet:BuffRemains(DemonicEmpowerment) < 3 or DemonicEmpowermentSwitch) and Player:CanCast(DemonicEmpowerment) then
                Player:Cast(DemonicEmpowerment);
                DemonicEmpowermentSwitch = false;
                InstantShadowboltSwitch = true;
                DemonicEmpowerment.LastCastTime = module.GetTime();
                return;
            end
            -- Thalkiels Consumption
            if ThalkielsConsumption:Exists() and module.IsOptionEnabled("Thal'kiel's Consumption") and Player:DemonsCount() >= module.GetOptionValue("Thal'kiel's Consumption") and Target:CanCast(ThalkielsConsumption, true) then
                Target:Cast(ThalkielsConsumption);
                return;
            end
            -- Shadowflame - Apply
            if Shadowflame:Exists() and (Shadowflame:Charges() == 2 or (Shadowflame:Charges() == 1 and Shadowflame:Recharge() < 1)) and Target:CanCast(Shadowflame) then
                Target:Cast(Shadowflame);
                return;
            end
            -- Doom
            if module.IsOptionEnabled("Doom") then
                if not Target:Debuff(Doom) and Target:CanCast(Doom) and Target:Health() >= module.GetSecondOptionValue("Doom")*1000000 then
                    module.Bug("Doom - Target");
                    Target:Cast(Doom);
                    return;
                end
                if DoomUnit then
                    module.Bug("Doom on " .. DoomUnit:GUID());
                    DoomUnit:Cast(Doom);
                    return;
                end
            end
            -- Demonwrath
            if Demonwrath:Exists() and module.IsOptionEnabled("Demonwrath") and (Player:IsMoving() or module.GetOptionValue("Demonwrath") == "Always") and Player:DemonsCount() >= module.GetSecondOptionValue("Demonwrath") and Player:CanCast(Demonwrath, true) then
                Player:Cast(Demonwrath);
                return;
            end
            -- Life Tap
            if Player:PowerPercentage() <= 40 and Player:HealthPercentage() >= 60 and Player:CanCast(LifeTap) then
                Player:Cast(LifeTap);
                return;
            end
            -- Player Moving, Life Tap or Demonwrath
            if Player:IsMoving() then
                -- Shadowy Inspiration
                if Player:Buff(ShadowyInspiration) then
                    -- Demonbolt
                    if Demonbolt:Exists() and Target:CanCast(DemonboltInstant) then
                        Target:Cast(DemonboltInstant);
                        return;
                    end
                    -- Shadow Bolt
                    if Target:CanCast(ShadowBoltInstant) then
                        Target:Cast(ShadowBoltInstant);
                        return;
                    end
                end
                -- Life Tap
                if Player:PowerPercentage() < 70 and Player:HealthPercentage() >= 60 and Player:CanCast(LifeTap) then
                    Player:Cast(LifeTap);
                    return;
                end
                -- Demonwrath
                if Demonwrath:Exists() and module.IsOptionEnabled("Demonwrath") and Player:DemonsCount() >= 2 and Player:CanCast(Demonwrath, true) then
                    Player:Cast(Demonwrath);
                    return;
                end
            end
            -- Demonbolt
            if Demonbolt:Exists() and Target:CanCast(Demonbolt) then
                InstantShadowboltSwitch = false;
                Target:Cast(Demonbolt);
                return;
            end
            -- Shadow Bolt
            if Target:CanCast(ShadowBolt) then
                InstantShadowboltSwitch = false;
                Target:Cast(ShadowBolt);
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        PetsManager();
        -- Create Healthstones
        if module.IsOptionEnabled("Create Healthstones") and Player:Standing() > 0.25 then
            if not Healthstone:InStock() and CreateHealthstone:TimeSinceCast() >= module.GetTime() + 5 and Player:CanCast(CreateHealthstone) then
                Player:Cast(CreateHealthstone);
                CreateHealthstone.LastCastTime = module.GetTime();
                return;
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Destruction Warlock
    local Rotation = {};
    module.SetRotation("_"..267, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local MainTank, OffTank, MainTankResDelay, OffTankResDelay = nil, nil, nil, nil; -- Battle Resurection timers
    local Enemies_40y, TargetEnemies_10y, NumEnemies, ImmolateUnit = {}, {}, 0, nil; -- Enemies Table
    -- Havoc Cycling
    local BestUnit, BestUnitHealth, ThisUnit, ThisUnitHealth;
    local HavocUnit, HavocTime = nil, 0;
    -- Pet Manager
    local PetTimer, SacrificeRandomDelay = 0, nil;


    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicIntellect = Item(109218, false, false, true);
        DraenicIntellectBuff = Spell(156426);
        HealingTonic = Item(109223, false, false, true);
        Healthstone = Item(5512, false, false, true);

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(33702, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant, resurrect)
        BackDraft = Spell(196406);
        BackDraftBuff = Spell(117828);
        Cataclysm = Spell(152108, false, true, true);
        ChaosBolt = Spell(116858, true, true, false);
        ChannelDemonfire = Spell(196447, true, true, false);
        Conflagrate = Spell(17962, true, true, true);
        CreateHealthstone = Spell(6201, false, false, false);
        DarkPact = Spell(108416, false, false, true);
        DimensionalRift = Spell(196586, false, true, true);
        DrainLife = Spell(689, true, true, false);
        Eradication = Spell(196412);
        EradicationDebuff = Spell(196414);
        GuardianDoomguard = Spell(18540, false, true, true);
        GuardianInfernal = Spell(1122, false, true, true);
        GrimoreOfSacrifice = Spell(108503, false, false, true);
        GrimoreOfSacrificeBuff = Spell(196099);
        GrimoreOfService = Spell(108501, false, false, true);
        GrimoreOfSupremacy = Spell(152107, false, true, true);
        GrimoreOfImp = Spell(111859, false, true, true);
        GrimoreOfVoid = Spell(111895, false, true, true);
        GrimoreOfSuccubus = Spell(111896, false, true, true);
        GrimoreOfFelHunter = Spell(111897, false, true, true);
        Havoc = Spell(80240, false, true, true);
        HealthFunnel = Spell(755, false, false, false);
        Immolate = Spell(348, true, true, true);
        ImmolateDebuff = Spell(157736);
        Incinerate = Spell(29722, true, true, true);
        LifeTap = Spell(1454, false, false, true);
        ManaTap = Spell(196104, false, false, true);
        MortalCoil = Spell(6789, false, true, true);
        RainOfFire = Spell(5740, false, true, false);
        RoaringBlaze = Spell(205184);
        Shadowburn = Spell(17877, true, true, true);
        ShadowLock = Spell(171138, true, true, true);
        SoulHarvest = Spell(196098, false, false, true);
        Soulstone = Spell(20707, false, false, false, true);
        SpellLock = Spell(19647, false, true, true);
        SummonDoomguard = Spell(157757, false, false, false);
        SummonFelhunter = Spell(691, false, false, false);
        SummonImp = Spell(688, false, false, false);
        SummonInfernal = Spell(157898, false, false, false);
        SummonSuccubus = Spell(712, false, false, false);
        SummonVoidwalker = Spell(697, false, false, false);
        UnendingBreath = Spell(5697, false, false, true);
        UnendingResolve = Spell(104773, false, false, true);
        WreakHavoc = Spell(196410);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddPresetOption("TargetAttack");
        module.AddPresetOption("BossCD");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Shadow Lock/Spell Lock to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddSection("General Settings", "Demons Management", "Green");
        module.AddNewOption("General Settings", "Demon Manager", 230, true, {3, "Doomguard", "Felhunter", "Imp", "Infernal", "Succubus", "Voidwalker"}, nil, "Enable pet management."..C.TOOLTIP_VALUE.."Choose demon to use.")
        module.AddNewOption("General Settings", "Health Funnel", 220, true, {25, 1, 100, 5}, nil, "Use Health Funnel to heal our demon."..C.TOOLTIP_VALUE.."Health threshold.");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pull BossMod", 232, true, { 1, "Boss Only", "Always", "Never" }, { 0.2, -1, 3, 0.1 }, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Offensive Settings", "Dimensional Rift", 232, true, {2, "Always", "Cooldown Only"}, {2, 1, 3, 1}, "Use Dimensional Rift."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."How many charges should we keep to use with the Cooldowns."..C.TOOLTIP_HINT("Set it to Cooldowns Only with charges at 2 to always keep the third charge recharging."));
        module.AddNewOption("Offensive Settings", "Doomguard", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Doomguard."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Grimoire Of Service", 233, true, {1, "Always", "Cooldown Only"}, {2, "Felhunter", "Imp", "Succubus", "Voidwalker"}, "Enable Grimoire of Service."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Choose demon to use.")
        module.AddNewOption("Offensive Settings", "Grimoire Of Sacrifice", 210, true, nil, nil, "Automatic Grimoire Of Sacrifice usage.");
        module.AddNewOption("Offensive Settings", "Infernal", 230, false, {2, "Always", "Cooldown Only"}, nil, "Use Infernal."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Mana Tap", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Mana Tap."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Soul Harvest", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Soul Harvest."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.AddPresetOption("Trinket");
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Cataclysm", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {1, 1, 10, 1}, "Use Cataclysm." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Havoc", 232, true, {1, "Auto", "Focus"}, {3, 0, 25, 0.1}, "Use Havoc."..C.TOOLTIP_VALUE_1.."On which unit should we apply Havoc."..C.TOOLTIP_SUBVALUE("Auto", true).."Use on the unit with the most health."..C.TOOLTIP_SUBVALUE("Focus", true).."Use on the Focus unit or the unit with the most health."..C.TOOLTIP_SUBVALUE("Target", true).."Use on the Target."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Rain Of Fire", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {6, 1, 10, 1}, "Use Rain Of Fire." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Shadowburn Filler", 210, true, nil, nil, "Use Shadowburn as Low Priority while moving.");
        module.AddNewOption("Offensive Settings", "Shadowburn Sniping", 210, true, nil, nil, "Attempt to get Shadowburn on adds that will die in the next 5 seconds to get back Soul Shards.");
        module.AddSection("Offensive Settings", "Multi-Dots", "Green");
        module.AddNewOption("Offensive Settings", "Multi-Dot Immolate", 222, true, {6, 1, 10, 1}, {3, 0, 25, 0.1}, "Multi-Dot Immolate Cycle."..C.TOOLTIP_VALUE_1.."Amount of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Create Healthstones", 210, true, nil, nil, "Will create you a new healthstone if you have none in your bags and are out of combat.");
        module.AddPresetOption("HealingItem");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Dark Pact", 220, true, {40, 1, 100, 1}, nil, "Use Dark Bargain."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Drain Life", 220, true, {20, 1, 75, 1}, nil, "Use Drain Life."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Mortal Coil", 220, true, {50, 1, 100, 1}, nil, "Use Mortal Coil."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Unending Resolve", 220, true, {40, 1, 100, 1}, nil, "Use Dark Unending Resolve."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();

        -- New Improved Spell Casting Logic
        module.ISCL = {
            [ChaosBolt:ID()] = "Chaos Bolt",
            [Immolate:ID()] = "Immolate"
        };
    end
    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Channeling(ChannelDemonfire) then
            return;
        end

        -- Reset the target for the Auto Re-Target Option
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 and module.GlobalCooldown() then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            if Player:Channeling(DrainLife) then
                return;
            end
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention and Player:IsReadyNoChannel() then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    function Rotation:Opening ()
        local OpenerSpell = not GrimoreOfSupremacy:Exists() and module.IsOptionEnabled("Doomguard") and GuardianDoomguard:Cooldown() == 0 and GuardianDoomguard or Immolate;
        -- 2) Potion
        if module.IsOptionEnabled("Pre-Pull BossMod") and not Potion and module.GetOptionValue("Pre-Pull BossMod") ~= "Never" and (module.GetOptionValue("Pre-Pull BossMod") == "Always" or Target:IsBoss()) and Player:IsWithinCastRange(Target, Immolate) and (BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + OpenerSpell:TravelTime() + 0.1 or (not Target:IsDummy() and Target:IsInCombat() and not Player:IsInCombat())) then
            if Player:Potion("Intellect", Potion) then Potion = true; end
        end
        -- 3) Doomguard/Immolate
        if BMPullTime() < module.GetSecondOptionValue("Pre-Pull BossMod") + OpenerSpell:CastTime() + OpenerSpell:TravelTime() and Target:CanCast(OpenerSpell) then
            Target:Cast(OpenerSpell);
            return;
        end
    end

    function Rotation:Interrupts ()
        local PetInterrupt = (SpellLock:PetKnown() and SpellLock) or (ShadowLock:PetKnown() and ShadowLock) or nil;
        if PetInterrupt then
            Player:UseInterrupt(PetInterrupt, ArcaneTorrent, true);
        end
    end

    function Rotation:OffGCDAbilities ()
        -- Enemies Check
        if RefreshEnemies < module.GetTime() then
            Enemies_40y = Player:EnemiesWithinDistance(40);
        end

        -- Find Best Target
        if HavocUnit and HavocTime > module.GetTime() and HavocUnit:Exists() and HavocUnit:GUID() == Target:GUID() then
            BestUnit, BestUnitHealth, BestTarget = nil, 0, nil;
            for i = 1, #Enemies_40y do
                ThisUnit, ThisUnitHealth = Enemies_40y[i], Enemies_40y[i]:Health();
                if not ThisUnit:Debuff(Havoc) and ThisUnitHealth > BestUnitHealth and ThisUnit:CanCast(Incinerate) then
                    BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                end
            end
            if BestUnit then
                BestTarget = BestUnit;
            end
        end
        -- Auto Target
        Target = Player:ReTarget(Immolate, true) or Unit.Target;
    end

    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Mortal Coil
        if MortalCoil:Exists() and module.IsOptionEnabled("Mortal Coil") and Target:Exists() and Target:CanCast(MortalCoil) and Player:HealthPercentage() <= module.GetOptionValue("Mortal Coil") then
            Target:Cast(MortalCoil);
        end
        -- Dark Pact
        if DarkPact:Exists() and module.IsOptionEnabled("Dark Pact") and Player:CanCast(DarkPact) and Player:HealthPercentage() <= module.GetOptionValue("Dark Pact") then
            Player:Cast(DarkPact);
            return;
        end
        -- Unending Resolve
        if UnendingResolve:Exists() and module.IsOptionEnabled("Unending Resolve") and Player:CanCast(UnendingResolve) and Player:HealthPercentage() <= module.GetOptionValue("Unending Resolve") then
            Player:Cast(UnendingResolve);
            return;
        end
        -- Drain Life
        if DrainLife:Exists() and module.IsOptionEnabled("Drain Life") then
            if Player:Channeling(DrainLife) and Player:HealthPercentage() > module.GetOptionValue("Drain Life") + 15 then
                module.Bug("Stop Chanelling Drain Life as Health threshold was reach.")
                SpellStopCasting();
            end
            if not Player:Channeling(DrainLife) and Player:HealthPercentage() < module.GetOptionValue("Drain Life") and Target:CanCast(DrainLife) then
                Target:Cast(DrainLife);
                return;
            end
        end
    end

    -- Havoc
    local function HavocHandler (HavocMode)
        if HavocMode ~= "Wreak Havoc" or WreakHavoc:Exists() then
            if Havoc:Exists() and module.IsOptionEnabled("Havoc") and #Enemies_40y >= 2 and not (HavocUnit and HavocTime > module.GetTime() and HavocUnit:Exists()) then
                HavocThreshold = module.GetSecondOptionValue("Havoc")*1000000;
                if module.GetOptionValue("Havoc") == "Focus" and Focus:Exists() and Focus:Health() >= HavocThreshold and Focus:CanCast(Havoc) then
                    HavocUnit, HavocTime = Focus, WreakHavoc:Exists() and module.GetTime() + 20 or module.GetTime() + 8;
                    Focus:Cast(Havoc);
                    return;
                else
                    BestUnit, BestUnitHealth = nil, 0;
                    for i = 1, #Enemies_40y do
                        ThisUnit, ThisUnitHealth = Enemies_40y[i], Enemies_40y[i]:Health();
                        if ThisUnitHealth >= HavocThreshold and ThisUnitHealth > BestUnitHealth and ThisUnit:CanCast(Havoc) then
                            BestUnit, BestUnitHealth = ThisUnit, ThisUnitHealth;
                        end
                    end
                    if BestUnit then
                        HavocUnit, HavocTime = BestUnit, WreakHavoc:Exists() and module.GetTime() + 20 - ChaosBolt:CastTime() or module.GetTime() + 8;
                        BestUnit:Cast(Havoc);
                    end
                end
            end
        end
    end

    local function PetsManager ()
        -- Grimoire of Sacrifice with random delay
        if module.IsOptionEnabled("Grimoire Of Sacrifice") and GrimoreOfSacrifice:Exists() and not Player:Buff(GrimoreOfSacrificeBuff) then
            if UnitExists("PlayerPet") and Player:CanCast(GrimoreOfSacrifice) then
                if SacrificeRandomDelay then
                    if SacrificeRandomDelay < module.GetTime() then
                        Player:Cast(GrimoreOfSacrifice);
                        module.PetTimer = module.GetTime() + 4;
                        SacrificeRandomDelay = nil;
                        return;
                    end
                else
                    SacrificeRandomDelay = module.GetTime() + math.random(2, 6);
                end
            end
        end
        if not (GrimoreOfSacrifice:Exists() and Player:Buff(GrimoreOfSacrificeBuff)) then
            -- Resurrect Pet
            if not Player:IsMoving() and module.IsOptionEnabled("Demon Manager") and (not PlayerPet:Exists() or PlayerPet:IsDeadOrGhost()) and Player:SoulShards() >= 1 then
                local SelectedPet = module.GetOptionValue("Demon Manager");
                local SelectedPetSpell = SelectedPet == "Doomguard" and GrimoreOfSupremacy:Exists() and SummonDoomguard or SelectedPet == "Felhunter" and SummonFelhunter:Exists() and SummonFelhunter or SelectedPet == "Infernal" and GrimoreOfService:Exists() and SummonInfernal or SelectedPet == "Succubus" and SummonSuccubus:Exists() and SummonSuccubus or SelectedPet == "Voidwalker" and SummonVoidwalker:Exists() and SummonVoidwalker or SummonImp;
                if module.GetTime() - PetTimer >= 1 and Player:CanCast(SelectedPetSpell) then
                    Player:Cast(SelectedPetSpell);
                    PetTimer = module.GetTime() + 2.5;
                end
            end
            -- Health Funnel
            if module.IsOptionEnabled("Health Funnel") and PlayerPet:Exists() and not PlayerPet:IsDeadOrGhost() and Player:Standing() > 0.25 and PlayerPet:HealthPercentage() < module.GetOptionValue("Health Funnel") and Player:CanCast(HealthFunnel) then
                Player:Cast(HealthFunnel);
                return;
            end
        end
    end

    local function ServicePet ()
        local SelectedGrimoire = module.GetSecondOptionValue("Grimoire Of Service");
        local SelectedGrimoireSpell = SelectedGrimoire == "Felhunter" and GrimoreOfFelHunter or SelectedGrimoire == "Imp" and GrimoreOfImp or SelectedGrimoire == "Succubus" and GrimoreOfSuccubus or SelectedGrimoire == "Voidwalker" and GrimoreOfVoid;
        if Target:CanCast(SelectedGrimoireSpell) then
            Target:Cast(SelectedGrimoireSpell);
            return;
        end
    end

    function Rotation:Combat ()
        -- Prevent Early Chaos Bolt recasts but allow to have Havoc during Chaos Bolt.
        if Player:Casting(ChaosBolt) then
            return;
        end
        -- Combat Res Tanks
        MainTank = Unit.MainTank();
        OffTank = Unit.OffTank();
        if MainTank and MainTank:Exists() and not MainTank:IsDeadOrGhost() then MainTankResDelay = nil; end
        if OffTank and OffTank:Exists() and not OffTank:IsDeadOrGhost() then OffTankResDelay = nil; end
        if module.IsOptionEnabled("Instant Soulstone Tank") then
            if MainTank and MainTank:Exists() and MainTank:IsDeadOrGhost() and MainTank:IsPlayer() and MainTank:CanCast(Soulstone) then
                if not MainTankResDelay then MainTankResDelay = module.GetTime(); end
                if module.GetTime()-MainTankResDelay >= module.GetOptionValue("Instant Soulstone Tank") then
                    MainTankResDelay = nil;
                    MainTank:Cast(Soulstone);
                    return;
                end
            elseif OffTank and OffTank:Exists() and OffTank:IsDeadOrGhost() and OffTank:IsPlayer() and OffTank:CanCast(Soulstone) then
                if not OffTankResDelay then OffTankResDelay = module.GetTime(); end
                if module.GetTime()-OffTankResDelay >= module.GetOptionValue("Instant Soulstone Tank") then
                    OffTankResDelay = nil;
                    OffTank:Cast(Soulstone);
                    return;
                end
            end
        end
        if module.IsOptionEnabled("Soulstone") and Target:Exists() and Target:IsDeadOrGhost() and not Player:IsMoving() and Target:IsPlayer() and Target:CanCast(Soulstone) then
            Target:Cast(Soulstone);
            return;
        end

        PetsManager();

        if Target:Exists() and Player:CanAttack(Target) then

            -- Enemies Check
            if RefreshEnemies < module.GetTime() then
                TargetEnemies_10y = Target:EnemiesWithinDistance(10, true);
                NumEnemies = #TargetEnemies_10y;
                ImmolateUnit = Unit.DotCycle(Enemies_40y, Immolate, ImmolateDebuff, 18, "Multi-Dot Immolate");
                RefreshEnemies = module.GetTime() + 0.25;
            end

            -- Shadowburn Sniping
            if Shadowburn:Exists() and module.IsOptionEnabled("Shadowburn Sniping") and Player:SoulShards() >= 1 and Player:SoulShards() < 4 then
                for i = 1, #Enemies_40y do
                    ThisUnit = Enemies_40y[i];
                    if not ThisUnit:Debuff(Shadowburn) and ThisUnit:HealthPercentage() < 20 and ThisUnit:CanCast(Shadowburn, true, true) and (ThisUnit:TimeToDie() < 5 or ThisUnit:IsDummy()) then
                        module.Bug("Cancel Cast and Snipe Shadowburn on " .. ThisUnit:Name());
                        SpellStopCasting();
                        ThisUnit:Cast(Shadowburn);
                        return;
                    end
                end
            end

            -- Cooldowns
            if Player:IsWithinCastRange(Target, Immolate) then
                Player:UseTrinkets();
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        CastSpellByID(26297, "player")
                    end
                end
                -- Grimoire Of Service
                if GrimoreOfService:Exists() and module.IsOptionEnabled("Grimoire Of Service") and (module.CooldownsAllowed() or module.GetOptionValue("Grimoire Of Service") == "Always") and Target:CanCast(GrimoreOfImp) then
                    ServicePet();
                end
                -- Doomguard
                if not GrimoreOfSupremacy:Exists() and GuardianDoomguard:Exists() and module.IsOptionEnabled("Doomguard") and (module.CooldownsAllowed() or module.GetOptionValue("Doomguard") == "Always") and Target:CanCast(GuardianDoomguard) then
                    Target:Cast(GuardianDoomguard);
                    return;
                end
                -- Infernal
                if not GrimoreOfSupremacy:Exists() and GuardianInfernal:Exists() and module.IsOptionEnabled("Infernal") and (module.CooldownsAllowed() or module.GetOptionValue("Infernal") == "Always") and Target:CanCast(GuardianInfernal) then
                    Target:Cast(GuardianInfernal);
                    return;
                end
                -- Mana Tap
                if ManaTap:Exists() and module.IsOptionEnabled("Mana Tap") and (module.CooldownsAllowed() or module.GetOptionValue("Mana Tap") == "Always") and Player:BuffRemains(ManaTap) < 3 and Player:CanCast(ManaTap) then
                    Player:Cast(ManaTap);
                    return;
                end
            end
            -- Havoc Rotation
            if not WreakHavoc:Exists() and BestTarget and BestTarget:Exists() and HavocTime > module.GetTime() then
                -- Chaos Bolt
                if Player:SoulShards() >= 2 and HavocTime > module.GetTime() + ChaosBolt:CastTime() and BestTarget:CanCast(ChaosBolt) then
                    BestTarget:Cast(ChaosBolt);
                    return;
                end
                -- Conflagrate
                if HavocTime > module.GetTime() + 0.2 and BestTarget:CanCast(Conflagrate) and (not BackDraft:Exists() or not Player:Buff(BackDraftBuff)) then
                    BestTarget:Cast(Conflagrate);
                    return;
                end
                -- Incinerate
                if HavocTime > module.GetTime() + Incinerate:CastTime() and BestTarget:CanCast(Incinerate) then
                    BestTarget:Cast(Incinerate);
                    return;
                end
            end
            -- Rotation
            if WreakHavoc:Exists() and BestTarget and BestTarget:Exists() and HavocTime > module.GetTime() then
                Target = BestTarget;
            end
            -- Dimensional Rift
            if DimensionalRift:Exists() and module.IsOptionEnabled("Dimensional Rift") and DimensionalRift:Charges() == 3 and (DimensionalRift:Charges() > module.GetSecondOptionValue("Dimensional Rift") or (module.CooldownsAllowed() or module.GetOptionValue("Mana Tap") == "Dimensional Rift")) and Target:CanCast(DimensionalRift) then
                Target:Cast(DimensionalRift);
                return;
            end
            -- Wreak Havoc
            HavocHandler("Wreak Havoc");
            -- Roaring Blaze Conflagrate
            if Conflagrate:Exists() and RoaringBlaze:Exists() and Target:DebuffRemains(ImmolateDebuff) >= 12 and Conflagrate:TimeSinceCast() >= 6 and Target:CanCast(Conflagrate) then
                Conflagrate.LastCastTime = module.GetTime();
                Target:Cast(Conflagrate);
                return;
            end
            -- Rain Of Fire
            if RainOfFire:Exists() and Player:SoulShards() >= 3 and module.IsOptionEnabled("Rain Of Fire") and Target:CanCast(RainOfFire) then
                if Target:CastGroundSpell(RainOfFire, "Rain Of Fire", 8) then return; end
            end
            -- Chaos Bolt
            if ChaosBolt:Exists() and Player:SoulShards() >= 4 and Target:CanCast(ChaosBolt) then
                HavocHandler();
                Target:Cast(ChaosBolt);
                return;
            end
            -- Life Tap
            if LifeTap:Exists() and Player:PowerPercentage() <= 40 and Player:HealthPercentage() >= 60 and Player:CanCast(LifeTap) then
                Player:Cast(LifeTap);
                return;
            end
            -- Cataclysm
            if Cataclysm:Exists() and module.IsOptionEnabled("Cataclysm") and Target:CanCast(Cataclysm) then
                if Target:CastGroundSpell(Cataclysm, "Cataclysm", 8) then return; end
            end
            -- Immolate - Target
            if Immolate:Exists() and Target:DebuffRemains(ImmolateDebuff) < 3 and Target:CanCast(Immolate) then
                Target:Cast(Immolate);
                return;
            end
            -- Immolate - Cycle
            if Immolate:Exists() and module.IsOptionEnabled("Multi-Dot Immolate") and ImmolateUnit and ImmolateUnit:CanCast(Immolate) then
                ImmolateUnit:Cast(Immolate);
                return;
            end
            -- Life Tap
            if LifeTap:Exists() and Player:PowerPercentage() <= 65 and Player:HealthPercentage() >= 60 and Player:CanCast(LifeTap) then
                Player:Cast(LifeTap);
                return;
            end
            -- Soul Harvest
            if SoulHarvest:Exists() and module.IsOptionEnabled("Soul Harvest") and Player:IsWithinCastRange(Target, Immolate) and (module.CooldownsAllowed() or module.GetOptionValue("Soul Harvest") == "Always") and Player:CanCast(SoulHarvest) then
                Player:Cast(SoulHarvest);
                return;
            end
            -- Conflagrate
            if Conflagrate:Exists() and not RoaringBlaze:Exists() and (not BackDraft:Exists() or not Player:Buff(BackDraftBuff)) and Target:CanCast(Conflagrate) then
                Conflagrate.LastCastTime = module.GetTime();
                Target:Cast(Conflagrate);
                return;
            end
            -- Dimensional Rift
            if DimensionalRift:Exists() and module.IsOptionEnabled("Dimensional Rift") and (DimensionalRift:Charges() > module.GetSecondOptionValue("Dimensional Rift") or (module.CooldownsAllowed() or module.GetOptionValue("Mana Tap") == "Dimensional Rift")) and Target:CanCast(DimensionalRift) then
                Target:Cast(DimensionalRift);
                return;
            end
            -- Life Tap
            if LifeTap:Exists() and Player:PowerPercentage() <= 40 and Player:CanCast(LifeTap) then
                Player:Cast(LifeTap);
                return;
            end
            -- Channel Demonfire
            if ChannelDemonfire:Exists() and Target:CanCast(ChannelDemonfire) then
                Target:Cast(ChannelDemonfire);
                return;
            end
            -- Chaos Bolt
            if ChaosBolt:Exists() and Player:SoulShards() >= 3 and (Player:SoulShards() >= 4 or not Eradication:Exists() or ChaosBolt:TimeSinceCast() + ChaosBolt:CastTime() >= 6) and Target:CanCast(ChaosBolt) then
                HavocHandler();
                Target:Cast(ChaosBolt);
                return;
            end
            -- Incinerate
            if Incinerate:Exists() and Target:CanCast(Incinerate) then
                Target:Cast(Incinerate);
                return;
            end
            -- Shadowburn while moving
            if Shadowburn:Exists() and module.IsOptionEnabled("Shadowburn Filler") and Player:IsMoving() and Target:CanCast(Shadowburn) then
                Target:Cast(Shadowburn);
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        PetsManager();
        -- Create Healthstones
        if module.IsOptionEnabled("Create Healthstones") and Player:Standing() > 0.25 then
            if not Healthstone:InStock() and CreateHealthstone:TimeSinceCast() >= module.GetTime() + 5 and Player:CanCast(CreateHealthstone) then
                Player:Cast(CreateHealthstone);
                CreateHealthstone.LastCastTime = module.GetTime();
                return;
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Arms Warrior
    local Rotation = {};
    module.SetRotation("_"..71, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local CleaveCount, Enemies_8y, Enemies_5y, ExecuteUnit, ShockwaveCount, NumEnemies = 0, {}, {}, nil, 0, 0; -- Enemies
    local ShouldDump, RendUnit;
    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicStrength = Item(109219, false, false, true);
        DraenicStrengthBuff = Spell(156428, false, false, true);

        --Racials
        ArcaneTorrent = Spell(69179, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        Avatar = Spell(107574, false, false, true);
        BattleCry = Spell(1719, false, false, true);
        BerserkerRage = Spell(18499, false, false, true);
        Bladestorm = Spell(227847, false, false, true);
        Charge = Spell(100, true, true, true);
        Cleave = Spell(845, true, false, true);
        CleaveBuff = Spell(188923);
        ColossusSmash = Spell(167105, true, true, true);
        ColossusSmashDebuff = Spell(208086);
        CommandingShout = Spell(97462, false, false, true);
        DeadlyCalm = Spell(227266);
        DefensiveStance = Spell(197690, false, false, true); -- Battle = DefensiveStance:Icon() == 132349
        DieByTheSword = Spell(118038, false, false, true);
        Execute = Spell(163201, true, true, true);
        FervorOfBattle = Spell(202316);
        FocusedRage = Spell(207982, false, false, true);
        Hamstring = Spell(1715, true, true, true);
        HeroicThrow = Spell(57755, true, true, true);
        InForTheKill = Spell(215550);
        MortalStrike = Spell(12294, true, true, true);
        Overpower = Spell(7384, true, true, true);
        OverpowerBuff = Spell(60503);
        PreciseStrikes = Spell(209492);
        Pummel = Spell(6552, true, true, true);
        Ravager = Spell(152277, false, true, true);
        Rend = Spell(772, true, true, true);
        Slam = Spell(1464, true, true, true);
        ShatteredDefenses = Spell(209706);
        Shockwave = Spell(46968, true, false, true);
        StoneHeart = Spell(225947); -- Legendary Ring Proc - Free Execute
        StormBolt = Spell(107570, true, true, true);
        VictoryRush = Spell(34428, true, true, true);
        VictoryRushBuff = Spell(32216);
        Warbreaker = Spell(209577, false, false, true);
        Whirlwind = Spell(1680, false, false, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Pummel to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Auto Charge Combat", 220, false, {15, 6.5, 22, 0.5}, nil, "Distance away from the target to auto use charge while in combat");
        module.AddNewOption("General Settings", "Auto Charge Out Of Combat", 220, false, {15, 6.5, 22, 0.5}, nil, "Distance away from the target to auto use charge while not in combat");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 232, true, {1, "Boss Only", "Always", "Never"}, {0.2, 0, 3, 0.1}, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Avatar", 233, true, {2, "Always", "Cooldown Only"}, {2, "Always", "With Bladestorm"}, "Use Avatar."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Use on cooldown."..C.TOOLTIP_SUBVALUE("With Bladestorm", true).."Pair with Bladestorm.");
        module.AddNewOption("Offensive Settings", "Battle Cry", 233, true, {1, "Always", "Cooldown Only"}, {2, "Always", "With Bladestorm"}, "Use Battle Cry."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2..C.TOOLTIP_SUBVALUE("Always", true).."Use on cooldown."..C.TOOLTIP_SUBVALUE("With Bladestorm", true).."Pair with Bladestorm.");
        module.AddNewOption("Offensive Settings", "Berserker Rage", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Berserker Rage."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Bladestorm", 232, true, {1, "Always", "Cooldown Only"}, {2, 1, 10, 1}, "Use Bladestorm."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be in range to use."..C.TOOLTIP_HINT("Only usable without the Ravager talent."));
        module.AddNewOption("Offensive Settings", "Execute", 230, true, {1, "Target Only", "Any Unit"}, nil, "Use Execute on low health Targets."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Target Only", true).."Only use Execute on current Target."..C.TOOLTIP_SUBVALUE("Any Unit", true).."Use Execute on any available unit that is in range.");
        module.AddNewOption("Offensive Settings", "Colossus Smash", 232, true, {1, "Always", "Without Debuff"}, {45, 1, 100, 1}, "Use Colossus Smash"..C.TOOLTIP_VALUE_1.."Choose when you want to use Colossus Smash."..C.TOOLTIP_SUBVALUE("Always").."Use Colossus Smash whenever it is ready."..C.TOOLTIP_SUBVALUE("Without Debuff").."Only use Colossus Smash to apply Colossus Smash debuff on the target."..C.TOOLTIP_VALUE_2.."Minimum Rage to use Colossus Smash.");
        module.AddNewOption("Offensive Settings", "Multi-Dot Rend", 222, false, { 5, 1, 10, 1 }, { 3, 0, 25, 0.1 }, "Multi-Dot Rend Cycle."..C.TOOLTIP_VALUE_1.."Number of dots to apply."..C.TOOLTIP_VALUE_2.."Minimum health (in million) to apply.");
        module.AddNewOption("Offensive Settings", "Ravager", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {1, 1, 10, 1}, "Use Death and Decay." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Shockwave", 220, true, {2, 1, 10, 1}, nil, "Use Shockwave."..C.TOOLTIP_VALUE_1.."Define number of units needed in front of us to use Shockwave.");
        module.AddNewOption("Offensive Settings", "Storm Bolt", 210, true, nil, nil, "Use Storm Bolt as filler.");
        module.AddNewOption("Offensive Settings", "Warbreaker", 220, true, {2, 1, 10, 1}, nil, "Use Warbreaker."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range to use.");
        module.AddNewOption("Offensive Settings", "Whirlwind", 222, true, {2, 1, 10, 1}, {3, 1, 10, 1}, "Use Whirlwind."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be in range to use."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be in range to use as high priority."..C.TOOLTIP_HINT("High Priority rotation will be only using Warbreaker + Bladestorm + Cleave + Whirlwind. Cleave will always be used to empower Whirlwind. The unit Count is frontal as it requires Cleave to be efficient."));

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Defensive Stance", 220, true, {20, 1, 100, 1}, nil, "Use Defensive Stance."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Die By The Sword", 220, true, {30, 1, 100, 1}, nil, "Use Die By The Sword."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Victory Rush", 220, true, {50, 1, 100, 1}, nil, "Use Victory Rush."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() or Player:Buff(Bladestorm) then
            return;
        end

        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Pummel, ArcaneTorrent);
    end


    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Victory Rush
        if VictoryRush:Exists() and Player:Buff(VictoryRushBuff) and module.IsOptionEnabled("Victory Rush") and Player:HealthPercentage() <= module.GetOptionValue("Victory Rush") and Target:CanCast(VictoryRush) then
            Target:Cast(VictoryRush);
            return;
        end
        -- Defensive Items
        Player:UseHealingItem();
        -- Die By The Sword
        if DieByTheSword:Exists() and module.IsOptionEnabled("Die By The Sword") and Player:HealthPercentage() <= module.GetOptionValue("Die By The Sword") and Player:CanCast(DieByTheSword) then
            Player:Cast(DieByTheSword);
        end
        -- Defensive Stance
        if DefensiveStance:Exists() then
            if module.IsOptionEnabled("Defensive Stance") and Player:HealthPercentage() <= module.GetOptionValue("Defensive Stance") and not Player:Buff(DefensiveStance) and Player:CanCast(DefensiveStance) then
                Player:Cast(DefensiveStance);
            end
            if (not module.IsOptionEnabled("Defensive Stance") or Player:HealthPercentage() > module.GetOptionValue("Defensive Stance")) and Player:Buff(DefensiveStance) and Player:CanCast(DefensiveStance) then
                Player:Cast(DefensiveStance);
            end
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end


    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(MortalStrike, false) or Unit.Target;
        -- actions+=/hamstring,if=talent.deadly_calm.enabled&buff.battle_cry.up
        if Target:Exists() and Hamstring:Exists() and DeadlyCalm:Exists() and Player:Buff(BattleCry) and Target:CanCast(Hamstring) then
            Target:Cast(Hamstring);
            return;
        end
        -- actions+=/focused_rage,if=talent.deadly_calm.enabled&buff.battle_cry.up
        if FocusedRage:Exists() and DeadlyCalm:Exists() and Player:Buff(BattleCry) and Player:BuffCount(FocusedRage) < 3 and Player:CanCast(FocusedRage) then
            Player:Cast(FocusedRage);
            return;
        end
        -- Focused Rage tweak
        if FocusedRage:Exists() and (Player:BuffCount(FocusedRage) < 3 or Player:BuffRemains(FocusedRage) < 5) and (not Target:Exists() or (not Target:Debuff(ColossusSmashDebuff) and Target:HealthPercentage() >= 20)) and Player:RageDeficit() < 30 and Player:CanCast(FocusedRage) then
            Player:Cast(FocusedRage);
            return;
        end
    end

    function Rotation:Opening ()
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicStrengthBuff) and DraenicStrength:InStock() and not DraenicStrength:IsOnCooldown() then
            if Player:Potion("Strength", Potion) then Potion = true; end
        end
    end

    local function ExecuteHandler ()
        if Target:HealthPercentage() < 20 and Target:CanCast(Execute) then
            Target:Cast(Execute);
            return;
        end
        if module.GetOptionValue("Execute") == "Any Unit" then
            if ExecuteUnit and ExecuteUnit:CanCast(Execute, true, true) then
                ExecuteUnit:Cast(Execute);
                return;
            end
        end
    end

    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Combat Charge
            if module.IsOptionEnabled("Auto Charge Combat") and Target:CanCast(Charge) and Player:DistanceTo(Target) >= 6.5 and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Charge Combat") and Player:IsFacing(Target) then
                Target:Cast(Charge);
                return;
            end
            -- Enemies Check
            if module.UseAOE() then
                CleaveCount = #Player:UnitsInFrontConeAroundUnit(Target, 7, 180);
                Enemies_8y = Player:EnemiesWithinDistance(8, true);
                Enemies_5y = Player:FilterEnemiesByDistance(Enemies_8y, 5, false);
                ExecuteUnit = Execute:Exists() and module.IsOptionEnabled("Execute") and module.GetOptionValue("Execute") == "Any Unit" and Unit.LightEnemyAvailableForSpellHP(Enemies_8y, Execute, 20) or nil;
                RendUnit = Rend:Exists() and Unit.DotCycle(Enemies_5y, Rend, Rend, 4.5, "Multi-Dot Rend") or nil; -- Rend DoT Cycle
                ShockwaveCount = Shockwave:Exists() and #Player:UnitsInFrontCone(10, 140) or 0;
                NumEnemies = #Enemies_8y;
            else
                CleaveCount, Enemies_8y, Enemies_5y, ExecuteUnit, RendUnit, ShockwaveCount, NumEnemies = 0, {}, {}, nil, nil, 0, 1;
            end

            if Player:IsWithinCastRange(Target, MortalStrike) then
                --- Cooldowns ---
                if module.CooldownsAllowed() then
                    Player:UseTrinkets();
                    -- Racials
                    if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                        -- Blood Fury
                        if BloodFury:Exists() and Player:CanCast(BloodFury) and Player:Buff(BattleCry) then
                            Player:Cast(BloodFury);
                        end
                        -- Berserking
                        if Berserking:Exists() and Player:CanCast(Berserking) and Player:Buff(BattleCry) then
                            Player:Cast(Berserking);
                        end
                        -- Arcane Torrent
                        if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Rage() < Player:RageMax() - 40 then
                            Player:Cast(ArcaneTorrent);
                        end
                    end
                end
                -- Berserker Rage
                if BerserkerRage:Exists() and module.IsOptionEnabled("Berserker Rage") and (module.CooldownsAllowed() or module.GetOptionValue("Berserker Rage") == "Always") and Player:CanCast(BerserkerRage) then
                    Player:Cast(BerserkerRage);
                end
                -- Battle Cry
                if BattleCry:Exists() and module.IsOptionEnabled("Battle Cry") and (module.CooldownsAllowed() or module.GetOptionValue("Battle Cry") == "Always") and (Target:DebuffRemains(ColossusSmashDebuff) > 5 or (Target:Debuff(ColossusSmashDebuff) and not ColossusSmash:IsOnCooldown())) and Player:CanCast(BattleCry) then
                    Player:Cast(BattleCry);
                end
                -- Avatar
                if Avatar:Exists() and module.IsOptionEnabled("Avatar") and (module.CooldownsAllowed() or module.GetOptionValue("Avatar") == "Always") and Player:Buff(BattleCry) and Player:CanCast(Avatar) then
                    Player:Cast(Avatar);
                    return;
                end
            end

            -- Bladestorm
            if Bladestorm:Exists() and not Ravager:Exists() and module.IsOptionEnabled("Bladestorm") and NumEnemies >= module.GetSecondOptionValue("Bladestorm") and Player:CanCast(Bladestorm) then
                -- Avatar
                if Avatar:Exists() and module.IsOptionEnabled("Avatar") and (module.CooldownsAllowed() or module.GetOptionValue("Avatar") == "Always") and module.GetSecondOptionValue("Avatar") == "With Bladestorm" and Player:CanCast(Avatar) then
                    Player:Cast(Avatar);
                end
                -- Battle Cry
                if BattleCry:Exists() and module.IsOptionEnabled("Battle Cry") and (module.CooldownsAllowed() or module.GetOptionValue("Battle Cry") == "Always") and module.GetSecondOptionValue("Battle Cry") == "With Bladestorm" and Player:CanCast(BattleCry) then
                    Player:Cast(BattleCry);
                end
                Player:Cast(Bladestorm);
                return;
            end

            -- Execute - Stone Heart
            if Execute:Exists() and Player:Buff(StoneHeart) and Target:CanCast(Execute) then
                Target:Cast(Execute);
                return;
            end
            -- actions+=/rend,if=remains<gcd
            if Rend:Exists() and Player:Rage() >= 15 and Target:DebuffRemains(Rend) < Player:GCD() and Target:CanCast(Rend) then
                Target:Cast(Rend);
                return;
            end
            -- actions+=/colossus_smash,if=debuff.colossus_smash.down
            if ColossusSmash:Exists() and not Target:Debuff(ColossusSmashDebuff) and Target:CanCast(ColossusSmash) then
                Target:Cast(ColossusSmash);
                return;
            end
            -- actions+=/warbreaker,if=debuff.colossus_smash.down
            if Warbreaker:Exists() and Player:IsWithinCastRange(Target, MortalStrike) and module.IsOptionEnabled("Warbreaker") and NumEnemies >= module.GetOptionValue("Warbreaker") and not Target:Debuff(ColossusSmashDebuff) and Player:CanCast(Warbreaker) then
                Player:Cast(Warbreaker);
                return;
            end
            -- actions+=/ravager
            if Ravager:Exists() and module.IsOptionEnabled("Ravager") and Target:CanCast(Ravager) then
                if Player:CastGroundSpell(Ravager, "Ravager", 10) then return; end
            end
            -- actions+=/overpower
            if Overpower:Exists()  and Player:Rage() >= 10 and Player:Buff(OverpowerBuff) and Target:CanCast(Overpower) then
                Target:Cast(Overpower);
                return;
            end

            -- actions+=/run_action_list,name=execute,if=target.health.pct<20
            if Target:HealthPercentage() < 20 then
                -- actions.execute=mortal_strike,if=buff.shattered_defenses.up&buff.focused_rage.stack=3
                if MortalStrike:Exists() and Player:Buff(ShatteredDefenses) and Player:BuffCount(FocusedRage) == 3 and Target:CanCast(MortalStrike) then
                    Target:Cast(MortalStrike);
                    return;
                end
                -- actions.execute+=/execute,if=debuff.colossus_smash.up&(buff.shattered_defenses.up|rage>100|talent.deadly_calm.enabled&buff.battle_cry.up)
                if Execute:Exists() and module.IsOptionEnabled("Execute") and Target:Debuff(ColossusSmashDebuff) and (Player:Buff(ShatteredDefenses) or Player:Rage() > 100 or (DeadlyCalm:Exists() and Player:Buff(BattleCry))) and Target:CanCast(Execute) then
                    Target:Cast(Execute);
                    return;
                end
                -- actions.execute+=/mortal_strike,if=talent.in_for_the_kill.enabled&buff.shattered_defenses.down
                if MortalStrike:Exists() and InForTheKill:Exists() and not Player:Buff(ShatteredDefenses) and Target:CanCast(MortalStrike) then
                    Target:Cast(MortalStrike);
                    return;
                end
                -- actions.execute+=/colossus_smash,if=buff.shattered_defenses.down&buff.precise_strikes.down
                if ColossusSmash:Exists() and Warbreaker:Exists() and not Player:Buff(ShatteredDefenses) and not Player:Buff(PreciseStrikes) and Target:CanCast(ColossusSmash) then
                    Target:Cast(ColossusSmash);
                    return;
                end
                -- actions.execute+=/warbreaker,if=buff.shattered_defenses.down
                if Warbreaker:Exists() and Player:IsWithinCastRange(Target, MortalStrike) and module.IsOptionEnabled("Warbreaker") and NumEnemies >= module.GetOptionValue("Warbreaker") and Player:Buff(ShatteredDefenses) and Player:CanCast(Warbreaker) then
                    Player:Cast(Warbreaker);
                    return;
                end
                -- actions.execute+=/mortal_strike
                if MortalStrike:Exists() and Target:CanCast(MortalStrike) then
                    Target:Cast(MortalStrike);
                    return;
                end
                -- actions.execute+=/execute,if=debuff.colossus_smash.up|rage>=100
                if Execute:Exists() and module.IsOptionEnabled("Execute") and (Target:Debuff(ColossusSmashDebuff) or Player:Rage() >= 100) and Target:CanCast(Execute) then
                    Target:Cast(Execute);
                    return;
                end
                -- actions.execute+=/rend,if=remains<=duration*0.3
                if Rend:Exists() and Player:Rage() >= 15 and Target:DebuffRemains(Rend) < 4.5 and Target:CanCast(Rend) then
                    Target:Cast(Rend);
                    return;
                end
                -- actions.execute+=/heroic_charge
                -- actions.execute+=/shockwave
                if Shockwave:Exists() and module.IsOptionEnabled("Shockwave") and ShockwaveCount >= module.GetOptionValue("Shockwave") and Player:CanCast(Shockwave) then
                    Player:Cast(Shockwave);
                    return;
                end
                -- actions.execute+=/storm_bolt
                if StormBolt:Exists() and module.IsOptionEnabled("Storm Bolt") and Target:CanCast(StormBolt) then
                    Target:Cast(StormBolt);
                    return;
                end
                return;
            end

            -- actions+=/run_action_list,name=single,if=target.health.pct>=20
            -- actions.single=mortal_strike
            if MortalStrike:Exists() and Target:CanCast(MortalStrike) then
                Target:Cast(MortalStrike);
                return;
            end
            -- actions.single+=/colossus_smash,if=buff.shattered_defenses.down&buff.precise_strikes.down
            if ColossusSmash:Exists() and Warbreaker:Exists() and not Player:Buff(ShatteredDefenses) and not Player:Buff(PreciseStrikes) and Target:CanCast(ColossusSmash) then
                Target:Cast(ColossusSmash);
                return;
            end
            -- actions.single+=/warbreaker,if=buff.shattered_defenses.down
            if Warbreaker:Exists() and Player:IsWithinCastRange(Target, MortalStrike) and module.IsOptionEnabled("Warbreaker") and NumEnemies >= module.GetOptionValue("Warbreaker") and Player:Buff(ShatteredDefenses) and Player:CanCast(Warbreaker) then
                Player:Cast(Warbreaker);
                return;
            end
            -- actions.single+=/whirlwind,if=talent.fervor_of_battle.enabled&(debuff.colossus_smash.up|rage.deficit<50)&!talent.focused_rage.enabled|talent.deadly_calm.enabled&buff.battle_cry.up|buff.cleave.up
            if Whirlwind:Exists() and module.IsOptionEnabled("Whirlwind") and CleaveCount >= module.GetSecondOptionValue("Whirlwind") then
                -- Whirlwind
                if (FervorOfBattle:Exists() and (Target:Debuff(ColossusSmash) or Player:RageDeficit() < 50) and not FocusedRage:Exists()) or (DeadlyCalm:Exists() and Player:Buff(BattleCry)) or Player:Buff(CleaveBuff) then
                    if Player:CanCast(Whirlwind) then
                        Player:Cast(Whirlwind);
                        return;
                    end
                end
                -- Cleave for Whirlwind
                if Cleave:Exists() and Player:Rage() >= 35 and not Player:Buff(CleaveBuff) and Player:CanCast(Cleave) then
                    Player:Cast(Cleave);
                    return;
                end
            end
            -- actions.single+=/slam,if=!talent.fervor_of_battle.enabled&(debuff.colossus_smash.up|rage.deficit<40)&!talent.focused_rage.enabled|talent.deadly_calm.enabled&buff.battle_cry.up
            if Slam:Exists() and not FervorOfBattle:Exists() and (Target:Debuff(ColossusSmash) or Player:RageDeficit() < 40) and (not FocusedRage:Exists() or (DeadlyCalm:Exists() and Player:Buff(BattleCry))) and Target:CanCast(Slam) then
                Target:Cast(Slam);
                return;
            end
            -- actions.single+=/rend,if=remains<=duration*0.3
            if Rend:Exists() and Player:Rage() >= 15 and Target:DebuffRemains(Rend) < 4.5 and Target:CanCast(Rend) then
                Target:Cast(Rend);
                return;
            end
            -- actions.single+=/heroic_charge
            -- actions.single+=/whirlwind,if=talent.fervor_of_battle.enabled&(!talent.focused_rage.enabled|rage>100|buff.focused_rage.stack=3)
            if Whirlwind:Exists() and module.IsOptionEnabled("Whirlwind") and CleaveCount >= module.GetSecondOptionValue("Whirlwind") then
                if FervorOfBattle:Exists() and (not FocusedRage:Exists() or Player:Rage() > 100 or Player:BuffCount(FocusedRage) == 3) then
                    if Player:CanCast(Whirlwind) then
                        Player:Cast(Whirlwind);
                        return;
                    end
                end
            end
            -- actions.single+=/slam,if=!talent.fervor_of_battle.enabled&(!talent.focused_rage.enabled|rage>100|buff.focused_rage.stack=3)
            if Slam:Exists() and (not FocusedRage:Exists() or Player:Rage() > 100 or Player:BuffCount(FocusedRage) == 3) and Target:CanCast(Slam) then
                Target:Cast(Slam);
                return;
            end
            -- actions.single+=/execute
            if Execute:Exists() and module.IsOptionEnabled("Execute") and Target:CanCast(Execute) then
                Target:Cast(Execute);
                return;
            end
            -- actions.single+=/shockwave
            if Shockwave:Exists() and module.IsOptionEnabled("Shockwave") and ShockwaveCount >= module.GetOptionValue("Shockwave") and Player:CanCast(Shockwave) then
                Player:Cast(Shockwave);
                return;
            end
            -- actions.single+=/storm_bolt
            if StormBolt:Exists() and module.IsOptionEnabled("Storm Bolt") and Target:CanCast(StormBolt) then
                Target:Cast(StormBolt);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(MortalStrike, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Out Of Combat Charge
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and module.IsOptionEnabled("Auto Charge Out Of Combat") and Player:DistanceTo(Target) >= 6.5 and ((BMPullTime() == 60 and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Charge Out Of Combat")) or BMPullTime() <= module.GetSecondOptionValue("Pre-Pot BossMod")) and Player:IsFacing(Target) and Target:CanCast(Charge) then
            Target:Cast(Charge);
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Fury Warrior
    local Rotation = {};
    module.SetRotation("_"..72, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local Enemies_20y, Enemies_8y, ExecuteUnit, ShockwaveCount, NumEnemies = {}, {}, nil, 0, 0; -- Enemies
    local BattleCryEnabled, CanExecute;

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicStrength = Item(109219, false, false, true);
        DraenicStrengthBuff = Spell(156428, false, false, true);

        --Racials
        ArcaneTorrent = Spell(69179, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        Avatar = Spell(107574, false, false, true);
        BattleCry = Spell(1719, false, false, true);
        BerserkerRage = Spell(18499, false, false, true);
        Bladestorm = Spell(46924, false, false, true);
        Bloodbath = Spell(12292, false, false, true);
        Bloodthirst = Spell(23881, true, true, true);
        Carnage = Spell(202922);
        Charge = Spell(100, true, true, true);
        CommandingShout = Spell(97462, false, false, true);
        DragonRoar = Spell(118000, false, false, true);
        Enrage = Spell(184362);
        EnragedRegeneration = Spell(184364, false, false, true);
        Execute = Spell(5308, true, true, true);
        Frenzy = Spell(206313);
        FrenzyBuff = Spell(202539);
        FuriousSlash = Spell(100130, true, true, true);
        HeroicThrow = Spell(57755, true, true, true);
        InnerRage = Spell(215573);
        Juggernaut = Spell(201009);
        Massacre = Spell(206316);
        MeatCleaver = Spell(85739);
        OdynsFury = Spell(205545, false, false, true);
        Pummel = Spell(6552, true, true, true);
        RagingBlow = Spell(85288, true, true, true);
        Rampage = Spell(184367, true, true, true);
        SenseForDeath = Spell(200979);
        Shockwave = Spell(46968, true, false, true);
        StoneHeart = Spell(225947); -- Legendary Ring Proc - Free Execute
        StormBolt = Spell(107570, true, true, true);
        Whirlwind = Spell(190411, false, false, true);
        WreckingBall = Spell(215570);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Pummel to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Auto Charge Combat", 220, false, {15, 6.5, 22, 0.5}, nil, "Distance away from the target to auto use charge while in combat");
        module.AddNewOption("General Settings", "Auto Charge Out Of Combat", 220, false, {15, 6.5, 22, 0.5}, nil, "Distance away from the target to auto use charge while not in combat");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 232, true, {1, "Boss Only", "Always", "Never"}, {0.2, 0, 3, 0.1}, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Avatar", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Avatar."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Battle Cry", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Battle Cry."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Berserker Rage", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Berserker Rage."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Bladestorm", 232, true, {1, "Always", "Cooldown Only"}, {2, 1, 10, 1}, "Use Bladestorm."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be in range to use.");
        module.AddNewOption("Offensive Settings", "Bloodbath", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Blood Bath."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Dragon Roar", 232, true, {2, "Always", "Cooldown Only"}, {1, 1, 10, 1}, "Use Dragon Roar."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be in range to use.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Execute", 230, true, {2, "Target Only", "Any Unit"}, nil, "Use Execute on low health Targets."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Target Only", true).."Only use Execute on current Target."..C.TOOLTIP_SUBVALUE("Any Unit", true).."Use Execute on any available unit that is in range.");
        module.AddNewOption("Offensive Settings", "Odyn's Fury", 220, true, {2, 1, 10, 1}, nil, "Use Odyn's Fury."..C.TOOLTIP_VALUE.."Amount of units that needs to be in range to use.");
        module.AddNewOption("Offensive Settings", "Shockwave", 220, false, {3, 1, 10, 1}, nil, "Use Shockwave."..C.TOOLTIP_VALUE.."Define number of units needed in front of us to use Shockwave.");
        module.AddSection("Offensive Settings", "Rotations", "Green");
        module.AddNewOption("Offensive Settings", "AoE Rotation", 220, true, {4, 4, 4, 0}, nil, "Use AoE Rotation. (4+ Targets)"..C.TOOLTIP_VALUE.."Amount of units that needs to be in Whirlwind Radius to use the AoE Rotation.");
        module.AddNewOption("Offensive Settings", "Cleave Rotation", 220, true, {2, 2, 2, 0}, nil, "Use Cleave Rotation. (2-3 Targets)"..C.TOOLTIP_VALUE.."Amount of units that needs to be in Whirlwind Radius to use the Cleave Rotation.");
        -- module.AddNewOption("Offensive Settings", "Whirlwind", 222, true, {2, 1, 10, 1}, {1, 1, 10, 1}, "Use Whirlwind."..C.TOOLTIP_VALUE_1.."Amount of units that needs to be in range to use."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be in range to use when we have the Wrecking Ball buff.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        module.AddNewOption("Defensive Settings", "Enraged Regeneration", 220, true, {30, 1, 100, 1}, nil, "Use Enraged Regeneration."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        module.AddOutput("|cFFE30000Rotation:");
        module.SetOutput("|cFFE30000Rotation:", "|cFFE30000Single Target");
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Pummel, ArcaneTorrent);
    end


    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Enraged Regeneration
        if EnragedRegeneration:Exists() and module.IsOptionEnabled("Enraged Regeneration") and Player:HealthPercentage() <= module.GetOptionValue("Enraged Regeneration") and Player:CanCast(EnragedRegeneration) then
            Player:Cast(EnragedRegeneration);
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:SpecialHealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end


    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target
        Target = Player:ReTarget(Bloodthirst, false) or Unit.Target;
    end

    function Rotation:Opening ()
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicStrengthBuff) and DraenicStrength:InStock() and not DraenicStrength:IsOnCooldown() then
            if Player:Potion("Strength", Potion) then Potion = true; end
        end
    end

    local function ExecuteHandler ()
        if Target:HealthPercentage() < 20 and Target:CanCast(Execute) then
            Target:Cast(Execute);
            return;
        end
        if module.GetOptionValue("Execute") == "Any Unit" then
            if ExecuteUnit and ExecuteUnit:CanCast(Execute, true, true) then
                ExecuteUnit:Cast(Execute);
                return;
            end
        end
    end

    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Combat Charge
            if module.IsOptionEnabled("Auto Charge Combat") and Target:CanCast(Charge) and Player:DistanceTo(Target) >= 6.5 and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Charge Combat") and Player:IsFacing(Target) then
                Target:Cast(Charge);
                return;
            end
            -- Enemies Check
            if module.UseAOE() then
                Enemies_20y = Player:EnemiesWithinDistance(20, true);
                Enemies_8y = Player:FilterEnemiesByDistance(Enemies_20y, 8, true);
                ExecuteUnit = Execute:Exists() and module.IsOptionEnabled("Execute") and module.GetOptionValue("Execute") == "Any Unit" and Unit.LightEnemyAvailableForSpellHP(Enemies_8y, Execute, 20) or nil;
                ShockwaveCount = Shockwave:Exists() and #Player:UnitsInFrontCone(10, 140) or 0;
                NumEnemies = #Enemies_8y;
            else
                NumEnemies = 1;
            end

            -- Shockwave
            if Shockwave:Exists() and module.IsOptionEnabled("Shockwave") and ShockwaveCount >= module.GetOptionValue("Shockwave") and Player:CanCast(Shockwave) then
                Player:Cast(Shockwave);
                return;
            end

            if Player:IsWithinCastRange(Target, Bloodthirst) then
                --- Cooldowns ---
                if module.CooldownsAllowed() then
                    Player:UseTrinkets();

                end
                BattleCryEnabled = module.IsOptionEnabled("Battle Cry") and (module.CooldownsAllowed() or module.GetOptionValue("Battle Cry") == "Always") or false;
                DragonRoarEnabled = DragonRoar:Exists() and (module.CooldownsAllowed() or module.GetOptionValue("Avatar") == "Always") and module.IsOptionEnabled("Dragon Roar") and NumEnemies >= module.GetSecondOptionValue("Dragon Roar") or false;
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    if ((BattleCryEnabled and BattleCry:Cooldown() < Player:GCD()) or not BattleCryEnabled) then
                        -- Blood Fury
                        if BloodFury:Exists() and Player:CanCast(BloodFury) then
                            Player:Cast(BloodFury);
                        end
                        -- Berserking
                        if Berserking:Exists() and Player:CanCast(Berserking) then
                            CastSpellByID(26297, "player")
                        end
                    end
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Rage() < Player:RageMax() - 40 then
                        Player:Cast(ArcaneTorrent);
                    end
                end
                -- DragonRoar
                if DragonRoar:Exists() and module.IsOptionEnabled("Dragon Roar") and (module.CooldownsAllowed() or module.GetOptionValue("Dragon Roar") == "Always") and NumEnemies >= module.GetSecondOptionValue("Dragon Roar") and ((BattleCryEnabled and BattleCry:Cooldown() < Player:GCD()) or not BattleCryEnabled or BattleCry:Cooldown() > 23) and Player:CanCast(DragonRoar) then
                    Player:Cast(DragonRoar);
                    return;
                end
                -- Avatar
                if Avatar:Exists() and module.IsOptionEnabled("Avatar") and (module.CooldownsAllowed() or module.GetOptionValue("Avatar") == "Always") and ((BattleCryEnabled and BattleCry:Cooldown() < 10) or not BattleCryEnabled) and Player:CanCast(Avatar) then
                    Player:Cast(Avatar);
                    return;
                end
                -- Bloodbath
                if Bloodbath:Exists() and module.IsOptionEnabled("Bloodbath") and (module.CooldownsAllowed() or module.GetOptionValue("Bloodbath") == "Always") and ((BattleCryEnabled and (Player:Buff(BattleCry) or BattleCry:Cooldown() > 28)) or not BattleCryEnabled) and Player:CanCast(Bloodbath) then
                    Player:Cast(Bloodbath);
                    return;
                end
                -- Berserker Rage
                if BerserkerRage:Exists() and not Player:Buff(Enrage) and not (DragonRoarEnabled and not Player:Buff(DragonRoar)) and module.IsOptionEnabled("Berserker Rage") and (module.CooldownsAllowed() or module.GetOptionValue("Berserker Rage") == "Always") and Player:CanCast(BerserkerRage) then
                    Player:Cast(BerserkerRage);
                end
                -- Battle Cry
                if BattleCry:Exists() and not (DragonRoarEnabled and not Player:Buff(DragonRoar)) and BattleCryEnabled and Player:CanCast(BattleCry) then
                    Player:Cast(BattleCry);
                    return;
                end
            end

            -- actions+=/call_action_list,name=aoe,if=spell_targets.whirlwind>3
            if module.UseAOE() and module.IsOptionEnabled("AoE Rotation") and NumEnemies >= 4 then
                module.SetOutput("|cFFE30000Rotation:", "|cFFE30000AoE");
                -- actions.aoe=bloodthirst,if=buff.enrage.down|rage<50
                if Bloodthirst:Exists() and (not Player:Buff(Enrage) or Player:Rage() < 50) and Target:CanCast(Bloodthirst) then
                    Target:Cast(Bloodthirst);
                    return;
                end
                -- actions.bladestorm+=/bladestorm,if=buff.enrage.remains>2&(raid_event.adds.in>90|!raid_event.adds.exists|spell_targets.bladestorm_mh>desired_targets)
                if Bladestorm:Exists() and Player:BuffRemains(Enrage) > 2 and module.IsOptionEnabled("Bladestorm") and NumEnemies >= module.GetSecondOptionValue("Bladestorm") and Player:CanCast(Bladestorm) then
                    Player:Cast(Bladestorm);
                    return;
                end
                -- actions.aoe+=/whirlwind
                if Whirlwind:Exists() and Player:IsWithinCastRange(Target, Bloodthirst) and Player:CanCast(Whirlwind) then
                    Player:Cast(Whirlwind);
                    return;
                end
                -- actions.aoe+=/dragon_roar
                -- actions.aoe+=/bloodthirst
                if Bloodthirst:Exists() and Target:CanCast(Bloodthirst) then
                    Target:Cast(Bloodthirst);
                    return;
                end

            -- actions+=/call_action_list,name=two_targets,if=spell_targets.whirlwind=2|spell_targets.whirlwind=3
            elseif module.UseAOE() and module.IsOptionEnabled("Cleave Rotation") and NumEnemies >= 2 then
                module.SetOutput("|cFFE30000Rotation:", "|cFFE30000Cleave");
                -- actions.two_targets=whirlwind,if=buff.meat_cleaver.down
                if Whirlwind:Exists() and Player:IsWithinCastRange(Target, Bloodthirst) and not Player:Buff(MeatCleaver) and Player:CanCast(Whirlwind) then
                    Player:Cast(Whirlwind);
                    return;
                end
                -- actions.two_targets+=/rampage,if=buff.enrage.down|(rage=100&buff.juggernaut.down)|buff.massacre.up
                if Rampage:Exists() and (not Player:Buff(Enrage) or (Player:Rage() == 100 and not Player:Buff(Juggernaut)) or Player:Buff(Massacre)) and Target:CanCast(Rampage) then
                    Target:Cast(Rampage);
                    return;
                end
                -- actions.two_targets+=/bloodthirst,if=buff.enrage.down
                if Bloodthirst:Exists() and not Player:Buff(Enrage) and Target:CanCast(Bloodthirst) then
                    Target:Cast(Bloodthirst);
                    return;
                end
                -- actions.two_targets+=/raging_blow,if=talent.inner_rage.enabled&spell_targets.whirlwind=2
                if RagingBlow:Exists() and InnerRage:Exists() and NumEnemies == 2 and Target:CanCast(RagingBlow) then
                    Target:Cast(RagingBlow);
                    return;
                end
                -- actions.two_targets+=/whirlwind,if=spell_targets.whirlwind>2
                if Whirlwind:Exists() and Player:IsWithinCastRange(Target, Bloodthirst) and NumEnemies == 3 and Player:CanCast(Whirlwind) then
                    Player:Cast(Whirlwind);
                    return;
                end
                -- actions.two_targets+=/dragon_roar
                -- actions.two_targets+=/bloodthirst
                if Bloodthirst:Exists() and Target:CanCast(Bloodthirst) then
                    Target:Cast(Bloodthirst);
                    return;
                end
            end

            -- actions+=/call_action_list,name=single_target
            module.SetOutput("|cFFE30000Rotation:", "|cFFE30000Single Target");
            -- actions.single_target=odyns_fury
            if OdynsFury:Exists() and (Player:Buff(BattleCry) or BattleCry:Cooldown() > 35 or not (module.IsOptionEnabled("Battle Cry") and (module.CooldownsAllowed() or module.GetOptionValue("Battle Cry") == "Always"))) and module.IsOptionEnabled("Odyn's Fury") and #Enemies_20y >= module.GetOptionValue("Odyn's Fury") and Player:CanCast(OdynsFury) then
                Player:Cast(OdynsFury);
                return;
            end
            -- Juggernaut Support
            if Execute:Exists() and Player:Rage() >= 25 and (Player:BuffRemains(Juggernaut) < 1.8 or Player:Buff(BattleCry) or (DragonRoarEnabled and DragonRoar:Cooldown() < 2 and Player:BuffRemains(Juggernaut) < 3.5)) and module.IsOptionEnabled("Execute") then
                ExecuteHandler();
            end
            -- Stone Hearth & Sens for Death Proc
            if Execute:Exists() and (Player:Buff(StoneHeart) or (Player:Buff(BattleCry) and Player:Buff(SenseForDeath) and Target:HealthPercentage() < 20)) and Target:CanCast(Execute) then
                ExecuteHandler();
            end
            -- actions.single_target+=/rampage,if=rage=100|buff.massacre.up
            if Rampage:Exists() and (Player:Rage() >= 100 or Player:Buff(Massacre)) and Target:CanCast(Rampage) then
                Target:Cast(Rampage);
                return;
            end
            -- actions.single_target+=/rampage,if=buff.enrage.down
            if Rampage:Exists() and not Player:Buff(Enrage) and Target:CanCast(Rampage) then
                Target:Cast(Rampage);
                return;
            end
            -- actions.single_target+=/furious_slash,if=talent.frenzy.enabled&(buff.frenzy.down|buff.frenzy.remains<=3)
            if FuriousSlash:Exists() and Frenzy:Exists() and (not Player:Buff(FrenzyBuff) or (Player:Buff(FrenzyBuff) and Player:BuffRemains(FrenzyBuff) <= 3)) and Target:CanCast(FuriousSlash) then
                Target:Cast(FuriousSlash);
                return;
            end
            -- actions.single_target+=/execute,if=buff.enrage.up&(!talent.massacre.enabled&!talent.inner_rage.enabled)|talent.massacre.enabled&buff.enrage.down|buff.enrage.up&(talent.massacre.enabled&!talent.inner_rage.enabled)
            if Execute:Exists() and Player:Rage() >= 25 and module.IsOptionEnabled("Execute") and ((Player:Buff(Enrage) and (not Massacre:Exists() and not InnerRage:Exists())) or (Massacre:Exists() and not Player:Buff(Enrage)) or (Player:Buff(Enrage) and (Massacre:Exists() and not InnerRage:Exists()))) then
                ExecuteHandler();
            end
            -- actions.single_target+=/bloodthirst,if=!talent.inner_rage.enabled
            if Bloodthirst:Exists() and not InnerRage:Exists() and Target:CanCast(Bloodthirst) then
                Target:Cast(Bloodthirst);
                return;
            end
            -- actions.single_target+=/whirlwind,if=!talent.inner_rage.enabled&buff.wrecking_ball.react
            if Whirlwind:Exists() and Player:IsWithinCastRange(Target, Bloodthirst) and not InnerRage:Exists() and Player:Buff(WreckingBall) and Player:CanCast(Whirlwind) then
                Player:Cast(Whirlwind);
                return;
            end
            -- actions.single_target+=/raging_blow,if=buff.enrage.up
            if RagingBlow:Exists() and Player:Buff(Enrage) and Target:CanCast(RagingBlow) then
                Target:Cast(RagingBlow);
                return;
            end
            -- actions.single_target+=/whirlwind,if=buff.wrecking_ball.react&buff.enrage.up
            if Whirlwind:Exists() and Player:IsWithinCastRange(Target, Bloodthirst) and Player:Buff(WreckingBall) and Player:CanCast(Whirlwind) then
                Player:Cast(Whirlwind);
                return;
            end
            -- actions.single_target+=/execute,if=buff.enrage.up&!talent.frenzy.enabled|talent.frenzy.enabled|talent.massacre.enabled
            if Execute:Exists() and Player:Rage() >= 25 and module.IsOptionEnabled("Execute") and ((Player:Buff(Enrage) and not Frenzy:Exists()) or not Frenzy:Exists() or not Massacre:Exists()) then
                ExecuteHandler();
            end
            -- actions.single_target+=/bloodthirst,if=buff.enrage.down
            if Bloodthirst:Exists() and not Player:Buff(Enrage) and Target:CanCast(Bloodthirst) then
                Target:Cast(Bloodthirst);
                return;
            end
            -- actions.single_target+=/raging_blow
            if RagingBlow:Exists() and (Player:Buff(Enrage) or InnerRage:Exists()) and Target:CanCast(RagingBlow) then
                Target:Cast(RagingBlow);
                return;
            end
            -- actions.single_target+=/bloodthirst
            if Bloodthirst:Exists() and Target:CanCast(Bloodthirst) then
                Target:Cast(Bloodthirst);
                return;
            end
            -- actions.single_target+=/furious_slash
            if FuriousSlash:Exists() and Target:CanCast(FuriousSlash) then
                Target:Cast(FuriousSlash);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Bloodthirst, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Out Of Combat Charge
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and module.IsOptionEnabled("Auto Charge Out Of Combat") and Player:DistanceTo(Target) >= 6.5 and ((BMPullTime() == 60 and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Charge Out Of Combat")) or BMPullTime() <= module.GetSecondOptionValue("Pre-Pot BossMod")) and Player:IsFacing(Target) and Target:CanCast(Charge) then
            Target:Cast(Charge);
            return;
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Leveling Protection Warrior
    local Rotation = {};
    module.SetRotation("_"..73, Rotation);

    --- Localization
    -- Core
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Rotation Specific
    local Enemies_30y, Enemies_15y, Enemies_8y, ShockwaveUnits, NumEnemies = {}, {}, {}, 0, 0; -- Enemies

    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();
        -- Items
        DraenicArmor = Item(109220, false, false, true);
        DraenicArmorBuff = Spell(156430, false, false, true);

        --Racials
        ArcaneTorrent = Spell(69179, false, false, true);
        Berserking = Spell(26297, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        GiftOfTheNaaru = Spell(28880, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        Avatar = Spell(107574, false, false, true);
        BattleCry = Spell(1719, false, false, true);
        BerserkerRage = Spell(18499, false, false, true);
        CracklingThunder = Spell(203201);
        DeepWounds = Spell(115767);
        DemoralizingShout = Spell(1160, false, false, true);
        Devastate = Spell(20243, true, true,  true);
        FocusedRage = Spell(204488, false, false, true);
        HeroicThrow = Spell(57755, true, true, true);
        IgnorePain = Spell(190456, false, false, true);
        ImpendingVictory = Spell(202168, true, true, true);
        Intercept = Spell(198304, true, true, true);
        LastStand = Spell(12975, false, false, true);
        NeltharionsFury = Spell(203524, false, false, true);
        Pummel = Spell(6552, true, true, true);
        -- Ravager = Spell(152277, true, true, true);
        Revenge = Spell(6572, false, false, true);
        ShieldBlock = Spell(2565, false, false, true);
        ShieldBlockBuff = Spell(132404);
        ShieldSlam = Spell(23922, true, true, true);
        ShieldWall = Spell(871, false, false, true);
        Shockwave = Spell(46968, true, false, true);
        SpellReflection = Spell(23920, false, false, true);
        StormBolt = Spell(107570, true, true, true);
        Taunt = Spell(355, false, true, true);
        ThunderClap = Spell(6343, false, false, true);
        Ultimatum = Spell(122510);
        Victorious = Spell(32216);
        VictoryRush = Spell(34428, true, true, true);

        module.AddPage("General Settings");
        module.AddPage("Offensive Settings");
        module.AddPage("Defensive Settings");
        module.AddSection("General Settings", "General", "Green");
        AddAllClassOptions();

        module.AddNewOption("General Settings", "Target | Attack", 133, true, {6, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest", "Untanked"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_SUBVALUE("Untanked").."Integrate tanking logic that will priorise the untaked units."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Cooldowns Only On Bosses", 210, false, nil, nil, "Enable to save Cooldowns for Bosses.");
        module.TauntManagerOptions("Taunt");
        module.AddSection("General Settings", "Utility", "Green");
        module.AddNewOption("General Settings", "Interrupt between %", 221, true, {C.INTERRUPT_DEFAULT1, C.INTERRUPT_MIN, C.INTERRUPT_MAX, C.INTERRUPT_STEP, C.INTERRUPT_GAP}, {C.INTERRUPT_DEFAULT2}, "Will use Pummel to interrupt the target when its cast time meets this % range."..C.TOOLTIP_VALUE_1.."Minimum % range."..C.TOOLTIP_VALUE_2.."Maximum % range.");
        if ArcaneTorrent:Exists() then
            module.AddNewOption("General Settings", "Arcane Torrent Interrupt", 210, false, nil, nil, "Enable to also use Arcane Torrent to interrupt.");
        end
        module.AddNewOption("General Settings", "Interrupt Any Unit", 210, false, nil, nil, "Enable to interrupt any units in range."..C.TOOLTIP_HINT("Works only if 'Interrupt between %' is enabled."));
        module.AddNewOption("General Settings", "Custom Interrupt List", 210, false, nil, nil, "Enable to interrupt only spells in the Custom Interrupt List.");
        module.AddSection("General Settings", "Movement", "Green");
        module.AddNewOption("General Settings", "Auto Intercept Combat", 220, false, {15, 6.5, 22, 0.5}, nil, "Distance away from the target to auto use charge while in combat");
        module.AddNewOption("General Settings", "Auto Intercept Out Of Combat", 220, false, {15, 6.5, 22, 0.5}, nil, "Distance away from the target to auto use charge while not in combat");

        module.AddSection("Offensive Settings", "General", "Green");
        module.AddNewOption("Offensive Settings", "Pre-Pot BossMod", 232, true, {1, "Boss Only", "Always", "Never"}, {0.2, 0, 3, 0.1}, "Use DBM countdown to do perfect opening sequence."..C.TOOLTIP_VALUE_1.."When should we use a potion in the opener."..C.TOOLTIP_VALUE_2.."When do we want our Pyroblast to land. Potion will be used 0.1s before if it is enabled."..C.TOOLTIP_HINT("Supports DBM, BW and ERT."));
        module.AddSection("Offensive Settings", "Cooldowns", "Green");
        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddNewOption("Offensive Settings", "Offensive Racials", 230, true, {2, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.TrinketOptions();
        --module.AddNewOption("Offensive Settings", "Use Potions", 210, false, nil, nil, "Will use Raid Potions."..C.TOOLTIP_HINT("Only if your target is a Boss."));
        module.AddNewOption("Offensive Settings", "Avatar", 230, true, {2, "Always", "Cooldown Only"}, nil, "Use Avatar."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Battle Cry", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Battle Cry."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        module.AddNewOption("Offensive Settings", "Berserker Rage", 230, true, {1, "Always", "Cooldown Only"}, nil, "Use Berserker Rage."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled."..C.TOOLTIP_VALUE_2.."Amount of units that needs to be in range to use.");
        module.AddSection("Offensive Settings", "Abilities", "Green");
        module.AddNewOption("Offensive Settings", "Heroic Throw", 210, true, nil, nil, "Use Heroic Throw while we are out of range.");
        module.AddNewOption("Offensive Settings", "Neltharion's Fury", 220, true, {2, 1, 10, 1}, nil, "Use Neltharion's Fury."..C.TOOLTIP_VALUE.."Amount of units needed in front of us to use.");
        -- module.AddNewOption("Offensive Settings", "Ravager", 232, true, {2, "Target", "Target Standing", "Centered", "Centered Standing"}, {1, 1, 10, 1}, "Use Ravager." .. C.TOOLTIP_VALUE_1 .. "Choose preferred mode." .. C.TOOLTIP_SUBVALUE("Target") .. "Always use on the current target." .. C.TOOLTIP_SUBVALUE("Target Standing") .. "Always use on the current target. Target must be standing still." .. C.TOOLTIP_SUBVALUE("Centered") .. "Use centered on a cluster of enemies." .. C.TOOLTIP_SUBVALUE("Centered Standing") .. "Use centered on a cluster of enemies. Enemies must be standing still." .. C.TOOLTIP_VALUE_2 .. "Amount of enemies that must be in the spell effect to use.");
        module.AddNewOption("Offensive Settings", "Shockwave", 220, true, {2, 1, 10, 1}, nil, "Use Shockwave."..C.TOOLTIP_VALUE.."Amount of units needed in front of us to use.");
        module.AddNewOption("Offensive Settings", "Storm Bolt", 210, true, nil, nil, "Use Storm Bolt.");
        module.AddNewOption("Offensive Settings", "Thunder Clap", 220, true, {2, 1, 10, 1}, nil, "Use Thunder Clap."..C.TOOLTIP_VALUE.."Amount of units needed within 8 yards around player to use.");

        module.AddSection("Defensive Settings", "Items", "Green");
        module.AddNewOption("Defensive Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Abilities", "Green");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("Defensive Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("Defensive Settings", "Ignore Pain", 222, true, {40, 1, 100, 1}, {90, 20, 101, 1}, "Use Ignore Pain."..C.TOOLTIP_VALUE_1.."Health threshold."..C.TOOLTIP_VALUE_2.."Rage threshold to use Ignore Pain to dump exceeding Rage."..C.TOOLTIP_HINT("You can set it to 101 to completely avoid using it for Rage dumping."));
        module.AddNewOption("Defensive Settings", "Shield Block", 221, true, {50, 1, 100, 1, 0}, {100}, "Use Shield Block."..C.TOOLTIP_VALUE_1.."Health threshold to use with one or two charges."..C.TOOLTIP_VALUE_2.."Health threshold to use with two charges.");
        module.AddNewOption("Defensive Settings", "Victory Rush, Impending Victory", 220, true, {80, 1, 100, 1}, nil, "Use Victory Rush."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("Defensive Settings", "Cooldowns", "Green");
        module.AddNewOption("Defensive Settings", "Demoralizing Shout", 222, true, {1, 1, 10, 1}, {70, 1, 100, 1}, "Use Demoralizing Shout."..C.TOOLTIP_VALUE_1.."Amount of units needed within 15 yards around player to use."..C.TOOLTIP_VALUE_2.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Last Stand", 220, true, {20, 1, 100, 1}, nil, "Use Last Stand."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("Defensive Settings", "Shield Wall", 220, true, {30, 1, 100, 1}, nil, "Use Shield Wall."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
        -- Spell Names
        HandofProtectionName = GetSpellInfo(1022);
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        -- Opening Sequence
        if module.IsOptionEnabled("Pre-Pull BossMod") and Target:Exists() and BMPullTime() < 7 then
            self:Opening();
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:Interrupts();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's interrupt logic.
    function Rotation:Interrupts ()
        Player:UseInterrupt(Pummel, ArcaneTorrent);
    end


    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        if Player:IsWithinCastRange(Target, Devastate) then
            if not Player:Buff(ShieldBlockBuff) then
                -- Shield Block
                if ShieldBlock:Exists() and module.IsOptionEnabled("Shield Block") and Player:HealthPercentage() <= module.GetOptionValue("Shield Block") and Player:CanCast(ShieldBlock) then
                    Player:Cast(ShieldBlock);
                    return;
                end
                -- Shield Block - 2 Charges
                if ShieldBlock:Exists() and (ShieldBlock:Charges() >= 2 or (ShieldBlock:Charges() == 1 and ShieldBlock:Recharge() < 2)) and module.IsOptionEnabled("Shield Block") and Player:HealthPercentage() <= module.GetSecondOptionValue("Shield Block") and Player:CanCast(ShieldBlock) then
                    Player:Cast(ShieldBlock);
                    return;
                end
            end
            -- Shield Wall
            if ShieldWall:Exists() and module.IsOptionEnabled("Shield Wall") and Player:HealthPercentage() <= module.GetOptionValue("Shield Wall") and Player:CanCast(ShieldWall) then
                Player:Cast(ShieldWall);
                return;
            end
            -- Ignore Pain
            if IgnorePain:Exists() and module.IsOptionEnabled("Ignore Pain") and (Player:HealthPercentage() <= module.GetOptionValue("Ignore Pain") or Player:Rage() >= module.GetSecondOptionValue("Ignore Pain")) and Player:CanCast(IgnorePain) then
                Player:Cast(IgnorePain);
                return;
            end
            -- Last Stand
            if LastStand:Exists() and module.IsOptionEnabled("Last Stand") and Player:HealthPercentage() <= module.GetOptionValue("Last Stand") and Player:CanCast(LastStand) then
                Player:Cast(LastStand);
                return;
            end
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
        -- Victory Rush/Impending Victory
        if module.IsOptionEnabled("Victory Rush, Impending Victory") and Player:HealthPercentage() <= module.GetOptionValue("Victory Rush, Impending Victory") then
            if not ImpendingVictory:Exists() and Player:Buff(Victorious) and Target:CanCast(VictoryRush) then
                Target:Cast(VictoryRush);
                return;
            elseif ImpendingVictory:Exists() and Target:CanCast(ImpendingVictory) then
                Target:Cast(ImpendingVictory);
                return;
            end
        end
    end


    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Hand of Protection Cancel Buff
        if module.IsOptionEnabled("Hand of Protection Cancel") and Player:BuffRemainsAny(HandofProtection) <= 10-module.GetOptionValue("Hand of Protection Cancel") then
            RunMacroText("/cancelaura " .. HandofProtectionName);
        end
        -- Auto Target or Intercept
        if not (module.IsOptionEnabled("Auto Intercept Combat") and Intercept:Charges() >= 1 and Player:DistanceTo(Target) >= 6.5 and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Intercept Combat") and Player:IsFacing(Target)) then
            Target = Player:ReTarget(ShieldSlam, false) or Unit.Target;
        end
        -- Focused Rage
        if FocusedRage:Exists() and (Player:Rage() >= 110 or Player:Buff(Ultimatum)) and Player:CanCast(FocusedRage) then
            Player:Cast(FocusedRage);
        end
    end

    function Rotation:Opening ()
        -- Pre-Pot
        if module.IsOptionEnabled("Pre-Pot BossMod") and BMPullTime() <= module.GetOptionValue("Pre-Pot BossMod") and not Player:Buff(DraenicArmorBuff) and DraenicArmor:InStock() and not DraenicArmor:IsOnCooldown() then
            if Player:Potion("Armor", Potion) then Potion = true; end
        end
    end

    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Combat Intercept
            if module.IsOptionEnabled("Auto Intercept Combat") and Target:CanCast(Intercept) and Player:DistanceTo(Target) >= 6.5 and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Intercept Combat") and Player:IsFacing(Target) then
                Target:Cast(Intercept);
                return;
            end
            -- Enemies Check
            if module.UseAOE() then
                Enemies_30y = Player:EnemiesWithinDistance(40, false);
                Enemies_15y = Player:FilterEnemiesByDistance(Enemies_30y, 15, true); -- Demoralizing Shout
                Enemies_8y = not CracklingThunder:Exists() and Player:FilterEnemiesByDistance(Enemies_15y, 8, true) or Enemies_15y; -- Thunderclap
                ShockwaveUnits = #Player:UnitsInFrontCone(10, 140) or 0; -- Shockwave + Neltharion's Fury
                NumEnemies = #Enemies_8y;
            else
                Enemies_15y, Enemies_8y, ShockwaveUnits, NumEnemies = {}, {}, 0, 1;
            end

            -- Taunt
            if Player:TauntManager(Taunt, "Taunt", Target, Enemies_30y) then
                return;
            end

            if Player:IsWithinCastRange(Target, Devastate) then
                -- Demoralizing Shout
                if DemoralizingShout:Exists() and #Enemies_15y > module.GetOptionValue("Demoralizing Shout") and Player:HealthPercentage() <= module.GetSecondOptionValue("Demoralizing Shout") and Player:CanCast(DemoralizingShout) then
                    Player:Cast(DemoralizingShout);
                    return;
                end
                --- Cooldowns ---
                if module.CooldownsAllowed() then
                    Player:UseTrinkets();
                    -- Racials
                    if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                        -- Blood Fury
                        if BloodFury:Exists() and Player:CanCast(BloodFury) then
                            Player:Cast(BloodFury);
                        end
                        -- Berserking
                        if Berserking:Exists() and Player:CanCast(Berserking) then
                            CastSpellByID(26297, "player")
                        end
                        -- Arcane Torrent
                        if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Rage() < Player:RageMax() - 40 then
                            Player:Cast(ArcaneTorrent);
                        end
                    end
                end
                -- Avatar
                if Avatar:Exists() and module.IsOptionEnabled("Avatar") and (module.CooldownsAllowed() or module.GetOptionValue("Avatar") == "Always") and Player:CanCast(Avatar) then
                    Player:Cast(Avatar);
                    return;
                end
                -- Berserker Rage
                if BerserkerRage:Exists() and module.IsOptionEnabled("Berserker Rage") and (module.CooldownsAllowed() or module.GetOptionValue("Berserker Rage") == "Always") and Player:CanCast(BerserkerRage) then
                    Player:Cast(BerserkerRage);
                end
                -- Battle Cry
                if BattleCry:Exists() and module.IsOptionEnabled("Battle Cry") and (module.CooldownsAllowed() or module.GetOptionValue("Battle Cry") == "Always") and Player:CanCast(BattleCry) then
                    Player:Cast(BattleCry);
                end
            end
            -- Rotation
            -- Revenge
            if Revenge:Exists() and Player:IsWithinCastRange(Target, Devastate) and Player:CanCast(Revenge) then
                Player:Cast(Revenge);
                return;
            end
            -- Thunder Clap
            if ThunderClap:Exists() and module.IsOptionEnabled("Thunder Clap") and #Enemies_8y >= module.GetOptionValue("Thunder Clap") and Player:CanCast(ThunderClap) then
                Player:Cast(ThunderClap);
                return;
            end
            --  Shield Slam
            if ShieldSlam:Exists() and Target:CanCast(ShieldSlam) then
                Target:Cast(ShieldSlam);
                return;
            end
            -- -- Ravager
            -- if Ravager:Exists() and module.IsOptionEnabled("Ravager") and Target:CanCast(Ravager) then
            --  if Target:CastGroundSpell(Ravager, "Ravager", 6) then return; end
            -- end
            -- Neltharion's Fury
            if NeltharionsFury:Exists() and Player:Standing() > 0.5 and module.IsOptionEnabled("Neltharion's Fury") and ShockwaveUnits >= module.GetOptionValue("Neltharion's Fury") and Player:CanCast(NeltharionsFury) then
                Player:Cast(NeltharionsFury);
                return;
            end
            -- Revenge/Devastate - Deep Wounds
            if Player:IsWithinCastRange(Target, Devastate) and not Target:Debuff(DeepWounds) then
                if Revenge:Exists() and Player:CanCast(Revenge) then
                    Player:Cast(Revenge);
                    return;
                end
                if Devastate:Exists() and Target:CanCast(Devastate) then
                    Target:Cast(Devastate);
                    return;
                end
            end
            -- shockwave
            if Shockwave:Exists() and module.IsOptionEnabled("Shockwave") and ShockwaveUnits >= module.GetOptionValue("Shockwave") and Player:CanCast(Shockwave) then
                Player:Cast(Shockwave);
                return;
            end
            -- Storm Bolt
            if StormBolt:Exists() and module.IsOptionEnabled("Storm Bolt") and Target:CanCast(StormBolt) then
                Target:Cast(StormBolt);
                return;
            end
            -- Devastate
            if Devastate:Exists() and Target:CanCast(Devastate) then
                Target:Cast(Devastate);
                return;
            end
            -- Heroic Throw
            if HeroicThrow:Exists() and module.IsOptionEnabled("Heroic Throw") and not Player:IsWithinCastRange(Target, Devastate) and Target:CanCast(HeroicThrow) then
                Target:Cast(HeroicThrow);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(ShieldSlam, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Out Of Combat Intercept
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) and module.IsOptionEnabled("Auto Intercept Out Of Combat") and Player:DistanceTo(Target) >= 6.5 and ((BMPullTime() == 60 and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Intercept Out Of Combat")) or BMPullTime() <= module.GetSecondOptionValue("Pre-Pot BossMod")) and Player:IsFacing(Target) and Target:CanCast(Intercept) then
            Target:Cast(Intercept);
            return;
        end
    end
end)();
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- 1-10 Druid
    local Rotation = {};
    module.SetRotation("DRUID", Rotation);

    --- Localization
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle

    -- Rotation Logic
    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        --Racials
        Berserking = Spell(26297, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        CatForm = Spell(768, false, false, true);
        FerociousBite = Spell(22568, true, true, true);
        Rake = Spell(1822, true, true, true);
        RakeDebuff = Spell(155722);
        Shred = Spell(5221, true, true, true);

        -- GUI Frame
        -- Clear previous loaded rotation's options
        module.ClearOptions();
        module.ClearOutputs();

        -- Add pages
        module.AddPage("General Settings");

        -- Add options to pages
        AddAllClassOptions();

        module.AddSection("General Settings", "General", "Green");
        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Auto Engage Combat", 210, true, nil, nil, "Run the combat logic even when out of combat.");
        module.AddNewOption("General Settings", "Cat Form", 210, true, nil, nil, "Automatically Shapeshift into Cat Form.");

        if Berserking:Exists() then
            module.AddSection("General Settings", "Offensive Cooldowns", "Green");
            module.AddNewOption("General Settings", "Offensive Racials", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end

        module.AddSection("General Settings", "Defensive Items", "Green");
        module.AddNewOption("General Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end
        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(Shred, false) or Unit.Target;
    end

    function Rotation:Combat ()
        -- Cat Form
        if CatForm:Exists() and module.IsOptionEnabled("Cat Form") and not Player:Buff(CatForm) and Player:CanCast(CatForm) then
            Player:Cast(CatForm);
            return;
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:Buff(CatForm) and Player:CanAttack(Target) then
            if Player:IsWithinCastRange(Target, Shred) then
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                end
            end
            -- Ferocious Bite
            if FerociousBite:Exists() and Player:ComboPoints() >= 2 and Target:CanCast(FerociousBite) then
                Target:Cast(FerociousBite);
                return;
            end
            -- Rake
            if Rake:Exists() and not Target:Debuff(RakeDebuff) and Target:CanCast(Rake) then
                Target:Cast(Rake);
                return;
            end
            -- Shred
            if Shred:Exists() and Target:CanCast(Shred) then
                Target:Cast(Shred);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Shred, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end


    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Cat Form
        if CatForm:Exists() and module.IsOptionEnabled("Cat Form") and not Player:Buff(CatForm) and Player:CanCast(CatForm) then
            Player:Cast(CatForm);
            return;
        end
        -- Automatically Engage when enabled
        if module.IsOptionEnabled("Auto Engage Combat") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Level 1-10 Hunter
    local Rotation = {};
    module.SetRotation("HUNTER", Rotation);

    --- Localization
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle

    -- Rotation Logic
    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        --Racials
        ArcaneTorrent = Spell(80483, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        Berserking = Spell(26297, false, false, true);
        GiftOfTheNaaru = Spell(59543, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        CobraShot = Spell(193455, true, true, false);
        ConcussiveShot = Spell(5116, true, true, true);
        KillCommand = Spell(34026, false, true, true);

        -- Pet Manager section
        CallPets = {Spell(883, false, false, true),
                    Spell(83242, false, false, true),
                    Spell(83243, false, false, true),
                    Spell(83244, false, false, true),
                    Spell(83245, false, false, true)}
        MendPet = Spell(982, false, false, true);
        MendPetBuff = Spell(136, false, false, true);
        RevivePet = Spell(982, false, false, false);

        -- GUI Frame
        -- Clear previous loaded rotation's options
        module.ClearOptions();
        module.ClearOutputs();

        -- Add pages
        module.AddPage("General Settings");

        -- Add options to pages
        AddAllClassOptions();

        module.AddSection("General Settings", "General", "Green");
        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Auto Engage Combat", 210, true, nil, nil, "Run the combat logic even when out of combat.");
        module.AddNewOption("General Settings", "Auto Summon/Revive Pet", 222, true, {3, 1, 25, 0.5}, {1, 1, 1, 1}, "Automatically Whistle/Revive your Pet."..C.TOOLTIP_VALUE_1.." How long would you like to wait before using Whistle when your pet is dismissed."..C.TOOLTIP_VALUE_2.."Which pet you would like to auto summon? (Only 1 enabled for leveling 1-10)");

        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddSection("General Settings", "Offensive Cooldowns", "Green");
            module.AddNewOption("General Settings", "Offensive Racials", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end
        module.AddSection("General Settings", "Offensive Abilities", "Green");
        module.AddNewOption("General Settings", "Concussive Shot", 210, false, nil, nil, "Maintain Concussive Shot on our current target.");

        module.AddSection("General Settings", "Defensive Items", "Green");
        module.AddNewOption("General Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("General Settings", "Defensive Abilities", "Green");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("General Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("General Settings", "Mend Pet", 222, true, {35, 0, 100, 1}, {85, 0, 100, 1}, "Enable use of Mend Pet when pet health fall under threshold."..C.TOOLTIP_VALUE_1.."In combat threshold."..C.TOOLTIP_VALUE_2.."Out of combat threshold.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
    end


    -- Pet Manager
    local function ManagePet ()
        if module.IsOptionEnabled("Auto Summon/Revive Pet") and (InstantWhistle or module.PetDismissed + module.GetOptionValue("Auto Summon/Revive Pet") < module.GetTime()) then
            InstantWhistle = false;
            -- if whistle works, fine, otherwise blacklist it fro 5 second (usually should work fine with 1 attempt)
            if not PlayerPet:Exists() and module.GetTime() > TriedToSummonPet and Player:CanCast(CallPets[module.GetSecondOptionValue("Auto Summon/Revive Pet")]) then
                TriedToSummonPet = module.GetTime() + 5;
                Player:Cast(CallPets[module.GetSecondOptionValue("Auto Summon/Revive Pet")]);
                return;
            end
            -- if revive didnt work then we blacklist it 3 seconds (usually happens when user moves during resurrection cast)
            if not Player:IsMoving() and (not PlayerPet:Exists() or PlayerPet:IsDead()) and Player:CanCast(RevivePet) and module.GetTime() > TriedToResurrectPet then
                TriedToResurrectPet = module.GetTime() + 3;
                Player:Cast(MendPet);
                return;
            end
        end
        -- Mend Pet
        if PlayerPet:Exists() and module.IsOptionEnabled("Mend Pet") and Player:CanCast(MendPet) and not PlayerPet:Buff(MendPetBuff) and MendPet:TimeSinceCast() > 8 then
            if (Player:IsInCombat() and PlayerPet:HealthPercentage() <= module.GetOptionValue("Mend Pet")) or (not Player:IsInCombat() and PlayerPet:HealthPercentage() <= module.GetSecondOptionValue("Mend Pet")) then
                PlayerPet:Cast(MendPet);
                return;
            end
        end
    end

    function Rotation:Combat ()
        ManagePet();
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Concussive Shot
            if ConcussiveShot:Exists() and module.IsOptionEnabled("Concussive Shot") and Target:CanCast(ConcussiveShot) then
                Target:Cast(ConcussiveShot);
                return;
            end
            if Player:IsWithinCastRange(Target, CobraShot) then
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Focus() < Player:FocusMax() - 40 then
                        Player:Cast(ArcaneTorrent);
                    end
                end
            end
            -- Kill Command (10 - BM)
            if KillCommand:Exists() and Target:CanCast(KillCommand) and PlayerPet:Exists() and PlayerPetTarget:Exists() and not PlayerPet:IsDead() and CanKillCommand() and PlayerPet:DistanceTo(PlayerPetTarget) - PlayerPetTarget:CombatReach() < 20 then
                PlayerPetTarget:Cast(KillCommand);
                return;
            end
            -- Cobra Shot
            if CobraShot:Exists() and (Player:Focus() >= 80 or not KillCommand:Exists()) and Target:CanCast(CobraShot) then
                Target:Cast(CobraShot);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(CobraShot, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end


    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        ManagePet();
        -- Automatically Engage when enabled
        if module.IsOptionEnabled("Auto Engage Combat") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- 1-10 Mage
    local Rotation = {};
    module.SetRotation("MAGE", Rotation);

    --- Localization
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle

    -- Rotation Logic
    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        BloodFury = Spell(33702, false, false, true);
        Berserking = Spell(26297, false, false, true);
        GiftOfTheNaaru = Spell(59548, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        Frostbolt = Spell(116, true, true, false);
        IceLance = Spell(30455, true, true, true);

        -- GUI Frame
        -- Clear previous loaded rotation's options
        module.ClearOptions();
        module.ClearOutputs();

        -- Add pages
        module.AddPage("General Settings");

        -- Add options to pages
        AddAllClassOptions();

        module.AddSection("General Settings", "General", "Green");
        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Engage Combat", 210, true, nil, nil, "Run the combat logic even when out of combat.");

        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddSection("General Settings", "Offensive Cooldowns", "Green");
            module.AddNewOption("General Settings", "Offensive Racials", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end

        module.AddSection("General Settings", "Defensive Items", "Green");
        module.AddNewOption("General Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddSection("General Settings", "Defensive Abilities", "Green");
            module.AddNewOption("General Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
    end

    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            if Player:IsWithinCastRange(Target, Frostbolt) and not Player:IsMoving() then
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:PowerPercentage() < 95 then
                        Player:Cast(ArcaneTorrent);
                    end
                end
            end
            -- Frostbolt
            if Frostbolt:Exists() and Target:CanCast(Frostbolt) then
                Target:Cast(Frostbolt);
                return;
            end
            -- Ice Lance
            if IceLance:Exists() and Target:CanCast(IceLance) then
                Target:Cast(IceLance);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Frostbolt, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Automatically Engage when enabled
        if module.IsOptionEnabled("Auto Engage Combat") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- 1-10 Monk
    local Rotation = {};
    module.SetRotation("MONK", Rotation);

    --- Localization
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle

    -- Rotation Logic
    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        --Racials
        ArcaneTorrent = Spell(129597, false, false, true);
        BloodFury = Spell(33697, false, false, true);
        Berserking = Spell(26297, false, false, true);
        GiftOfTheNaaru = Spell(121093, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        BlackoutKick = Spell(100784, true, true, true);
        Effuse = Spell(166694, false, false, false);
        TigerPalm = Spell(100780, true, true, true);

        -- GUI Frame
        -- Clear previous loaded rotation's options
        module.ClearOptions();
        module.ClearOutputs();

        -- Add pages
        module.AddPage("General Settings");

        -- Add options to pages
        AddAllClassOptions();

        module.AddSection("General Settings", "General", "Green");
        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Auto Engage Combat", 210, true, nil, nil, "Run the combat logic even when out of combat.");

        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddSection("General Settings", "Offensive Cooldowns", "Green");
            module.AddNewOption("General Settings", "Offensive Racials", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end

        module.AddSection("General Settings", "Defensive Items", "Green");
        module.AddNewOption("General Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("General Settings", "Defensive Abilities", "Green");
        module.AddNewOption("General Settings", "Effuse", 220, true, {25, 1, 100, 1}, nil, "Use Effuse to heal ourself."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("General Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end
        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(TigerPalm, false) or Unit.Target;
    end

    function Rotation:Combat ()
        -- Effuse
        if Effuse:Exists() and module.IsOptionEnabled("Effuse") and Player:HealthPercentage() <= module.GetOptionValue("Effuse") and Player:CanCast(Effuse) then
            Player:Cast(Effuse);
            return;
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            if Player:IsWithinCastRange(Target, TigerPalm) then
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Chi() < 5 then
                        Player:Cast(ArcaneTorrent);
                    end
                end
            end
            -- Blackout Kick
            if BlackoutKick:Exists() and Player:Chi() >= 1 and Target:CanCast(BlackoutKick) then
                Target:Cast(BlackoutKick);
                return;
            end
            -- TigerPalm
            if TigerPalm:Exists() and Target:CanCast(TigerPalm) then
                Target:Cast(TigerPalm);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(TigerPalm, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end


    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Effuse
        if Effuse:Exists() and module.IsOptionEnabled("Effuse") and Player:HealthPercentage() <= module.GetOptionValue("Effuse") and Player:CanCast(Effuse) then
            Player:Cast(Effuse);
            return;
        end
        -- Automatically Engage when enabled
        if module.IsOptionEnabled("Auto Engage Combat") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- 1-10 Paladin
    local Rotation = {};
    module.SetRotation("PALADIN", Rotation);

    --- Localization
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle

    -- Rotation Logic
    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        --Racials
        GiftOfTheNaaru = Spell(59542, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        CrusaderStrike = Spell(35395, true, true, true);
        FlashOfLight = Spell(19750, false, false, false);
        Judgment = Spell(20271, false, true, true);

        -- GUI Frame
        -- Clear previous loaded rotation's options
        module.ClearOptions();
        module.ClearOutputs();

        -- Add pages
        module.AddPage("General Settings");

        -- Add options to pages
        AddAllClassOptions();

        module.AddSection("General Settings", "General", "Green");
        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Auto Engage Combat", 210, true, nil, nil, "Run the combat logic even when out of combat.");

        module.AddSection("General Settings", "Defensive Items", "Green");
        module.AddNewOption("General Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("General Settings", "Defensive Abilities", "Green");
        module.AddNewOption("General Settings", "Flash Of Light", 220, true, {25, 1, 100, 1}, nil, "Use Flash of Light to heal ourself."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("General Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end
        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(CrusaderStrike, false) or Unit.Target;
    end

    function Rotation:Combat ()
        -- Flash Of Light
        if FlashOfLight:Exists() and module.IsOptionEnabled("Flash Of Light") and Player:HealthPercentage() <= module.GetOptionValue("Flash Of Light") and Player:CanCast(FlashOfLight) then
            Player:Cast(FlashOfLight);
            return;
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Judgment
            if Judgment:Exists() and Target:CanCast(Judgment) then
                Target:Cast(Judgment);
                return;
            end
            -- Crusader Strike
            if CrusaderStrike:Exists() and Target:CanCast(CrusaderStrike) then
                Target:Cast(CrusaderStrike);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(CrusaderStrike, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end


    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Flash Of Light
        if FlashOfLight:Exists() and module.IsOptionEnabled("Flash Of Light") and Player:HealthPercentage() <= module.GetOptionValue("Flash Of Light") and Player:CanCast(FlashOfLight) then
            Player:Cast(FlashOfLight);
            return;
        end
        -- Automatically Engage when enabled
        if module.IsOptionEnabled("Auto Engage Combat") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- 1-10 Priest
    local Rotation = {};
    module.SetRotation("PRIEST", Rotation);

    --- Localization
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle

    -- Rotation Logic
    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        Berserking = Spell(26297, false, false, true);
        GiftOfTheNaaru = Spell(59544, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        Pain = Spell(589, false, true, true);
        Plea = Spell(200829, false, false, true);
        Shield = Spell(17, false, false, true);
        Smite = Spell(585, true, true, false);

        -- GUI Frame
        -- Clear previous loaded rotation's options
        module.ClearOptions();
        module.ClearOutputs();

        -- Add pages
        module.AddPage("General Settings");

        -- Add options to pages
        AddAllClassOptions();

        module.AddSection("General Settings", "General", "Green");
        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Engage Combat", 210, true, nil, nil, "Run the combat logic even when out of combat.");

        if ArcaneTorrent:Exists() or Berserking:Exists() then
            module.AddSection("General Settings", "Offensive Cooldowns", "Green");
            module.AddNewOption("General Settings", "Offensive Racials", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end

        module.AddSection("General Settings", "Defensive Items", "Green");
        module.AddNewOption("General Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("General Settings", "Defensive Abilities", "Green");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("General Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("General Settings", "Plea", 220, true, {60, 1, 100, 1}, nil, "Use Plea to heal ourself."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddNewOption("General Settings", "Power Word: Shield", 220, true, {25, 1, 100, 1}, nil, "Use Power Word: Shield on ourself."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
    end

    function Rotation:Combat ()
        if Player:IsInCombat() then
            -- Shield
            if Shield:Exists() and module.IsOptionEnabled("Power Word: Shield") and Player:HealthPercentage() <= module.GetOptionValue("Power Word: Shield") and Player:CanCast(Shield) then
                Player:Cast(Shield);
                return;
            end
        end
        -- Plea
        if Plea:Exists() and module.IsOptionEnabled("Plea") and Player:HealthPercentage() <= module.GetOptionValue("Plea") and Player:CanCast(Plea) then
            Player:Cast(Plea);
            return;
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            if Player:IsWithinCastRange(Target, Smite) and not Player:IsMoving() then
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:ManaPercentage() < 95 then
                        Player:Cast(ArcaneTorrent);
                    end
                end
            end
            -- Pain
            if Pain:Exists() and not Target:Debuff(Pain) and Target:CanCast(Pain) then
                Target:Cast(Pain);
                return;
            end
            -- Smite
            if Smite:Exists() and Target:CanCast(Smite) then
                Target:Cast(Smite);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Smite, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end


    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Plea
        if Plea:Exists() and module.IsOptionEnabled("Plea") and Player:HealthPercentage() <= module.GetOptionValue("Plea") and Player:CanCast(Plea) then
            Player:Cast(Plea);
            return;
        end
        -- Automatically Engage when enabled
        if module.IsOptionEnabled("Auto Engage Combat") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- 1-10 Rogue
    local Rotation = {};
    module.SetRotation("ROGUE", Rotation);

    --- Localization
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle

    -- Rotation Logic
    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        --Racials
        ArcaneTorrent = Spell(25046, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        Berserking = Spell(26297, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        Envenom = Spell(32645, true, true, true);
        Mutilate = Spell(1329, true, true, true);
        Evasion = Spell(5277, false, false, true);
        DeadlyPoison = Spell(2823, false, false, false);

        -- GUI Frame
        -- Clear previous loaded rotation's options
        module.ClearOptions();
        module.ClearOutputs();

        -- Add pages
        module.AddPage("General Settings");

        -- Add options to pages
        AddAllClassOptions();

        module.AddSection("General Settings", "General", "Green");
        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Auto Engage Combat", 210, true, nil, nil, "Run the combat logic even when out of combat.");

        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddSection("General Settings", "Offensive Cooldowns", "Green");
            module.AddNewOption("General Settings", "Offensive Racials", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end

        module.AddSection("General Settings", "Defensive Items", "Green");
        module.AddNewOption("General Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("General Settings", "Defensive Abilities", "Green");
        module.AddNewOption("General Settings", "Evasion", 220, true, {30, 1, 100, 1}, nil, "Use Evasion."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end
        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Evasion
        if Evasion:Exists() and module.IsOptionEnabled("Evasion") and Player:HealthPercentage() <= module.GetOptionValue("Evasion") and Player:CanCast(Evasion) then
            Player:Cast(Evasion);
        end
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(Mutilate, false) or Unit.Target;
    end

    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            if Player:IsWithinCastRange(Target, Mutilate) then
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Energy() < Player:EnergyMax() - 25 then
                        Player:Cast(ArcaneTorrent);
                    end
                end
            end
            -- Envenom
            if Envenom:Exists() and Player:ComboPoints() >= 3 and Target:CanCast(Envenom) then
                Target:Cast(Envenom);
                return;
            end
            -- Mutilate
            if Mutilate:Exists() and Target:CanCast(Mutilate) then
                Target:Cast(Mutilate);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Mutilate, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end


    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Deadly Poison
        if DeadlyPoison:Exists() and not Player:Buff(DeadlyPoison) and DeadlyPoison:TimeSinceCast() >= 5 and Player:CanCast(DeadlyPoison) then
            DeadlyPoison.LastCastTime = module.GetTime();
            Player:Cast(DeadlyPoison);
            return;
        end
        -- Automatically Engage when enabled
        if module.IsOptionEnabled("Auto Engage Combat") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- 1-10 Shaman
    local Rotation = {};
    module.SetRotation("SHAMAN", Rotation);

    --- Localization
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle

    -- Rotation Logic
    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        --Racials
        BloodFury = Spell(33697, false, false, true);
        Berserking = Spell(26297, false, false, true);
        GiftOfTheNaaru = Spell(59547, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        EarthShock = Spell(8042, true, true, true);
        FlameShock = Spell(188389, true, true, true);
        HealingSurge = Spell(8004, false, false, false);
        LightningBolt = Spell(188196, true, true, false);

        -- GUI Frame
        -- Clear previous loaded rotation's options
        module.ClearOptions();
        module.ClearOutputs();

        -- Add pages
        module.AddPage("General Settings");

        -- Add options to pages
        AddAllClassOptions();

        module.AddSection("General Settings", "General", "Green");
        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Engage Combat", 210, true, nil, nil, "Run the combat logic even when out of combat.");

        if Berserking:Exists() or BloodFury:Exists() then
            module.AddSection("General Settings", "Offensive Cooldowns", "Green");
            module.AddNewOption("General Settings", "Offensive Racials", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end

        module.AddSection("General Settings", "Defensive Items", "Green");
        module.AddNewOption("General Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        module.AddSection("General Settings", "Defensive Abilities", "Green");
        if GiftOfTheNaaru:Exists() then
            module.AddNewOption("General Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end
        module.AddNewOption("General Settings", "Healing Surge", 220, true, {25, 1, 100, 1}, nil, "Use Healing Surge to heal ourself."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
    end

    function Rotation:Combat ()
        -- Healing Surge
        if HealingSurge:Exists() and module.IsOptionEnabled("Healing Surge") and Player:HealthPercentage() <= module.GetOptionValue("Healing Surge") and Player:CanCast(HealingSurge) then
            Player:Cast(HealingSurge);
            return;
        end
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            if Player:IsWithinCastRange(Target, LightningBolt) and not Player:IsMoving() then
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                end
            end
            -- Flame Shock
            if FlameShock:Exists() and not Target:Debuff(FlameShock) and Target:CanCast(FlameShock) then
                Target:Cast(FlameShock);
                return;
            end
            -- Earth Shock
            if EarthShock:Exists() and Player:Maelstrom() >= 10 and Target:CanCast(EarthShock) then
                Target:Cast(EarthShock);
                return;
            end
            -- Lightning Bolt
            if LightningBolt:Exists() and Target:CanCast(LightningBolt) then
                Target:Cast(LightningBolt);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(LightningBolt, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end


    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        -- Healing Surge
        if HealingSurge:Exists() and module.IsOptionEnabled("Healing Surge") and Player:HealthPercentage() <= module.GetOptionValue("Healing Surge") and Player:CanCast(HealingSurge) then
            Player:Cast(HealingSurge);
            return;
        end
        -- Automatically Engage when enabled
        if module.IsOptionEnabled("Auto Engage Combat") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- 1-10 Warlock
    local Rotation = {};
    module.SetRotation("WARLOCK", Rotation);

    --- Localization
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle
    -- Pet Manager
    local PetTimer = 0;

    -- Rotation Logic
    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        --Racials
        ArcaneTorrent = Spell(28730, false, false, true);
        BloodFury = Spell(33702, false, false, true);
        Berserking = Spell(26297, false, false, true);
        Healthstone = Item(5512, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        Agony = Spell(980, false, true, true);
        Corruption = Spell(172, false, true, true);
        CorruptionDebuff = Spell(146739);
        CreateHealthstone = Spell(6201, false, false, false);
        DrainLife = Spell(689, true, true, false);

        SummonImp = Spell(688, false, false, false);

        -- GUI Frame
        -- Clear previous loaded rotation's options
        module.ClearOptions();
        module.ClearOutputs();

        -- Add pages
        module.AddPage("General Settings");

        -- Add options to pages
        AddAllClassOptions();

        module.AddSection("General Settings", "General", "Green");
        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Engage Combat", 210, true, nil, nil, "Run the combat logic even when out of combat.");
        module.AddSection("General Settings", "Demons Management", "Green");
        module.AddNewOption("General Settings", "Demon Manager", 210, true, nil, nil, "Enable summoning our Imp.")

        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddSection("General Settings", "Offensive Cooldowns", "Green");
            module.AddNewOption("General Settings", "Offensive Racials", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end

        module.AddSection("General Settings", "Defensive Items", "Green");
        module.AddNewOption("General Settings", "Create Healthstones", 210, true, nil, nil, "Will create you a new healthstone if you have none in your bags and are out of combat.");
        module.AddNewOption("General Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");

        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end

        if Player:IsInCombat() then
            self:Defensives();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
    end

    local function PetsManager ()
        -- Resurrect Pet
        if not Player:IsMoving() and module.IsOptionEnabled("Demon Manager") and (not PlayerPet:Exists() or PlayerPet:IsDeadOrGhost()) and Player:SoulShards() >= 1 then
            if module.GetTime() - PetTimer >= 1 and Player:CanCast(SummonImp) then
                PetTimer = module.GetTime() + 2.5;
                Player:Cast(SummonImp);
                return;
            end
        end
    end

    function Rotation:Combat ()
        PetsManager();
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            if Player:IsWithinCastRange(Target, DrainLife) and not Player:IsMoving() then
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:PowerPercentage() < 95 then
                        Player:Cast(ArcaneTorrent);
                    end
                end
            end
            -- Agony
            if Agony:Exists() and not Target:Debuff(Agony) and Target:CanCast(Agony) then
                Target:Cast(Agony);
                return;
            end
            -- Corruption
            if Corruption:Exists() and not Target:Debuff(CorruptionDebuff) and Target:CanCast(Corruption) then
                Target:Cast(Corruption);
                return;
            end
            -- Drain Life
            if DrainLife:Exists() and not Player:IsMoving() and Target:CanCast(DrainLife) then
                Target:Cast(DrainLife);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(DrainLife, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end

    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        PetsManager();
        -- Create Healthstones
        if CreateHealthstone:Exists() and module.IsOptionEnabled("Create Healthstones") and Player:Standing() > 0.25 then
            if not Healthstone:InStock() and CreateHealthstone:TimeSinceCast() >= module.GetTime() + 5 and Player:CanCast(CreateHealthstone) then
                CreateHealthstone.LastCastTime = module.GetTime();
                Player:Cast(CreateHealthstone);
                return;
            end
        end
        -- Automatically Engage when enabled
        if module.IsOptionEnabled("Auto Engage Combat") then
            self:Combat();
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- 1-10 Warrior
    local Rotation = {};
    module.SetRotation("WARRIOR", Rotation);

    --- Localization
    local SpamPrevention, TPSTime, RefreshEnemies = 0, 0.1, 0; -- Combat Module Throttle

    -- Rotation Logic
    --- Initialize the rotation's variables.
    function Rotation:Initialize ()
        module.UpdateSettings();

        --Racials
        ArcaneTorrent = Spell(69179, false, false, true);
        BloodFury = Spell(20572, false, false, true);
        Berserking = Spell(26297, false, false, true);
        GiftOfTheNaaru = Spell(28880, false, false, true);

        -- (ID, RequiresFacing, Hostile, instant)
        Charge = Spell(100, true, true, true);
        Execute = Spell(163201, true, true, true);
        MortalStrike = Spell(12294, true, true, true);
        Slam = Spell(1464, true, true, true);

        -- GUI Frame
        -- Clear previous loaded rotation's options
        module.ClearOptions();
        module.ClearOutputs();

        -- Add pages
        module.AddPage("General Settings");

        -- Add options to pages
        AddAllClassOptions();

        module.AddSection("General Settings", "General", "Green");
        module.AddNewOption("General Settings", "Target | Attack", 133, true, {4, "Disabled", "Closest", "Least HP", "Most HP", "Target Closest"}, {2, "Disabled", "Enabled"}, "Automatically Target the next available enemy during combat if we have no target or the current target dies. Use the dropdown to select your preferred mode.\nThen choose wether you want or not to /startattack your target."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Closest", true).."Target the closest enemy."..C.TOOLTIP_SUBVALUE("Least HP").."Target the enemy with the least health remaining."..C.TOOLTIP_SUBVALUE("Most HP").."Target the enemy with the most health remaining."..C.TOOLTIP_SUBVALUE("Target Closest").."Target the Enemy which is closest to our actual dead target. If we do not have a dead target, it will target the unit with the most health remaining."..C.TOOLTIP_VALUE_2.."Enable for the automatic usage of /startattack."..C.TOOLTIP_HINT("/startattack is good for melee classes."));
        module.AddNewOption("General Settings", "Auto Re-Target", 232, true, {1, "Keep", "Switch"}, {5, 5, 30, 1}, "Enable to auto re-target an unit if you target go out the range set and there is an unit in your melee range."..C.TOOLTIP_VALUE_1..C.TOOLTIP_SUBVALUE("Keep", true).."Cast on the new unit but keep your target the same."..C.TOOLTIP_SUBVALUE("Switch").."Cast on the new unit and change your target to this unit."..C.TOOLTIP_VALUE_2.."Set the range from wich you want to re-target.");
        module.AddNewOption("General Settings", "Auto Engage Combat", 210, true, nil, nil, "Run the combat logic even when out of combat.");
        module.AddNewOption("General Settings", "Auto Charge Combat", 220, false, {15, 6.5, 22, 0.5}, nil, "Distance away from the target to auto use charge while in combat");
        module.AddNewOption("General Settings", "Auto Charge Out Of Combat", 220, false, {15, 6.5, 22, 0.5}, nil, "Distance away from the target to auto use charge while not in combat");

        if ArcaneTorrent:Exists() or Berserking:Exists() or BloodFury:Exists() then
            module.AddSection("General Settings", "Offensive Cooldowns", "Green");
            module.AddNewOption("General Settings", "Offensive Racials", 230, true, {1, "Always", "Cooldown Only"}, nil, "Enable for the automatic usage of Racials."..C.TOOLTIP_VALUE..C.TOOLTIP_SUBVALUE("Always", true).."Will use the ability even if CDs are disabled."..C.TOOLTIP_SUBVALUE("Cooldown Only").."Will only use the ability if CDs are enabled.");
        end

        module.AddSection("General Settings", "Defensive Items", "Green");
        module.AddNewOption("General Settings", "Healing Item", 220, true, {35, 1, 95, 1}, nil, "Use Healing Belt / Healing Pot / Healthstone."..C.TOOLTIP_VALUE.."Health threshold.");
        if GiftOfTheNaaru:Exists() then
            module.AddSection("General Settings", "Defensive Abilities", "Green");
            module.AddNewOption("General Settings", "Gift Of The Naaru", 220, true, {50, 1, 100, 1}, nil, "Use Gift Of The Naaru."..C.TOOLTIP_VALUE.."Health threshold.");
        end

        -- Status Frame
        Player:AddCommonMeleeStatus();
        -- Time Throttle Computing
        TPSTime = module.GetTPSTime();
    end

    --- Run the rotation's logic.
    function Rotation:Pulse ()
        if not Player:IsReady() or Player:IsMounted() or Player:InVehicle() or Player:IsEating() then
            return;
        end
        -- Put the Outputs here that we want to keep updated.
        Player:SetCommonMeleeStatus();

        -- Reset the target for the Auto Re-Target Option.
        Target = Unit.Target;

        if Player:IsInCombat() then
            self:Defensives();
            self:OffGCDAbilities();
            if module.GlobalCooldown() and module.GetTime() >= SpamPrevention then
                SpamPrevention = module.GetTime() + TPSTime;
                self:Combat();
            end
        elseif module.GetTime() >= SpamPrevention then
            SpamPrevention = module.GetTime() + TPSTime;
            self:OutOfCombat();
        end
    end

    --- Run the rotation's defensive logic.
    function Rotation:Defensives ()
        -- Defensive Items
        Player:UseHealingItem();
        -- Gift Of The Naaru
        if GiftOfTheNaaru:Exists() and module.IsOptionEnabled("Gift Of The Naaru") and Player:HealthPercentage() <= module.GetOptionValue("Gift Of The Naaru") and Player:CanCast(GiftOfTheNaaru) then
            Player:Cast(GiftOfTheNaaru);
            return;
        end
    end

    --- Run the rotation's off gcd combat logic.
    function Rotation:OffGCDAbilities ()
        -- Auto Target
        Target = Player:ReTarget(Slam, false) or Unit.Target;
    end

    function Rotation:Combat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Combat Charge
            if Charge:Exists() and module.IsOptionEnabled("Auto Charge Combat") and Player:DistanceTo(Target) >= 6.5 and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Charge Combat") and Target:CanCast(Charge) then
                Target:Cast(Charge);
                return;
            end
            if Player:IsWithinCastRange(Target, Slam) then
                -- Racials
                if module.IsOptionEnabled("Offensive Racials") and (module.CooldownsAllowed() or module.GetOptionValue("Offensive Racials") == "Always") then
                    -- Blood Fury
                    if BloodFury:Exists() and Player:CanCast(BloodFury) then
                        Player:Cast(BloodFury);
                    end
                    -- Berserking
                    if Berserking:Exists() and Player:CanCast(Berserking) then
                        Player:Cast(Berserking);
                    end
                    -- Arcane Torrent
                    if ArcaneTorrent:Exists() and Player:CanCast(ArcaneTorrent) and Player:Rage() < Player:RageMax() - 40 then
                        Player:Cast(ArcaneTorrent);
                    end
                end
            end
            -- Execute
            if Execute:Exists() and Player:Rage() >= 10 and Target:HealthPercentage() < 20 and Target:CanCast(Execute) then
                Target:Cast(Execute);
                return;
            end
            -- Mortal Strike
            if MortalStrike:Exists() and Player:Rage() >= 20 and Target:CanCast(MortalStrike) then
                Target:Cast(MortalStrike);
                return;
            end
            -- Slam
            if Slam:Exists() and Target:CanCast(Slam) then
                Target:Cast(Slam);
                return;
            end
        end
        -- Find New Target
        if (not Target:Exists() or Target:IsDead()) and module.GetOptionValue("Target | Attack") ~= "Disabled" then
            local NewTargetUnit = Unit.AutoTarget(Slam, module.GetOptionValue("Target | Attack"));
            if NewTargetUnit then
                NewTargetUnit:Attack();
                return;
            end
        end
    end


    --- Run the rotation's out of combat logic.
    function Rotation:OutOfCombat ()
        if Target:Exists() and not Target:IsDeadOrGhost() and Player:CanAttack(Target) then
            -- Out Of Combat Charge
            if Charge:Exists() and module.IsOptionEnabled("Auto Charge Out Of Combat") and Player:DistanceTo(Target) >= 6.5 and Player:DistanceTo(Target) <= module.GetOptionValue("Auto Charge Out Of Combat") and Target:CanCast(Charge) then
                Target:Cast(Charge);
                return;
            end
        end
        -- Automatically Engage when enabled
        if module.IsOptionEnabled("Auto Engage Combat") then
            self:Combat();
        end
    end
end)();
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function()
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function()
    (function()
        local stringLen = string.len

        local log_height = 18
        local log_items = 10
        local abs_height = log_height * log_items + log_height
        local delta = 0
        Soapbox_ActionLog = CreateFrame("Frame", "SB_ActionLog", UIParent)
        local ActionLog = Soapbox_ActionLog
        ActionLog.show = false
        ActionLog:SetFrameLevel(90)
        ActionLog:SetWidth(430)
        ActionLog:SetHeight(abs_height)
        ActionLog:SetPoint("CENTER", UIParent)
        ActionLog:SetFrameStrata("MEDIUM");
        ActionLog:SetMovable(true)
        ActionLog:EnableMouseWheel(true)
        ActionLog:SetClampedToScreen(true);

        local Backdrop = {
          bgFile = "Interface\\DialogFrame\\UI-DialogBox-Background",
          tileSize = 32,
          edgeFile = "Interface\\FriendsFrame\\UI-Toast-Border",
          tile = 1,
          edgeSize = 3,
          insets = {
            top = 1,
            right = 1,
            left = 1,
            bottom = 1,
          },
        };

        ActionLog:SetBackdrop(Backdrop);

        local ActionLog_texture = ActionLog:CreateTexture(nil, "BACKGROUND")
        ActionLog_texture:SetTexture(0,0,0,0.9)
        ActionLog_texture:SetAllPoints(ActionLog)
        ActionLog.texture = ActionLogHeader_texture

        ActionLog:SetScript("OnMouseDown", function(self, button)
          if not self.isMoving then
           self:StartMoving()
           self.isMoving = true
          end
        end)
        ActionLog:SetScript("OnMouseUp", function(self, button)
          if self.isMoving then
           self:StopMovingOrSizing()
           self.isMoving = false
          end
        end)
        ActionLog:SetScript("OnHide", function(self)
          if self.isMoving then
           self:StopMovingOrSizing()
           self.isMoving = false
          end
        end)
        ActionLog:SetScript("OnMouseWheel", function(self, mouse)
          local top = #module.actionLog.log - log_items

          if IsShiftKeyDown() then
            if mouse == 1 then
              delta = top
            elseif mouse == -1 then
              delta = 0
            end
          else
            if mouse == 1 then
              if delta < top then
                delta = delta + mouse
              end
            elseif mouse == -1 then
              if delta > 0 then
                delta = delta + mouse
              end
            end
          end

          module.actionLog.update()
        end)


        local ActionLogDivA = CreateFrame("Frame", nil , Soapbox_ActionLog)
        ActionLogDivA:SetFrameLevel(99)
        ActionLogDivA:SetWidth(1)
        ActionLogDivA:SetHeight(abs_height)
        ActionLogDivA:SetPoint("LEFT", Soapbox_ActionLog, 125, 0)
        ActionLogDivA:SetMovable(true)

        local ActionLogDivA_texture = ActionLogDivA:CreateTexture(nil, "BACKGROUND")
        ActionLogDivA_texture:SetTexture(0,0,0,0.5)
        ActionLogDivA_texture:SetAllPoints(ActionLogDivA)
        ActionLogDivA.texture = ActionLogDivA_texture

        local ActionLogDivB = CreateFrame("Frame", nil , Soapbox_ActionLog)
        ActionLogDivB:SetFrameLevel(99)
        ActionLogDivB:SetWidth(1)
        ActionLogDivB:SetHeight(abs_height)
        ActionLogDivB:SetPoint("LEFT", Soapbox_ActionLog, 375, 0)
        ActionLogDivB:SetMovable(true)

        local ActionLogDivB_texture = ActionLogDivB:CreateTexture(nil, "BACKGROUND")
        ActionLogDivB_texture:SetTexture(0,0,0,0.5)
        ActionLogDivB_texture:SetAllPoints(ActionLogDivB)
        ActionLogDivB.texture = ActionLogDivB_texture


        Soapbox_ActionLog:Hide()

        local ActionLogHeader = CreateFrame("Frame", nil, Soapbox_ActionLog)
        ActionLogHeader:SetFrameLevel(92)
        ActionLogHeader:SetHeight(20)
        ActionLogHeader:SetPoint("TOPLEFT", Soapbox_ActionLog, "TOPLEFT")
        ActionLogHeader:SetPoint("TOPRIGHT", Soapbox_ActionLog, "TOPRIGHT")
        ActionLogHeader:SetBackdrop(Backdrop);
        ActionLogHeader:SetBackdropColor(0, 0, 0, 1);
        local ActionLogHeader_texture = ActionLogHeader:CreateTexture(nil, "BACKGROUND")
        ActionLogHeader_texture:SetTexture(0.15,0.15,0.15,1)
        ActionLogHeader_texture:SetGradient("VERTICAL", 0.8,0.8,0.8, 0,0,0)
        ActionLogHeader_texture:SetAllPoints(ActionLogHeader)
        ActionLogHeader.texture = ActionLogHeader_texture

        ActionLogHeader.statusTextA = ActionLogHeader:CreateFontString('SB_ActionLogHeaderText')
        ActionLogHeader.statusTextA:SetFont("Fonts\\ARIALN.TTF", 12)
        ActionLogHeader.statusTextA:SetPoint("LEFT", ActionLogHeader, 5, -1)
        ActionLogHeader.statusTextA:SetText("Action")

        ActionLogHeader.statusTextB = ActionLogHeader:CreateFontString('SB_ActionLogHeaderText')
        ActionLogHeader.statusTextB:SetFont("Fonts\\ARIALN.TTF", 12)
        ActionLogHeader.statusTextB:SetPoint("LEFT", ActionLogHeader, 130, -1)
        ActionLogHeader.statusTextB:SetText("Description")

        ActionLogHeader.statusTextC = ActionLogHeader:CreateFontString('SB_ActionLogHeaderText')
        ActionLogHeader.statusTextC:SetFont("Fonts\\ARIALN.TTF", 12)
        ActionLogHeader.statusTextC:SetPoint("LEFT", ActionLogHeader, 380, -1)
        ActionLogHeader.statusTextC:SetText("Time")
        --TitleBar.CloseButton = CreateFrame("Button", nil, TitleBar, "UIPanelCloseButton");
        local ActionLogClose = CreateFrame("Button", "SB_TrackerClose", Soapbox_ActionLog, "UIPanelCloseButton")
        ActionLogClose:SetFrameLevel(93)
        --ActionLogClose:SetHeight(100)
        ActionLogClose:SetWidth(26)
        ActionLogClose:SetHeight(26)
        ActionLogClose:SetPoint("TOPRIGHT", ActionLogHeader, 2, 2)

        ActionLogClose.statusText = ActionLogHeader:CreateFontString('SB_ActionLogCloseX')
        ActionLogClose.statusText:SetFont("Fonts\\ARIALN.TTF", 20)ActionLogClose.statusText:SetPoint("CENTER", ActionLogClose)
        --ActionLogClose.statusText:SetText("UIPanelCloseButton")

        ActionLogClose:SetScript("OnMouseUp", function(self, button)
          Soapbox_ActionLog:Hide()
        end)

        local ActionLogItem = { }

        for i = 1, (log_items) do

          ActionLogItem[i] = CreateFrame("Frame", nil, Soapbox_ActionLog)
          ActionLogItem[i]:SetFrameLevel(94)
          local texture = ActionLogItem[i]:CreateTexture(nil, "BACKGROUND")
          texture:SetAllPoints(ActionLogItem[i])

          if (i % 2) == 1 then
            texture:SetTexture(0.15,0.15,0.15,1)
          else
            texture:SetTexture(0.1,0.1,0.1,1)
          end

          ActionLogItem[i].texture = texture


          ActionLogItem[i]:SetHeight(log_height)
          ActionLogItem[i]:SetPoint("LEFT", Soapbox_ActionLog, "LEFT")
          ActionLogItem[i]:SetPoint("RIGHT", Soapbox_ActionLog, "RIGHT")


          ActionLogItem[i].itemA = ActionLogItem[i]:CreateFontString('itemA')
          ActionLogItem[i].itemA:SetFont("Fonts\\ARIALN.TTF", 12)
          ActionLogItem[i].itemA:SetShadowColor(0,0,0, 0.8)
          ActionLogItem[i].itemA:SetShadowOffset(-1,-1)
          ActionLogItem[i].itemA:SetPoint("LEFT", ActionLogItem[i], 5, 0)

          ActionLogItem[i].itemB = ActionLogItem[i]:CreateFontString('itemA')
          ActionLogItem[i].itemB:SetFont("Fonts\\ARIALN.TTF", 12)
          ActionLogItem[i].itemB:SetShadowColor(0,0,0, 0.8)
          ActionLogItem[i].itemB:SetShadowOffset(-1,-1)
          ActionLogItem[i].itemB:SetPoint("LEFT", ActionLogItem[i], 130, 0)

          ActionLogItem[i].itemC = ActionLogItem[i]:CreateFontString('itemA')
          ActionLogItem[i].itemC:SetFont("Fonts\\ARIALN.TTF", 12)
          ActionLogItem[i].itemC:SetShadowColor(0,0,0, 0.8)
          ActionLogItem[i].itemC:SetShadowOffset(-1,-1)
          ActionLogItem[i].itemC:SetPoint("LEFT", ActionLogItem[i], 380, 0)


          local position = ((i * log_height) * -1)
          ActionLogItem[i]:SetPoint("TOPLEFT", Soapbox_ActionLog, "TOPLEFT", 0, position)

        end


        module.actionLog = {
          log = {}
        }

        module.actionLog.insert = function(type, spell, spellIcon, target)
          if spellIcon then
            if module.actionLog.log[1] and module.actionLog.log[1]['event'] == type and module.actionLog.log[1]['description'] == spell and module.actionLog.log[1]['target'] == target then
              module.actionLog.log[1]['count'] = module.actionLog.log[1]['count'] + 1
            else
              table.insert(module.actionLog.log, 1, {
                event = type,
                target = target or '',
                icon = spellIcon,
                description = spell,
                count = 1,
                time = date("%H:%M:%S")
              })

              if delta > 0 and delta < #module.actionLog.log - log_items then
                delta = delta + 1
              end
            end
          end
        end

        module.actionLog.updateRow = function (row, a, b, c)
          ActionLogItem[row].itemA:SetText(a)
          ActionLogItem[row].itemB:SetText(b)
          ActionLogItem[row].itemC:SetText(c)
        end

        module.actionLog.update = function ()
          local offset = 0
          for i = log_items, 1, -1 do
            offset = offset + 1
            local item = module.actionLog.log[offset + delta]
            if not item then
              module.actionLog.updateRow(i, '', '', '')
            else
              local target = stringLen(item.target) > 0 and ' @ (' .. item.target .. ')' or ''
              module.actionLog.updateRow(i, item.event, 'x' .. item.count .. ' ' .. '|T' .. item.icon .. ':-1:-1:0:0|t' .. item.description .. target, item.time)
            end
          end
        end

        module.timer.register("updateActionLog", function()
          if not Soapbox_ActionLog:IsShown() then return end

          module.actionLog.update()
        end, 100)
    end)();

    module:SetScript("OnShow",
        function (self)
            module.SetSetting("Visible", true);
        end
    );

    module:SetScript("OnHide",
        function (self)
            module.SetSetting("Visible", false);
        end
    );

    -- Chat commands
    --- Function used when the Command is used (or via the Toolbox button).
    function module.AlCmd ()
        local Visible = not Soapbox_ActionLog:IsVisible();
        if Visible then
            Soapbox_ActionLog:Show();
        else
            Soapbox_ActionLog:Hide();
        end

        module.Print("The action log is now", Visible and "|cFF00FF00shown.|r" or "|cFFFF0000hidden.|r");
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Defines the Debug frame.
    module.DebugFrame = CreateFrame("Frame");
    local DebugFrame = module.DebugFrame;
    local Spacing = 14;
    local Target = Target;
    local Player = module.Player;

    DebugFrame:ClearAllPoints();

    DebugFrame:SetHeight(35);
    DebugFrame:SetWidth(205);
    DebugFrame:SetPoint(module.GetSetting("DebugFrameAnchorPoint") or "CENTER", module.GetSetting("DebugFrameX") or 0, module.GetSetting("DebugFrameY") or 0);
    DebugFrame:SetFrameStrata("MEDIUM");
    DebugFrame:SetClampedToScreen(true);
    DebugFrame:SetMovable(true);
    DebugFrame:EnableMouse(true);

    local Backdrop = {
        bgFile = "Interface\\DialogFrame\\UI-DialogBox-Background",
        tileSize = 32,
        edgeFile = "Interface\\FriendsFrame\\UI-Toast-Border",
        tile = 1,
        edgeSize = 3,
        insets = {
            top = 1,
            right = 1,
            left = 1,
            bottom = 1,
        },
    };

    DebugFrame:SetBackdrop(Backdrop);

    DebugFrame:SetScript("OnShow",
        function (self)
            module.SetSetting("DebugFrameVisible", true);
        end
    );

    DebugFrame:SetScript("OnHide",
        function (self)
            module.SetSetting("DebugFrameVisible", false);
        end
    );

    -- Title Bar
    DebugFrame.TitleBar = CreateFrame("Frame", nil, DebugFrame);
    local TitleBar = DebugFrame.TitleBar;
    TitleBar:SetPoint("TOPLEFT", 1, -1);
    TitleBar:SetPoint("TOPRIGHT", -1, -1);
    TitleBar:SetHeight(16);
    Backdrop.edgeSize = 2;
    Backdrop.insets.bottom = 1;
    TitleBar:SetBackdrop(Backdrop);
    TitleBar:SetBackdropColor(0, 0, 0, 1);

    TitleBar:SetScript("OnMouseDown",
        function (self)
            DebugFrame:StartMoving();
        end
    );

    TitleBar:SetScript("OnMouseUp",
        function (self)
            DebugFrame:StopMovingOrSizing();

            local Point, RelativeTo, RelativePoint, X, Y = DebugFrame:GetPoint();
            module.SetSetting("DebugFrameAnchorPoint", Point);
            module.SetSetting("DebugFrameX", X);
            module.SetSetting("DebugFrameY", Y);
        end
    );

    -- Title Bar Text
    DebugFrame.TitleBarText = TitleBar:CreateFontString();
    local TitleBarText = DebugFrame.TitleBarText;
    TitleBarText:SetAllPoints(TitleBar);
    TitleBarText:SetFont("Fonts\\FRIZQT__.TTF", 9, "OUTLINE");
    TitleBarText:SetText("DebugFrame");
    TitleBarText:SetJustifyH("CENTER");

    -- Title Bar Close Button
    TitleBar.CloseButton = CreateFrame("Button", nil, TitleBar, "UIPanelCloseButton");
    local CloseButton = TitleBar.CloseButton;
    CloseButton:SetPoint("TOPRIGHT", 1, 1);
    CloseButton:SetHeight(18);
    CloseButton:SetWidth(18);
    CloseButton:SetScript("OnClick",
        function (self)
            DebugFrame:Hide();
        end
    );

    local Pages = {};
    local PageIndex = 1;
    local OutputInfo = {};
    local Outputs = {};

    -- Previous Page button
    local PreviousPageButton = CreateFrame("Button", nil, DebugFrame);
    PreviousPageButton:SetPoint("TOPLEFT", TitleBar, "BOTTOMLEFT", 2, -1);
    PreviousPageButton:SetPoint("BOTTOMRIGHT", TitleBar, "BOTTOMLEFT", 17, -16);
    PreviousPageButton:SetNormalTexture("Interface\\Buttons\\UI-SpellbookIcon-PrevPage-Up");
    PreviousPageButton:SetPushedTexture("Interface\\Buttons\\UI-SpellbookIcon-PrevPage-Down");
    PreviousPageButton:SetDisabledTexture("Interface\\Buttons\\UI-SpellbookIcon-PrevPage-Disabled");
    PreviousPageButton:SetHighlightTexture("Interface\\Buttons\\UI-Common-MouseHilight");
    PreviousPageButton:SetScript("PostClick",
        function (self)
            PageIndex = PageIndex - 1;
            DebugFrame.UpdateOutputs();
        end
    );

    -- Page Title
    DebugFrame.PageTitle = DebugFrame:CreateFontString();
    local PageTitle = DebugFrame.PageTitle;
    PageTitle:SetPoint("TOPLEFT", TitleBar, "BOTTOMLEFT", 2, -2);
    PageTitle:SetPoint("BOTTOMRIGHT", TitleBar, "BOTTOMRIGHT", -2, -16);
    PageTitle:SetFont("Fonts\\FRIZQT__.TTF", 8, "OUTLINE");
    PageTitle:SetJustifyH("CENTER");

    -- Next Page button.
    local NextPageButton = CreateFrame("Button", nil, DebugFrame);
    NextPageButton:SetPoint("TOPRIGHT", TitleBar, "BOTTOMRIGHT", -2, -1);
    NextPageButton:SetPoint("BOTTOMLEFT", TitleBar, "BOTTOMRIGHT", -17, -16);
    NextPageButton:SetNormalTexture("Interface\\Buttons\\UI-SpellbookIcon-NextPage-Up");
    NextPageButton:SetPushedTexture("Interface\\Buttons\\UI-SpellbookIcon-NextPage-Down");
    NextPageButton:SetDisabledTexture("Interface\\Buttons\\UI-SpellbookIcon-NextPage-Disabled");
    NextPageButton:SetHighlightTexture("Interface\\Buttons\\UI-Common-MouseHilight");
    NextPageButton:SetScript("PostClick",
        function (self)
            PageIndex = PageIndex + 1;
            DebugFrame.UpdateOutputs();
        end
    );

    --- Update the Outputs.
    function DebugFrame.UpdateOutputs ()
        local PageName = Pages[PageIndex];
        local PageCount = {};
        PageTitle:SetText(PageName);

        local Count = 0;
        for Index, Info in pairs(OutputInfo) do
            if PageCount[Info.Page] then
                PageCount[Info.Page] = PageCount[Info.Page] + 1;
            else
                PageCount[Info.Page] = 1;
            end

            if Info.Page == PageIndex or Info.Page == PageName then
                local Output = Outputs[Count + 1];

                Output[1]:SetText(Info.Name)
                Output[1]:Show();

                Output[2]:SetText("");
                Output[2]:Show();

                Count = Count + 1;
            end
        end

        for Index, Output in pairs(Outputs) do
            if Index > Count then
                Output[1]:Hide();
                Output[2]:Hide();
            end
        end

        if PageIndex == 1 then
            PreviousPageButton:Disable();
        else
            PreviousPageButton:Enable();
        end

        if PageIndex == #Pages or #Pages == 0 then
            NextPageButton:Disable();
        else
            NextPageButton:Enable();
        end

        local MaxPage = nil;
        local MaxCount = 0;
        for Page, Count in pairs(PageCount) do
            if not MaxPage or Count > MaxCount then
                MaxPage = Page;
                MaxCount = Count;
            end
        end

        DebugFrame:SetHeight(35 + Spacing * MaxCount);
    end

    for Index = 1, 30 do
        local Output = {
            DebugFrame:CreateFontString("Output" .. Index .. "Label"),
            DebugFrame:CreateFontString("Output" .. Index .. "Value"),
        };

        Output[1]:SetPoint("TOPLEFT", DebugFrame, "TOPLEFT", 5, -21 + -Spacing * Index);
        Output[1]:SetWidth(195);
        Output[1]:SetFont("Fonts\\ARIALN.TTF", 10, "OUTLINE");
        Output[1]:SetJustifyH("LEFT");

        Output[2]:SetPoint("TOPLEFT", DebugFrame, "TOPLEFT", 5, -21 + -Spacing * Index);
        Output[2]:SetWidth(195);
        Output[2]:SetFont("Fonts\\ARIALN.TTF", 10, "OUTLINE");
        Output[2]:SetJustifyH("RIGHT");

        table.insert(Outputs, Output);
    end

    -- Display the frame.
    local Visible = module.GetSetting("DebugFrameVisible");
    if Visible == true then
        DebugFrame:Show();
    else
        DebugFrame:Hide();
    end

    -- Chat commands
    -- dag = devsaregods
    module.RegisterCommand("dag",
        function (Parts)
            local Visible = DebugFrame:IsVisible();
            if Visible then
                DebugFrame:Hide();
            else
                DebugFrame:Show();
            end
            module.Print("The Debug frame is now", Visible and "|cFFFF0000hidden.|r" or "|cFF00FF00shown.|r");
        end
    );

    -- Functions for manipulating the UI.

    --- Clear all pages and outputs.
    function module.DebugFrame.ClearOutputs ()
        for Index, Output in pairs(Outputs) do
            Output[1]:Hide(); -- Hide the label.
            Output[2]:Hide(); -- Hide the value.
        end

        Pages = {};
        OutputInfo = {};
        DebugFrame.UpdateOutputs();
    end

    --- Add a page to the output frame.
    -- @param Name The name of the page.
    -- @return The index of the page.
    function module.DebugFrame.AddOutputPage (Name)
        table.insert(Pages, Name);
        DebugFrame.UpdateOutputs();
        return #Pages;
    end

    --- Add a new output.
    -- @param Page The name or index of the page the output will be on.
    -- @param Name The output's name.
    function module.DebugFrame.AddOutput (Page, Name, Tooltip)
        table.insert(OutputInfo, {
            ["Page"] = Page,
            ["Name"] = Name,
            ["Tooltip"] = Tooltip,
        });

        DebugFrame.UpdateOutputs();
    end

    function module.DebugFrame.IsOutputActive (Name)
        for Index, Output in pairs(Outputs) do
            if Output[1]:GetText() == Name then
                return true;
            end
        end

        return false;
    end

    --- Set the value of an output.
    -- @param Name The output's name.
    -- @param Value The output's value.
    function module.DebugFrame.SetOutput (Name, Value)
        for Index, Output in pairs(Outputs) do
            if Output[1]:GetText() == Name then
                local Value = tostring(Value);
                Value = Value:gsub("true", "|cFF00FF00TRUE|r");
                Value = Value:gsub("false", "|cFFFF0000FALSE|r");

                Output[2]:SetText(Value);
                return;
            end
        end
    end

    function module.DebugFrame.Initialize ()
        module.DebugFrame.AddOutputPage("General");
        module.DebugFrame.AddOutputPage("TTD");
        module.DebugFrame.AddOutput(1, "FPS:");
        module.DebugFrame.AddOutput(1, "Units:");
        module.DebugFrame.AddOutput(1, "EnemyUnits:");
        module.DebugFrame.AddOutput(1, "FriendlyUnits:");
        module.DebugFrame.AddOutput(1, "Creature ID:");
        module.DebugFrame.AddOutput(1, "IsDeadOrGhost:");
        module.DebugFrame.AddOutput(1, "IsHardBlacklisted:");
        module.DebugFrame.AddOutput(1, "Blacklist:");
        module.DebugFrame.AddOutput(1, "IsInCombat:");
        module.DebugFrame.AddOutput(1, "CombatFlagForced:");
        module.DebugFrame.AddOutput(1, "CanAttack:");
        module.DebugFrame.AddOutput(1, "IsCrowdControlled:");
        module.DebugFrame.AddOutput(1, "IsMissable:");
        module.DebugFrame.AddOutput(1, "Behind:");
        module.DebugFrame.AddOutput(1, "Facing:");
        module.DebugFrame.AddOutput(1, "InLineOfSight:");
        module.DebugFrame.AddOutput(1, "IsMounted:");
        module.DebugFrame.AddOutput(1, "InVehicle:");
        module.DebugFrame.AddOutput(1, "InVehicle SBR:");
        module.DebugFrame.AddOutput(1, "HasFullControl:");
        module.DebugFrame.AddOutput(1, "RawDistance:");
        module.DebugFrame.AddOutput(1, "Player Reach:");
        module.DebugFrame.AddOutput(1, "Target Reach:");
        module.DebugFrame.AddOutput(1, "Melee Range:");
        module.DebugFrame.AddOutput(1, "FinalDistance:");
        module.DebugFrame.AddOutput(2, "Enemy1:");
        module.DebugFrame.AddOutput(2, "TTD1:");
        module.DebugFrame.AddOutput(2, "Enemy2:");
        module.DebugFrame.AddOutput(2, "TTD2:");
        module.DebugFrame.AddOutput(2, "Enemy3:");
        module.DebugFrame.AddOutput(2, "TTD3:");
        module.DebugFrame.AddOutput(2, "Enemy4:");
        module.DebugFrame.AddOutput(2, "TTD4:");
        module.DebugFrame.AddOutput(2, "Enemy5:");
        module.DebugFrame.AddOutput(2, "TTD5:");
        module.DebugFrame.AddOutput(2, "Enemy6:");
        module.DebugFrame.AddOutput(2, "TTD6:");
        module.DebugFrame.AddOutput(2, "Enemy7:");
        module.DebugFrame.AddOutput(2, "TTD7:");
        module.DebugFrame.AddOutput(2, "Enemy8:");
        module.DebugFrame.AddOutput(2, "TTD8:");
        module.DebugFrame.AddOutput(2, "Enemy9:");
        module.DebugFrame.AddOutput(2, "TTD9:");
        module.DebugFrame.AddOutput(2, "Enemy10:");
        module.DebugFrame.AddOutput(2, "TTD10:");
        module.DebugFrame.AddOutput(2, "Enemy11:");
        module.DebugFrame.AddOutput(2, "TTD11:");
        module.DebugFrame.AddOutput(2, "Enemy12:");
        module.DebugFrame.AddOutput(2, "TTD12:");
    end

    function module.DebugFrame.Refresh ()
        if PageIndex == 1 then
            if not UpdateUnitTime or module.GetTime() > UpdateUnitTime then
                UpdateUnitTime = module.GetTime() + 0.7;
                module.DebugFrame.SetOutput("FPS:", floor(GetFramerate()));
                module.DebugFrame.SetOutput("Units:", #module.Units);
                module.DebugFrame.SetOutput("EnemyUnits:", #module.EnemyUnits);
                module.DebugFrame.SetOutput("FriendlyUnits:", #module.FriendlyUnits);
            end
            if Target:Exists() then
                if not UpdateUnitTime2 or module.GetTime() > UpdateUnitTime2 then
                    UpdateUnitTime = module.GetTime() + 0.4;
                    local CanAttack = Player:CanAttack(Target)
                    module.DebugFrame.SetOutput("Creature ID:", Target:CreatureID());
                    module.DebugFrame.SetOutput("IsDeadOrGhost:", Target:IsDeadOrGhost());
                    module.DebugFrame.SetOutput("IsHardBlacklisted:", Target:IsHardBlacklisted());
                    module.DebugFrame.SetOutput("Blacklist:", Target:Blacklist());
                    module.DebugFrame.SetOutput("IsInCombat:", Target:IsInCombat());
                    module.DebugFrame.SetOutput("CombatFlagForced:", Target:WithoutCombatFlags());
                    module.DebugFrame.SetOutput("CanAttack:", CanAttack);
                    module.DebugFrame.SetOutput("IsCrowdControlled:", Target:IsCrowdControlled());
                    module.DebugFrame.SetOutput("IsMissable:", Target:IsMissable());
                    module.DebugFrame.SetOutput("Facing:", Player:IsFacing(Target));
                    module.DebugFrame.SetOutput("InLineOfSight:", Player:InLineOfSight(Target));
                    module.DebugFrame.SetOutput("IsMounted:", IsMounted());
                    module.DebugFrame.SetOutput("InVehicle:", UnitInVehicle("Player"));
                    module.DebugFrame.SetOutput("InVehicle SBR:", Player:InVehicle());
                    module.DebugFrame.SetOutput("HasFullControl:", HasFullControl());
                end
                module.DebugFrame.SetOutput("Behind:", Player:IsBehindPulsed(Target));
                module.DebugFrame.SetOutput("RawDistance:", Player:Position():DistanceTo(Target:Position()));
                module.DebugFrame.SetOutput("Player Reach:", Player:CombatReach());
                module.DebugFrame.SetOutput("Target Reach:", Target:CombatReach());
                module.DebugFrame.SetOutput("Melee Range:", Player:MeleeRange(Target));
                module.DebugFrame.SetOutput("FinalDistance:", Player:DistanceTo(Target));
            else
                module.DebugFrame.SetOutput("Creature ID:", "|CFF939393No Target");
                module.DebugFrame.SetOutput("IsDeadOrGhost:", "|CFF939393No Target");
                module.DebugFrame.SetOutput("IsHardBlacklisted:", "|CFF939393No Target");
                module.DebugFrame.SetOutput("Blacklist:", "|CFF939393No Target");
                module.DebugFrame.SetOutput("IsInCombat:", "|CFF939393No Target");
                module.DebugFrame.SetOutput("CombatFlagForced:", "|CFF939393No Target");
                module.DebugFrame.SetOutput("CanAttack:", "|CFF939393No Target");
                module.DebugFrame.SetOutput("IsCrowdControlled:", "|CFF939393No Target");
                module.DebugFrame.SetOutput("IsMissable:", "|CFF939393No Target");
                module.DebugFrame.SetOutput("Behind:", "|CFF939393No Target");
                module.DebugFrame.SetOutput("Facing:", "|CFF939393No Target");
                module.DebugFrame.SetOutput("InLineOfSight:", "|CFF939393No Target");
                module.DebugFrame.SetOutput("IsMounted:", IsMounted());
                module.DebugFrame.SetOutput("InVehicle:", UnitInVehicle("Player"));
                module.DebugFrame.SetOutput("InVehicle SBR:", Player:InVehicle());
                module.DebugFrame.SetOutput("HasFullControl:", HasFullControl());
                module.DebugFrame.SetOutput("RawDistance:", "|CFF939393No Target");
                module.DebugFrame.SetOutput("Target Reach:", "|CFF939393No Target");
                module.DebugFrame.SetOutput("Player Reach:", Player:CombatReach());
                module.DebugFrame.SetOutput("Melee Range:", "|CFF939393No Target");
                module.DebugFrame.SetOutput("FinalDistance:", "|CFF939393No Target");
            end
        elseif PageIndex == 2 then
            local Enemies = Player:EnemiesWithinDistance(30, false);
            local NumEnemies = #Enemies
            if not UpdateUnitTime or module.GetTime() > UpdateUnitTime then
                UpdateUnitTime = module.GetTime() + 0.4;
                for i = 1, NumEnemies do
                    module.DebugFrame.SetOutput("Enemy"..i..":", Enemies[i]:Name());
                    module.DebugFrame.SetOutput("TTD"..i..":", Enemies[i]:TimeToDie());
                end
            end
            for i = NumEnemies+1, 12-NumEnemies do
                module.DebugFrame.SetOutput("Enemy"..i..":", "|CFF939393No Unit");
                module.DebugFrame.SetOutput("TTD"..i..":", "|CFF939393No Unit");
            end
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Defines the Toolbox.
    module.Toolbox = CreateFrame("Frame");
    local Toolbox = module.Toolbox;

    -- MaxRowValue, by default set to 4 (as we have 4 lines atm)
    local MaxRowValue = 4;

    local function ToolboxInit()
        -- Check to avoid operation on nil settings
        if not module.GetSetting("ToolboxAnchorPoint") then module.SetSetting("ToolboxAnchorPoint", "CENTER"); end
        if not module.GetSetting("ToolboxX") then module.SetSetting("ToolboxX", 0); end
        if not module.GetSetting("ToolboxY") then module.SetSetting("ToolboxY", -130); end
        if not module.GetSetting("ToolboxRows") then module.SetSetting("ToolboxRows", MaxRowValue); end

        -- Non-Premium/Premium changes
        if AccessGranted() ~= true then MaxRowValue = 5; module.SetSetting("ToolboxRows", MaxRowValue);
        else MaxRowValue = 4; if module.GetSetting("ToolboxRows") > 4 then module.SetSetting("ToolboxRows", MaxRowValue); end end
    end

    ToolboxInit();

    -- Local Variables for the frame
    local ButtonRowNumber, ButtonInit = module.GetSetting("ToolboxRows"), nil;
    local ButtonRowSize = 20*ButtonRowNumber
    local Height, Width, Spacing, MaxCount = 20+ButtonRowSize, 205, 14, 0;
    local StatusHidden = module.GetSetting("StatusVisible") or false;

    Toolbox:ClearAllPoints();
    Toolbox:SetHeight(Height);
    Toolbox:SetWidth(Width);
    Toolbox:SetFrameStrata("LOW");
    Toolbox:SetClampedToScreen(true);
    Toolbox:SetMovable(true);
    Toolbox:EnableMouse(true);

    local Backdrop = {
        bgFile = "Interface\\DialogFrame\\UI-DialogBox-Background",
        tileSize = 32,
        edgeFile = "Interface\\FriendsFrame\\UI-Toast-Border",
        tile = 1,
        edgeSize = 3,
        insets = {
            top = 1,
            right = 1,
            left = 1,
            bottom = 1,
        },
    };

    Toolbox:SetBackdrop(Backdrop);

    Toolbox:SetScript("OnShow",
        function (self)
            module.SetSetting("ToolboxVisible", true);
        end
    );

    Toolbox:SetScript("OnHide",
        function (self)
            module.SetSetting("ToolboxVisible", false);
        end
    );

    -- Title Bar
    Toolbox.TitleBar = CreateFrame("Frame", nil, Toolbox);
    local TitleBar = Toolbox.TitleBar;
    TitleBar:SetPoint("TOPLEFT", 1, -1);
    TitleBar:SetPoint("TOPRIGHT", -1, -1);
    TitleBar:SetHeight(16);
    Backdrop.edgeSize = 2;
    Backdrop.insets.bottom = 1;
    TitleBar:SetBackdrop(Backdrop);
    TitleBar:SetBackdropColor(0, 0, 0, 1);

    -- Title Bar Text
    Toolbox.TitleBarText = TitleBar:CreateFontString();
    local TitleBarText = Toolbox.TitleBarText;
    TitleBarText:SetAllPoints(TitleBar);
    TitleBarText:SetFont("Fonts\\FRIZQT__.TTF", 12, "OUTLINE");
    TitleBarText:SetText("Soap Toolbox");
    TitleBarText:SetJustifyH("CENTER");

    Toolbox.TitleBarErrorIcon = CreateFrame("Frame", nil, Toolbox.TitleBar);
    local TitleBarErrorIcon = Toolbox.TitleBarErrorIcon;
    TitleBarErrorIcon:SetFrameStrata("LOW");
    TitleBarErrorIcon:SetWidth(16);
    TitleBarErrorIcon:SetHeight(16);
    TitleBarErrorIcon.TooltipMsg = "Everything is working fine.";
    TitleBarErrorIcon.texture = TitleBarErrorIcon:CreateTexture(nil, "BACKGROUND");
    TitleBarErrorIcon.texture:SetTexture("Interface\\FriendsFrame\\StatusIcon-Online.blp");
    TitleBarErrorIcon.texture:SetAllPoints(TitleBarErrorIcon);
    TitleBarErrorIcon:SetPoint("LEFT", 5, 0);
    TitleBarErrorIcon:SetScript("OnEnter",
        function (self)
            GameTooltip:SetOwner(Toolbox, "ANCHOR_TOPLEFT", 0, 0);
            GameTooltip:ClearLines();
            GameTooltip:SetBackdropColor(0, 0, 0, 1);
            GameTooltip:SetText(TitleBarErrorIcon.TooltipMsg, nil, nil, nil, 1, true);
            GameTooltip:Show();
        end
    );
    TitleBarErrorIcon:SetScript("OnLeave",
        function (self)
            GameTooltip:Hide();
        end
    );
    TitleBarErrorIcon:Show();

    function module.ToolboxError (Message)
        TitleBarErrorIcon.TooltipMsg = Message;
        TitleBarErrorIcon.texture:SetTexture("Interface\\FriendsFrame\\StatusIcon-DnD.blp");
    end

    --- Add Button to the frame.
    local Button = {};
    function module.AddButton (Text, SecondText, i, j, Command, Status, StatusCommand, Tooltip, FullLength)
        Button[i] = Button[i] or {};
        Button[i][j] = CreateFrame("Button", nil, Toolbox);
        local y = -18 - 20 * (i-1);
        local x = 2 + 67 * (j-1);
        Button[i][j]:SetPoint("TOPLEFT", Toolbox, "TOPLEFT", x, y);
        if FullLength then
            Button[i][j]:SetWidth(200);
        else
            Button[i][j]:SetWidth(67);
        end
        Button[i][j]:SetHeight(18);
        if Text == "CDs" then
            Button[i][j].TimeSinceLastUpdate = 0;
            Button[i][j].UpdateInterval = 0.25;
            Button[i][j]:SetScript("OnUpdate",
                function (self, elapsed)
                    self.TimeSinceLastUpdate = self.TimeSinceLastUpdate + elapsed;
                    if self.TimeSinceLastUpdate > self.UpdateInterval then
                        if StatusCommand() then
                            if module.IsOptionEnabled("Cooldowns Only On Bosses") then
                                Button[i][j]:SetFormattedText("|cffa901db%s|r", Text);
                            else
                                Button[i][j]:SetFormattedText("|cff00ff00%s|r", Text);
                            end
                        else
                            Button[i][j]:SetFormattedText("|cffff0000%s|r", Text);
                        end
                        self.TimeSinceLastUpdate = 0;
                    end
                end
            );
        elseif Text == "ON" then
            Button[i][j].TimeSinceLastUpdate = 0;
            Button[i][j].UpdateInterval = 0.25;
            Button[i][j]:SetScript("OnUpdate",
                function (self, elapsed)
                    self.TimeSinceLastUpdate = self.TimeSinceLastUpdate + elapsed;
                    if self.TimeSinceLastUpdate > self.UpdateInterval then
                        if StatusCommand() then
                            if module.IsOptionEnabled("Pulse Control") and module.Control ~= "Complete" then
                                Button[i][j]:SetFormattedText("|cfffff569%s|r", Text);
                            else
                                Button[i][j]:SetFormattedText("|cff00ff00%s|r", Text);
                            end
                        else
                            Button[i][j]:SetFormattedText("|cffff0000%s|r", SecondText);
                        end
                        self.TimeSinceLastUpdate = 0;
                    end
                end
            );
        elseif Status then
            Button[i][j].TimeSinceLastUpdate = 0;
            Button[i][j].UpdateInterval = 0.25;
            Button[i][j]:SetScript("OnUpdate",
                function (self, elapsed)
                    self.TimeSinceLastUpdate = self.TimeSinceLastUpdate + elapsed;
                    if self.TimeSinceLastUpdate > self.UpdateInterval then
                        if StatusCommand() then
                            Button[i][j]:SetFormattedText("|cff00ff00%s|r", Text);
                        else
                            Button[i][j]:SetFormattedText("|cffff0000%s|r", SecondText or Text);
                        end
                        self.TimeSinceLastUpdate = 0;
                    end
                end
            );
        else
            Button[i][j]:SetFormattedText("|cffd3d3d3%s|r", Text);
        end
        if Tooltip then
            Button[i][j]:SetScript("OnEnter",
                function (self)
                    GameTooltip:SetOwner(Toolbox, "ANCHOR_TOPLEFT", 0, 0);
                    GameTooltip:ClearLines();
                    GameTooltip:SetBackdropColor(0, 0, 0, 1);
                    GameTooltip:SetText(Tooltip, nil, nil, nil, 1, true);
                    GameTooltip:Show();
                end
            );
            Button[i][j]:SetScript("OnLeave",
                function (self)
                    GameTooltip:Hide();
                end
            );
        end
        Button[i][j]:SetNormalFontObject("GameFontNormalSmall");
        local ntex = Button[i][j]:CreateTexture();
        ntex:SetTexture("Interface/Buttons/UI-Silver-Button-Up");
        ntex:SetTexCoord(0, 0.625, 0, 0.7875);
        ntex:SetAllPoints();
        Button[i][j]:SetNormalTexture(ntex);
        local htex = Button[i][j]:CreateTexture();
        htex:SetTexture("Interface/Buttons/UI-Silver-Button-Highlight");
        htex:SetTexCoord(0, 0.625, 0, 0.7875);
        htex:SetAllPoints();
        Button[i][j]:SetHighlightTexture(htex);
        local ptex = Button[i][j]:CreateTexture();
        ptex:SetTexture("Interface/Buttons/UI-Silver-Button-Down");
        ptex:SetTexCoord(0, 0.625, 0, 0.7875);
        ptex:SetAllPoints();
        Button[i][j]:SetPushedTexture(ptex);
        if Text == "CDs" then
            Button[i][j]:SetScript("OnMouseDown",
                function (self, button)
                    if button == "RightButton" then
                        if not module.IsOptionEnabled("Cooldowns Only On Bosses") then
                            module.SetSetting("Cooldowns Only On Bosses_Checked", true);
                        else
                            module.SetSetting("Cooldowns Only On Bosses_Checked", false);
                        end
                        module.UpdateOptions();
                    else
                        Command();
                    end
                end
            );
        elseif Text == "|cFFA901DBUPGRADE ROTATION|r" or Text == "|cFFA901DBUPGRADE|r" then
            Button[i][j]:SetScript("OnMouseDown",
                function (self)
                    local Content = AccessGranted();
                    OpenURL('http://soapboxrotations.com/'..Content);
                end
            );
        else
            Button[i][j]:SetScript("OnMouseDown",
                function (self)
                    Command();
                end
            );
        end
    end

    -- Buttons Addins
    function module.ToolboxButtonAdd ()
        if not Button[1] then
            module.AddButton("ON", "OFF", 1, 1, module.ToggleCmd, true, function () return module.IsRunning(); end, "Toggle On/Off the Manager.\nIf you enable the Pulse Control, when the Pulse is prevented the text will be displayed in Yellow.");
            module.AddButton("CDs", nil, 1, 2, module.CDsCmd, true, function () return module.UseCooldowns(); end, "Left-Click : Toggle On/Off Cds. Right-Click : Toggle Cooldowns on 'Bosses Only' (Purple) or 'Everything' (Green).");
            module.AddButton("AoE", nil, 1, 3, module.AOECmd, true, function () return module.UseAOE(); end, "Toggle On/Off the AoE.");
            module.AddButton("UI", nil, 2, 1, module.UICmd, true, function () return module.UserInterface:IsVisible(); end, "Toggle the UI for Settings.");
            module.AddButton("Status", nil, 2, 2, module.StatusCmd, true, function () return not StatusHidden; end, "Toggle the Status UI in the Toolbox.");
            module.AddButton("Custom", nil, 2, 3, module.CsCmd, true, function () return module.CustomSettings:IsVisible(); end, "Toggle the UI for Custom Settings.");
            module.AddButton("Action Log", nil, 3, 1, module.AlCmd, true, function () return Soapbox_ActionLog:IsVisible(); end, "Display the Action Log frame.");
            module.AddButton("Debug", nil, 3, 2, module.DebugCmd, true, function () return module.UseDebug(); end, "Enable the Debug Mode.");
            module.AddButton("Cancel", nil, 3, 3, module.CancelCmd, false, nil, "Cancel all Queued Spells.");
            module.AddButton("Rotations", nil, 4, 1, module.RotationsCmd, false, nil, "Create a Log of all Rotations Purchased.");
            --module.AddButton("Morph", nil, 4, 1, module.MorpherCmd, true, function () return module.UseMorpher(); end, "Enable the Morpher");
            module.AddButton("Ticket", nil, 4, 2, module.TicketCmd, false, nil, "Create a Ticket Log.");
            module.AddButton("Settings", nil, 4, 3, module.SettingsCmd, false, nil, "Create a Log of all Settings.");
            module.AddButton("|cFFA901DBUPGRADE ROTATION|r", nil, 5, 1, "", false, nil, "Purchase the Premium Content Upgrade to access All Raids, Mythic Dungeons, Proving Grounds and Challenge Modes.", true);

            if ButtonRowNumber < MaxRowValue then
                for a = ButtonRowNumber+1, #Button do
                    for b = 1, #Button[a] do
                        Button[a][b]:Hide();
                    end
                end
            end
        end
    end

    local OutputInfo = {};
    local Outputs = {};
    --- Update the Outputs.
    function UpdateOutputs ()
        local Count = 0;
        for Index, Info in pairs(OutputInfo) do
            local Output = Outputs[Count + 1];
            Output[1]:SetText(Info.Name)
            Output[1]:Show();
            Output[2]:SetText("");
            Output[2]:Show();
            Count = Count + 1;
        end
        MaxCount = Count;
        if StatusHidden then
            for Index, Output in pairs(Outputs) do
                Output[1]:Hide();
                Output[2]:Hide();
            end
            Toolbox:SetHeight(20 + ButtonRowSize);
        else
            for Index, Output in pairs(Outputs) do
                if Index > Count then
                    Output[1]:Hide();
                    Output[2]:Hide();
                end
            end
            Toolbox:SetHeight(20 + ButtonRowSize + Spacing*MaxCount);
        end
    end

    for Index = 1, 20 do
        local Output = {
            Toolbox:CreateFontString("Output" .. Index .. "Label"),
            Toolbox:CreateFontString("Output" .. Index .. "Value"),
        };

        Output[1]:SetPoint("TOPLEFT", Toolbox, "TOPLEFT", 5, -(4 + ButtonRowSize + Spacing * Index));
        Output[1]:SetWidth(Width-10);
        Output[1]:SetFont("Fonts\\ARIALN.TTF", 10, "OUTLINE");
        Output[1]:SetJustifyH("LEFT");

        Output[2]:SetPoint("TOPLEFT", Toolbox, "TOPLEFT", 5, -(4 + ButtonRowSize + Spacing * Index));
        Output[2]:SetWidth(Width-10);
        Output[2]:SetFont("Fonts\\ARIALN.TTF", 12, "OUTLINE");
        Output[2]:SetJustifyH("RIGHT");

        table.insert(Outputs, Output);
    end

    -- Chat commands
        --- Function used when the Command is used.
        function module.TbCmd ()
            local Visible = Toolbox:IsVisible();
            if Visible then
                if AccessGranted() ~= true then
                    module.Print("Hiding the Toolbox is only for Subscribers with a Rotation Upgrade or a Premium Subscription");
                    return;
                end
                Toolbox:Hide();
            elseif not Visible then
                Toolbox:Show();
            end
            module.Print("The Toolbox is now", Visible and "|cFFFF0000hidden.|r" or "|cFF00FF00shown.|r");
        end
        --- Function used when the Command is used (or via the Toolbox button).
        function module.StatusCmd ()
            if MaxCount > 0 then
                Toolbox:StartMoving();
                ToolboxPreviousHeight = Toolbox:GetHeight();
                if not StatusHidden then
                    StatusHidden = true;
                    module.SetSetting("StatusVisible", true);
                    for Index, Output in pairs(Outputs) do
                        Output[1]:Hide();
                        Output[2]:Hide();
                    end
                    Toolbox:SetHeight(20 + ButtonRowSize);
                else
                    if not Toolbox:IsVisible() then
                        Toolbox:Show();
                        module.Print("|cFFFF0000The Toolbox has been forced to be visible, use '/"..module.CmdName.." "..module.CmdArgument.tb.."' to toggle the Toolbox instead of '/"..module.CmdName.." "..module.CmdArgument.status.."'' wich is only to control the Status part of Toolbox.|r");
                    end
                    StatusHidden = false;
                    module.SetSetting("StatusVisible", false);
                    UpdateOutputs();
                    Toolbox:SetHeight(20 + ButtonRowSize + Spacing*MaxCount);
                    for Index, Output in pairs(Outputs) do
                        local Point, RelativeTo, RelativePoint, X, Y = Output[1]:GetPoint();
                        Output[1]:SetPoint(Point, RelativeTo, RelativePoint, X, -(4 + ButtonRowSize + Spacing * Index));
                        local Point, RelativeTo, RelativePoint, X, Y = Output[2]:GetPoint();
                        Output[2]:SetPoint(Point, RelativeTo, RelativePoint, X, -(4 + ButtonRowSize + Spacing * Index));
                    end
                end
                Toolbox:StopMovingOrSizing();
                module.Print("The Status part of Toolbox is now", StatusHidden and "|cFFFF0000hidden.|r" or "|cFF00FF00shown.|r");
            else
                module.Print("The Status part of Toolbox is |cFFFF0000empty|r for this rotation.");
                StatusHidden = true;
                module.SetSetting("StatusVisible", true);
            end
        end

    --- Clear all outputs.
    function module.ClearOutputs ()
        for Index, Output in pairs(Outputs) do
            Output[1]:Hide(); -- Hide the label.
            Output[2]:Hide(); -- Hide the value.
        end

        OutputInfo = {};
        UpdateOutputs();
    end

    --- Add a new output. (TODO : Remove Param Page)
    -- @param Page The name or index of the page the output will be on.
    -- @param Name The output's name.
    function module.AddOutput (Name)
        table.insert(OutputInfo, {
            ["Name"] = Name
        });

        UpdateOutputs();
    end

    --- Set the value of an output.
    -- @param Name The output's name.
    -- @param Value The output's value.
    function module.SetOutput (Name, Value)
        for Index, Output in pairs(Outputs) do
            if Output[1]:GetText() == Name then
                local Value = tostring(Value);
                Value = Value:gsub("true", "|cFF00FF00ENABLED|r");
                Value = Value:gsub("false", "|cFFFF0000DISABLED|r");

                Output[2]:SetText(Value);
                return;
            end
        end
    end

    -- Resize the toolbox based on outputs.
    function module.UpdateToolbox ()
        Toolbox:StartMoving();
        StatusHidden = module.GetSetting("StatusVisible");
        ButtonRowNumber = module.GetSetting("ToolboxRows");
        ButtonRowSize = 20*ButtonRowNumber;
        if ButtonRowNumber == 0 then
            for a = 1, #Button do
                for b = 1, #Button[a] do
                    Button[a][b]:Hide();
                end
            end
        else
            for a = 1, ButtonRowNumber do
                for b = 1, #Button[a] do
                    Button[a][b]:Show();
                end
            end
        end
        if not StatusHidden then
            Toolbox:SetHeight(20 + ButtonRowSize + Spacing*MaxCount);
            for Index, Output in pairs(Outputs) do
                local Point, RelativeTo, RelativePoint, X, Y = Output[1]:GetPoint();
                Output[1]:SetPoint(Point, RelativeTo, RelativePoint, X, -(4 + ButtonRowSize + Spacing * Index));
                local Point, RelativeTo, RelativePoint, X, Y = Output[2]:GetPoint();
                Output[2]:SetPoint(Point, RelativeTo, RelativePoint, X, -(4 + ButtonRowSize + Spacing * Index));
            end
        else
            Toolbox:SetHeight(20 + ButtonRowSize);
        end
        Toolbox:StopMovingOrSizing();
    end

    function module.UpdateToolboxChangeSpec ()
        ToolboxInit();
        Toolbox:SetPoint(module.GetSetting("ToolboxAnchorPoint"), module.GetSetting("ToolboxX"), module.GetSetting("ToolboxY"));
        -- Display the frame.
        local Visible = module.GetSetting("ToolboxVisible");
        if Visible == false then
            Toolbox:Hide();
        else
            Toolbox:Show();
        end
        if not Visible and AccessGranted() ~= true then
            Toolbox:Show();
        end
        for a = 1, #Button do
            for b = 1, #Button[a] do
                Button[a][b]:Hide();
            end
        end
        module.UpdateToolbox();
    end

    --- Control display of the Toolbox.
    -- Title Bar Close Button
    TitleBar.CloseButton = CreateFrame("Button", nil, TitleBar, "UIPanelCloseButton");
    local CloseButton = TitleBar.CloseButton;
    CloseButton:SetPoint("TOPRIGHT", 1, 1);
    CloseButton:SetHeight(18);
    CloseButton:SetWidth(18);
    CloseButton:SetScript("OnClick",
        function (self)
            if AccessGranted() ~= true then
                module.Print("Hiding the Toolbox is only for Subscribers with a Rotation Upgrade or a Premium Subscription");
                return;
            else
                Toolbox:Hide();
            end
        end
    );
    CloseButton:SetScript("OnEnter",
        function (self)
            GameTooltip:SetOwner(Toolbox, "ANCHOR_TOPLEFT", 0, 0);
            GameTooltip:ClearLines();
            GameTooltip:SetBackdropColor(0, 0, 0, 1);
            GameTooltip:SetText("Click to close the Toolbox.", nil, nil, nil, 1, true);
            GameTooltip:Show();
        end
    );
    CloseButton:SetScript("OnLeave",
        function (self)
            GameTooltip:Hide();
        end
    );
    -- Title Bar Stop Move
    TitleBar:SetScript("OnMouseUp",
        function (self, button)
            Toolbox:StopMovingOrSizing();

            local Point, RelativeTo, RelativePoint, X, Y = Toolbox:GetPoint();
            module.SetSetting("ToolboxAnchorPoint", Point);
            module.SetSetting("ToolboxX", X);
            module.SetSetting("ToolboxY", Y);
        end
    );
    -- Buton Show/Hide Function
    local function ToolboxRowResize ()
        if AccessGranted() ~= true then
            module.Print("Hiding the Buttons is only for Subscribers with a Rotation Upgrade or a Premium Subscription");
            return;
        end
        if not ButtonInit then
            if module.GetSetting("ToolboxRows") ~= 0 or module.GetSetting("ToolboxRows") == MaxRowValue then
                module.SetSetting("ToolboxRows", 0);
            else
                module.SetSetting("ToolboxRows", module.GetSetting("ToolboxRows")+1);
            end
            ButtonInit = true;
        elseif module.GetSetting("ToolboxRows") == MaxRowValue then
            module.SetSetting("ToolboxRows", 0);
        else
            module.SetSetting("ToolboxRows", module.GetSetting("ToolboxRows")+1);
        end
        module.UpdateToolbox();
    end
    -- Title Bar Start Move + Button Show/Hide on Right Click
    TitleBar:SetScript("OnMouseDown",
        function (self, button)
            if button == "RightButton" then
                ToolboxRowResize();
            else
                Toolbox:StartMoving();
            end
        end
    );
    -- Title Bar Button Show/Hide on MouseWheel
    TitleBar:SetScript("OnMouseWheel",
        function (self)
            ToolboxRowResize();
        end
    );
    -- Title Bar Tooltip
    TitleBar:SetScript("OnEnter",
        function (self)
            GameTooltip:SetOwner(Toolbox, "ANCHOR_TOPLEFT", 0, 0);
            GameTooltip:ClearLines();
            GameTooltip:SetBackdropColor(0, 0, 0, 1);
            GameTooltip:SetText("Right-Click to show/hide buttons.", nil, nil, nil, 1, true);
            GameTooltip:Show();
        end
    );
    TitleBar:SetScript("OnLeave",
        function (self)
            GameTooltip:Hide();
        end
    );
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Defines the Custom Settings Panel.
    module.CustomSettings = CreateFrame("Frame", "SB_CS");
    local CS = module.CustomSettings;

    local function CS_SettingsInit ()
        -- Check to avoid operation on nil settings
        if not module.GetSetting("CS_AnchorPoint") then module.SetSetting("CS_AnchorPoint", "CENTER"); end
        if not module.GetSetting("CS_X") then module.SetSetting("CS_X", -250); end
        if not module.GetSetting("CS_Y") then module.SetSetting("CS_Y", 0); end
    end

    CS_SettingsInit();

    -- Local Variables for the frame
    local Height, Width = 300, 215;
    local Backdrop = {
        bgFile = "Interface\\DialogFrame\\UI-DialogBox-Background",
        tileSize = 32,
        edgeFile = "Interface\\FriendsFrame\\UI-Toast-Border",
        tile = 1,
        edgeSize = 3,
        insets = {
            top = 1,
            right = 1,
            left = 1,
            bottom = 1,
        },
    };

    -- Main Frame
    CS:SetFrameStrata("LOW");
    CS:SetPoint(module.GetSetting("CS_AnchorPoint"), module.GetSetting("CS_X"), module.GetSetting("CS_Y"));
    CS:SetClampedToScreen(true);
    CS:SetMovable(true);
    CS:SetWidth(Width);
    CS:SetHeight(Height);
    CS:SetBackdrop(Backdrop);
    CS:SetBackdropColor(0,0,0,1);

    -- Visible Scripts
    CS:SetScript("OnShow",
        function (self)
            module.SetSetting("CS_Visible", true);
        end
    );
    CS:SetScript("OnHide",
        function (self)
            module.SetSetting("CS_Visible", false);
        end
    );

    -- Title Bar
    CS.TitleBar = CreateFrame("Frame", nil, CS);
    local TitleBar = CS.TitleBar;
    TitleBar:SetPoint("TOPLEFT", 1, -1);
    TitleBar:SetPoint("TOPRIGHT", -1, -1);
    TitleBar:SetHeight(16);
    Backdrop.edgeSize = 2;
    Backdrop.insets.bottom = 1;
    TitleBar:SetBackdrop(Backdrop);
    TitleBar:SetBackdropColor(0, 0, 0, 1);
    -- Title Bar Text
    local TitleBarText = TitleBar:CreateFontString();
    TitleBarText:SetAllPoints(TitleBar);
    TitleBarText:SetFont("Fonts\\FRIZQT__.TTF", 12, "OUTLINE");
    TitleBarText:SetText("Custom Settings");
    TitleBarText:SetJustifyH("CENTER");
    -- Title Bar Close Button
    TitleBar.CloseButton = CreateFrame("Button", nil, TitleBar, "UIPanelCloseButton");
    local CloseButton = TitleBar.CloseButton;
    CloseButton:SetPoint("TOPRIGHT", 1, 1);
    CloseButton:SetHeight(18);
    CloseButton:SetWidth(18);
    CloseButton:SetScript("OnClick",
        function (self)
            CS:Hide();
        end
    );
    -- Title Bar Start Move
    TitleBar:SetScript("OnMouseDown",
        function (self, button)
            CS:StartMoving();
        end
    );
    -- Title Bar Stop Move
    TitleBar:SetScript("OnMouseUp",
        function (self, button)
            CS:StopMovingOrSizing();
            local Point, RelativeTo, RelativePoint, X, Y = CS:GetPoint();
            module.SetSetting("CS_AnchorPoint", Point);
            module.SetSetting("CS_X", X);
            module.SetSetting("CS_Y", Y);
        end
    );

    -- Tab Management
    CS.numTabs = 2
    CS.selectedTab = 1
    CS.subFrames = {}
    CS.name = CS:GetName()
    -- Function to display the right tab
    local function showTabFrame (name)
      for index, value in pairs(CS.subFrames) do
        if (value == name) then
            _G[value]:Show();
        else
            _G[value]:Hide();
        end
      end
    end
    -- Function to update the Panel
    local function updatePanel (panel)
        PanelTemplates_UpdateTabs(panel);
        showTabFrame(panel.name.."TabFrame"..panel.selectedTab);
    end
    -- Function to set the Panel
    local function setPanel (panel, id)
        PanelTemplates_SetTab(panel, id);
        updatePanel(panel);
    end
    -- Function to create Tabs
    local function createTab (parent, index)
        local tab = CreateFrame("Button", "$parentTab"..index, parent, "CharacterFrameTabButtonTemplate");
        tab.text = "TAB"..index;
        tab.id = index;
        if index == 1 then
            tab:SetPoint("TOPLEFT", CS, 0, -16);
        else
            tab:SetPoint("LEFT", "$parentTab"..index-1, "RIGHT", -15, 0);
        end
        tab:HookScript("OnClick",
            function(self)
                setPanel(self:GetParent(), self.id)
            end
        );
        if index == 1 then
            tab:SetText("Blacklist");
            tab:SetScript("OnEnter",
                function (self)
                    GameTooltip:SetOwner(tab, "ANCHOR_TOPLEFT", 0, 0);
                    GameTooltip:ClearLines();
                    GameTooltip:SetBackdropColor(0, 0, 0, 1);
                    GameTooltip:SetText("Click to display the Blacklist tab.\nEvery Blacklisted Units are ignored by spells except if you target them.", nil, nil, nil, 1, true);
                    GameTooltip:Show();
                end
            );
            tab:SetScript("OnLeave",
                function (self)
                    GameTooltip:Hide();
                end
            );
        elseif index == 2 then
            tab:SetText("CIL");
            tab:SetScript("OnEnter",
                function (self)
                    GameTooltip:SetOwner(tab, "ANCHOR_TOPLEFT", 0, 0);
                    GameTooltip:ClearLines();
                    GameTooltip:SetBackdropColor(0, 0, 0, 1);
                    GameTooltip:SetText("Click to display the Custom Interrupt List tab.\nIf you enable CIL in UI Settings (if available for you rotation), it will only interrupt spells in the list.", nil, nil, nil, 1, true);
                    GameTooltip:Show();
                end
            );
            tab:SetScript("OnLeave",
                function (self)
                    GameTooltip:Hide();
                end
            );
        else
            tab:SetText("Tab "..index);
        end
    end
    -- Function to create Tabs Frames
    local function createTabFrame (parent, index)
        local tabFrame = CreateFrame("Frame", "$parentTabFrame"..index, parent)
        table.insert(CS.subFrames, tabFrame:GetName());
        tabFrame:SetPoint("TOPLEFT", CS.name.."Tab1", "BOTTOMLEFT", 1, 0);
        tabFrame:SetWidth(Width-2);
        tabFrame:SetHeight(Height-16-32);

        if index == 1 or index == 2 then
            local tabBottomEditBox = CreateFrame("EditBox", nil, tabFrame, "InputBoxTemplate");
            tabBottomEditBox:SetPoint("BOTTOMLEFT", tabFrame, "BOTTOMLEFT", 7, 5);
            tabBottomEditBox:SetWidth(104);
            tabBottomEditBox:SetHeight(15);
            tabBottomEditBox:SetAutoFocus(false);
            tabBottomEditBox:SetFontObject("GameFontHighlight");

            local tabBottomPlusButton = CreateFrame("Button", nil, tabFrame);
            tabBottomPlusButton:SetPoint("LEFT", tabBottomEditBox, "RIGHT", 8, 0.5);
            tabBottomPlusButton:SetWidth(20);
            tabBottomPlusButton:SetHeight(23);
            tabBottomPlusButton:SetNormalFontObject("GameFontNormalSmall");
            local ntex = tabBottomPlusButton:CreateTexture();
            ntex:SetTexture("Interface/Buttons/UI-Silver-Button-Up");
            ntex:SetTexCoord(0, 0.625, 0, 0.7875);
            ntex:SetAllPoints();
            tabBottomPlusButton:SetNormalTexture(ntex);
            local htex = tabBottomPlusButton:CreateTexture();
            htex:SetTexture("Interface/Buttons/UI-Silver-Button-Highlight");
            htex:SetTexCoord(0, 0.625, 0, 0.7875);
            htex:SetAllPoints();
            tabBottomPlusButton:SetHighlightTexture(htex);
            local ptex = tabBottomPlusButton:CreateTexture();
            ptex:SetTexture("Interface/Buttons/UI-Silver-Button-Down");
            ptex:SetTexCoord(0, 0.625, 0, 0.7875);
            ptex:SetAllPoints();
            tabBottomPlusButton:SetPushedTexture(ptex);
            tabBottomPlusButton:SetFormattedText("%s", "+");

            local tabBottomMinusButton = CreateFrame("Button", nil, tabFrame);
            tabBottomMinusButton:SetPoint("LEFT", tabBottomPlusButton, "RIGHT", 8, 0);
            tabBottomMinusButton:SetWidth(20);
            tabBottomMinusButton:SetHeight(23);
            tabBottomMinusButton:SetNormalFontObject("GameFontNormalSmall");
            local ntex = tabBottomMinusButton:CreateTexture();
            ntex:SetTexture("Interface/Buttons/UI-Silver-Button-Up");
            ntex:SetTexCoord(0, 0.625, 0, 0.7875);
            ntex:SetAllPoints();
            tabBottomMinusButton:SetNormalTexture(ntex);
            local htex = tabBottomMinusButton:CreateTexture();
            htex:SetTexture("Interface/Buttons/UI-Silver-Button-Highlight");
            htex:SetTexCoord(0, 0.625, 0, 0.7875);
            htex:SetAllPoints();
            tabBottomMinusButton:SetHighlightTexture(htex);
            local ptex = tabBottomMinusButton:CreateTexture();
            ptex:SetTexture("Interface/Buttons/UI-Silver-Button-Down");
            ptex:SetTexCoord(0, 0.625, 0, 0.7875);
            ptex:SetAllPoints();
            tabBottomMinusButton:SetPushedTexture(ptex);
            tabBottomMinusButton:SetFormattedText("%s", "-");

            local tabBottomResetButton = CreateFrame("Button", nil, tabFrame);
            tabBottomResetButton:SetPoint("LEFT", tabBottomMinusButton, "RIGHT", 8, 0);
            tabBottomResetButton:SetWidth(37);
            tabBottomResetButton:SetHeight(23);
            tabBottomResetButton:SetNormalFontObject("GameFontNormalSmall");
            local ntex = tabBottomResetButton:CreateTexture();
            ntex:SetTexture("Interface/Buttons/UI-Silver-Button-Up");
            ntex:SetTexCoord(0, 0.625, 0, 0.7875);
            ntex:SetAllPoints();
            tabBottomResetButton:SetNormalTexture(ntex);
            local htex = tabBottomResetButton:CreateTexture();
            htex:SetTexture("Interface/Buttons/UI-Silver-Button-Highlight");
            htex:SetTexCoord(0, 0.625, 0, 0.7875);
            htex:SetAllPoints();
            tabBottomResetButton:SetHighlightTexture(htex);
            local ptex = tabBottomResetButton:CreateTexture();
            ptex:SetTexture("Interface/Buttons/UI-Silver-Button-Down");
            ptex:SetTexCoord(0, 0.625, 0, 0.7875);
            ptex:SetAllPoints();
            tabBottomResetButton:SetPushedTexture(ptex);
            tabBottomResetButton:SetFormattedText("%s", "Reset");

            if index == 1 then
                -- Tooltips
                tabBottomEditBox:SetScript("OnEnter",
                    function (self)
                        GameTooltip:SetOwner(tabBottomEditBox, "ANCHOR_TOPLEFT", 0, 0);
                        GameTooltip:ClearLines();
                        GameTooltip:SetBackdropColor(0, 0, 0, 1);
                        GameTooltip:SetText("Enter the ID of the mob or the GUID of the player you want to modify.", nil, nil, nil, 1, true);
                        GameTooltip:Show();
                    end
                );
                tabBottomEditBox:SetScript("OnLeave",
                    function (self)
                        GameTooltip:Hide();
                    end
                );
                tabBottomPlusButton:SetScript("OnEnter",
                    function (self)
                        GameTooltip:SetOwner(tabBottomEditBox, "ANCHOR_TOPLEFT", 0, 0);
                        GameTooltip:ClearLines();
                        GameTooltip:SetBackdropColor(0, 0, 0, 1);
                        GameTooltip:SetText("Click to add the mob/player in the list.\nIf nothing is in the box and your target isn't in the list, it will add it.", nil, nil, nil, 1, true);
                        GameTooltip:Show();
                    end
                );
                tabBottomPlusButton:SetScript("OnLeave",
                    function (self)
                        GameTooltip:Hide();
                    end
                );
                tabBottomMinusButton:SetScript("OnEnter",
                    function (self)
                        GameTooltip:SetOwner(tabBottomEditBox, "ANCHOR_TOPLEFT", 0, 0);
                        GameTooltip:ClearLines();
                        GameTooltip:SetBackdropColor(0, 0, 0, 1);
                        GameTooltip:SetText("Click to remove the mob/player from the list.\nIf nothing is in the box and your target is in the list, it will remove it.", nil, nil, nil, 1, true);
                        GameTooltip:Show();
                    end
                );
                tabBottomMinusButton:SetScript("OnLeave",
                    function (self)
                        GameTooltip:Hide();
                    end
                );
                tabBottomResetButton:SetScript("OnEnter",
                    function (self)
                        GameTooltip:SetOwner(tabBottomEditBox, "ANCHOR_TOPLEFT", 0, 0);
                        GameTooltip:ClearLines();
                        GameTooltip:SetBackdropColor(0, 0, 0, 1);
                        GameTooltip:SetText("Click to reset the Blacklist.", nil, nil, nil, 1, true);
                        GameTooltip:Show();
                    end
                );
                tabBottomResetButton:SetScript("OnLeave",
                    function (self)
                        GameTooltip:Hide();
                    end
                );

                -- EditBox Chars Securing
                tabBottomEditBox:SetScript("OnChar",
                    function (self, text)
                        self:SetText(self:GetText():gsub("[^0-9%a-]", ""));
                    end
                );
                -- Buttons Scripts
                tabBottomPlusButton:SetScript("OnMouseDown",
                    function (self)
                        local EditBoxText = tabBottomEditBox:GetText();
                        if EditBoxText ~= "" then
                            BlacklistAdd(EditBoxText);
                            tabBottomEditBox:SetText("");
                        else
                            BlacklistAdd();
                        end
                    end
                );
                tabBottomMinusButton:SetScript("OnMouseDown",
                    function (self)
                        local EditBoxText = tabBottomEditBox:GetText();
                        if EditBoxText ~= "" then
                            BlacklistRemove(EditBoxText);
                            tabBottomEditBox:SetText("");
                        else
                            BlacklistRemove();
                        end
                    end
                );
                tabBottomResetButton:SetScript("OnMouseDown",
                    function (self)
                        BlacklistReset();
                    end
                );

                -- Content / ScrollFrame
                local tabScrollFrame = CreateFrame("ScrollFrame", CS.name.."TabScrollFrame"..index, tabFrame, "UIPanelScrollFrameTemplate");
                tabScrollFrame:SetWidth(Width-2);
                tabScrollFrame:SetHeight(Height-16-32-23);

                local tabScrollChild = CreateFrame("Frame");

                local tabScrollBarName = tabScrollFrame:GetName()
                tabScrollBar = _G[tabScrollBarName.."ScrollBar"];
                tabScrollUpButton = _G[tabScrollBarName.."ScrollBarScrollUpButton"];
                tabScrollDownButton = _G[tabScrollBarName.."ScrollBarScrollDownButton"];
                tabScrollUpButton:ClearAllPoints();
                tabScrollUpButton:SetPoint("TOPRIGHT", tabScrollFrame, "TOPRIGHT", -2, -2);
                tabScrollDownButton:ClearAllPoints();
                tabScrollDownButton:SetPoint("BOTTOMRIGHT", tabScrollFrame, "BOTTOMRIGHT", -2, 2);
                tabScrollBar:ClearAllPoints();
                tabScrollBar:SetPoint("TOP", tabScrollUpButton, "BOTTOM", 0, -2);
                tabScrollBar:SetPoint("BOTTOM", tabScrollDownButton, "TOP", 0, 2);


                tabScrollFrame:SetScrollChild(tabScrollChild);
                tabScrollFrame:SetPoint("TOPLEFT", tabFrame, "TOPLEFT", 0, 0);

                local Spacing = 20;
                local tabScrollModule = CreateFrame("Frame", nil, tabScrollChild);

                local tabScrollModuleIDRow = {};
                local tabScrollModuleTextRow = {};
                tabScrollModule.TimeSinceLastUpdate = 0;
                tabScrollModule.UpdateInterval = 0.25;
                tabScrollModule:SetScript("OnUpdate",
                    function (self, elapsed)
                        self.TimeSinceLastUpdate = self.TimeSinceLastUpdate + elapsed;
                        if self.TimeSinceLastUpdate > self.UpdateInterval then
                            BlacklistTargets = module.GetSetting("BlacklistTargets") or {};
                            local Rows = #BlacklistTargets;
                            if Rows == 0 then Rows = 1; end
                            tabScrollChild:SetSize(tabScrollFrame:GetWidth(), Spacing*Rows);
                            tabScrollModule:SetAllPoints(tabScrollChild);

                            if not BlacklistTargets[1] then
                                tabScrollModuleIDRow[1] = tabScrollModuleIDRow[1] or tabScrollModule:CreateFontString();
                                local id = tabScrollModuleIDRow[1];
                                id:SetPoint("TOPLEFT", tabScrollModule, "TOPLEFT", 10, -5);
                                id:SetWidth(60);
                                id:SetHeight(30);
                                id:SetFont("Fonts\\FRIZQT__.TTF", 9, "OUTLINE");
                                id:SetJustifyH("LEFT");
                                id:SetJustifyV("MIDDLE");
                                id:SetText("");
                                id:Show();
                                tabScrollModuleTextRow[1] = tabScrollModuleTextRow[1] or tabScrollModule:CreateFontString();
                                local text = tabScrollModuleTextRow[1] or tabScrollModule:CreateFontString();
                                text:SetPoint("LEFT", id, "RIGHT", -10, 0);
                                text:SetHeight(30);
                                text:SetFont("Fonts\\FRIZQT__.TTF", 9, "OUTLINE");
                                text:SetJustifyV("MIDDLE");
                                text:SetText("|cffff0000Blacklist is empty.|r");
                                text:Show();
                            else
                                for Key, Value in pairs(BlacklistTargets) do
                                    tabScrollModuleIDRow[Key] = tabScrollModuleIDRow[Key] or tabScrollModule:CreateFontString();
                                    local id = tabScrollModuleIDRow[Key];
                                    id:SetPoint("TOPLEFT", tabScrollModule, "TOPLEFT", 10, -5-Spacing*(Key-1));
                                    id:SetWidth(60);
                                    id:SetHeight(30);
                                    id:SetFont("Fonts\\FRIZQT__.TTF", 9, "OUTLINE");
                                    id:SetJustifyH("LEFT");
                                    id:SetJustifyV("MIDDLE");
                                    id:SetText(Value["id"]);
                                    id:Show();
                                    tabScrollModuleTextRow[Key] = tabScrollModuleTextRow[Key] or tabScrollModule:CreateFontString();
                                    local text = tabScrollModuleTextRow[Key] or tabScrollModule:CreateFontString();
                                    text:SetPoint("LEFT", id, "RIGHT", 0, 0);
                                    text:SetHeight(30);
                                    text:SetFont("Fonts\\FRIZQT__.TTF", 9, "OUTLINE");
                                    text:SetJustifyV("MIDDLE");
                                    text:SetText(Value["name"]);
                                    text:Show();
                                end
                            end

                            if #tabScrollModuleIDRow > Rows then
                                for i = Rows+1, #tabScrollModuleIDRow do
                                    tabScrollModuleIDRow[i]:Hide();
                                end
                            end
                            if #tabScrollModuleTextRow > Rows then
                                for i = Rows+1, #tabScrollModuleTextRow do
                                    tabScrollModuleTextRow[i]:Hide();
                                end
                            end
                            self.TimeSinceLastUpdate = 0;
                        end
                    end
                );
            end

            if index == 2 then
                -- Tooltips
                tabBottomEditBox:SetScript("OnEnter",
                    function (self)
                        GameTooltip:SetOwner(tabBottomEditBox, "ANCHOR_TOPLEFT", 0, 0);
                        GameTooltip:ClearLines();
                        GameTooltip:SetBackdropColor(0, 0, 0, 1);
                        GameTooltip:SetText("Enter the ID of the spell you want to modify.", nil, nil, nil, 1, true);
                        GameTooltip:Show();
                    end
                );
                tabBottomEditBox:SetScript("OnLeave",
                    function (self)
                        GameTooltip:Hide();
                    end
                );
                tabBottomPlusButton:SetScript("OnEnter",
                    function (self)
                        GameTooltip:SetOwner(tabBottomEditBox, "ANCHOR_TOPLEFT", 0, 0);
                        GameTooltip:ClearLines();
                        GameTooltip:SetBackdropColor(0, 0, 0, 1);
                        GameTooltip:SetText("Click to add the spell in the list.", nil, nil, nil, 1, true);
                        GameTooltip:Show();
                    end
                );
                tabBottomPlusButton:SetScript("OnLeave",
                    function (self)
                        GameTooltip:Hide();
                    end
                );
                tabBottomMinusButton:SetScript("OnEnter",
                    function (self)
                        GameTooltip:SetOwner(tabBottomEditBox, "ANCHOR_TOPLEFT", 0, 0);
                        GameTooltip:ClearLines();
                        GameTooltip:SetBackdropColor(0, 0, 0, 1);
                        GameTooltip:SetText("Click to remove the spell from the list.", nil, nil, nil, 1, true);
                        GameTooltip:Show();
                    end
                );
                tabBottomMinusButton:SetScript("OnLeave",
                    function (self)
                        GameTooltip:Hide();
                    end
                );
                tabBottomResetButton:SetScript("OnEnter",
                    function (self)
                        GameTooltip:SetOwner(tabBottomEditBox, "ANCHOR_TOPLEFT", 0, 0);
                        GameTooltip:ClearLines();
                        GameTooltip:SetBackdropColor(0, 0, 0, 1);
                        GameTooltip:SetText("Click to reset the Custom Interrupt List.", nil, nil, nil, 1, true);
                        GameTooltip:Show();
                    end
                );
                tabBottomResetButton:SetScript("OnLeave",
                    function (self)
                        GameTooltip:Hide();
                    end
                );

                -- EditBox Chars Securing
                tabBottomEditBox:SetScript("OnChar",
                    function (self, text)
                        self:SetText(self:GetText():gsub("[^0-9]", ""));
                    end
                );
                -- Buttons Scripts
                tabBottomPlusButton:SetScript("OnMouseDown",
                    function (self)
                        local EditBoxText = tabBottomEditBox:GetText();
                        CustomInterruptListAdd(EditBoxText);
                        tabBottomEditBox:SetText("");
                    end
                );
                tabBottomMinusButton:SetScript("OnMouseDown",
                    function (self)
                        local EditBoxText = tabBottomEditBox:GetText();
                        CustomInterruptListRemove(EditBoxText);
                        tabBottomEditBox:SetText("");
                    end
                );
                tabBottomResetButton:SetScript("OnMouseDown",
                    function (self)
                        CustomInterruptListReset();
                    end
                );

                -- Content / ScrollFrame
                local tabScrollFrame = CreateFrame("ScrollFrame", CS.name.."TabScrollFrame"..index, tabFrame, "UIPanelScrollFrameTemplate");
                tabScrollFrame:SetWidth(Width-2);
                tabScrollFrame:SetHeight(Height-16-32-23);

                local tabScrollChild = CreateFrame("Frame");

                local tabScrollBarName = tabScrollFrame:GetName()
                tabScrollBar = _G[tabScrollBarName.."ScrollBar"];
                tabScrollUpButton = _G[tabScrollBarName.."ScrollBarScrollUpButton"];
                tabScrollDownButton = _G[tabScrollBarName.."ScrollBarScrollDownButton"];
                tabScrollUpButton:ClearAllPoints();
                tabScrollUpButton:SetPoint("TOPRIGHT", tabScrollFrame, "TOPRIGHT", -2, -2);
                tabScrollDownButton:ClearAllPoints();
                tabScrollDownButton:SetPoint("BOTTOMRIGHT", tabScrollFrame, "BOTTOMRIGHT", -2, 2);
                tabScrollBar:ClearAllPoints();
                tabScrollBar:SetPoint("TOP", tabScrollUpButton, "BOTTOM", 0, -2);
                tabScrollBar:SetPoint("BOTTOM", tabScrollDownButton, "TOP", 0, 2);


                tabScrollFrame:SetScrollChild(tabScrollChild);
                tabScrollFrame:SetPoint("TOPLEFT", tabFrame, "TOPLEFT", 0, 0);

                local Spacing = 20;
                local tabScrollModule = CreateFrame("Frame", nil, tabScrollChild);

                local tabScrollModuleIDRow = {};
                local tabScrollModuleTextRow = {};
                tabScrollModule.TimeSinceLastUpdate = 0;
                tabScrollModule.UpdateInterval = 0.25;
                tabScrollModule:SetScript("OnUpdate",
                    function (self, elapsed)
                        self.TimeSinceLastUpdate = self.TimeSinceLastUpdate + elapsed;
                        if self.TimeSinceLastUpdate > self.UpdateInterval then
                            InterruptTargets = module.GetSetting("InterruptTargets") or {};
                            local Rows = #InterruptTargets;
                            if Rows == 0 then Rows = 1; end
                            tabScrollChild:SetSize(tabScrollFrame:GetWidth(), Spacing*Rows);
                            tabScrollModule:SetAllPoints(tabScrollChild);

                            if not InterruptTargets[1] then
                                tabScrollModuleIDRow[1] = tabScrollModuleIDRow[1] or tabScrollModule:CreateFontString();
                                local id = tabScrollModuleIDRow[1];
                                id:SetPoint("TOPLEFT", tabScrollModule, "TOPLEFT", 10, -5);
                                id:SetWidth(60);
                                id:SetHeight(30);
                                id:SetFont("Fonts\\FRIZQT__.TTF", 9, "OUTLINE");
                                id:SetJustifyH("LEFT");
                                id:SetJustifyV("MIDDLE");
                                id:SetText("");
                                id:Show();
                                tabScrollModuleTextRow[1] = tabScrollModuleTextRow[1] or tabScrollModule:CreateFontString();
                                local text = tabScrollModuleTextRow[1] or tabScrollModule:CreateFontString();
                                text:SetPoint("LEFT", id, "RIGHT", -50, 0);
                                text:SetHeight(30);
                                text:SetFont("Fonts\\FRIZQT__.TTF", 9, "OUTLINE");
                                text:SetJustifyV("MIDDLE");
                                text:SetText("|cffff0000Custom interrupts list is empty.|r");
                                text:Show();
                            else
                                for Key, Value in pairs(InterruptTargets) do
                                    tabScrollModuleIDRow[Key] = tabScrollModuleIDRow[Key] or tabScrollModule:CreateFontString();
                                    local id = tabScrollModuleIDRow[Key];
                                    id:SetPoint("TOPLEFT", tabScrollModule, "TOPLEFT", 10, -5-Spacing*(Key-1));
                                    id:SetWidth(60);
                                    id:SetHeight(30);
                                    id:SetFont("Fonts\\FRIZQT__.TTF", 9, "OUTLINE");
                                    id:SetJustifyH("LEFT");
                                    id:SetJustifyV("MIDDLE");
                                    id:SetText(Value["id"]);
                                    id:Show();
                                    tabScrollModuleTextRow[Key] = tabScrollModuleTextRow[Key] or tabScrollModule:CreateFontString();
                                    local text = tabScrollModuleTextRow[Key] or tabScrollModule:CreateFontString();
                                    text:SetPoint("LEFT", id, "RIGHT", 0, 0);
                                    text:SetHeight(30);
                                    text:SetFont("Fonts\\FRIZQT__.TTF", 9, "OUTLINE");
                                    text:SetJustifyV("MIDDLE");
                                    text:SetText(Value["name"]);
                                    text:Show();
                                end
                            end

                            if #tabScrollModuleIDRow > Rows then
                                for i = Rows+1, #tabScrollModuleIDRow do
                                    tabScrollModuleIDRow[i]:Hide();
                                end
                            end
                            if #tabScrollModuleTextRow > Rows then
                                for i = Rows+1, #tabScrollModuleTextRow do
                                    tabScrollModuleTextRow[i]:Hide();
                                end
                            end
                            self.TimeSinceLastUpdate = 0;
                        end
                    end
                );
            end
        end
    end
    -- Tab Init
    for i = 1, CS.numTabs do
        createTab(CS, i);
    end
    for i = 1, CS.numTabs do
        createTabFrame(CS, i);
    end
    updatePanel(CS);
    CS:HookScript("OnShow", updatePanel);

    -- Display the frame.
    function module.UpdateCSChangeSpec ()
        CS_SettingsInit();
        CS:SetPoint(module.GetSetting("CS_AnchorPoint"), module.GetSetting("CS_X"), module.GetSetting("CS_Y"));
        local Visible = module.GetSetting("CS_Visible");
        if Visible == false then
            CS:Hide();
        else
            CS:Show();
        end
    end
    -- Chat commands
        --- Function used when the Command is used (or via the Toolbox button).
        function module.CsCmd ()
            local Visible = CS:IsVisible();
            if Visible then
                CS:Hide();
            elseif not Visible then
                CS:Show();
            end
            module.Print("The Custom Settings UI is now", Visible and "|cFFFF0000hidden.|r" or "|cFF00FF00shown.|r");
        end

    -- Triggered via macro /soap savecil
    -- saves current Custom Interrupts List into a file with the specified name in the Profiles directory
    function module.SaveCILCmd (Arg)
        local FullList = "";
        local AllCustomInterrupts = module.GetSetting("InterruptTargets");
        local TotalInterrupts = #AllCustomInterrupts;
        for i = 1, #AllCustomInterrupts do
            local ThisInterrupt = AllCustomInterrupts[i];
            FullList = FullList .. ThisInterrupt.id .. "--" .. ThisInterrupt.name;
            if i < TotalInterrupts then
                FullList = FullList .. "\n";
            end
        end
        WriteFile(GetManagerDirectory() .. ProfilesDirectoryChange .. "Interrupts - " .. Arg .. ".txt", FullList);
        module.Print("|cffa901dbSaved |cFF0099FF" .. Arg .. "|r Custom Interrupt List.");
    end

    local function Split(Str, Pat)
        local t = {};
        local fpat = "(.-)" .. Pat;
        local last_end = 1;
        local s, e, cap = Str:find(fpat, 1);
        while s do
            if s ~= 1 or cap ~= "" then
                table.insert(t,cap);
            end
            last_end = e+1;
            s, e, cap = Str:find(fpat, last_end);
        end
        if last_end <= #Str then
            cap = Str:sub(last_end);
            table.insert(t, cap);
        end
        return t;
    end

    -- Triggered via macro /soap loadcil
    -- loads a Interrupts file with the specified name in the Profiles directory
    function module.LoadCILCmd (Arg)
        local InterruptsFile = ReadFile(GetManagerDirectory() .. ProfilesDirectoryChange .. "Interrupts - " .. Arg .. ".txt");
        if InterruptsFile then
            local FinalInterruptsArray = {};
            local InterruptsArray = Split(InterruptsFile, "\n");
            -- get all the spell IDs, one per line
            for i = 1, #InterruptsArray do
                local ThisInterrupt = Split(InterruptsArray[i], "-");
                if ThisInterrupt[1] ~= nil and type(tonumber(ThisInterrupt[1])) == "number" then
                    local ThisInterruptPosition = #FinalInterruptsArray + 1;
                    local SpellID = tonumber(ThisInterrupt[1])
                    local SpellName = select(1, GetSpellInfo(SpellID));
                    if SpellName ~= nil then
                        FinalInterruptsArray[ThisInterruptPosition] = { id = SpellID, name = SpellName };
                    end
                end
            end
            -- sort the spells by IDs
            for i = 1, #FinalInterruptsArray do
                for j = 2, #FinalInterruptsArray do
                    if FinalInterruptsArray[j].id < FinalInterruptsArray[j-1].id then
                        local TempSpell = FinalInterruptsArray[j]
                        FinalInterruptsArray[j] = FinalInterruptsArray[j-1]
                        FinalInterruptsArray[j-1] = TempSpell
                    end
                end
            end
            module.SetSetting("InterruptTargets", FinalInterruptsArray);
            module.Print("|cffa901dbLoaded |cFF0099FF" .. Arg .. "|r Custom Interrupt List.");
        else
            module.Print("|cffa901dbAttempted to load |cFF0099FF" .. Arg .. "|r Custom Interrupt List but the file does not exists.");
        end
    end
end)();





--[[------------------------------------------------------------------------------------------------
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
------------------------------------------------------------------------------------------------]]--
(function() --- Defines the graphical user interface.
    -- Set up the main frame.
    module.UserInterface = CreateFrame("Frame", "SB_UI"); -- When module will be randomized, randomize name here also.
    local UI = module.UserInterface;

    local function UI_SettingsInit ()
        -- Check to avoid operation on nil settings
        if not module.GetSetting("UI_AnchorPoint") then module.SetSetting("UI_AnchorPoint", "CENTER"); end
        if not module.GetSetting("UI_X") then module.SetSetting("UI_X", 250); end
        if not module.GetSetting("UI_Y") then module.SetSetting("UI_Y", 0); end
    end

    -- Local Variables for Frames
    local TitleBar_Height, ProfileSwitcher_Height, PageInfo_Height, Header_Height = 20, 0, 16;
    local Header_Height = ProfileSwitcher_Height + PageInfo_Height + 2; -- PS + PI + Space PS/PI.
    local Height_Total = TitleBar_Height + 2 + Header_Height + 2 + 2; -- Tb + Tb/Header Space + Header + Header/Options Space + Bottom Space.
    local UI_Height, UI_Width = Height_Total, 215;
    local Spacing = 14; -- Between each options.
    local Backdrop = {
        bgFile = "Interface\\DialogFrame\\UI-DialogBox-Background",
        tileSize = 32,
        edgeFile = "Interface\\FriendsFrame\\UI-Toast-Border",
        tile = 1,
        edgeSize = 3,
        insets = {
            top = 1,
            right = 1,
            left = 1,
            bottom = 1,
        },
    };
    -- Local Variables Frames
    local StaticInitialized = false;
    local TitleBar, TitleBarText, CloseButton;
    local Header, ProfileSwitcher, ProfileSwitcherTitle, PageInfo, PreviousPageButton, PageTitle, NextPageButton;
    -- Local Variables for Options
    local Pages, PageIndex = {}, 1;
    local OptionInfo, OptionFrame, Options = {}, {}, {};
    local DropDown_Index_Bis = {};

    --- Options styles
    local function CheckButton (OptionTable, CheckEntry)
        local Option = OptionTable;

        Option[CheckEntry]:SetPoint("TOPLEFT", OptionFrame[POIndex], "TOPLEFT", 5, - Spacing * LineIndex);
        Option[CheckEntry]:SetWidth(12);
        Option[CheckEntry]:SetHeight(12);
        Option[CheckEntry]:Hide();
        Option[CheckEntry]:SetScript("PostClick",
            function (self)
                module.SetSetting(self.Name .. "_Checked", self:GetChecked());
            end
        );
        Option[CheckEntry]:SetScript("OnEnter",
            function (self)
                if self.Tooltip then
                    GameTooltip:SetOwner(self, "ANCHOR_BOTTOMRIGHT");
                    GameTooltip:ClearLines();
                    GameTooltip:SetBackdropColor(0, 0, 0, 1);
                    GameTooltip:SetText(self.Tooltip, nil, nil, nil, 1, true);
                    GameTooltip:Show();
                end
            end
        );
        Option[CheckEntry]:SetScript("OnLeave",
            function (self)
                GameTooltip:Hide();
            end
        );

        return Option;
    end
    local function Label (OptionTable, TextEntry)
        local Option = OptionTable;

        Option[TextEntry]:SetPoint("TOPLEFT", OptionFrame[POIndex], "TOPLEFT", 20, - 1 - Spacing * LineIndex);
        Option[TextEntry]:SetWidth(190);
        Option[TextEntry]:SetFont("Fonts\\ARIALN.TTF", 9, "OUTLINE");
        Option[TextEntry]:SetJustifyH("LEFT");
        Option[TextEntry]:Hide();

        return Option;
    end
    local function NumericInputBox (OptionTable, SettingValue, SettingName, NumericEntry, x)
        -- x has to be either 78 (for Left - Value 1) or 38 (for Right - Value 2)
        local Option = OptionTable;

        Option[NumericEntry]:SetPoint("TOPLEFT", OptionFrame[POIndex], "TOPRIGHT", -x, - Spacing * LineIndex);
        Option[NumericEntry]:SetWidth(34);
        Option[NumericEntry]:SetHeight(10);
        Option[NumericEntry]:SetFont("Fonts\\ARIALN.TTF", 9, "OUTLINE");
        Option[NumericEntry]:SetAutoFocus(false);
        Option[NumericEntry]:SetFontObject(ChatFontNormal);
        Option[NumericEntry]:SetMaxLetters(4);
        Option[NumericEntry]:SetScript("OnMouseWheel",
            function (self, delta)
                local Value = tonumber(self:GetText());
                if Value then
                    Value = Value + (self.Step * delta);

                    if Value < self.Minimum then
                        Value = self.Minimum;
                    elseif Value > self.Maximum then
                        Value = self.Maximum;
                    end

                    self:SetText(Value);
                    module.SetSetting(SettingName .. SettingValue, Value);
                    module.UpdateOptions();
                end
            end
        );
        Option[NumericEntry]:SetScript("OnEnterPressed",
            function (self)
                local CurrentOptionValue = module.GetOptionValue(SettingName);
                if self:GetText():gsub("[^0-9%.]", "") ~= "" then
                    local NewOptionValue = tonumber(self:GetText());
                    if NewOptionValue > Option[NumericEntry].Maximum then
                        NewOptionValue = Option[NumericEntry].Maximum;
                    elseif NewOptionValue < Option[NumericEntry].Minimum then
                        NewOptionValue = Option[NumericEntry].Minimum;
                    end
                    module.SetSetting(SettingName .. SettingValue, NewOptionValue);
                    self:SetText(NewOptionValue);
                    self:ClearFocus();
                else
                    self:SetText(CurrentOptionValue);
                    module.SetSetting(SettingName .. SettingValue, tonumber(CurrentOptionValue));
                    self:ClearFocus();
                end
                module.UpdateOptions();
            end
        );
        Option[NumericEntry]:SetScript("OnChar",
            function (self, text)
                if not LastOption then LastOption = nil; end
                local CurrentOption = SettingName;
                local CurrentOptionValue = module.GetOptionValue(SettingName);
                if CurrentOption ~= LastOption then LastNumbers = nil; end
                if text:gsub("[^0-9%.]", "") ~= "" then
                    self:SetText(self:GetText():gsub("[^0-9%.]", ""));
                    LastNumbers = self:GetText():gsub("[^0-9%.]", "");
                    LastOption = SettingName;
                    LastOptionValue = module.GetOptionValue(SettingName);
                    module.SetSetting(SettingName .. SettingValue, tonumber(self:GetText()));
                elseif CurrentOption == LastOption and LastNumbers then
                    LastOption = SettingName;
                    LastOptionValue = module.GetOptionValue(SettingName);
                    self:SetText(LastNumbers);
                    module.SetSetting(SettingName .. SettingValue, tonumber(LastNumbers));
                    self:ClearFocus();
                elseif CurrentOption == LastOption then
                    LastOption = SettingName;
                    LastOptionValue = module.GetOptionValue(SettingName);
                    self:SetText(LastOptionValue);
                    module.SetSetting(SettingName .. SettingValue, tonumber(LastOptionValue));
                    self:ClearFocus();
                else
                    self:SetText(CurrentOptionValue);
                    module.SetSetting(SettingName .. SettingValue, tonumber(CurrentOptionValue));
                    self:ClearFocus();
                end
            end
        );

        Option[NumericEntry]:SetTextInsets(-3, -3, 0, 0);
        Option[NumericEntry].Left:SetWidth(3);
        Option[NumericEntry].Left:SetHeight(12);
        Option[NumericEntry].Middle:SetHeight(12);
        Option[NumericEntry].Right:SetWidth(3);
        Option[NumericEntry].Right:SetHeight(12);
        Option[NumericEntry]:Hide();

        return Option;
    end
    local function DropDown (OptionTable, DDIndex, SettingValue, SettingName, DDEntry, Items, x)
        -- x has to be either 41 (for Left - Value 1) or 0 (for Right - Value 2)
        local Option = OptionTable;

        Option[DDEntry]:SetPoint("TOPRIGHT", OptionFrame[POIndex], "TOPRIGHT", -x, - Spacing * LineIndex);

        local function OnClick(self)
            UIDropDownMenu_SetSelectedID(Option[DDEntry], self:GetID());
            module.SetSetting(SettingName .. SettingValue, UIDropDownMenu_GetText(Option[DDEntry]));
        end

        local function Initialize(Self, Level)
            local Info = UIDropDownMenu_CreateInfo();
            for k, v in pairs(Items) do
                if k > 1 then
                    Info = UIDropDownMenu_CreateInfo();
                    Info.text = v;
                    Info.value = v;
                    Info.func = OnClick;
                    UIDropDownMenu_AddButton(Info, Level);
                end
            end
        end

        UIDropDownMenu_Initialize(Option[DDEntry], Initialize);
        UIDropDownMenu_SetButtonWidth(Option[DDEntry], 24);
        UIDropDownMenu_SetSelectedValue(Option[DDEntry], module.GetSetting(SettingName .. SettingValue));
        UIDropDownMenu_JustifyText(Option[DDEntry], "LEFT");

        local FrameName = Option[DDEntry]:GetName();

        _G[FrameName]:SetSize(46, 16);
        _G[FrameName.."Text"]:SetFont("Fonts\\ARIALN.TTF", 9, "OUTLINE");
        _G[FrameName.."Left"]:SetSize(5, 32);
        _G[FrameName.."Middle"]:SetSize(36, 32);
        _G[FrameName.."Right"]:SetSize(5, 32);
        _G[FrameName.."Text"]:SetWidth(30);
        _G[FrameName.."Left"]:SetPoint("TOPLEFT", 0, 10);
        _G[FrameName.."Button"]:SetSize(46, 16);
        _G[FrameName.."ButtonNormalTexture"]:SetSize(12, 12);
        _G[FrameName.."ButtonPushedTexture"]:SetSize(12, 12);
        _G[FrameName.."ButtonDisabledTexture"]:SetSize(12, 12);
        _G[FrameName.."ButtonHighlightTexture"]:SetSize(12, 12);
        _G[FrameName.."Button"]:SetPoint("TOPRIGHT", -2.5, 2.5);
        _G[FrameName.."Text"]:SetPoint("LEFT", _G[FrameName.."Left"], "RIGHT", 1, 1);

        if not DropDown_Index_Bis[DDIndex] then
            DropDown_Index_Bis[DDIndex] = 1;
        else
            DropDown_Index_Bis[DDIndex] = DropDown_Index_Bis[DDIndex] + 1;
        end

        return Option;
    end
    local function EditBoxButton (OptionTable, SettingValue, SettingName, EditEntry, x)
        -- x has to be either 83 (for Left - Value 1) or 43 (for Right - Value 2)
        local Option = OptionTable;
        if SettingName == "Macro Command" then
            module.CmdPopup = Option[EditEntry]:GetName().." - Popup";
        end

        StaticPopupDialogs[Option[EditEntry]:GetName().." - Popup"] = {
            text = "Set the Setting you want.",
            button1 = "Accept",
            button2 = "Cancel",
            OnShow = function (self, data)
                self.editBox:SetText(module.GetSetting(SettingName .. SettingValue));
            end,
            OnAccept = function (self, data, data2)
                local Text = self.editBox:GetText();
                module.SetSetting(SettingName .. SettingValue, Text);
                if string.len(Text) > 4 then Text = string.sub(Text, 1, 4)..".."; end
                Option[EditEntry]:SetFormattedText("|cFF0066FF%s|r", Text);
            end,
            hasEditBox = true,
            timeout = 0,
            whileDead = true,
            hideOnEscape = true,
            preferredIndex = 3
        };

        Option[EditEntry]:SetPoint("TOPLEFT", OptionFrame[POIndex], "TOPRIGHT", -x, - Spacing * LineIndex + 1);
        Option[EditEntry]:SetWidth(40);
        Option[EditEntry]:SetHeight(12);
        local Text = module.GetSetting(SettingName .. SettingValue) or "Clic";
        if string.len(Text) > 4 then Text = string.sub(Text, 1, 4)..".."; end
        Option[EditEntry]:SetFormattedText("|cFF0066FF%s|r", Text);
        Option[EditEntry]:SetScript("OnEnter",
            function (self)
                GameTooltip:SetOwner(Option[EditEntry], "ANCHOR_TOPLEFT", 0, 0);
                GameTooltip:ClearLines();
                GameTooltip:SetBackdropColor(0, 0, 0, 1);
                GameTooltip:SetText(module.GetSetting(SettingName .. SettingValue), nil, nil, nil, 1, true);
                GameTooltip:Show();
            end
        );
        Option[EditEntry]:SetScript("OnLeave",
            function (self)
                GameTooltip:Hide();
            end
        );
        Option[EditEntry]:SetNormalFontObject("GameFontNormalSmall");
        local ntex = Option[EditEntry]:CreateTexture();
        ntex:SetTexture("Interface/Buttons/UI-Silver-Button-Up");
        ntex:SetTexCoord(0, 0.625, 0, 0.7875);
        ntex:SetAllPoints();
        Option[EditEntry]:SetNormalTexture(ntex);
        local htex = Option[EditEntry]:CreateTexture();
        htex:SetTexture("Interface/Buttons/UI-Silver-Button-Highlight");
        htex:SetTexCoord(0, 0.625, 0, 0.7875);
        htex:SetAllPoints();
        Option[EditEntry]:SetHighlightTexture(htex);
        local ptex = Option[EditEntry]:CreateTexture();
        ptex:SetTexture("Interface/Buttons/UI-Silver-Button-Down");
        ptex:SetTexCoord(0, 0.625, 0, 0.7875);
        ptex:SetAllPoints();
        Option[EditEntry]:SetPushedTexture(ptex);
        Option[EditEntry]:SetScript("OnMouseDown",
            function (self)
                StaticPopup_Show(Option[EditEntry]:GetName().." - Popup");
            end
        );

        return Option;
    end

    --- Create the Main Frame
    local function InitFrame ()
        -- Settings checks
        UI_SettingsInit();
        --- UI Frame Display
        UI:ClearAllPoints();
        UI:SetHeight(UI_Height);
        UI:SetWidth(UI_Width);
        UI:SetPoint(module.GetSetting("UI_AnchorPoint"), module.GetSetting("UI_X"), module.GetSetting("UI_Y"));
        UI:SetFrameStrata("LOW");
        UI:SetClampedToScreen(true);
        UI:SetMovable(true);
        UI:EnableMouse(true);
        UI:SetBackdrop(Backdrop);
        -- UI Visible Scripts
        UI:SetScript("OnShow",
            function (self)
                module.SetSetting("UI_Visible", true);
            end
        );
        UI:SetScript("OnHide",
            function (self)
                module.SetSetting("UI_Visible", false);
            end
        );
    end

    local function InitStatic ()
        --- Title Bar Frame Display
        TitleBar = CreateFrame("Frame", "$parent_TitleBar", UI);
        TitleBar:SetPoint("TOPLEFT", 1, -1);
        TitleBar:SetPoint("TOPRIGHT", -1, -1);
        TitleBar:SetHeight(TitleBar_Height);
        Backdrop.edgeSize = 2;
        Backdrop.insets.bottom = 1;
        TitleBar:SetBackdrop(Backdrop);
        TitleBar:SetBackdropColor(0, 0, 0, 1);
        -- Title Bar Text
        TitleBarText = TitleBar:CreateFontString("$parent_Title");
        TitleBarText:SetAllPoints(TitleBar);
        TitleBarText:SetFont("Fonts\\FRIZQT__.TTF", 12, "OUTLINE");
        TitleBarText:SetText("Soapbox Rotations");
        TitleBarText:SetJustifyH("CENTER");
        TitleBarText:SetJustifyV("CENTER");
        -- Title Bar Close Button
        CloseButton = CreateFrame("Button", "$parent_CloseButton", TitleBar, "UIPanelCloseButton");
        CloseButton:SetPoint("TOPRIGHT", 1, 1);
        CloseButton:SetHeight(20);
        CloseButton:SetWidth(20);
        CloseButton:SetScript("OnClick",
            function (self)
                UI:Hide();
            end
        );
        -- Title Bar Start Move
        TitleBar:SetScript("OnMouseDown",
            function (self)
                UI:StartMoving();
            end
        );
        -- Title Bar Stop Move
        TitleBar:SetScript("OnMouseUp",
            function (self)
                UI:StopMovingOrSizing();

                local Point, RelativeTo, RelativePoint, X, Y = UI:GetPoint();
                module.SetSetting("UI_AnchorPoint", Point);
                module.SetSetting("UI_X", X);
                module.SetSetting("UI_Y", Y);
            end
        );


        --- Frame [HEADER : Profile Switcher + Page Infos]
        Header = CreateFrame("Frame", "$parent_Header", UI);
        Header:SetPoint("TOPLEFT", TitleBar, "BOTTOMLEFT", 1, -2);
        Header:SetPoint("TOPRIGHT", TitleBar, "BOTTOMRIGHT", -1, -2);
        Header:SetHeight(Header_Height);
        -- Profile Switcher Frame Display
        ProfileSwitcher = CreateFrame("Frame", "$parent_ProfileSwitcher", Header);
        ProfileSwitcher:SetPoint("TOPLEFT", 1, 0);
        ProfileSwitcher:SetPoint("TOPRIGHT", -1, 0);
        ProfileSwitcher:SetHeight(ProfileSwitcher_Height);
        -- [TEMP] ProfilSwitcherTitle until I do the real module
        ProfileSwitcherTitle = ProfileSwitcher:CreateFontString("$parent_Title");
        ProfileSwitcherTitle:SetAllPoints();
        ProfileSwitcherTitle:SetFont("Fonts\\FRIZQT__.TTF", 8, "OUTLINE");
        ProfileSwitcherTitle:SetJustifyH("CENTER");
        ProfileSwitcherTitle:SetText("------------[Profile Switcher]------------");
        -- Page Infos Frame Display
        PageInfo = CreateFrame("Frame", "$parent_PageInfo", Header);
        PageInfo:SetPoint("TOPLEFT", 1, -ProfileSwitcher_Height-2);
        PageInfo:SetPoint("TOPRIGHT", -1, -ProfileSwitcher_Height-2);
        PageInfo:SetHeight(PageInfo_Height);
        PageInfo:SetScript("OnMouseWheel",
            function (self, delta)
                if delta > 0 and PageIndex == #Pages or delta < 0 and PageIndex == 1 then return; end
                OptionFrame[PageIndex]:Hide();
                PageIndex = PageIndex + delta;
                OptionFrame[PageIndex]:Show();
                module.UpdateOptions();
            end
        );
        -- Previous Page button
        PreviousPageButton = CreateFrame("Button", "$parent_PreviousButton", PageInfo);
        PreviousPageButton:SetPoint("TOPLEFT", PageInfo, "TOPLEFT", 2, -1);
        PreviousPageButton:SetPoint("BOTTOMRIGHT", PageInfo, "TOPLEFT", 17, -16);
        PreviousPageButton:SetNormalTexture("Interface\\Buttons\\UI-SpellbookIcon-PrevPage-Up");
        PreviousPageButton:SetPushedTexture("Interface\\Buttons\\UI-SpellbookIcon-PrevPage-Down");
        PreviousPageButton:SetDisabledTexture("Interface\\Buttons\\UI-SpellbookIcon-PrevPage-Disabled");
        PreviousPageButton:SetHighlightTexture("Interface\\Buttons\\UI-Common-MouseHilight");
        PreviousPageButton:SetScript("PostClick",
            function (self)
                OptionFrame[PageIndex]:Hide();
                PageIndex = PageIndex - 1;
                OptionFrame[PageIndex]:Show();
                module.UpdateOptions();
            end
        );
        -- Page Title
        PageTitle = PageInfo:CreateFontString("$parent_Title");
        PageTitle:SetPoint("TOPLEFT", PageInfo, "TOPLEFT", 2, -2);
        PageTitle:SetPoint("BOTTOMRIGHT", PageInfo, "BOTTOMRIGHT", -2, 2);
        PageTitle:SetFont("Fonts\\FRIZQT__.TTF", 8, "OUTLINE");
        PageTitle:SetJustifyH("CENTER");
        -- Next Page button.
        NextPageButton = CreateFrame("Button", "$parent_NextButton", PageInfo);
        NextPageButton:SetPoint("TOPRIGHT", PageInfo, "TOPRIGHT", -2, -1);
        NextPageButton:SetPoint("BOTTOMLEFT", PageInfo, "TOPRIGHT", -17, -16);
        NextPageButton:SetNormalTexture("Interface\\Buttons\\UI-SpellbookIcon-NextPage-Up");
        NextPageButton:SetPushedTexture("Interface\\Buttons\\UI-SpellbookIcon-NextPage-Down");
        NextPageButton:SetDisabledTexture("Interface\\Buttons\\UI-SpellbookIcon-NextPage-Disabled");
        NextPageButton:SetHighlightTexture("Interface\\Buttons\\UI-Common-MouseHilight");
        NextPageButton:SetScript("PostClick",
            function (self)
                OptionFrame[PageIndex]:Hide();
                PageIndex = PageIndex + 1;
                OptionFrame[PageIndex]:Show();
                module.UpdateOptions();
            end
        );

        StaticInitialized = true;
    end

    --- Create all the Pages.
    local function InitPages ()
        for Index = 1, #Pages do
            local PageName = Pages[Index];
            POIndex = Index;
            OptionFrame[POIndex] = CreateFrame("Frame", "$parent_OptionFrame_"..POIndex, UI);
            OptionFrame[POIndex]:SetPoint("TOPLEFT", Header, "BOTTOMLEFT", 0, -2);
            OptionFrame[POIndex]:SetPoint("BOTTOMRIGHT", UI, "BOTTOMRIGHT", 0, 0);
            Options[POIndex] = {};
            LineIndex = 0;
            for Index = 1, #OptionInfo do
                local CurrentLine = OptionInfo[Index];
                local Type = CurrentLine.Type;
                if CurrentLine.Page == PageName then
                    local Option = {};
                    -- X 1 Z : Text
                    if Type.X == 1 and Type.Y == 1 then
                        Option = {
                            Type,
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label")
                        };
                        Option = Label(Option, 2);
                    -- X 2 0 : Simple Numeric
                    elseif Type.Y == 2 and Type.Z == 0 then
                        Option = {
                            Type,
                            CreateFrame("CheckButton", "Option" .. Index .. "CheckButton", OptionFrame[POIndex], "ChatConfigSmallCheckButtonTemplate"),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("EditBox", "Option" .. Index .. "EditBox", OptionFrame[POIndex], "InputBoxTemplate")
                        };
                        Option = CheckButton(Option, 2);
                        Option = Label(Option, 3);
                        Option = NumericInputBox(Option, "_Value1", CurrentLine.Name, 4, 38);
                    -- 2 1 Z : Toggle
                    elseif Type.X == 2 and Type.Y == 1 then
                        Option = {
                            Type,
                            CreateFrame("CheckButton", "Option" .. Index .. "CheckButton", OptionFrame[POIndex], "ChatConfigSmallCheckButtonTemplate"),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label")
                        };
                        Option = CheckButton(Option, 2);
                        Option = Label(Option, 3);
                    -- X 2 1 : Double Numeric Bound
                    -- X 2 2 : Double Numeric Free
                    elseif Type.Y == 2 and (Type.Z == 1 or Type.Z == 2) then
                        Option = {
                            Type,
                            CreateFrame("CheckButton", "Option" .. Index .. "CheckButton", OptionFrame[POIndex], "ChatConfigSmallCheckButtonTemplate"),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("EditBox", "Option" .. Index .. "EditBox", OptionFrame[POIndex], "InputBoxTemplate"),
                            CreateFrame("EditBox", "Option" .. Index .. "EditBox2", OptionFrame[POIndex], "InputBoxTemplate")
                        };
                        Option = CheckButton(Option, 2);
                        Option = Label(Option, 3);
                        Option = NumericInputBox(Option, "_Value1", CurrentLine.Name, 4, 78);
                        Option = NumericInputBox(Option, "_Value2", CurrentLine.Name, 5, 38);
                    -- X 2 3 : Numeric + Dropdown
                    elseif Type.Y == 2 and Type.Z == 3 then
                        local DropDownIndex;
                        if not DropDown_Index_Bis[Index] then DropDownIndex = Index; else DropDownIndex = Index.."Bis("..DropDown_Index_Bis[Index]..")"; end
                        Option = {
                            Type,
                            CreateFrame("CheckButton", "Option" .. Index .. "CheckButton", OptionFrame[POIndex], "ChatConfigSmallCheckButtonTemplate"),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("EditBox", "Option" .. Index .. "EditBox", OptionFrame[POIndex], "InputBoxTemplate"),
                            CreateFrame("Button", "Option" .. DropDownIndex .. "DropDownMenu", OptionFrame[POIndex], "UIDropDownMenuTemplate")
                        };
                        Option = CheckButton(Option, 2);
                        Option = Label(Option, 3);
                        Option = NumericInputBox(Option, "_Value1", CurrentLine.Name, 4, 78);
                        Option = DropDown(Option, Index, "_Value2", CurrentLine.Name, 5, CurrentLine.Value2, 0);
                    -- X 2 4 : Numeric + EditBoxButton
                    elseif Type.Y == 2 and Type.Z == 4 then
                        Option = {
                            Type,
                            CreateFrame("CheckButton", "Option" .. Index .. "CheckButton", OptionFrame[POIndex], "ChatConfigSmallCheckButtonTemplate"),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("EditBox", "Option" .. Index .. "EditBox", OptionFrame[POIndex], "InputBoxTemplate"),
                            CreateFrame("Button", "Option" .. Index .. "EditBoxButton", OptionFrame[POIndex])
                        };
                        Option = CheckButton(Option, 2);
                        Option = Label(Option, 3);
                        Option = NumericInputBox(Option, "_Value1", CurrentLine.Name, 4, 78);
                        Option = EditBoxButton(Option, "_Value2", CurrentLine.Name, 5, 36);
                    -- X 3 0 : Simple Dropdown
                    elseif Type.Y == 3 and Type.Z == 0 then
                        local DropDownIndex;
                        if not DropDown_Index_Bis[Index] then DropDownIndex = Index; else DropDownIndex = Index.."Bis("..DropDown_Index_Bis[Index]..")"; end
                        Option = {
                            Type,
                            CreateFrame("CheckButton", "Option" .. Index .. "CheckButton", OptionFrame[POIndex], "ChatConfigSmallCheckButtonTemplate"),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("Button", "Option" .. DropDownIndex .. "DropDownMenu", OptionFrame[POIndex], "UIDropDownMenuTemplate")
                        };
                        Option = CheckButton(Option, 2);
                        Option = Label(Option, 3);
                        Option = DropDown(Option, Index, "_Value1", CurrentLine.Name, 4, CurrentLine.Value1, 0);
                    -- X 3 2 : Dropdown + Numeric
                    elseif Type.Y == 3 and Type.Z == 2 then
                        local DropDownIndex;
                        if not DropDown_Index_Bis[Index] then DropDownIndex = Index; else DropDownIndex = Index.."Bis("..DropDown_Index_Bis[Index]..")"; end
                        Option = {
                            Type,
                            CreateFrame("CheckButton", "Option" .. Index .. "CheckButton", OptionFrame[POIndex], "ChatConfigSmallCheckButtonTemplate"),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("Button", "Option" .. DropDownIndex .. "DropDownMenu", OptionFrame[POIndex], "UIDropDownMenuTemplate"),
                            CreateFrame("EditBox", "Option" .. Index .. "EditBox", OptionFrame[POIndex], "InputBoxTemplate")
                        };
                        Option = CheckButton(Option, 2);
                        Option = Label(Option, 3);
                        Option = DropDown(Option, Index, "_Value1", CurrentLine.Name, 4, CurrentLine.Value1, 41);
                        Option = NumericInputBox(Option, "_Value2", CurrentLine.Name, 5, 38);
                    -- X 3 3 : Double Dropdown
                    elseif Type.Y == 3 and Type.Z == 3 then
                        local DropDownIndex;
                        if not DropDown_Index_Bis[Index] then DropDownIndex = Index; else DropDownIndex = Index.."Bis("..DropDown_Index_Bis[Index]..")"; end
                        Option = {
                            Type,
                            CreateFrame("CheckButton", "Option" .. Index .. "CheckButton", OptionFrame[POIndex], "ChatConfigSmallCheckButtonTemplate"),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("Button", "Option" .. DropDownIndex .. "DropDownMenu", OptionFrame[POIndex], "UIDropDownMenuTemplate"),
                            CreateFrame("Button", "Option" .. DropDownIndex .. "DropDownMenu2", OptionFrame[POIndex], "UIDropDownMenuTemplate")
                        };
                        Option = CheckButton(Option, 2);
                        Option = Label(Option, 3);
                        Option = DropDown(Option, Index, "_Value1", CurrentLine.Name, 4, CurrentLine.Value1, 41);
                        Option = DropDown(Option, Index, "_Value2", CurrentLine.Name, 5, CurrentLine.Value2, 0);
                    -- X 3 4 : Dropdown + EditBoxButton
                    elseif Type.Y == 3 and Type.Z == 4 then
                        local DropDownIndex;
                        if not DropDown_Index_Bis[Index] then DropDownIndex = Index; else DropDownIndex = Index.."Bis("..DropDown_Index_Bis[Index]..")"; end
                        Option = {
                            Type,
                            CreateFrame("CheckButton", "Option" .. Index .. "CheckButton", OptionFrame[POIndex], "ChatConfigSmallCheckButtonTemplate"),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("Button", "Option" .. DropDownIndex .. "DropDownMenu", OptionFrame[POIndex], "UIDropDownMenuTemplate"),
                            CreateFrame("Button", "Option" .. Index .. "EditBoxButton", OptionFrame[POIndex])
                        };
                        Option = CheckButton(Option, 2);
                        Option = Label(Option, 3);
                        Option = DropDown(Option, Index, "_Value1", CurrentLine.Name, 4, CurrentLine.Value1, 41);
                        Option = EditBoxButton(Option, "_Value2", CurrentLine.Name, 5, 36);
                    -- X 4 0 : EditBoxButton
                    elseif Type.Y == 4 and Type.Z == 0 then
                        Option = {
                            Type,
                            CreateFrame("CheckButton", "Option" .. Index .. "CheckButton", OptionFrame[POIndex], "ChatConfigSmallCheckButtonTemplate"),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("Button", "Option" .. Index .. "EditBoxButton", OptionFrame[POIndex])
                        };
                        Option = CheckButton(Option, 2);
                        Option = Label(Option, 3);
                        Option = EditBoxButton(Option, "_Value1", CurrentLine.Name, 4, 43);
                    -- X 4 2 : EditBoxButton + Numeric
                    elseif Type.Y == 4 and Type.Z == 2 then
                        Option = {
                            Type,
                            CreateFrame("CheckButton", "Option" .. Index .. "CheckButton", OptionFrame[POIndex], "ChatConfigSmallCheckButtonTemplate"),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("Button", "Option" .. Index .. "EditBoxButton", OptionFrame[POIndex]),
                            CreateFrame("EditBox", "Option" .. Index .. "EditBox", OptionFrame[POIndex], "InputBoxTemplate")
                        };
                        Option = CheckButton(Option, 2);
                        Option = Label(Option, 3);
                        Option = EditBoxButton(Option, "_Value1", CurrentLine.Name, 4, 83);
                        Option = NumericInputBox(Option, "_Value2", CurrentLine.Name, 5, 38);
                    -- X 4 3 : EditBoxButton + Dropdown
                    elseif Type.Y == 4 and Type.Z == 3 then
                        local DropDownIndex;
                        if not DropDown_Index_Bis[Index] then DropDownIndex = Index; else DropDownIndex = Index.."Bis("..DropDown_Index_Bis[Index]..")"; end
                        Option = {
                            Type,
                            CreateFrame("CheckButton", "Option" .. Index .. "CheckButton", OptionFrame[POIndex], "ChatConfigSmallCheckButtonTemplate"),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("Button", "Option" .. Index .. "EditBoxButton", OptionFrame[POIndex]),
                            CreateFrame("Button", "Option" .. DropDownIndex .. "DropDownMenu", OptionFrame[POIndex], "UIDropDownMenuTemplate")
                        };
                        Option = CheckButton(Option, 2);
                        Option = Label(Option, 3);
                        Option = EditBoxButton(Option, "_Value1", CurrentLine.Name, 4, 83);
                        Option = DropDown(Option, Index, "_Value2", CurrentLine.Name, 5, CurrentLine.Value2, 0);
                    -- X 4 4 : Double EditBoxButton
                    elseif Type.Y == 4 and Type.Z == 4 then
                        Option = {
                            Type,
                            CreateFrame("CheckButton", "Option" .. Index .. "CheckButton", OptionFrame[POIndex], "ChatConfigSmallCheckButtonTemplate"),
                            OptionFrame[POIndex]:CreateFontString("Option" .. Index .. "Label"),
                            CreateFrame("Button", "Option" .. Index .. "EditBoxButton", OptionFrame[POIndex]),
                            CreateFrame("Button", "Option" .. Index .. "EditBoxButton2", OptionFrame[POIndex])
                        };
                        Option = CheckButton(Option, 2);
                        Option = Label(Option, 3);
                        Option = EditBoxButton(Option, "_Value1", CurrentLine.Name, 4, 83);
                        Option = EditBoxButton(Option, "_Value2", CurrentLine.Name, 5, 43);
                    end
                    LineIndex = LineIndex + 1;
                    Options[POIndex][LineIndex] = Option;
                end
            end
        end
        for Index = 1, #OptionFrame do
            OptionFrame[Index]:Hide();
        end
        OptionFrame[PageIndex]:Show();
        module.UpdateOptions();
    end

    function module.CreateUI ()
        -- Init the frame.
        InitFrame();
        -- Init static parts if not already done
        if not StaticInitialized then
            InitStatic();
        end
        -- Init pages.
        InitPages();
        -- Display the frame.
        local Visible = module.GetSetting("UI_Visible");
        if Visible == false then
            UI:Hide();
        else
            UI:Show();
        end
        module.UISpec = GetSpecialization();
    end

    --- Update the Options.
    function module.UpdateOptions ()
        local PageName = Pages[PageIndex];
        local PageCount = {};
        PageTitle:SetText(PageName);

        local Count = 0;
        for Index, Info in pairs(OptionInfo) do
            if PageCount[Info.Page] then
                PageCount[Info.Page] = PageCount[Info.Page] + 1;
            else
                PageCount[Info.Page] = 1;
            end

            if Info.Page == PageIndex or Info.Page == PageName then
                local Option = Options[PageIndex][Count + 1];
                local CheckEntry, TextEntry, NumericEntry1, NumericEntry2, DDEntry1, DDEntry2 = nil, nil, nil, nil, nil;
                local Type = Info.Type;
                -- Uncomment for debug: print(Info.Name.. " : "..tostring(Type.X)..tostring(Type.Y)..tostring(Type.Z));
                -- X 1 Z : Text
                if Type.X == 1 and Type.Y == 1 then
                    TextEntry = 2;
                -- X 2 0 : Simple Numeric
                elseif Type.Y == 2 and Type.Z == 0 then
                    CheckEntry = 2;
                    TextEntry = 3;
                    NumericEntry1 = 4;
                -- 2 1 Z : Toggle
                elseif Type.X == 2 and Type.Y == 1 then
                    CheckEntry = 2;
                    TextEntry = 3;
                -- X 2 1 : Double Numeric Bound
                -- X 2 2 : Double Numeric Free
                elseif Type.Y == 2 and (Type.Z == 1 or Type.Z == 2) then
                    CheckEntry = 2;
                    TextEntry = 3;
                    NumericEntry1 = 4;
                    NumericEntry2 = 5;
                -- X 2 3 : Numeric + Dropdown
                elseif Type.Y == 2 and Type.Z == 3 then
                    CheckEntry = 2;
                    TextEntry = 3;
                    NumericEntry1 = 4;
                    DDEntry1 = 5;
                -- X 2 4 : Numeric + EditBoxButton
                elseif Type.Y == 2 and Type.Z == 4 then
                    CheckEntry = 2;
                    TextEntry = 3;
                    NumericEntry1 = 4;
                -- X 3 0 : Simple Dropdown
                elseif Type.Y == 3 and Type.Z == 0 then
                    CheckEntry = 2;
                    TextEntry = 3;
                    DDEntry1 = 4;
                -- X 3 2 : Dropdown + Numeric
                elseif Type.Y == 3 and Type.Z == 2 then
                    CheckEntry = 2;
                    TextEntry = 3;
                    DDEntry1 = 4;
                    NumericEntry1 = 5;
                -- X 3 3 : Double Dropdown
                elseif Type.Y == 3 and Type.Z == 3 then
                    CheckEntry = 2;
                    TextEntry = 3;
                    DDEntry1 = 4;
                    DDEntry2 = 5;
                -- X 3 4 : Dropdown + EditBoxButton
                elseif Type.Y == 3 and Type.Z == 4 then
                    CheckEntry = 2;
                    TextEntry = 3;
                    DDEntry1 = 4;
                -- X 4 0 : EditBoxButton
                elseif Type.Y == 4 and Type.Z == 0 then
                    CheckEntry = 2;
                    TextEntry = 3;
                -- X 4 2 : EditBoxButton + Numeric
                elseif Type.Y == 4 and Type.Z == 2 then
                    CheckEntry = 2;
                    TextEntry = 3;
                    NumericEntry1 = 5;
                -- X 4 3 : EditBoxButton + Dropdown
                elseif Type.Y == 4 and Type.Z == 3 then
                    CheckEntry = 2;
                    TextEntry = 3;
                    DDEntry1 = 5;
                -- X 4 4 : Double EditBoxButton
                elseif Type.Y == 4 and Type.Z == 4 then
                    CheckEntry = 2;
                    TextEntry = 3;
                end
                Option[TextEntry]:SetText(Info.Name);

                if not (Type.X == 1 and Type.Y == 1) then
                    Option[CheckEntry].Tooltip = Info.Tooltip;
                    Option[CheckEntry].Name = Info.Name;

                    Option[CheckEntry]:SetChecked(module.GetSetting(Info.Name .. "_Checked"));
                    if Type.X == 1 then Option[CheckEntry]:SetAlpha(0); else Option[CheckEntry]:SetAlpha(1); end
                    Option[CheckEntry]:Show();

                    if Type.Y == 2 or Type.Z == 2 then
                        local Value;
                        local Minimum, Maximum, Step, Gap;

                        if Type.Y ~= 2 and Type.Z == 2 then
                            Value = module.GetSetting(Info.Name .. "_Value2") or Info.Value2[1] or 0;
                            Minimum, Maximum, Step = Info.Value2[2], Info.Value2[3], Info.Value2[4];
                        else
                            Value = module.GetSetting(Info.Name .. "_Value1") or Info.Value1[1] or 0;
                            Minimum, Maximum, Step, Gap = Info.Value1[2], Info.Value1[3], Info.Value1[4], Info.Value1[5];
                        end

                        Option[NumericEntry1]:SetText(Value);
                        Option[NumericEntry1].Step = Step;
                        Option[NumericEntry1].Minimum = Minimum;
                        Option[NumericEntry1].Maximum = Maximum;
                        Option[NumericEntry1]:Show();

                        if Type.Z == 1 or (Type.Y == 2 and Type.Z == 2) then
                            local Value2 = module.GetSetting(Info.Name .. "_Value2") or Info.Value2[1] or 0;

                            if Type.Y == 2 and Type.Z == 2 then
                                Minimum, Maximum, Step = Info.Value2[2], Info.Value2[3], Info.Value2[4];
                                Option[NumericEntry2]:SetText(Value2);
                                Option[NumericEntry2].Step = Step;
                                Option[NumericEntry2].Minimum = Minimum;
                                Option[NumericEntry2].Maximum = Maximum;
                                Option[NumericEntry2]:Show();
                            elseif Type.Z == 1 then
                                Option[NumericEntry1].Maximum = Value2 - Gap;
                                Option[NumericEntry2]:SetText(Value2);
                                Option[NumericEntry2].Step = Step;
                                Option[NumericEntry2].Minimum = Value + Gap;
                                Option[NumericEntry2].Maximum = Maximum;
                                Option[NumericEntry2]:Show();
                            end
                        end
                    end
                end

                Option[TextEntry]:Show();

                Count = Count + 1;
            end
        end

        if PageIndex == 1 then
            PreviousPageButton:Disable();
        else
            PreviousPageButton:Enable();
        end

        if PageIndex == #Pages or #Pages == 0 then
            NextPageButton:Disable();
        else
            NextPageButton:Enable();
        end

        local MaxPage = nil;
        local MaxCount = 0;
        for Page, Count in pairs(PageCount) do
            if not MaxPage or Count > MaxCount then
                MaxPage = Page;
                MaxCount = Count;
            end
        end

        UI:SetHeight(UI_Height + Spacing * MaxCount);
    end

    -- Functions for manipulating the UI.

    --- Clear all pages and options.
    function module.ClearOptions ()
        Pages = {};
        OptionInfo = {};
        for Index = 1, #OptionFrame do
            OptionFrame[Index]:Hide();
        end
    end

    --- Add a page.
    -- @param Name The name of the page.
    -- @return The index of the page.
    function module.AddPage (Name)
        table.insert(Pages, Name);
        UpdateOutputs();
        return #Pages;
    end

    --- Add a section.
    -- @param Page The name or index of the page to add the section to.
    -- @param Name The name of the section.
    -- @param Color The color to apply to Name.
        -- If you want to customize the entire Name (adding Code outside of the string to color all the string), then set it to "Custom" and see the 4th parameter.
        -- If you want to customize INSIDE Name, then set it to "None".
        -- If it's white, you can ommit Color parameter. (But do not put Color Code inside, to achieve this set Color to "None").
        -- If you want to add Color support, feel free to add them like I did below (if Color == "...." then ...) and them in the Supported Color section.
        -- Supported Color :
            -- "Blue"       -- "Red"        -- "Green"          -- "JadeGreen"
    -- @param Code The code to apply if Color is set to "Custom".
    -- 4 Examples :
        -- White : module.AddSection("Page", "The Name") -> "The Name"
        -- Simple Color : module.AddSection("Page", "The Name", "Blue") -> "|cFF0066FFThe Name|r"
        -- Outside Custom Color : module.AddSection("Page", "The Name", "Custom", "334455") -> "|cFF334455The Name|r"
        -- Inside Custom Color : module.AddSection("Page", "|cFFFF0000This part in Red|r |cFF0000FFThis part in Blue|r", "None") -> "|cFFFF0000This part in Red|r |cFF0000FFThis part in Blue|r"
    function module.AddSection (Page, Name, Color, Code)
        local Name = Name or "";
        -- -- --
        --- Part to remove when all AddSection won't have Color Code in name and Color will be set.
        if string.sub(Name, 1, 2) == "|c" and string.sub(Name, -2, -1) == "|r" then -- Those with "|r" at the end.
            Name = string.sub(Name, 11, -3);
            Color = "Green";
        elseif string.sub(Name, 1, 2) == "|c" then -- Those without "|r" at the end.
            Name = string.sub(Name, 11, -1);
            Color = "Green";
        end
        -- -- --

        if Color == "Custom" and Code then
            Name = "|cFF"..Code..Name.."|r";
        elseif Color == "Blue" then
            Name = "|cFF0066FF"..Name.."|r";
        elseif Color == "Red" then
            Name = "|cFFFF0044"..Name.."|r";
        elseif Color == "Green" then
            Name = "|cFF66FF00"..Name.."|r";
        elseif Color == "JadeGreen" then
            Name = "|cFF00EE99"..Name.."|r";
        elseif not Color == "None" then
            Name = "|cFFFFFFFF"..Name.."|r";
        end

        module.AddNewOption(Page, Name, 110);
        return;
    end

    --- Add an option.
    -- @param Page The name or index of the page to add the option to.
    -- @param Name The name of the option.
    -- @param CheckedIfNotSaved Whether the option is enabled.
    -- @param Tooltip The tooltip text to display when mousing over the checkbox.
    -- @param NumericInput Whether the option has a numeric input.
    -- @param NumericInputValue The value in the numeric input.
    -- @param NumericInputMinimum The minimum value in the numeric input.
    -- @param NumericInputMaximum The maximum value in the numeric input.
    -- @param NumericInputStep The step value in the numeric input.
    -- @param NumericInputSecondValue The second value in the numeric input.
    function module.AddOption (Page, Name, CheckedIfNotSaved, Tooltip, NumericInput, NumericInputValue, NumericInputMinimum, NumericInputMaximum, NumericInputStep, NumericInputSecondValue)
        local Type, CheckedIfNotSaved, Value1, Value2 = 210, CheckedIfNotSaved, nil, nil;
        if NumericInput then
            if NumericInputSecondValue then
                Type = 221;
            else
                Type = 220;
            end
        end
        if CheckedIfNotSaved == "locked" then
            Type = 120;
            CheckedIfNotSaved = true;
        end
        if NumericInputSecondValue then
            Value1 = {NumericInputSecondValue, NumericInputMinimum, NumericInputMaximum, NumericInputStep, 20};
            Value2 = {NumericInputValue};
        elseif NumericInputValue then
            Value1 = {NumericInputValue, NumericInputMinimum, NumericInputMaximum, NumericInputStep};
        end
        module.AddNewOption(Page, Name, Type, CheckedIfNotSaved, Value1, Value2, Tooltip);
    end

    --- Add an option.
    -- @param Page The name or index of the page to add the option to.
    -- @param Name The name of the option.
    -- @param Type The Type of the option :
        -- It uses a code like XYZ where :
            -- X is the type of the toggle (locked or toggleable)
            -- Y is the primary type
            -- Z is the secondary type (we might add others in the future)
        -- Here is the full table value :
            -- X :  1 : Locked              2 : Toggleable
            -- Y :  1 : Text Only           2 : Numeric                 3 : Dropdown Menu                       4 : EditBoxButton(PopUp)
            -- Z :  1 : Numeric Bound*      2 : Numeric Free*           3 : Dropdown Menu (only if Y = 3)       4 : EditBoxButton(PopUp)
                -- *Bound : The Z box value have the initial max and the max value of Y box as minimum (and the reverse for Y).
                -- *Free : Both value box are independent.
        -- Implemented Code Table List :
            -- 110  Simple Text                         -- 210  Toggleable Text (Simple Option)
            -- 120  Locked Simple Numeric               -- 220  Toggleable Simple Numeric
            -- 121  Locked Double Numeric Bound         -- 221  Toggleable Double Numeric Bound
            -- 122  Locked Double Numeric Free          -- 222  Toggleable Double Numeric Free
            -- 123  Locked Numeric + Dropdown           -- 223  Toggleable Numeric + Dropdown
            -- 124  Locked Numeric + EditBoxButton      -- 224  Toggleable Numeric + EditBoxButton
            -- 130  Locked Simple Dropdown              -- 230  Toggleable Simple Dropdown
            -- 132  Locked Dropdown + Numeric           -- 232  Toggleable Dropdown + Numeric
            -- 133  Locked Double Dropdown              -- 233  Toggleable Double Dropdown
            -- 134  Locked Dropdown + EditBoxButton     -- 234  Toggleable Dropdown + EditBoxButton
            -- 140  Locked EditBoxButton                -- 240  Toggleable EditBoxButton
            -- 142  Locked EditBoxButton + Numeric      -- 242  Toggleable EditBoxButton + Numeric
            -- 143  Locked EditBoxButton + Dropdown     -- 243  Toggleable EditBoxButton + Dropdown
            -- 144  Locked Double EditBoxButton         -- 244  Toggleable Double EditBoxButton
    -- @param CheckedIfNotSaved Whether the option is enabled by default. (Overwritten by the user after)
    -- @param First value : Must be in array with the first value the default then parameters
        -- Numeric must include the Value (the default one then overwritten by the user after), the Min, the Max, the Step (+ Gap in case of bound values)
        -- Drodpown must inclued the Value as number (the default one then overwritten by the user after) then all the Strings Possible.
        -- Examples :
            -- {25, 10, 70, 5} 25 : Value (here it's the default), 10 : Minimum, 70 : Maximum, 5 : Step
            -- {2, "Player", "Target", "Focus", "Tank"} It will show 4 values (from [2] to [5] as we have 4 Strings), and the value is in [1] (Default Value will be "Target" as it's 2).
    -- @param Second value : Exactly like First Value.
        -- If it's a Numeric Bound (code X21), then it's not mandatory to set again min/max/step as they won't be checked.
            -- You can instead of enter : {30, 10, 90, 5, 20}, {50, 10, 90, 5, 20}
            -- Enter this : {30, 10, 90, 5, 20}, {50}
    -- @param Tooltip The tooltip text to display when mousing over the checkbox.
    function module.AddNewOption (Page, Name, Type, CheckedIfNotSaved, Value1, Value2, Tooltip)
        -- Split Type Code into 3 Parts.
        local StringType = tostring(Type);
        local Type = {};
        Type.X = tonumber(string.sub(StringType, 1, 1));
        Type.Y = tonumber(string.sub(StringType, 2, 2));
        Type.Z = tonumber(string.sub(StringType, 3, 3));

        -- Force true for CheckedIfNotSaved if it's locked.
        local CheckedIfNotSaved = Type.X == 1 and true or CheckedIfNotSaved;

        -- Modify Tooltip to show Default Values
        local Tooltip = Tooltip;
        if Tooltip then
            Tooltip = C.TOOLTIP_DESCRIPTION..Tooltip;
            -- Simple Text
            if Type.Y == 1 then
                Tooltip = Tooltip .. (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and "Checked" or "Unchecked") or "");
            -- Value Numeric
            elseif Type.Y == 2 and Type.Z == 0 then
                Tooltip = Tooltip .. (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and "Checked" or "Unchecked") or "\n") .. C.TOOLTIP_DEFAULT_VALUE .. tostring(Value1[1]);
            -- Value Dropdown
            elseif Type.Y == 3 and Type.Z == 0 then
                Tooltip = Tooltip .. (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and "Checked" or "Unchecked") or "\n") .. C.TOOLTIP_DEFAULT_VALUE .. Value1[Value1[1]+1];
            -- Value 1 Numeric + Value 2 Numeric
            elseif Type.Y == 2 and (Type.Z == 1 or Type.Z == 2) then
                Tooltip = Tooltip .. (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and "Checked" or "Unchecked") or "\n") .. C.TOOLTIP_DEFAULT_VALUE_1 .. tostring(Value1[1]) .. C.TOOLTIP_DEFAULT_VALUE_2 .. tostring(Value2[1]);
            -- Value 1 Numeric + Value 2 Dropdown
            elseif Type.Y == 2 and Type.Z == 3 then
                Tooltip = Tooltip .. (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and "Checked" or "Unchecked") or "\n") .. C.TOOLTIP_DEFAULT_VALUE_1 .. tostring(Value1[1]) .. C.TOOLTIP_DEFAULT_VALUE_2 .. Value2[Value2[1]+1];
            -- Value 1 Numeric + Value 2 EditBoxButton
            elseif Type.Y == 2 and Type.Z == 4 then
                Tooltip = Tooltip .. (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and "Checked" or "Unchecked") or "\n") .. C.TOOLTIP_DEFAULT_VALUE_1 .. tostring(Value1[1]) .. C.TOOLTIP_DEFAULT_VALUE_2 .. Value2;
            -- Value 1 Dropdown + Value 2 Numeric
            elseif Type.Y == 3 and Type.Z == 2 then
                Tooltip = Tooltip .. (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and "Checked" or "Unchecked") or "\n") .. C.TOOLTIP_DEFAULT_VALUE_1 .. Value1[Value1[1]+1] .. C.TOOLTIP_DEFAULT_VALUE_2 .. tostring(Value2[1]);
            -- Value 1 Dropdown + Value 2 Dropdown
            elseif Type.Y == 3 and Type.Z == 3 then
                Tooltip = Tooltip .. (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and "Checked" or "Unchecked") or "\n") .. C.TOOLTIP_DEFAULT_VALUE_1 .. Value1[Value1[1]+1] .. C.TOOLTIP_DEFAULT_VALUE_2 .. Value2[Value2[1]+1];
            -- Value 1 Dropdown + Value 2 EditBoxButton
            elseif Type.Y == 3 and Type.Z == 4 then
                Tooltip = Tooltip .. (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and "Checked" or "Unchecked") or "\n") .. C.TOOLTIP_DEFAULT_VALUE_1 .. Value1[Value1[1]+1] .. C.TOOLTIP_DEFAULT_VALUE_2 .. Value2;
            -- Value 1 EditBoxButton + Value 2 Numeric
            elseif Type.Y == 4 and Type.Z == 2 then
                Tooltip = Tooltip .. (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and "Checked" or "Unchecked") or "\n") .. C.TOOLTIP_DEFAULT_VALUE_1 .. Value1 .. C.TOOLTIP_DEFAULT_VALUE_2 .. tostring(Value2[1]);
            -- Value 1 EditBoxButton + Value 2 Dropdown
            elseif Type.Y == 4 and Type.Z == 3 then
                Tooltip = Tooltip .. (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and "Checked" or "Unchecked") or "\n") .. C.TOOLTIP_DEFAULT_VALUE_1 .. Value1 .. C.TOOLTIP_DEFAULT_VALUE_2 .. Value2[Value2[1]+1];
            -- Value 1 EditBoxButton + Value 2 EditBoxButton
            elseif Type.Y == 4 and Type.Z == 4 then
                Tooltip = Tooltip .. (Type.X == 2 and C.TOOLTIP_DEFAULT_STATE .. (CheckedIfNotSaved and "Checked" or "Unchecked") or "\n") .. C.TOOLTIP_DEFAULT_VALUE_1 .. Value1 .. C.TOOLTIP_DEFAULT_VALUE_2 .. Value2;
            end
        end

        table.insert(OptionInfo, {
            ["Page"] = Page,
            ["Name"] = Name,
            ["Type"] = Type,
            ["CheckedIfNotSaved"] = CheckedIfNotSaved,
            ["Value1"] = Value1,
            ["Value2"] = Value2,
            ["Tooltip"] = Tooltip
        });

        local SettingChecked = Name .. "_Checked";
        local SettingValue1 = Name .. "_Value1";
        local SettingValue2 = Name .. "_Value2";


        -- Force CheckedIfNotSaved settings if it's locked or if no settings are found.
        if Type.X == 1 or (Type.X == 2 and module.GetSetting(SettingChecked) == nil) then
            module.SetSetting(SettingChecked, CheckedIfNotSaved);
        end

        --- Stuff to avoid Values Hacking :
        -- @NumericInputs : Correct out of range numeric values.
        --- Correct Values for Simple or Free Numeric Input.
        if Value1 and Type.Y == 2 then
            if not module.GetSetting(SettingValue1) or type(module.GetSetting(SettingValue1)) ~= "number" then module.SetSetting(SettingValue1, Value1[1]); end
            if module.GetSetting(SettingValue1) < Value1[2] then module.SetSetting(SettingValue1, Value1[2]); end
            if module.GetSetting(SettingValue1) > Value1[3] then module.SetSetting(SettingValue1, Value1[3]); end
        end
        if Value2 and Type.Z == 2 then
            if not module.GetSetting(SettingValue2) or type(module.GetSetting(SettingValue2)) ~= "number" then module.SetSetting(SettingValue2, Value2[1]); end
            if module.GetSetting(SettingValue2) < Value2[2] then module.SetSetting(SettingValue2, Value2[2]); end
            if module.GetSetting(SettingValue2) > Value2[3] then module.SetSetting(SettingValue2, Value2[3]); end
        end
        --- Correct Values for Bound Numeric Input.
        if Value1 and Value2 and Type.Y == 2 and Type.Z == 1 then
            if not module.GetSetting(SettingValue2) or type(module.GetSetting(SettingValue2)) ~= "number" then module.SetSetting(SettingValue2, Value2[1]); end
            if module.GetSetting(SettingValue2) < module.GetSetting(SettingValue1) then module.SetSetting(SettingValue2, module.GetSetting(SettingValue1)); end
            if module.GetSetting(SettingValue2) > Value1[3] then module.SetSetting(SettingValue2, Value1[3]); end
            if module.GetSetting(SettingValue1) > module.GetSetting(SettingValue2) then module.SetSetting(SettingValue1, module.GetSetting(SettingValue2)); end
        end
        -- @DropdownMenus : Check if the value from settings is in the Value Table.
        if Value1 and Type.Y == 3 then
            if not module.GetSetting(SettingValue1) or type(module.GetSetting(SettingValue1)) ~= "string" then module.SetSetting(SettingValue1, Value1[Value1[1]+1]); end
            local Value1IsCorrect = false;
            local ValueFromSettings = module.GetSetting(SettingValue1);
            for Index, Value in pairs(Value1) do
                if Index > 1 and ValueFromSettings == Value then Value1IsCorrect = true; end
            end
            if not Value1IsCorrect then module.SetSetting(SettingValue1, Value1[Value1[1]+1]); end
        end
        if Value2 and Type.Z == 3 then
            if not module.GetSetting(SettingValue2) or type(module.GetSetting(SettingValue2)) ~= "string" then module.SetSetting(SettingValue2, Value2[Value2[1]+1]); end
            local Value2IsCorrect = false;
            local ValueFromSettings = module.GetSetting(SettingValue2);
            for Index, Value in pairs(Value2) do
                if Index > 1 and ValueFromSettings == Value then Value2IsCorrect = true; end
            end
            if not Value2IsCorrect then module.SetSetting(SettingValue2, Value2[Value2[1]+1]); end
        end
        -- @EditBoxButton : Check if there is a value and if it's a string
        if Value1 and Type.Y == 4 then
            if not module.GetSetting(SettingValue1) or type(module.GetSetting(SettingValue1)) ~= "string" then module.SetSetting(SettingValue1, Value1); end
        end
        if Value2 and Type.Z == 4 then
            if not module.GetSetting(SettingValue2) or type(module.GetSetting(SettingValue2)) ~= "string" then module.SetSetting(SettingValue2, Value2); end
        end
    end

    -- Chat commands
        --- Function used when the Command is used (or via the Toolbox button).
        -- Toggle Display of UI.
        function module.UICmd ()
            local Visible = UI:IsVisible();
            if Visible then
                UI:Hide();
            else
                UI:Show();
            end
            module.Print("The settings are now", Visible and "|cFFFF0000hidden.|r" or "|cFF00FF00shown.|r");
        end
        --- Function used when the Command is used (or via the Toolbox button).
        -- Dump all Settings in a .txt file
        function module.SettingsCmd ()
            local String = "";
            local function WriteLine (Line)
                String = String .. Line .. "\n";
            end
            local CurrentOptionName;
            for i = 1, #OptionInfo do
                CurrentOptionName = OptionInfo[i].Name;
                WriteLine(tostring(CurrentOptionName).."\nEnabled: "..tostring(module.IsOptionEnabled(CurrentOptionName)).."\nValue1: "..tostring(module.GetOptionValue(CurrentOptionName)).."\nValue2: "..tostring(module.GetSecondOptionValue(CurrentOptionName)).."\n");
            end
            WriteFile(GetManagerDirectory() .. SettingsDirectoryChange, String);
            module.StatusUpdate("Settings Log Created! Please check your Manager folder.");
            return;
        end

    -- Toolbox Button Addins as UI.lua is the last file loaded in .toc
    module.ToolboxButtonAdd();
end)();